---
title: 从零开始的编译原理（1.5）：编译器架构
tags:
  - 编译
  - 架构
  - 编译器
categories: 教程
abbrlink: 4192c4b7
date: 2024-01-06 16:33:50
---
## 一、前言
本篇文章是一个间章。旨在衔接文法理论与编译器的内容。文法理论旨在解释自然语言，而编译却要创造新的语言。编译过程依赖于编译器的实现。通过将文法规则机械化，编译器实现了计算的高级抽象。

## 二、何为 “编译”
<!-- 编译是一种特殊的翻译过程，用于将一种语言转换为含义等价的另一种语言。但和自然语言处理中的机器翻译不同的是，编译所翻译的语言总是由 2 型文法定义，而机器翻译则针对于自然语言。 -->

为了理解何为 “编译”，我们可以从一个具体的编译器开始。这里我们以 C 语言的编译过程为例：

现在有一个简单的由 C 语言文法写成的文本文件 `test.c`
```c
// test.c
#include <stdio.h>

int main() {
    printf("hello, world.\n");

    return 0;
}
```

想要将其编译为可执行文件，当然可以使用 `gcc test.c -o test` 或 `clang test.c -o test`，但是这样就不能反映编译的具体过程了。所以这里我编写了一个 `Makefile`，用来指明 gcc 编译时所经历的具体步骤。
```makefile
# Makefile
srcname = test
cc = gcc

# Default target
all: $(srcname)
	@echo "Finish!"

# Linking stage
$(srcname): $(srcname).o
	@echo "Linking stage: Creating executable '$(srcname)'"
	$(cc) $(srcname).o -o $(srcname)

# Assembly stage
$(srcname).o: $(srcname).s
	@echo "Assembly stage: Creating object file '$(srcname).o'"
	$(cc) -c $(srcname).s -o $(srcname).o

# Compilation stage
$(srcname).s: $(srcname).i
	@echo "Compilation stage: Creating assembly file '$(srcname).s'"
	$(cc) -S $(srcname).i -o $(srcname).s

# Preprocessing stage
$(srcname).i:
	@echo "Preprocessing stage: Creating preprocessed file '$(srcname).i'"
	$(cc) -E $(srcname).c -o $(srcname).i

# Clean target
clean:
	@echo "Cleaning up"
	rm -f $(srcname).i $(srcname).s $(srcname).o $(srcname)
```

按照 `Makefile` 中的内容，想要将源文件翻译成可执行二进制文件需要经历以下几个步骤：
1. **预处理**：将预处理宏替换为对应的文本，*翻译*得到不含预处理宏的 C 语言代码
    ```makefile
    # Preprocessing stage
    $(srcname).i:
      @echo "Preprocessing stage: Creating preprocessed file '$(srcname).i'"
      $(cc) -E $(srcname).c -o $(srcname).i
    ```
2. **编译**：将不包含预处理宏的 C 语言代码*翻译*成汇编代码
    ```makefile
    # Compilation stage
    $(srcname).s: $(srcname).i
      @echo "Compilation stage: Creating assembly file '$(srcname).s'"
      $(cc) -S $(srcname).i -o $(srcname).s
    ```
3. **汇编**：将汇编代码*翻译*成二进制机械码
    ```makefile
    # Assembly stage
    $(srcname).o: $(srcname).s
      @echo "Assembly stage: Creating object file '$(srcname).o'"
      $(cc) -c $(srcname).s -o $(srcname).o
    ```
4. **链接**：将多个机械码的目标文件合并成一个可执行文件
    ```makefile
    # Linking stage
    $(srcname): $(srcname).o
      @echo "Linking stage: Creating executable '$(srcname)'"
      $(cc) $(srcname).o -o $(srcname)
    ```

> 这可能有些让人迷惑，因为 gcc 作为 “编译器”，它的处理过程中还具有 “编译” 这一步骤。这就是编译的广义与狭义之分了。广义的编译是指将源代码翻译成目标代码的过程，而狭义的编译则特指将高级语言代码翻译成汇编代码的过程。

<!-- 编译是一种翻译过程， -->

如果我们仔细考察编译器的四个阶段，会发现其中前三个阶段都实现了某种翻译过程。我们将能够将一种代码翻译成另一种代码的程序称为**翻译程序**。翻译程序的输入称为**源程序**，输出为**目标程序**

> 链接阶段和翻译无关，因为这一阶段只是对二进制目标文件本身的修改。链接阶段的产生也只是因为我们总是将源程序分为不同的文件（模块）而已。（当然，模块化本身是必须的，所以我们也不可能将链接阶段去掉。）

在预处理阶段，源程序是由预处理宏和其他符号串所组成的，其文法定义了预处理宏的表示方法。因此这一阶段并不会考虑 C 语言的文法是否正确。我们可以做如下的实验。首先我们创建一个文件 `test.c`，有着如下内容。
```c
// test.c
#define XXX YYY
XXX
```

很明显这并不符合 C 语言的文法。但是如果我们使用命令 `gcc -E test.c -o test.i`，就会发现依旧正确生成了经过预处理的 `test.i` 文件。该文件中 `XXX` 被替换成了 `YYY`。但是经过预处理后的 `test.i` 文件并不能通过编译。执行 `gcc -S test.i -o test.s` 会产生如下的报错信息。

```text
test.c:2:1: error: expected ‘=’, ‘,’, ‘;’, ‘asm’ or ‘__attribute__’ at end of input
    2 | XXX
      | ^~~
```

与预处理阶段类似，在编译阶段，源程序由 C 语言表示，目标程序则由汇编代码表示；在汇编阶段，源代码由汇编代码表示，目标代码则由二进制机械码表示。这背后的原理都是相同的：读入按照某一文法规定编写的源程序，对其进行解析，并将其转换为含义等价的符合另一种文法的目标程序。

预处理阶段、编译阶段和汇编阶段分别作为编译器的子程序。称为**预处理程序**（Preprocessor）、**编译程序**（Compiler）和**汇编程序**（Assembler）。它们都是翻译程序。

编译程序不同于预处理程序和汇编程序就在于其输入的程序由高级语言表示。不同于预处理程序所做的单纯替换和汇编程序的汇编指令和二进制码一一对应，编译程序所处理的文法可以具有更为复杂的结构，这既使其源程序具有强大的表达能力，也为编译程序的编写带来了挑战。可以这样认为，编译程序是形式语言翻译程序中最为复杂一种。通过理解编译程序的架构，就可以对所有的形式语言翻译程序拥有整体的认识。

## 三、编译程序的架构
编译程序是一种翻译程序，所以其架构一定包含了对源程序的理解以及对目标程序的生成两个部分。其中 “对源程序的理解” 部分我们称为编译程序的**前端**（Frontend），而 “对目标程序的生成” 部分我们称为编译程序的**后端**（Backend）。

如果我们想要理解一个句子，按照我们在上一章中所学到的文法理论的说法，就需要将此句子 ”结构化“，生成对应的文法树，并按照文法树理解其表达的含义。这就是我们在前端所作的具体工作，包含了 “词法分析”、“语法分析”、“语义分析和中间代码生成” 三阶段。

前端的产物是**中间代码**（Intermediate Code），表达了源代码和目标代码之间抽象层次。中间代码不像目标代码，与目标体系结构无关，这意味着可以通过使用不同的后端翻译成不同的目标代码，从而降低了体系结构迁移的难度。另外中间代码常常设计为更加贴近目标代码，这为后端的工作提供了便利。

> 在自然语言处理（NLP）领域的机器翻译方向上，有一个类似的概念 “中间语”（Interlingua）。在将某种语言翻译成另一种语言时，可以先翻译成 “中间语”，之后再将 “中间语” 翻译成另一种语言。这样在 $N$ 种语言相互翻译的情况下，所需要实现的翻译机制数量就由 $N(N-1)$ 减少为 $2N$。

而后端的目的主要是由中间代码生成目标代码，但也有对中间代码和目标代码进行优化的职责。目标代码常常依赖于硬件，因此存在物理上的限制。后端的目标就是在有限的资源下实现性能更高的代码。后端具体包含了 “代码优化” 和 “目标程序生成” 两阶段。

在前后端之外，还存在着两个贯穿编译程序始终的部分。其一是 “出错处理”，用于在源程序存在错误的情况下尽可能的探查出错误并向用户汇报。其二是 “符号表管理”，此部分用于及时地将源程序和编译过程中所产生的可能在之后使用的信息记录于表格中，以便在随后的编译过程中查找表格中的信息。

综上所述，一个完整的编译程序包括前端和后端，其中前端包括 “词法分析”、“语法分析” 和 “语义分析和中间代码生成”。后端包括 “代码优化” 和 “目标程序生成”。通过这五个阶段的处理，将源程序翻译为目标程序。再加上 “出错处理” 和 “符号表管理” 两个贯穿编译过程始终的部分，共同组成了编译程序的七个逻辑部分。

## 四、词法分析
现在我们拿到一份源程序，那么这个源程序总是由字符序列所构成（大部分是 ASCII，也可能包括汉字或其他语言的字符）。我们实际上并不会对这样的字符序列直接构建文法树，因为单个字符并不一定构成完整的含义。

> 这一点对于表音文字系统来说毫无问题，但是对表意文字系统来说却不那么明显，因为在表意文字系统中，一字即一意。或许也是这个原因，表意文字系统在书写时就使用空格或其他方法进行了分词，而表意文字系统却不然。

我们所要做的是识别字符序列中组合在一起共同表达含义的字符串，将其作为 ”最小的含义单元“。这一单元称之为**词**（Token）。因此在 NLP 领域，这一过程称为**分词**（Tokenization）；在编译领域，这一过程称为**词法分析**（Lexical Analysis）。其中 “Lexical” 指 “词法”。其名词形式 “Lexeme” 可翻译为 “**词素**”。词素和词的不同在于词素意指构成词的字符串本身，而词则指词素所表达的具体含义。（“Token” 也可翻译为 “标记”，这更能体现词的抽象意味。）

词和词素的不同也可以体现出词法分析阶段所作的工作，那就是识别能够构成词素的字符串，将其转化为具有特定含义的词。

> 突然想到一点。如果某些 “中文编程” 的 “爱好者” 有心的话，完全可以利用汉字的特性做一个不需要词法分析的编译器。这样至少有些技术含量。

词法分析的实现依赖于我们的文法理论。在这里我们要定义两个概念。如果对于一个文法 $G[Z]$，句子 $s \in V_t^*$，有 $s \in L(G[Z])$，那么称句子 $s$ 可被文法 $G$ 接受。否则称句子 $s$ 被文法 $G$ 拒绝。

为了将字符序列识别为特定的词，我们所需要做的就是为每个词 $t$ 定义对应的文法 $G_t$。其中文法的终结符集 $V_t^{(G_t)} = \{\text{字符序列中可能出现的所有字符}\}$。这样，对于任意的字符序列 $s$，我们只需要一种算法判断 $s$ 是否可被文法 $G_t$ 接受，就能识别 $s$ 所对应的词的类型了。

实现词法分析功能的子程序称为**词法分析器**（Lexer）。在实现时，词法分析器会按顺序不断读入字符，并判断已经读入的字符串是否被某一文法所接受，如果被接受，则此时的字符串为一词素，接受该字符串的文法对应的类型即词的类型。

在词法分析阶段，我们通常使用的文法是 3 型文法，即正则文法。实现判断符号序列是否可被文法接受则需要用到自动机理论，对于 3 型文法，我们需要使用有穷自动机。对于有穷自动机的相关理论和实现将在之后的章节讲解。

## 五、语法分析
字符序列经过词法分析后变为词序列或词流，之后进入语法分析阶段，按照定义的文法将词序列解析为文法树的形式。

实现语法分析功能的子程序称为**语法分析器**（Parser）。语法分析的方法主要有两大类。第一类是从句子的生成角度思考，从开始符号推导出与输入序列相同的句子，推导过程产生的文法树即语法分析的结果。这一类方法主要包括 $LL(n)$ 分析法。

第二类是从句子的理解角度思考，从输入序列不断归约文法树，最终得到一棵以开始符号为根节点的文法树。这一类方法主要包括算符优先分析法和 $LR(n)$ 分析法。

定义高级语言的文法均为 2 型文法，与词法分析时的有穷自动机类似，2 型文法也有称为 “下推自动机” 的自动机接受。以上提到的不同分析法，实际上就是下推自动机的不同实现。关于语法分析和下推自动机的相关理论和实现也将在之后的章节讲解。

## 六、语义分析和中间代码生成
我们用于定义编程语言的文法是 2 型文法，即上下文无关文法。这意味着在文法中并不能描述程序的上下文关系。因此程序中变量或符号的声明、使用等等上下文相关的信息并不能在文法树的解析过程中得到。因此为了真正理解源程序所表达的含义，还需经过语义分析阶段。

*语义分析*的目的是*生成中间代码*，途径是*管理符号表*。这就是本小节所描述的编译阶段中包括的三个子部分。


<!-- 
编程语言是一类人为创造的语言，旨在描述计算机的处理过程。由高级的编程语言写成的程序称为源程序。

如果有程序能够解析源程序，并将程序转换为另一种语言写成的程序，则执行这一转换过程的程序称为翻译程序。而被转换成的另一种语言写成的程序称为目标程序。

编译程序就是这样一类翻译程序。其以高级语言写成的程序作为源程序，而以汇编、字节码或机械码作为其目标程序。 -->

## 