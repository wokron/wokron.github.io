---
title: 从零开始的编译原理（2）：词法分析与有穷自动机
tags:
  - 编译
  - 文法
  - 有穷自动机
categories: 教程
mathjax: true
abbrlink: 24c6e53e
date: 2024-01-10 19:04:00
---
## 一、前言
> 因而，每一生物的有机形体都是一个神圣的机器，或一台无限地优越于任何人造的自动机器的自然的自动机器（automata）。因为人的技艺所制造的机器的每一部分并非机器。……而自然的机器，即有机体，在其无限小的部分仍是机器。
>
> —— 戈特弗里德·威廉·莱布尼茨《单子论》第 64 节

<!-- more -->

本章将从词法分析所用的 3 型文法入手，引入自动机的概念，并详细介绍有穷自动机的原理及实现。最终实现编译程序的词法分析模块。

## 二、正则文法的解析过程
在第 1 章的最后我们介绍了 3 型文法。3 型文法也称正则文法，特征是对于文法中的每一条规则，其右侧要么是一个终结符，要么是一个终结符加上一个非终结符，且非终结符只位于终结符的一侧。根据非终结符位置的不同分为左线性和右线性。

> 或许有些人会这样讲：“左线性是终结符在右侧；右线性是终结符在左侧”。但是这样实在太别扭了。应该说 “左线性是非终结符在左侧；右线性是非终结符在右侧”。

为什么通过这一约束，3 型文法就能区别于 2 型文法了呢？我们可以通过正则文法的解析过程来理解。

现在有一左线性正则文法 $G_1[Z]$：
$$
\begin{align*}
  Z & \rightarrow A1 \\
  A & \rightarrow B1 | 1 \\
  B & \rightarrow A0
\end{align*}
$$

现在可能不太能看得出来，但是 $G_1[Z]$ 能够接受符号串 $101011$。我们可以画出此符号串对应的文法树。

{% asset_img regex-tree1.png regex-tree1 %}

通过文法树我们可以看出，对于**左线性**正则文法 $G_1[Z]$，其文法树只向**左**增长。当然这一点从规则中也可以看出，只不过不那么直观罢了。

可为什么具有这样特性的文法就特殊了呢？接下来我们根据文法树，以归约的视角看待符号串 $101011$ 的解析过程：
1. 读入 `1`，`1` 归约得到 `A`；
2. 读入 `0`，`A0` 归约得到 `B`；
3. 读入 `1`，`B1` 归约得到 `A`；
4. ……

以此类推，我们就可以发现其中的规律。对于这样的文法，**读入一次即归约一次**。因为文法中最多只有两个符号，所以一旦读入了一个新的符号，则必定进行一次归约。

同理的，我们考虑右线性正则文法 $G_2[S]$：
$$
\begin{align*}
  S & \rightarrow 1A \\
  A & \rightarrow 0B | 1 \\
  B & \rightarrow 1A
\end{align*}
$$

$101011$ 也能被 $G_2[S]$ 接受。其文法树如下，对于**右线性**正则文法 $G_2[Z]$，其文法树只向**右**增长

{% asset_img regex-tree2.png regex-tree2 %}

而这一次我们以推导的视角来看。文法树的生成过程应该是这样的：
1. `S` 推导得到 `1A`，输出 `1`；
2. `A` 推导得到 `0B`，输出 `0`；
3. `B` 推导得到 `1A`，输出 `1`；
4. ……

其中规律是**推导一次即输出一次**。因为非终结符总是出现在左侧，所以每进行一步推导，当前句型左侧就多出一个非终结符。

由此我们可以看出，不管是左线性还是右线性，对于正则文法，符号串解析的每一步都只与目前唯一的非终结符和正在被解析的终结符有关。

正因为此，我们可以对正则文法做进一步的抽象。可将当前句型中唯一的非终结符视为当前的**状态**，由于解析了新的终结符而产生了**状态的转移**。

## 三、有穷自动机
这就引入了**有限状态机**的概念。有限状态机又称**有穷自动机**（Finite Automata），之后我们将使用有穷自动机这个名词。

有穷自动机是表示有限个状态以及在这些状态之间的转移和动作等行为的模型，可以使用图形表示。我们用圆圈表示**状态**，用圆圈间的箭头表示**状态的转移**，其中箭头上的字符表示进行这一状态转移所需要读入的字符。在有穷自动机还未读入任何字符时所处的状态称为**开始状态**，用一个小箭头指向该状态表示。另外还有**接受状态**，当有穷自动机处于该状态时，说明此前读入的符号串可被**识别/接受**，用两个同心圆表示。

> “接受” 的概念来自文法，因为有穷自动机实际上就是用于判断正则文法是否接受符号串的机器。

下面一个有穷自动机的例子可以说明上述概念。

{% asset_img automata1.png automata1 %}

> 图是在[这个网站](https://ivanzuzak.info/noam/webapps/fsm_simulator/)画的。

图中 $S、A、Z$ 均是状态。状态 $S$ 有一个小箭头指向，因此是开始状态。状态 Z 有两个同心圆，因此是接受状态。状态 $S$ 与状态 $A$ 之间有一箭头从 $S$ 指向 $A$，同时箭头上有字符 $0$，说明处于状态 $S$ 时读入字符 $0$ 可以转移到状态 $A$。其他箭头的含义同理。

判断某一符号串是否可被有穷自动机接受十分简单。只需要让有穷自动机按顺序读入符号串的每一个符号，并根据箭头做状态转移，等到读入符号串的全部符号后，查看此时是否处于接受状态即可。如果处于接受状态，则证明该符号串可以被有穷自动机识别。

还以上图中的有穷自动机为例，对于符号串 $0100$，会经过 $S \rightarrow A \rightarrow Z \rightarrow Z$ 的状态转移。最终状态为接受状态。因此 $0100$ 可以被上图的有穷自动机接受。

根据上一章，我们得知对正则文法的推导或归约等同于状态的转移，因此正则文法实际上和有穷自动机等价。正则文法的推导或归约过程可以用有穷自动机实现。下面分别给出左线性和右线性文法构造有穷自动机的方法：
- **左线性**：
  1. 对于左线性文法 $G_{L}[Z]$。将该文法中的每一个非终结符都视为状态，其中将开始符号 $Z$ 作为**接受状态**。并添加一个**开始状态** $S$。
  2. 对于文法 $G_L$ 中形如 $Q \rightarrow Rt$ 其中 $Q,R \in V_n; t \in V_t$ 的规则，为有穷自动机添加由状态 $R$ 指向状态 $Q$ 的箭头，箭头上的符号为 $t$。
  3. 对于文法 $G_L$ 中形如 $Q \rightarrow t$ 其中 $Q \in V_n; t \in V_t$ 的规则，为有穷自动机添加由状态 $S$ 指向状态 $Q$ 的箭头，箭头上的符号为 $t$。
- **右线性**：
  1. 对于左线性文法 $G_{R}[S]$。将该文法中的每一个非终结符都视为状态，其中将开始符号 $S$ 作为**开始状态**。并添加一个**接受状态** $Z$。
  2. 对于文法 $G_R$ 中形如 $Q \rightarrow tR$ 其中 $Q,R \in V_n; t \in V_t$ 的规则，为有穷自动机添加由状态 $Q$ 指向状态 $R$ 的箭头，箭头上的符号为 $t$。
  3. 对于文法 $G_R$ 中形如 $Q \rightarrow t$ 其中 $Q \in V_n; t \in V_t$ 的规则，为有穷自动机添加由状态 $Q$ 指向状态 $Z$ 的箭头，箭头上的符号为 $t$。

> 由正则文法转换为有穷自动机的过程也反映了左线性进行归约、右线性进行推导的这一区别：对于左线性，状态转移箭头所指向的是规则左侧的非终结符对应的状态；而对于右线性，状态转移箭头所指向的是规则右侧的非终结符对于的状态。

据此我们就可以根据上一节中定义的两个正则文法构造有穷自动机。实际上这两个文法所对应的有穷自动机相同。

{% asset_img automata2.png automata2 %}

对于符号串 $101011$，经过 $S \rightarrow A \rightarrow B \rightarrow A \rightarrow B \rightarrow A \rightarrow Z$ 的状态转移过程，被此有穷自动机接受。

> 左线性文法的文法树中非终结符自底向上、或右线性文法的文法树中非终结符自顶向下，所组成的序列与在有穷自动机中状态转移过程得到的状态序列相同，都是 $SABABAZ$。除了开始状态或接受状态可能不存在。

目前为止，有穷自动机看似十分简单，其实是因为我们只考虑了最简单的情况。让我们再考虑下面的正则文法 $G[S]$：
$$
\begin{align*}
  S & \rightarrow 0A | 1B | 1 \\
  A & \rightarrow \epsilon \\
  B & \rightarrow 0S
\end{align*}
$$

这是一个右线性文法，我们可以按照上面提到的方法将其构造成有穷自动机。如下图所示，图中的 `$` 指空符号串 $\epsilon$。

{% asset_img automata3.png automata3 %}

看似没有什么特别的。但是如果现在我问一些问题，就会发现这个有穷自动机有着很多奇怪的地方。

比如说，$1$ 能够被这一有穷自动机接受吗？因为文法中存在规则 $S \rightarrow 1$，所以肯定可以被接受。但是从有穷自动机图中看来，初始状态为 $S$，读入 $1$ 之后却可以从两个不同的箭头转移到不同的状态。既可以是接受状态 $Z$，也可以是普通状态 $B$。这样又要如何判断哪个状态是正确的呢？

又比如说，$0$ 能够被这一有穷自动机接受吗？从有穷自动机图中看来，初始状态为 $S$，读入 $0$ 之后转移到状态 $A$。但是状态 $A$ 到状态 $Z$ 之间存在一个箭头，其上的符号为 $\epsilon$，这意味着不读入符号也可以进行状态转移。那么读入 $0$ 之后的状态究竟应该是 $A$ 还是 $Z$ 呢？

要回答这样的问题，我们不能再使用不严谨的语言了。下面我们需要将有穷自动机以数学的语言加以形式化。

## 四、有穷自动机的形式化
### （1）有穷自动机的定义
在形式上，有穷自动机分为两类，分别是**确定的有穷自动机**（DFA, Deterministic Finite Automata）和 **不确定的有穷自动机**（NFA, Nondeterministic Finite Automata）。

本文第一和第二个图所展示的有穷自动机为 DFA。DFA $M$ 可以由一个五元组表示：
$$
  M = (S, \Sigma, \sigma, s_0, Z)
$$
其中
- $S$ 表示**有穷状态集**。
- $\Sigma$ 表示输入字符的集合，也即**字母表**，注意 $\epsilon \notin \Sigma$
- $\sigma$ 为**状态转移函数**，其中 $\sigma: S \times \Sigma \rightarrow S$。
- $s_0$ 表示**初始状态**，其中 $s_0 \in S$。
- $Z$ 表示**接受状态集**，其中 $Z \subseteq S$。

> 由于状态转移函数 $\sigma$ 的两个自变量的取值范围均有穷且离散，所以我们可以用一个二维表格表示状态转移函数，这一表格称为有穷自动机的**状态转移矩阵**。表格的第一行和第一列表示两个自变量，其余部分表示状态转移后的取值。还举如下的有穷自动机为例，我们给出其状态转移矩阵。
>
> {% asset_img automata1.png automata1 %}
> 
> ||$0$|$1$|
> |---|---|---|
> |$S$|$A$|$\phi$|
> |$A$|$\phi$|$Z$|
> |$Z$|$Z$|$\phi$|
> |$\phi$|$\phi$|$\phi$|
>
> 注意这里增加了一个自动机中不存在的新状态 $\phi$。这是为了填补状态转移矩阵中无法接受的符号造成的空缺，代表一个**永远不被接受**的状态。当然为了方便，我们也可以直接将 $\phi$ 处留空。

通过 DFA 的形式化定义，我们可以定义 DFA 所接受的符号串：对于 DFA $M$，令 $a = a_1a_2... a_n, a \in \Sigma^*$，若存在 $\sigma(...\sigma(\sigma(s_0, a_1), a_2)..., a_n) = s_n$ 且 $s_n \in Z$，则称 $a$ 可被 $M$ 接受。

如果我们记 $\sigma(...\sigma(\sigma(s_0, a_1), a_2)..., a_n) = s_n$ 为 $\sigma(s_0, a) = s_n$。则 DFA $M$ 所接受的语言可以表示为 $L(M) = \{a | \sigma(s_0, a) = s_n, s_n \in Z, a \in \Sigma^* \}$

而如果在 DFA 的基础上放宽一些限制条件，我们就得到了 NFA。本文第三个图所展示的有穷自动机为 NFA，这也是该有穷自动机和之前的性质有所不同的原因。NFA $M'$ 同样可由一个五元组表示：
$$
  M' = (S, \Sigma \cup \{\epsilon\}, \sigma', s_0, Z)
$$
其中
- $S$ 表示**有穷状态集**，与 DFA 相同。
- $\Sigma$ 表示**字母表**加上 $\epsilon$，这意味着 NFA 所接受的符号包括空字符。
- $\sigma$ 为**状态转移函数**，其中 $\sigma: S \times \Sigma \cup \{\epsilon\} \rightarrow 2^S$。（$2^S$ 是 $S$ 的幂集，即 $S$ 的所有可能子集的集合。这意味着 NFA 的 $\sigma$ 的取值为集合 $S' \subseteq S$ 而非 $s \in S$。）
- $s_0$ 表示**初始状态**，其中 $s_0 \in S$，与 DFA 相同。
- $Z$ 表示**接受状态集**，其中 $Z \subseteq S$，与 DFA 相同。

由此我们可以看出，NFA 相较于 DFA 放宽的条件有两处：
1. 将 $\epsilon$ 加入到接受符号中，由于对任意 $a = a_1 a_2 ... a_n, a \in \Sigma^*$ ，对任意的 $i \in [0, n]$，有 $a_1 ... a_i \epsilon a_{i+1}...a_n = a_1...a_i a_{i+1} ... a_n = a$。这意味着在任意时刻 NFA 都**可以无条件的读入 $\epsilon$ 进行状态转移**。
2. $\sigma$ 的值域为 $2^S$，这意味着一次状态转移**有多个不同的状态可以选择**，而非只能转移到单一状态。

NFA 放宽了条件，也为理解和使用带来了困难。可以无条件读入 $\epsilon$，那么什么时候读入是合理的呢？允许状态转移后有多个状态，那么哪一个状态才是当前状态？终止条件又要如何确定？

为了解答这些问题，我们要形式化地定义 NFA 所接受的符号串。对于 NFA $M'$，我们定义 $\sigma': 2^S \times \Sigma \cup \{\epsilon\} \rightarrow 2^S$，其中对于 $\sigma'(S'_{i-1}, a'_i) = S'_i$，有 $S'_i = \bigcup_{s'_{i-1} \in S'_{i-1}} \sigma(s'_{i-1}, a'_i)$。

则对于符号串 $a \in \Sigma^*$，若存在 $a' \in (\Sigma \cup \{\epsilon\})^*$ 且 $a = a'$。存在 $\sigma'(...\sigma'(\sigma'(\{s_0\}, a'_1), a'_2)..., a'_n) = S'_n$ 且 $S'_n \cap Z \ne \emptyset$，则称 $a$ 可被 $M'$ 接受。

> 也可以这样理解 NFA 所接受的符号串：在每次尝试读取符号并进行状态转移时，可以**选择**读入 $\epsilon$ 或下一个符号；在状态转移过后，也可以**选择**状态集中某个状态作为当前状态。在这样不同选择所组成的不同路径中，如果**存在**这样一条路径，在读完符号串所有符号后转移到了某个接受状态，则判定 NFA 接受了该符号串。

与 DFA 类似，如果我们记 $\sigma'(...\sigma'(\sigma'(\{s_0\}, a'_1), a'_2)..., a'_n) = S'_n$ 为 $\sigma(\{s_0\}, a) = S'_n$。则 NFA $M'$ 所接受的语言可以表示为 $L(M') = \{a | \sigma(\{s_0\}, a) = S'_n, S'_n \cap Z \ne \emptyset, a \in \Sigma^* \}$。

> NFA 同样可以使用状态转移矩阵，只不过这一次表格中的取值变为了状态集而非单一状态。

### （2）NFA 的确定化
DFA 的状态转移实现起来较为简单，只需要维护唯一的当前状态，每一步读入符号都根据规则更改当前状态即可。而 NFA 的实现就稍显复杂了。首先，每一次状态转移都有许多可能的目标状态，当然我们可以选择保留每一次状态转移得到的所有状态，只不过这一状态集可能会十分庞大。其次，NFA 在任何时刻都可能读入 $\epsilon$，这种不确定性又要如何解决？

我们要消除 $\epsilon$ 带来的不确定性。可以再次审视 NFA 中每一步状态转移得到的状态集合：该集合实际上表示的是**当前所有可能的状态**。此时如果我们选择读入 $\epsilon$，那么状态集合会发生变化，但是实际上我们并没有读入符号串中的符号。因此**读入下一个符号串中的符号之前所有可能的状态**和**当前所有可能的状态**并不相同，前者包括了后者以及在后者基础上不断读入 $\epsilon$ 所得到的所有新的状态。如果我们能找到前者的计算方法，那么我们就能从 NFA 中消除不确定位置的 $\epsilon$。

这里要引入 **ε-闭包**（ε-closure）的概念。对于 NFA $M'$，令 $I \subseteq S$，则其 ε-闭包为 $\text{ε-closure}(I) = I \cup \text{ε-closure}(\sigma'(I, \epsilon))$ 其中 $\text{ε-closure}(\emptyset) = \emptyset$。

对第 $i$ 步使用 $\sigma'$ 进行状态转移得到状态集合 $S_i$，我们只要对其求 ε-闭包得到 $S'_i = \text{ε-closure}(S_i)$，之后再用 $S'_i$ 执行状态转移，读入下一个非 $\epsilon$ 符号得到 $S_{i+1}$。这样就消除了 NFA 中 $\epsilon$ 带来的不确定性。

如此一来，我们就得到了 NFA $M'$ 的状态转移的实现方法：
1. 维护一个当前状态集合，并设置初始状态集合为 $S'_0 = \text{ε-closure}(\{s_0\})$；
2. 读入下一个符号串中的符号 $a'_i$，得到第 $i$ 步的状态集合 $S'_i = \text{ε-closure}(\sigma'(S'_{i-1}, a'_i))$；
3. 不断重复第 2 步，直到读入了所有符号串中的符号，此时得到状态集合 $S'_n$；
4. 若 $S'_n \cap Z \ne \emptyset$，则此 NFA 接受该符号串，否则不接受。

根据上面的方法，如果我们将其中**所有可能出现的状态集合**分别视作不同的状态（$s''_i := S'_i$），则我们可以**构造一个新的有穷自动机** $M''$。并且由于该有穷自动机中不存在 $\epsilon$；同时状态转移函数 $\sigma''(s''_{i-1}, a'_i) := \text{ε-closure}(\sigma'(S'_{i-1}, a'_i))$ 的取值唯一，所以 $M''$ 还是 DFA。

也就是说对于给定的 NFA，我们总能通过一种方法将其构造成一个 DFA。这意味着 NFA 与 DFA 从功能上来说是**等价的**。将一个 NFA 转化为 DFA 的过程称为 **NFA 的确定化**。

下面给出 NFA 确定化的算法：

想要将 NFA $M = (S, \Sigma \cup \{\epsilon\}, \sigma, s_0, Z)$ 确定化为 DFA $M' = (S', \Sigma, \sigma', s'_0, Z')$。
1. 初始化 $s'_0 := \text{ε-closure}(\{s_0\})$，$S' = \{s'_0\}$，$S'_{\text{new}} := S'$，$\sigma' = \emptyset$，$Z' = \emptyset$；
2. 对任意 $s'_{\text{new}} \in S'_{\text{new}}$，令 $S'_{\text{new}} := S'_{\text{new}} - \{s'_{\text{new}}\}$，对任意 $a \in \Sigma$，令 $s'_\sigma := \text{ε-closure}(\sigma(s'_{\text{new}}, a))$，$\sigma' := \sigma' \cup \{(s'_{\text{new}}, a) \rightarrow s'_\sigma \}$；
3. 若 $s'_\sigma \notin S'$，则令 $S'_{\text{new}} := S'_{\text{new}} \cup \{s'_\sigma\}$，$S' := S' \cup \{s'_\sigma\}$。若 $Z \cap s'_\sigma \ne \emptyset$，则令 $Z' := Z' \cup \{s'_\sigma\}$；
4. 重复 2、3 步，直到 $S'_{\text{new}} = \emptyset$。

这样说似乎有些太过抽象。让我们以上文中我们构造的 NFA 为例。

{% asset_img automata3.png automata3 %}

算法的目标是构建一个 DFA，其中最主要的就是构建 DFA 的状态转移函数 $\sigma'$。所以我们可以使用状态转移矩阵表示算法过程。

最开始，我们的 $S'_{\text{new}} := \{\{S\}\}$，这时我们在表格 $T$  中添加 $\{S\}$ 状态所对应的行。由于还未对 $\{S\}$ 进行处理，所以其状态转移后的目标状态暂时为空。

||$0$|$1$|
|---|---|---|
|$\{S\}$| - | - |

之后我们求 $\{S\}$ 转移后的目标状态集。有 $\text{ε-closure}(\sigma(\{S\}\, 0)) = \{A,Z\}$（注意计算 ε-闭包）。因此我们在 $T[\{S\},0]$ 的位置填入 $\{A,Z\}$，并添加 $\{A,Z\} 对应的行。同理我们对符号 $1$ 也进行操作。最终表格状态如下。

||$0$|$1$|
|---|---|---|
|$\{S\}$| $\{A,Z\}$ | $\{B,Z\}$ |
|$\{A,Z\}$| - | - |
|$\{B,Z\}$| - | - |

此时 $S'_{\text{new}} := \{ \{A,Z\}, \{B,Z\} \}$。我们同样依次对 $\{A,Z\}$ 和 $\{B,Z\}$ 求转移后的状态集。

对于 $\{A,Z\}$，我们得到了两个空集
||$0$|$1$|
|---|---|---|
|$\{S\}$| $\{A,Z\}$ | $\{B,Z\}$ |
|$\{A,Z\}$| $\emptyset$ | $\emptyset$ |
|$\{B,Z\}$| - | - |

对于 $\{B,Z\}$，有 $T[\{B,Z\},0] = \{S\}$。但由于 $\{S\}$ 已经在表格中了，所以不需要添加额外的行。此时表格中所有位置都填写完成，相当于 $S'_{\text{new}} = \emptyset$。算法停止。

||$0$|$1$|
|---|---|---|
|$\{S\}$| $\{A,Z\}$ | $\{B,Z\}$ |
|$\{A,Z\}$| $\emptyset$ | $\emptyset$ |
|$\{B,Z\}$| $\{S\}$ | $\emptyset$ |

除了表格之外，我们还可得到初始状态 $s'_0 = \{S\}$。并且由于 $Z \in \{A,Z\}, Z \in \{B,Z\}$，所以 $Z' = \{ \{A,Z\}, \{B,Z\} \}$。

我们可以将上述表格中的各状态替换成方便阅读的形式。令 $\{S\} \rightarrow S, \{A,Z\} \rightarrow A, \{B,Z\} \rightarrow B, \emptyset \rightarrow \phi$。得到：

||$0$|$1$|
|---|---|---|
|$S$| $A$ | $B$ |
|$A$| $\phi$ | $\phi$ |
|$B$| $S$ | $\phi$ |
|$\phi$|$\phi$|$\phi$|

其中初始状态为 $S$，接受状态集为 $\{A,B\}$

### （3）DFA 的最小化
在上一小节中，我们描述了 NFA 确定化为 DFA 的方法。但是也并非所有的 DFA 都是其最简的等价形式。我们可以考虑如下的 DFA：

{% asset_img automata4.png automata4 %}

很明显，该 DFA 可接受 0 个或多个 $a$ 组成的符号串。但是该 DFA 并不是接受这一类符号串的最简 DFA，因为下面的 DFA 同样能够接受：

{% asset_img automata5.png automata5 %}

因此在 DFA 中，我们依旧可以进行分类。我们将 DFA 分为**最小化（化简）的**和不是最小化的。可以证明，对于任意一个 DFA，存在一个唯一的、状态最少的等价的 DFA，该 DFA 是最小化的。

一个 DFA 是最小化的当且仅当其没有**多余状态**且状态中没有**相互等价的状态**。其中多余状态指的是从开始状态出发不可能达到的状态；而等价状态


## 五、词法分析子程序
