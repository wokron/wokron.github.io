<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"wokron.github.io","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":"default","style":"mac"},"back2top":{"enable":true,"sidebar":false,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="一、Lab2 前言这篇文章应该是我目前写过的文章中长度排行前几的了。Lab2 的内容着实繁多，不仅是分页内存管理本身的理论和实现细节颇多；操作系统的基本知识和注意事项也占据了很大的篇幅。后者在不理解的情况下实在会对本次实验产生许多困惑。本人也是在逐步地探索之后才得以有了较多的认识——当然，这一认识或许也只是片面的。 本文逐函数、逐代码地讲解了 Lab2 中新增的内容。主要在于内核初始化中关于内存的">
<meta property="og:type" content="article">
<meta property="og:title" content="BUAA OS实验笔记之Lab2">
<meta property="og:url" content="https://wokron.github.io/posts/db841b3c/index.html">
<meta property="og:site_name" content="StringCat的博客">
<meta property="og:description" content="一、Lab2 前言这篇文章应该是我目前写过的文章中长度排行前几的了。Lab2 的内容着实繁多，不仅是分页内存管理本身的理论和实现细节颇多；操作系统的基本知识和注意事项也占据了很大的篇幅。后者在不理解的情况下实在会对本次实验产生许多困惑。本人也是在逐步地探索之后才得以有了较多的认识——当然，这一认识或许也只是片面的。 本文逐函数、逐代码地讲解了 Lab2 中新增的内容。主要在于内核初始化中关于内存的">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2023-03-20T13:38:57.000Z">
<meta property="article:modified_time" content="2023-06-26T02:38:38.376Z">
<meta property="article:author" content="wokron">
<meta property="article:tag" content="MOS">
<meta property="article:tag" content="os">
<meta property="article:tag" content="BUAA">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://wokron.github.io/posts/db841b3c/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>BUAA OS实验笔记之Lab2 | StringCat的博客</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">StringCat的博客</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">学生党踩坑记录</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://wokron.github.io/posts/db841b3c/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="wokron">
      <meta itemprop="description" content="StringCat的个人博客。记录学习、分享经验">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="StringCat的博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          BUAA OS实验笔记之Lab2
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-03-20 21:38:57" itemprop="dateCreated datePublished" datetime="2023-03-20T21:38:57+08:00">2023-03-20</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-06-26 10:38:38" itemprop="dateModified" datetime="2023-06-26T10:38:38+08:00">2023-06-26</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">学习笔记</span></a>
                </span>
            </span>

          
          <span class="post-meta-divider">|</span>
          <span class="post-meta-item-icon">
              <i class="fa fa-fa fa-eye"></i>
          </span>
          <span class="post-meta-item-text">阅读次数：</span>
          <span id="busuanzi_value_page_pv"></span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h2 id="一、Lab2-前言"><a href="#一、Lab2-前言" class="headerlink" title="一、Lab2 前言"></a>一、Lab2 前言</h2><p>这篇文章应该是我目前写过的文章中长度排行前几的了。Lab2 的内容着实繁多，不仅是分页内存管理本身的理论和实现细节颇多；操作系统的基本知识和注意事项也占据了很大的篇幅。后者在不理解的情况下实在会对本次实验产生许多困惑。本人也是在逐步地探索之后才得以有了较多的认识——当然，这一认识或许也只是片面的。</p>
<p>本文逐函数、逐代码地讲解了 Lab2 中新增的内容。主要在于内核初始化中关于内存的部分以及分页内存管理的实现。在本文中，关于链表宏和虚拟/物理内存的辨析也占据了比较多的内容。</p>
<span id="more"></span>
<h2 id="二、内核初始化（续）"><a href="#二、内核初始化（续）" class="headerlink" title="二、内核初始化（续）"></a>二、内核初始化（续）</h2><p>在 Lab1 中，我们的内核初始化过程只进行了一部分。因为 Lab1 中 <code>mips_init</code> 函数几乎没有任何功能。在 Lab2 中，我们会继续推进这一过程。</p>
<p>在 Lab2 中，我们会建立操作系统的内存管理机制。具体来说，我们会在 <code>mips_init</code> 中调用三个函数 <code>mips_detect_memory</code>、<code>mips_vm_init</code> 和 <code>page_init</code>。这三个函数会分别完成探测内存、初始化虚拟地址和初始化页的工作。接下来我们会分别介绍这三个函数。</p>
<p>Lab2 中 <code>mips_init</code> 的结构如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">mips_init</span><span class="params">()</span> &#123;</span><br><span class="line">	printk(<span class="string">&quot;init.c:\tmips_init() is called\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// lab2:</span></span><br><span class="line">	mips_detect_memory();</span><br><span class="line">	mips_vm_init();</span><br><span class="line">	page_init();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="（1）探测内存"><a href="#（1）探测内存" class="headerlink" title="（1）探测内存"></a>（1）探测内存</h3><p><code>mips_detect_memory</code> 的作用是获取总物理内存大小，并根据物理内存计算分页数。</p>
<blockquote>
<p>注意！是物理内存</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">mips_detect_memory</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="comment">/* Step 1: Initialize memsize. */</span></span><br><span class="line">	memsize = *(<span class="keyword">volatile</span> u_int *)(KSEG1 | DEV_MP_ADDRESS | DEV_MP_MEMORY)</span><br></pre></td></tr></table></figure>
<p>第一步中的这条语句似乎使人困惑。为什么这样就可以获得物理内存大小了呢？我们可以查看一下 <code>DEV_MP_ADDRESS</code> 和 <code>DEV_MP_MEMORY</code> 所在的头文件。它们定义在 include/driver/dev_mp.h 中。</p>
<p>恰好 include/driver 目录下有一个 README，其中提到<br><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">The files in this directory describe the devices found in GXemul&#x27;s &quot;test</span><br><span class="line">machines&quot;. These machines do not match any real-world machines, but they</span><br><span class="line">have devices that are similar to those found in real machines:</span><br><span class="line"></span><br><span class="line">omit...</span><br><span class="line"></span><br><span class="line">  o)  mp (dev_mp):</span><br><span class="line">	A multiprocessor inter-processor communication device.</span><br><span class="line">	It also contains other useful functionality, such as retrieving</span><br><span class="line">	the amount of &quot;physical&quot; RAM installed in the emulated machine.</span><br><span class="line"></span><br><span class="line">omit...</span><br></pre></td></tr></table></figure><br>这就说明 dev_mp.h 中的信息应该是关于 multiprocessor inter-processor communication device (mp) 的相关信息的。这是 GXemul 定义的虚拟设备。mp 能够检索（retrive）RAM 数量（？amount）。这就足够了。</p>
<p>再看 dev_mp.h。通过注释我们可以得知，这个头文件中定义的 <code>DEV_MP_ADDRESS</code> 是（mp 设备）默认的物理基地址。而 <code>DEV_MP_MEMORY</code> 是物理基地址到 “设备寄存器” 的偏移量。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *  Default (physical) base address and length:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEV_MP_ADDRESS 0x11000000ULL</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEV_MP_LENGTH 0x00000100ULL</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// omit...</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *  Offsets from the base address to reach the MP device&#x27; registers:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEV_MP_MEMORY 0x0090</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// omit...</span></span><br></pre></td></tr></table></figure></p>
<p>现在我们就可以解释 <code>DEV_MP_ADDRESS | DEV_MP_MEMORY</code> 的含义了。这表示一个物理地址，该地址正好对应 mp 设备的 <code>MEMORY</code> 寄存器。其中存储了物理内存大小的相关的信息。</p>
<p>但是在代码中，我们只能使用虚拟地址进行访存。因此我们需要得到该物理地址对应的虚拟地址。这时候 <code>KSEG1</code> 就派上用场了。根据指导书我们知道，kseg1 段的虚拟地址转换为物理地址只需要将最高 3 位置 0，不通过 TLB，同时也不通过 cache。实际上，kseg1 段就是为访问外设准备的。</p>
<p>我们将物理地址 <code>DEV_MP_ADDRESS | DEV_MP_MEMORY</code> 转换为虚拟地址 <code>KSEG1 |</code>，指明该地址指向的是一个无符号整数 <code>(volatile u_int *)</code>，最后取出该位置的值 <code>memsize = *</code>。这就是这一条语句的含义。</p>
<p>话说回来，在 Lab1 的 <code>printcharc</code> 函数中我们也遇到过类似的写法：<code>KSEG1 + DEV_CONS_ADDRESS + DEV_CONS_PUTGETCHAR</code>。但是当时没有进一步说明。本使用中的使用的是按位或而非加法，也进一步加深了代码的迷惑程度。</p>
<blockquote>
<p>我在这里需要插一句，因为我不知道要把这部分内容放到哪里。</p>
<p>根据指导书可以知道，kseg1 段位于 <code>0xa0000000~0xbfffffff</code>，映射的物理地址为 <code>0x00000000~0x1fffffff</code>。同样 kseg0 段位于 <code>0x80000000~0x9fffffff</code>，但映射的物理地址也为 <code>0x00000000~0x1fffffff</code>。这是否出错了呢？其实不是。</p>
<p>kseg0 和 kseg1 中两个不同的虚拟地址，其实就对应同一个物理地址。区分 kseg0 和 kseg1 的目的，就在于区分是否使用 cache。</p>
<p>同样的，其实 kuseg 映射的物理地址也和 kseg0 和 kseg1 相同。你可能会想：“不对呀，kuseg 的虚拟地址空间明显大于 kseg0 和 kseg1。怎么可能映射到同样的物理地址空间？” 其实解决问题的关键就在于页表。这在本篇文章的后面会详细讲解。</p>
</blockquote>
<p>终于分析完第一条语句了。<code>mips_detect_memory</code> 中剩下的部分就比较简单了。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">	<span class="comment">/* Step 2: Calculate the corresponding &#x27;npage&#x27; value. */</span></span><br><span class="line">	<span class="comment">/* Exercise 2.1: Your code here. */</span></span><br><span class="line">	npage = memsize / BY2PG;</span><br><span class="line"></span><br><span class="line">	printk(<span class="string">&quot;Memory size: %lu KiB, number of pages: %lu\n&quot;</span>, memsize / <span class="number">1024</span>, npage);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>在这部分中，我们将总物理内存大小除以页大小，得到总页数。并调用 Lab1 中编写的 <code>printk</code> 输出相关信息。需要注意的是 <code>BY2PG</code> 是一个宏，定义在 include/mmu.h 中。根据注释可以得知这表示一页的字节数。因此除以 <code>BY2PG</code> 即可得到总页数。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> BY2PG 4096		<span class="comment">// bytes to a page</span></span></span><br></pre></td></tr></table></figure></p>
<h3 id="（2）初始化虚拟地址"><a href="#（2）初始化虚拟地址" class="headerlink" title="（2）初始化虚拟地址"></a>（2）初始化虚拟地址</h3><p>接着我们考虑 <code>mips_vm_init</code> 函数。这个函数将申请一部分空间用作页控制块。页控制块是 <code>struct Page</code> 类型的结构体。每一个页控制块对应一个物理页。</p>
<p><code>struct Page</code> 的结构很简单，只不过因为使用了链表宏（链表宏会在之后讲解），导致不容易理解。如下是展开后的 <code>struct Page</code><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Page</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">Page</span> *<span class="title">le_next</span>;</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">Page</span> **<span class="title">le_prev</span>;</span></span><br><span class="line">	&#125; pp_link;</span><br><span class="line">	u_short pp_ref;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>其中只有一个用于表示链表前后节点的结构体 <code>pp_link</code>；以及用于引用计数，反映页的使用情况的 <code>pp_ref</code>。</p>
<p>这么简单的结构是如何映射到物理页的呢？其实也很简单。在 include/pmap.h 中我们可以得知，所有的页控制块都保存在一个数组中 <code>extern struct Page *pages</code>（这也是我们将要在<code>mips_vm_init</code>申请的数组）。</p>
<p>通过指针减法，可以得到对应的页控制块是第几个页<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> u_long <span class="title function_">page2ppn</span><span class="params">(<span class="keyword">struct</span> Page *pp)</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> pp - pages;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>一个物理页有确定的大小，我们将第几个页乘以物理页大小即可得到对应物理页的基地址。<code>page2pa</code> 表示 “page to physical addresss” 的意思。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// in mmu.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PGSHIFT 12</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// in pmap.h</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> u_long <span class="title function_">page2pa</span><span class="params">(<span class="keyword">struct</span> Page *pp)</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> page2ppn(pp) &lt;&lt; PGSHIFT;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>同样的，还有反过程。通过物理地址获取对应的页控制块。<code>PPN</code> 宏获取物理地址对应的页数，<code>pa2page</code> 根据该页数求对应的页控制块。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// in mmu.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PPN(va) (((u_long)(va)) &gt;&gt; 12)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// in pmap.h</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="keyword">struct</span> Page *<span class="title function_">pa2page</span><span class="params">(u_long pa)</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> (PPN(pa) &gt;= npage) &#123;</span><br><span class="line">		panic(<span class="string">&quot;pa2page called with invalid pa: %x&quot;</span>, pa);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> &amp;pages[PPN(pa)];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这样页控制块就大概讲清楚了。让我们回到 <code>mips_vm_init</code>。其中真正重要的只有第一句。在这一句中，我们调用了 <code>alloc</code> 函数申请了 <code>npage</code> 个 <code>struct Page</code> 大小的内存。并以 <code>BY2PG</code>（页的大小）进行对齐。同时将申请的内存中内容初始化为 0。这到底是什么意思？还是让我们看一下 <code>alloc</code> 的定义。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">mips_vm_init</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="comment">/* Allocate proper size of physical memory for global array `pages`,</span></span><br><span class="line"><span class="comment">	 * for physical memory management. Then, map virtual address `UPAGES` to</span></span><br><span class="line"><span class="comment">	 * physical address `pages` allocated before. For consideration of alignment,</span></span><br><span class="line"><span class="comment">	 * you should round up the memory size before map. */</span></span><br><span class="line">	pages = (<span class="keyword">struct</span> Page *)alloc(npage * <span class="keyword">sizeof</span>(<span class="keyword">struct</span> Page), BY2PG, <span class="number">1</span>);</span><br><span class="line">	printk(<span class="string">&quot;to memory %x for struct Pages.\n&quot;</span>, freemem);</span><br><span class="line">	printk(<span class="string">&quot;pmap.c:\t mips vm init success\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在内核启动阶段，我们还没有什么像样的内存申请方式。因此只能自己写一个。在 <code>alloc</code> 函数中，我们首先定义了两个变量。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> *<span class="title function_">alloc</span><span class="params">(u_int n, u_int align, <span class="type">int</span> clear)</span> &#123;</span><br><span class="line">	<span class="keyword">extern</span> <span class="type">char</span> end[];</span><br><span class="line">	u_long alloced_mem;</span><br></pre></td></tr></table></figure></p>
<p><code>alloced_mem</code> 是在程序中表示已分配内存的变量。<code>end</code> 是一个外部定义的变量，我们可以在 kernel.lds 中找到其对应的值。这在 Lab1 中也有所提及。需要注意的是，这里使用的是虚拟地址。查看内存分布表可知，此虚拟地址位于 kseg0 中。我们将内核的代码与数据结构都存储到 kseg0。接下来的内容都是在 kseg0 中进行。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">. = <span class="number">0x80400000</span>;</span><br><span class="line">end = . ;</span><br></pre></td></tr></table></figure></p>
<p>回到 <code>alloc</code>。第一步，我们先对 <code>freemem</code> 的值进行初始化。<code>freemem</code> 是用来表示可用内存地址的全局变量。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (freemem == <span class="number">0</span>) &#123;</span><br><span class="line">	freemem = (u_long)end; <span class="comment">// end</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>接着，我们把 <code>freemem</code> 以参数 <code>align</code> 对齐。这样接下来我们分配的内存才能从能被参数 <code>align</code> 整除的地址开始。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Step 1: Round up `freemem` up to be aligned properly */</span></span><br><span class="line">freemem = ROUND(freemem, align);</span><br></pre></td></tr></table></figure></p>
<p><code>ROUND</code> 宏定义在 include/types.h 中。只能对齐 2 的整数幂。主要原理是将低位抹零。<code>ROUND</code> 宏还有一个对应的宏 <code>ROUNDDOWN</code>。前者向上对齐，后者向下对齐。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Rounding; only works for n = power of two */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ROUND(a, n) (((((u_long)(a)) + (n)-1)) &amp; ~((n)-1))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ROUNDDOWN(a, n) (((u_long)(a)) &amp; ~((n)-1))</span></span><br></pre></td></tr></table></figure></p>
<p>在 <code>align</code> 中，我们现在确定已分配空间的上界，继续分配参数 <code>n</code> 个字节的内存。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Step 2: Save current value of `freemem` as allocated chunk. */</span></span><br><span class="line">alloced_mem = freemem;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Step 3: Increase `freemem` to record allocation. */</span></span><br><span class="line">freemem = freemem + n;</span><br></pre></td></tr></table></figure></p>
<p>如果需要清零，则使用 <code>memset</code> 函数清零。接着返回 <code>alloced_mem</code> 的地址。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Step 4: Clear allocated chunk if parameter `clear` is set. */</span></span><br><span class="line">	<span class="keyword">if</span> (clear) &#123;</span><br><span class="line">		<span class="built_in">memset</span>((<span class="type">void</span> *)alloced_mem, <span class="number">0</span>, n);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Step 5: return allocated chunk. */</span></span><br><span class="line">	<span class="keyword">return</span> (<span class="type">void</span> *)alloced_mem;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>值得注意的是中间还有一个类似于 <code>assert</code> 的语句<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Panic if we&#x27;re out of memory.</span></span><br><span class="line">panic_on(PADDR(freemem) &gt;= memsize);</span><br></pre></td></tr></table></figure></p>
<p>需要说明的是其中用到的的 <code>PADDR</code> 宏。这个宏将 kseg0 中的虚拟地址转化为物理地址。<code>ULIM</code> 是 kseg0 的基地址，因此 <code>a - ULIM</code> 等价于最高三位抹零。<code>PADDR</code> 还有一个对应宏 <code>KADDR</code>，将物理地址转换为 kseg0 中的内核虚拟地址，只不过是将减号改为加号。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> PADDR(kva) \</span></span><br><span class="line"><span class="meta">	(&#123; \</span></span><br><span class="line"><span class="meta">		u_long a = (u_long)(kva); \</span></span><br><span class="line"><span class="meta">		<span class="keyword">if</span> (a &lt; ULIM) \</span></span><br><span class="line"><span class="meta">			panic(<span class="string">&quot;PADDR called with invalid kva %08lx&quot;</span>, a); \</span></span><br><span class="line"><span class="meta">		a - ULIM; \</span></span><br><span class="line"><span class="meta">	&#125;)</span></span><br></pre></td></tr></table></figure></p>
<p><code>memsize</code> 是物理内存的大小，当物理地址大于 <code>memsize</code> 时也就说明其超出了内存。</p>
<p>好了，现在 <code>alloc</code> 也讲解完了。你可能会想：“这分配了什么，不是就直接返回了个指针么？” 确实。说白了内存你本就可以随意使用，申请内存不过是为了避免内存使用冲突的机制罢了。</p>
<p>当讲完了 <code>alloc</code> 后，<code>mips_vm_init</code> 的内容也就明了了。我们创建了一个 <code>struct Page</code> 的数组，大小为 <code>npage</code>。</p>
<h3 id="（3）初始化页"><a href="#（3）初始化页" class="headerlink" title="（3）初始化页"></a>（3）初始化页</h3><p>在 <code>page_init</code> 中，我们将对 <code>mips_vm_init</code> 中申请的数组内容进行初始化，并维护一个存储所有空闲页的链表。</p>
<p>在正式开始之前，需要介绍一下在 include/queue.h 中定义的双向链表宏。通过使用宏，我们在 c 语言中实现了泛型。</p>
<p>为了使用链表，我们需要定义两个结构 <code>LIST_HEAD</code> 和 <code>LIST_ENTRY</code>。前者表示链表头或链表本身的类型，后者表示链表中元素的类型。通过宏定义可知，<code>LIST_HEAD(name, type)</code> 表示创建一个元素类型为 <code>type</code> 的链表，这个链表类型名为 <code>name</code>。<code>LIST_ENTRY(type)</code> 表示创建一个类型为 <code>type</code> 的链表元素。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> LIST_HEAD(name, type) \</span></span><br><span class="line"><span class="meta">	struct name &#123; \</span></span><br><span class="line"><span class="meta">		struct type *lh_first; <span class="comment">/* first element */</span> \</span></span><br><span class="line"><span class="meta">	&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LIST_ENTRY(type) \</span></span><br><span class="line"><span class="meta">	struct &#123; \</span></span><br><span class="line"><span class="meta">		struct type *le_next;  <span class="comment">/* next element */</span> \</span></span><br><span class="line"><span class="meta">		struct type **le_prev; <span class="comment">/* address of previous next element */</span> \</span></span><br><span class="line"><span class="meta">	&#125;</span></span><br></pre></td></tr></table></figure></p>
<p>我们在 include/pmap.h 中就定义了元素为 <code>Page</code>，类型名为 <code>Page_list</code> 的链表。可以注意到 <code>struct Page</code> 的原始定义中包含了链表元素类型 <code>Page_LIST_entry_t</code><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">LIST_HEAD(Page_list, Page);</span><br><span class="line"><span class="keyword">typedef</span> <span class="title function_">LIST_ENTRY</span><span class="params">(Page)</span> Page_LIST_entry_t;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Page</span> &#123;</span></span><br><span class="line">	Page_LIST_entry_t pp_link; <span class="comment">/* free list link */</span></span><br><span class="line"></span><br><span class="line">	u_short pp_ref;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="class"><span class="keyword">struct</span> <span class="title">Page_list</span> <span class="title">page_free_list</span>;</span></span><br></pre></td></tr></table></figure></p>
<p>include/queue.h 中也定义了一些链表操作，因为原理相似，在这里只介绍 <code>LIST_INSERT_AFTER(listelm, elm, field)</code>。这个函数也是我们需要填写的。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> LIST_INSERT_AFTER(listelm, elm, field)                                                     \</span></span><br><span class="line"><span class="meta">	<span class="comment">/* Exercise 2.2: Your code here. */</span>  \</span></span><br><span class="line"><span class="meta">	do &#123; \</span></span><br><span class="line"><span class="meta">		<span class="keyword">if</span> ((LIST_NEXT((elm), field) = LIST_NEXT((listelm), field)) != NULL) \</span></span><br><span class="line"><span class="meta">			LIST_NEXT((listelm), field)-&gt;field.le_prev = &amp;LIST_NEXT((elm), field); \</span></span><br><span class="line"><span class="meta">		LIST_NEXT((listelm), field) = (elm); \</span></span><br><span class="line"><span class="meta">		(elm)-&gt;field.le_prev = &amp;LIST_NEXT((listelm), field); \</span></span><br><span class="line"><span class="meta">	&#125; while (0)</span></span><br></pre></td></tr></table></figure></p>
<p>对于代码的第一行，我们是容易理解的。在这两行中，我们先让 <code>elm</code> 的下一个元素指向 <code>listelm</code> 的下一个元素。若下一个元素不是 <code>NULL</code>，则还需要将这下一个元素的前一个元素设置为 <code>elm</code>。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ((LIST_NEXT((elm), field) = LIST_NEXT((listelm), field)) != <span class="literal">NULL</span>) \</span><br><span class="line">			LIST_NEXT((listelm), field)-&gt;field.le_prev = &amp;LIST_NEXT((elm), field); \</span><br></pre></td></tr></table></figure></p>
<p>但这里出现了问题，为什么第二行使用的是 <code>&amp;LIST_NEXT((elm), field)</code> 而非 <code>&amp;elm</code>？重新看一下 <code>LIST_ENTRY</code> 的定义，可以发现对 le_prev 的注释是 <code>/* address of previous next element */</code>。(前一个(下一个元素))的地址，也就是说本来 <code>le_prev</code> 的地址就是上一个元素的 <code>le_next</code> 的地址。这样做有什么意义呢？叶gg说这样方便定义头指针。因为 <code>LIST_HEAD</code> 和 <code>LIST_ENTRY</code> 不是同一个类型，如果 <code>le_prev</code> 的类型是 <code>struct type *</code>，那么头结点也必须是 <code>type</code> 类型，这会浪费一个指针大小的空间。</p>
<blockquote>
<p>有些文章可能会认为这个链表无法直接访问前节点，其实这应该是错的（因为如果是单向链表，那么根本没必要设计 <code>le_prev</code>）。</p>
</blockquote>
<p>这样的话，代码的第三四行也可以理解了。<code>listelm</code> 的下一个元素是 <code>elm</code>。<code>elm</code> 的 <code>le_prev</code> 的值是前一个元素，<code>listelm</code> 的 <code>le_next</code> 的地址。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">LIST_NEXT((listelm), field) = (elm); \</span><br><span class="line">(elm)-&gt;field.le_prev = &amp;LIST_NEXT((listelm), field); \</span><br></pre></td></tr></table></figure></p>
<p>现在我们理解了链表宏的含义，可以回来看 <code>page_init</code> 函数了。我们想一下接下来要做什么。我们有物理内存，并将其划分成了许多的页，这些页的信息通过页控制块保存在 <code>pages</code> 数组中。可是现在页控制块还没有被设置，具体来说，我们还没有明确哪些页是可用的，哪些页是已经被使用的。因此接下来我们要做到就是将页划分成可用和不可用的，并将可用的页控制块放入 <code>page_free_list</code> 中（这样想要申请新的页，只需要取出该链表的头结点即可）。</p>
<p>第一步，我们初始化链表（实际上只是将头结点的指针值设为 <code>NULL</code>）。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">page_init</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">	<span class="comment">/* Step 1: Initialize page_free_list. */</span></span><br><span class="line">	<span class="comment">/* Hint: Use macro `LIST_INIT` defined in include/queue.h. */</span></span><br><span class="line">	<span class="comment">/* Exercise 2.3: Your code here. (1/4) */</span></span><br><span class="line">	LIST_INIT(&amp;page_free_list);</span><br></pre></td></tr></table></figure></p>
<p>然后我们确定已使用内存的最大地址，为了适配页的大小，需要进行对齐<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Step 2: Align `freemem` up to multiple of BY2PG. */</span></span><br><span class="line"><span class="comment">/* Exercise 2.3: Your code here. (2/4) */</span></span><br><span class="line">freemem = ROUND(freemem, BY2PG);</span><br></pre></td></tr></table></figure></p>
<p>接着，我们需要将已使用的页的引用数设为 1，表示页已经被使用。首先我们计算有多少已使用的页，我们先使用 <code>PADDR</code> 将 <code>freemem</code> 转换为物理地址，接着使用 <code>PPN</code> 获取该地址属于第几个页表。使用一个循环将前 <code>usedpage</code> 个页控制块的 <code>pp_ref</code> 设置为 1。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Step 3: Mark all memory below `freemem` as used (set `pp_ref` to 1) */</span></span><br><span class="line"><span class="comment">/* Exercise 2.3: Your code here. (3/4) */</span></span><br><span class="line">u_long usedpage = PPN(PADDR(freemem));</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (u_long i = <span class="number">0</span>; i &lt; usedpage; i++) &#123;</span><br><span class="line">	pages[i].pp_ref = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>最后，我们将剩下的页控制块的 <code>pp_ref</code> 设置为 0，并将这些页控制块插入到 <code>page_free_list</code> 中。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">	<span class="comment">/* Step 4: Mark the other memory as free. */</span></span><br><span class="line">	<span class="comment">/* Exercise 2.3: Your code here. (4/4) */</span></span><br><span class="line">	<span class="keyword">for</span> (u_long i = usedpage; i &lt; npage; i++) &#123;</span><br><span class="line">		pages[i].pp_ref = <span class="number">0</span>;</span><br><span class="line">		LIST_INSERT_HEAD(&amp;page_free_list, &amp;pages[i], pp_link);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="三、页式内存管理"><a href="#三、页式内存管理" class="headerlink" title="三、页式内存管理"></a>三、页式内存管理</h2><p>当我们使用 kuseg 地址空间的虚拟地址访问内存时，我们会通过 TLB 将其转换为物理地址。当 TLB 中查询不到对应的物理地址时，就会发生 TLB Miss 异常。这时将跳转到异常处理函数，执行 TLB 重填。在 Lab2，我们的代码还未启用异常处理，因此无法真正运行页式内存管理机制，但是代码中已经定义了 TLB 重填函数。我们将从此开始解读 MOS 中的页式内存管理。</p>
<blockquote>
<p>注意，页式内存管理部分各类函数杂糅在一起。水平有限，以调用过程叙述时实在难以保证行文结构，因此小节题目不一定完全概括小节内容</p>
</blockquote>
<h3 id="（1）TLB-重填"><a href="#（1）TLB-重填" class="headerlink" title="（1）TLB 重填"></a>（1）TLB 重填</h3><p>TLB 的重填过程由 kern/tlb_asm.S 中的 <code>do_tlb_refill</code> 函数完成。该函数是汇编实现的。首先，定义了一个字的变量，标签为 <code>tlb_refill_ra</code><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.data</span><br><span class="line">tlb_refill_ra:</span><br><span class="line">.word <span class="number">0</span></span><br></pre></td></tr></table></figure></p>
<p>接着是代码部分。首先我们使用 <code>NESTED</code> 定义函数标签。<code>NESTED</code> 与 <code>LEAF</code> 宏相对应。前者表示非叶函数，后者表示叶函数。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">.text</span><br><span class="line"><span class="title function_">NESTED</span><span class="params">(do_tlb_refill, <span class="number">0</span>, zero)</span></span><br></pre></td></tr></table></figure></p>
<p>我们希望汇编尽可能少，因此希望 <code>do_tlb_refill</code> 只做必要的处理，随后调用 c 函数进一步处理。因此首先我们设置参数。第一个参数是 <code>BadVAddr</code> 寄存器的值，即发生 TLB Miss 的虚拟地址；第二个参数是 <code>EntryHi</code> 寄存器的 6-11 位。即当前进程的 ASID。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mfc0    a0, CP0_BADVADDR</span><br><span class="line">mfc0    a1, CP0_ENTRYHI</span><br><span class="line">srl     a1, a1, <span class="number">6</span></span><br><span class="line">andi    a1, a1, <span class="number">0b111111</span></span><br></pre></td></tr></table></figure></p>
<p>接着我们调用 c 函数 <code>_do_tlb_refill</code>（这个函数会在后面说明）。注意这里存储了原来的 <code>ra</code> 寄存器值。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sw      ra, tlb_refill_ra</span><br><span class="line">jal     _do_tlb_refill</span><br><span class="line">lw      ra, tlb_refill_ra</span><br></pre></td></tr></table></figure></p>
<p><code>_do_tlb_refill</code> 会返回虚拟地址对应的页表项。我们将该返回值存入 <code>EntryLo</code>，并将 <code>EntryHi</code> 和 <code>EntryLo</code> 的值写入 TLB。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">	mtc0    v0, CP0_ENTRYLO0</span><br><span class="line">	<span class="comment">// See &lt;IDT R30xx Family Software Reference Manual&gt; Chapter 6-8</span></span><br><span class="line">	nop</span><br><span class="line">	<span class="comment">/* Hint: use &#x27;tlbwr&#x27; to write CP0.EntryHi/Lo into a random tlb entry. */</span></span><br><span class="line">	<span class="comment">/* Exercise 2.10: Your code here. */</span></span><br><span class="line">	tlbwr</span><br><span class="line"></span><br><span class="line">	jr      ra</span><br><span class="line"><span class="title function_">END</span><span class="params">(do_tlb_refill)</span></span><br></pre></td></tr></table></figure></p>
<p>这样就完成了 TLB 重填。跳回到正常程序后，此前产生异常的虚拟地址就可以通过 TLB 访问内存了。</p>
<p>接着我们详细深入 <code>_do_tlb_refill</code>，这个函数在 kern/tlbex.c 中。正如 hints 所说，在这个函数中，我们会不断查找虚拟地址对应的页表项，如果未找到，则试图申请一个新的页表项。最终返回申请到的页表项的内容。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Pte _do_tlb_refill(u_long va, u_int asid) &#123;</span><br><span class="line">	Pte *pte;</span><br><span class="line">	<span class="comment">/* Hints:</span></span><br><span class="line"><span class="comment">	 *  Invoke &#x27;page_lookup&#x27; repeatedly in a loop to find the page table entry &#x27;pte&#x27; associated</span></span><br><span class="line"><span class="comment">	 *  with the virtual address &#x27;va&#x27; in the current address space &#x27;cur_pgdir&#x27;.</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 *  **While** &#x27;page_lookup&#x27; returns &#x27;NULL&#x27;, indicating that the &#x27;pte&#x27; could not be found,</span></span><br><span class="line"><span class="comment">	 *  allocate a new page using &#x27;passive_alloc&#x27; until &#x27;page_lookup&#x27; succeeds.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Exercise 2.9: Your code here. */</span></span><br><span class="line">	<span class="keyword">while</span> (page_lookup(cur_pgdir, va, &amp;pte) == <span class="literal">NULL</span>) &#123;</span><br><span class="line">		passive_alloc(va, cur_pgdir, asid);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> *pte;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="（2）页的查找"><a href="#（2）页的查找" class="headerlink" title="（2）页的查找"></a>（2）页的查找</h3><p>接着我们详细讨论 <code>_do_tlb_refill</code> 中所使用的函数。</p>
<p><code>page_lookup</code> 函数在 kern/pmap.c 中定义。这个函数用于查找虚拟地址对应的页控制块及页表项。函数的参数是页目录的（虚拟）基地址，想要转换的虚拟地址和用于返回对应页表项的指针。值得注意的是，<code>_do_tlb_refill</code> 调用该函数时页目录基地址参数使用的是全局变量 <code>cur_pgdir</code>。可是这个全局变量并没有任何被赋值。这也是在 Lab2 中页式内存管理无法使用的一个原因。</p>
<p>我们继续看 <code>page_lookup</code> 的内容。其中首先调用了另一个函数 <code>pgdir_walk</code>。这个函数会获取想要转换的虚拟地址对应的（二级）页表项地址，通过 <code>pte</code> 返回。其中第三个参数 <code>create</code> 表示若未找到对应页表是否创建新的页表，此处为 0 表示不创建。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> Page *<span class="title function_">page_lookup</span><span class="params">(Pde *pgdir, u_long va, Pte **ppte)</span> &#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Page</span> *<span class="title">pp</span>;</span></span><br><span class="line">	Pte *pte;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Step 1: Get the page table entry. */</span></span><br><span class="line">	pgdir_walk(pgdir, va, <span class="number">0</span>, &amp;pte);</span><br></pre></td></tr></table></figure></p>
<p>接着 <code>page_lookup</code> 检查是否获取到对应的页表项，未获取到返回 <code>NULL</code><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Hint: Check if the page table entry doesn&#x27;t exist or is not valid. */</span></span><br><span class="line"><span class="keyword">if</span> (pte == <span class="literal">NULL</span> || (*pte &amp; PTE_V) == <span class="number">0</span>) &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>如果获取到，我们找到页表项对应的页控制块，并返回。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">	<span class="comment">/* Step 2: Get the corresponding Page struct. */</span></span><br><span class="line">	<span class="comment">/* Hint: Use function `pa2page`, defined in include/pmap.h . */</span></span><br><span class="line">	pp = pa2page(*pte);</span><br><span class="line">	<span class="keyword">if</span> (ppte) &#123;</span><br><span class="line">		*ppte = pte;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> pp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>需要注意这里有一个容易引起困惑的地方，<code>pte</code> 是虚拟地址对应的页表项的地址，<code>*pte</code> 是页表项的内容。我们知道页表项中除了物理地址之外还存储有其他信息。怎么就把其当做物理地址传入 <code>pa2page</code> 函数了呢？</p>
<p>让我们回到 <code>pa2page</code> 就知道了。在 <code>pa2page</code> 中我们通过 <code>PPN</code> 获取物理地址对应的第几页，而 <code>PPN</code> 是通过右移 12 位实现的。这样我们就将页表项中低位的用于表示权限等信息的内容消去，而只剩下页数了。（或许也正是因为 <code>*pte</code> 的低位无用，才将其用作其他内容。）</p>
</blockquote>
<p>接着我们考察 <code>pgdir_walk</code> 函数，这个函数也在 kern/pmap.c 中定义。并且是需要我们填写的函数。如前所述，这个函数要实现查找对应虚拟地址对应的（二级）页表项，并根据 <code>create</code> 参数的设置在未找到二级页表时创建二级页表。</p>
<p>首先，我们根据虚拟地址确定对应的页目录项的地址。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">pgdir_walk</span><span class="params">(Pde *pgdir, u_long va, <span class="type">int</span> create, Pte **ppte)</span> &#123;</span><br><span class="line">	Pde *pgdir_entryp;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Page</span> *<span class="title">pp</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Step 1: Get the corresponding page directory entry. */</span></span><br><span class="line">	<span class="comment">/* Exercise 2.6: Your code here. (1/3) */</span></span><br><span class="line">	pgdir_entryp = pgdir + PDX(va);</span><br></pre></td></tr></table></figure></p>
<p>其中使用了 <code>PDX</code> 宏。这个宏定义在 include/mmu.h 中。用于获取虚拟地址的 22-31 位的数值，这是虚拟地址对应的页目录项相对于页目录基地址的偏移。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> PDX(va) ((((u_long)(va)) &gt;&gt; 22) &amp; 0x03FF)</span></span><br></pre></td></tr></table></figure></p>
<p>随后我们判断该页目录项是否有效。如果无效，判断是否需要创建新的二级页表。如需要则使用 <code>page_alloc</code> 函数申请一个物理页，并设置虚拟地址对应页目录项的内容 <code>*pgdir_entryp = page2pa(pp) | PTE_D | PTE_V</code>，使其与该物理页关联。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!(*pgdir_entryp &amp; PTE_V)) &#123;</span><br><span class="line">		<span class="keyword">if</span> (create) &#123;</span><br><span class="line">			<span class="keyword">if</span> (page_alloc(&amp;pp) != <span class="number">0</span>) &#123;</span><br><span class="line">				<span class="keyword">return</span> -E_NO_MEM;</span><br><span class="line">			&#125;</span><br><span class="line">			pp-&gt;pp_ref++;</span><br><span class="line">			*pgdir_entryp = page2pa(pp) | PTE_D | PTE_V;</span><br></pre></td></tr></table></figure></p>
<p><code>page_alloc</code> 函数是一个简单的函数，用于从 <code>page_free_list</code> 中抽取第一个空闲的页控制块，将页控制块对应的物理内存作为分配的内存。将该内存初始化为 0。唯一需要注意的是 <code>page2kva</code>。此函数实际上只是 <code>KADDR(page2pa(pp))</code>。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">page_alloc</span><span class="params">(<span class="keyword">struct</span> Page **new)</span> &#123;</span><br><span class="line">	<span class="comment">/* Step 1: Get a page from free memory. If fails, return the error code.*/</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Page</span> *<span class="title">pp</span>;</span></span><br><span class="line">	<span class="comment">/* Exercise 2.4: Your code here. (1/2) */</span></span><br><span class="line">	<span class="keyword">if</span> (LIST_EMPTY(&amp;page_free_list)) &#123;</span><br><span class="line">		<span class="keyword">return</span> -E_NO_MEM;</span><br><span class="line">	&#125;</span><br><span class="line">	pp = LIST_FIRST(&amp;page_free_list);</span><br><span class="line"></span><br><span class="line">	LIST_REMOVE(pp, pp_link);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Step 2: Initialize this page with zero.</span></span><br><span class="line"><span class="comment">	 * Hint: use `memset`. */</span></span><br><span class="line">	<span class="comment">/* Exercise 2.4: Your code here. (2/2) */</span></span><br><span class="line">	<span class="built_in">memset</span>((<span class="type">void</span> *)page2kva(pp), <span class="number">0</span>, BY2PG);</span><br><span class="line"></span><br><span class="line">	*new = pp;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>回到 <code>pgdir_walk</code>，如果不需要创建，则直接返回<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		*ppte = <span class="literal">NULL</span>;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>函数中剩下的流程中，二级页表必然存在了。我们获取二级页表的虚拟基地址，并找到虚拟地址 <code>va</code> 对应的二级页表项，返回。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">	<span class="comment">/* Step 3: Assign the kernel virtual address of the page table entry to &#x27;*ppte&#x27;. */</span></span><br><span class="line">	<span class="comment">/* Exercise 2.6: Your code here. (3/3) */</span></span><br><span class="line">	Pte *pgtable = (Pte *)KADDR(PTE_ADDR(*pgdir_entryp));</span><br><span class="line">	*ppte = pgtable + PTX(va);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>需要注意这里我们使用了两个宏来获取二级页表基地址。第一个宏 <code>PTE_ADDR</code> 定义在 include/mmu.h 中。它返回页目录项对应的二级页表的基地址。实际上就是将页目录项内容的低 12 位抹零。如果是新申请的物理页作为二级页表，则该值实际上等于 <code>page2pa(pp)</code>。另一个宏 <code>KADDR</code> 将物理地址转换为 kseg0 的虚拟地址，不用细说。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> PTE_ADDR(pte) ((u_long)(pte) &amp; ~0xFFF)</span></span><br></pre></td></tr></table></figure></p>
<p>与 <code>PDX</code> 类似，<code>PTX</code> 宏返回虚拟地址 12-21 位的数值，<code>pgtable</code> 二级页表基地址加上偏移得到虚拟地址 <code>va</code> 对应的二级页表项。</p>
<h3 id="（3）页的申请"><a href="#（3）页的申请" class="headerlink" title="（3）页的申请"></a>（3）页的申请</h3><p><code>pgdir_walk</code> 的内容我们已经分析完成，现在 <code>page_lookup</code> 函数也没有需要讲解的部分了。接下来我们分析 <code>_do_tlb_refill</code> 中的 <code>passive_alloc</code>。</p>
<p><code>passive_alloc</code> 定义在 kern/tlbex.c 中。这是一个用于为虚拟地址申请物理页的函数。它的参数是：想要关联物理地址的虚拟地址、页目录的基地址和标识进程的 asid。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">passive_alloc</span><span class="params">(u_int va, Pde *pgdir, u_int asid)</span> &#123;</span><br></pre></td></tr></table></figure></p>
<p>函数一开头就是好几条检查地址是否非法的判断语句，这里就不列出了。接下来的内容是，函数通过 <code>page_alloc</code> 申请一个物理页，并试图通过 <code>page_insert</code> 建立物理页和虚拟地址的联系。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">	panic_on(page_alloc(&amp;p));</span><br><span class="line">	panic_on(page_insert(pgdir, asid, p, PTE_ADDR(va), PTE_D));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>page_alloc</code> 已经在之前介绍过了，现在介绍 <code>page_insert</code>。这个函数定义在 kern/pmap.c 中。是我们需要补完的函数。</p>
<p>该函数首先调用 <code>pgdir_walk</code>，试图获取当前虚拟地址对应的二级页表项。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">page_insert</span><span class="params">(Pde *pgdir, u_int asid, <span class="keyword">struct</span> Page *pp, u_long va, u_int perm)</span> &#123;</span><br><span class="line">	Pte *pte;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/* Step 1: Get corresponding page table entry. */</span></span><br><span class="line">	pgdir_walk(pgdir, va, <span class="number">0</span>, &amp;pte);</span><br></pre></td></tr></table></figure></p>
<p>如果确实获得了虚拟地址对应的二级页表项，并且是有效的，那么判断该页表项对应的物理页是否就是 <code>va</code> 想要映射的物理页（通过比较页控制块）。如果不一样，那么调用 <code>page_remove</code> 移除虚拟地址到原有的页的映射。<code>page_remove</code> 将在后续说明。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (pte &amp;&amp; (*pte &amp; PTE_V)) &#123;</span><br><span class="line">	<span class="keyword">if</span> (pa2page(*pte) != pp) &#123;</span><br><span class="line">		page_remove(pgdir, asid, va);</span><br></pre></td></tr></table></figure></p>
<p>如果相同，说明虚拟地址已经映射到了对应的物理页。这时我们只需要更新一下页表项的权限 <code>*pte = page2pa(pp) | perm | PTE_V</code>。为了保证对页表的修改都能反映到 TLB 中，我们要调用 <code>tlb_invalidate</code> 函数将原有的关于 <code>va</code> 和 <code>asid</code> 的 TLB 表项清除。<code>tlb_invalidate</code> 将在后面说明。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		tlb_invalidate(asid, va);</span><br><span class="line">		*pte = page2pa(pp) | perm | PTE_V;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>程序执行 <code>page_insert</code> 的后续语句时，一定不存在虚拟地址 <code>va</code> 到页控制块对应的物理页的映射。于是接下来，我们就要建立这样的映射。首先我们还是要调用 <code>tlb_invalidate</code> 清除原有内容。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Step 2: Flush TLB with &#x27;tlb_invalidate&#x27;. */</span></span><br><span class="line"><span class="comment">/* Exercise 2.7: Your code here. (1/3) */</span></span><br><span class="line">tlb_invalidate(asid, va);</span><br></pre></td></tr></table></figure></p>
<p>随后再调用一次 <code>pgdir_walk</code>，只不过这次 <code>create=1</code>。这将获得 <code>va</code> 对应的二级页表项<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Step 3: Re-get or create the page table entry. */</span></span><br><span class="line"><span class="comment">/* If failed to create, return the error. */</span></span><br><span class="line"><span class="comment">/* Exercise 2.7: Your code here. (2/3) */</span></span><br><span class="line"><span class="keyword">if</span> (pgdir_walk(pgdir, va, <span class="number">1</span>, &amp;pte) != <span class="number">0</span>) &#123;</span><br><span class="line">	<span class="keyword">return</span> -E_NO_MEM;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>最后，我们只需要建立二级页表项到物理页的联系即可。我们只需修改二级页表项的内容，修改为物理页的物理地址和权限设置即可。同时不要忘记递增页控制块的引用计数。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">	<span class="comment">/* Step 4: Insert the page to the page table entry with &#x27;perm | PTE_V&#x27; and increase its</span></span><br><span class="line"><span class="comment">	 * &#x27;pp_ref&#x27;. */</span></span><br><span class="line">	<span class="comment">/* Exercise 2.7: Your code here. (3/3) */</span></span><br><span class="line">	*pte = page2pa(pp) | perm | PTE_V;</span><br><span class="line">	pp-&gt;pp_ref++;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="（4）页的移除"><a href="#（4）页的移除" class="headerlink" title="（4）页的移除"></a>（4）页的移除</h3><p>结束了 <code>page_insert</code> 的说明，让我们重新拾起按下不表的 <code>page_remove</code> 和 <code>tlb_invalidate</code>。我们首先考察 <code>page_remove</code>，此函数定义在 kern/pmap.c 中。用于取消虚拟地址 <code>va</code> 到物理页的映射。</p>
<p>首先该函数调用 <code>page_lookup</code> 查找与 <code>va</code> 和 <code>asid</code> 映射的物理页。如果不存在这样的页，则直接返回<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">page_remove</span><span class="params">(Pde *pgdir, u_int asid, u_long va)</span> &#123;</span><br><span class="line">	Pte *pte;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Step 1: Get the page table entry, and check if the page table entry is valid. */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Page</span> *<span class="title">pp</span> =</span> page_lookup(pgdir, va, &amp;pte);</span><br><span class="line">	<span class="keyword">if</span> (pp == <span class="literal">NULL</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure></p>
<p>如果存在，则调用 <code>page_decref</code> 以递减该页的引用数。当引用数等于零时，将该物理页重新放入未使用页的链表。因为对页表进行了修改，需要调用 <code>tlb_invalidate</code> 确保 TLB 中不保留原有内容。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">	<span class="comment">/* Step 2: Decrease reference count on &#x27;pp&#x27;. */</span></span><br><span class="line">	page_decref(pp);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Step 3: Flush TLB. */</span></span><br><span class="line">	*pte = <span class="number">0</span>;</span><br><span class="line">	tlb_invalidate(asid, va);</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>page_decref</code> 定义如下，该函数和 <code>page_free</code> 都定义在 kern/pmap.c 中。这两个函数不需要讲解。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">page_free</span><span class="params">(<span class="keyword">struct</span> Page *pp)</span> &#123;</span><br><span class="line">	assert(pp-&gt;pp_ref == <span class="number">0</span>);</span><br><span class="line">	<span class="comment">/* Just insert it into &#x27;page_free_list&#x27;. */</span></span><br><span class="line">	<span class="comment">/* Exercise 2.5: Your code here. */</span></span><br><span class="line">	LIST_INSERT_HEAD(&amp;page_free_list, pp, pp_link);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">page_decref</span><span class="params">(<span class="keyword">struct</span> Page *pp)</span> &#123;</span><br><span class="line">	assert(pp-&gt;pp_ref &gt; <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* If &#x27;pp_ref&#x27; reaches to 0, free this page. */</span></span><br><span class="line">	<span class="keyword">if</span> (--pp-&gt;pp_ref == <span class="number">0</span>) &#123;</span><br><span class="line">		page_free(pp);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>还剩 <code>tlb_invalidate</code> 函数需要说明。这个函数主要用于调用另一个汇编函数 <code>tlb_out</code>。<code>tlb_invalidate</code> 将参数 <code>asid</code> 和 <code>va</code> 结合在了一起，传入 <code>tlb_out</code>。实际上这个结合在一起的参数就是 <code>EntryHi</code> 寄存器的结构。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">tlb_invalidate</span><span class="params">(u_int asid, u_long va)</span> &#123;</span><br><span class="line">	tlb_out(PTE_ADDR(va) | (asid &lt;&lt; <span class="number">6</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>我们再考察 <code>tlb_out</code> 的内容。这部分定义在 kern/tlb_asm.S 中。首先可知，<code>tlb_out</code> 是一个叶函数。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LEAF(tlb_out)</span><br></pre></td></tr></table></figure></p>
<p>函数在一开始将原有的 <code>EnryHi</code> 寄存器中的值保存，并将传入的参数设置为 <code>EnryHi</code> 新的值。然后根据新的值查找 TLB 表项。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">set</span> noreorder</span><br><span class="line">	mfc0    t0, CP0_ENTRYHI</span><br><span class="line">	mtc0    a0, CP0_ENTRYHI</span><br><span class="line">	nop</span><br><span class="line">	<span class="comment">/* Step 1: Use &#x27;tlbp&#x27; to probe TLB entry */</span></span><br><span class="line">	<span class="comment">/* Exercise 2.8: Your code here. (1/2) */</span></span><br><span class="line">	tlbp <span class="comment">// 这条指令根据 EntryHi 中的 Key，查找 TLB 中对应的表项，将该项的索引存入 Index 寄存器</span></span><br><span class="line">	</span><br><span class="line">	nop</span><br></pre></td></tr></table></figure></p>
<p>随后将 <code>Index</code> 寄存器中的查询结果存储到 <code>t1</code> 寄存器，如果结果小于 0，说明未找到对应的表项，跳转到 NO_SUCH_ENTRY，不需要进行清零操作。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">	mfc0    t1, CP0_INDEX</span><br><span class="line">.<span class="built_in">set</span> reorder</span><br><span class="line">	bltz    t1, NO_SUCH_ENTRY </span><br></pre></td></tr></table></figure></p>
<p>这里分别将 <code>EntryHi</code> 和 <code>EntryLo</code> 设置为 0。并将内容写入对应的表项，实现清零。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">.<span class="built_in">set</span> noreorder</span><br><span class="line">	mtc0    zero, CP0_ENTRYHI</span><br><span class="line">	mtc0    zero, CP0_ENTRYLO0</span><br><span class="line">	nop</span><br><span class="line">	</span><br><span class="line">	tlbwi</span><br></pre></td></tr></table></figure></p>
<p>最后，恢复进入函数时 <code>EntryHi</code> 存储的值，函数返回。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">.<span class="built_in">set</span> reorder</span><br><span class="line"></span><br><span class="line">NO_SUCH_ENTRY:</span><br><span class="line">	mtc0    t0, CP0_ENTRYHI</span><br><span class="line"></span><br><span class="line">	j       ra</span><br><span class="line"><span class="title function_">END</span><span class="params">(tlb_out)</span></span><br></pre></td></tr></table></figure></p>
<p>这样就完成了 Lab2 中所有涉及到的代码的讲解。</p>

    </div>

    
    
    
        

<div>
<ul class="post-copyright">
  <li class="post-copyright-author">
    <strong>本文作者： </strong>wokron
  </li>
  <li class="post-copyright-link">
    <strong>本文链接：</strong>
    <a href="https://wokron.github.io/posts/db841b3c/" title="BUAA OS实验笔记之Lab2">https://wokron.github.io/posts/db841b3c/</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/zh-CN" rel="noopener" target="_blank"><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！
  </li>
</ul>
</div>


      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/MOS/" rel="tag"># MOS</a>
              <a href="/tags/os/" rel="tag"># os</a>
              <a href="/tags/BUAA/" rel="tag"># BUAA</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/posts/7a0960e5/" rel="prev" title="基于概率模型的蘑菇菌丝规模分析">
      <i class="fa fa-chevron-left"></i> 基于概率模型的蘑菇菌丝规模分析
    </a></div>
      <div class="post-nav-item">
    <a href="/posts/5e49fa6a/" rel="next" title="BUAA-OS实验笔记之Lab3">
      BUAA-OS实验笔记之Lab3 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%80%E3%80%81Lab2-%E5%89%8D%E8%A8%80"><span class="nav-number">1.</span> <span class="nav-text">一、Lab2 前言</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%8C%E3%80%81%E5%86%85%E6%A0%B8%E5%88%9D%E5%A7%8B%E5%8C%96%EF%BC%88%E7%BB%AD%EF%BC%89"><span class="nav-number">2.</span> <span class="nav-text">二、内核初始化（续）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%881%EF%BC%89%E6%8E%A2%E6%B5%8B%E5%86%85%E5%AD%98"><span class="nav-number">2.1.</span> <span class="nav-text">（1）探测内存</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%882%EF%BC%89%E5%88%9D%E5%A7%8B%E5%8C%96%E8%99%9A%E6%8B%9F%E5%9C%B0%E5%9D%80"><span class="nav-number">2.2.</span> <span class="nav-text">（2）初始化虚拟地址</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%883%EF%BC%89%E5%88%9D%E5%A7%8B%E5%8C%96%E9%A1%B5"><span class="nav-number">2.3.</span> <span class="nav-text">（3）初始化页</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%89%E3%80%81%E9%A1%B5%E5%BC%8F%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86"><span class="nav-number">3.</span> <span class="nav-text">三、页式内存管理</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%881%EF%BC%89TLB-%E9%87%8D%E5%A1%AB"><span class="nav-number">3.1.</span> <span class="nav-text">（1）TLB 重填</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%882%EF%BC%89%E9%A1%B5%E7%9A%84%E6%9F%A5%E6%89%BE"><span class="nav-number">3.2.</span> <span class="nav-text">（2）页的查找</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%883%EF%BC%89%E9%A1%B5%E7%9A%84%E7%94%B3%E8%AF%B7"><span class="nav-number">3.3.</span> <span class="nav-text">（3）页的申请</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%884%EF%BC%89%E9%A1%B5%E7%9A%84%E7%A7%BB%E9%99%A4"><span class="nav-number">3.4.</span> <span class="nav-text">（4）页的移除</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="wokron"
      src="/images/avatar.jpg">
  <p class="site-author-name" itemprop="name">wokron</p>
  <div class="site-description" itemprop="description">StringCat的个人博客。记录学习、分享经验</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">64</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">7</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">66</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/wokron" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;wokron" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="/stringcatwok@gmail.com" title="E-Mail → stringcatwok@gmail.com"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>
  <div class="cc-license motion-element" itemprop="license">
    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/zh-CN" class="cc-opacity" rel="noopener" target="_blank"><img src="/images/cc-by-nc-sa.svg" alt="Creative Commons"></a>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">wokron</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item-icon">
      <i class="fa fa-fa fa-user"></i>
    </span>
    <span class="site-uv" title="总访客量">
      总访问人数：<span id="busuanzi_value_site_uv"></span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-fa fa-eye"></i>
    </span>
    <span class="site-pv" title="总访问量">
      总阅读次数：<span id="busuanzi_value_site_pv"></span>
    </span>
</div>







      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

  

<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"log":false,"model":{"jsonPath":"/live2dw/assets/hijiki.model.json"},"display":{"position":"right","width":150,"height":300},"mobile":{"show":true}});</script></body>
</html>
