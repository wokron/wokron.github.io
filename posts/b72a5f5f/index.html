<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"wokron.github.io","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":"default","style":"mac"},"back2top":{"enable":true,"sidebar":false,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="一、Lab5 前言这是最长的一篇文章，可就算这么长，文中出现的代码也不过本次 Lab 中新增加的代码的一小部分。幸好完成本次实验不需要熟悉所有代码，一部分练习甚至不需要熟悉要填写的代码的前后文，只需要根据注释就可以填出很多。可是我感觉本篇文章还是有帮助的，毕竟谁也不知道 Exam 会出什么题。 Lab5 主要分为四部分，分别是镜像制作工具、关于设备的系统调用、文件系统服务进程、文件操作库函数。本文">
<meta property="og:type" content="article">
<meta property="og:title" content="BUAA-OS实验笔记之Lab5">
<meta property="og:url" content="https://wokron.github.io/posts/b72a5f5f/index.html">
<meta property="og:site_name" content="StringCat的博客">
<meta property="og:description" content="一、Lab5 前言这是最长的一篇文章，可就算这么长，文中出现的代码也不过本次 Lab 中新增加的代码的一小部分。幸好完成本次实验不需要熟悉所有代码，一部分练习甚至不需要熟悉要填写的代码的前后文，只需要根据注释就可以填出很多。可是我感觉本篇文章还是有帮助的，毕竟谁也不知道 Exam 会出什么题。 Lab5 主要分为四部分，分别是镜像制作工具、关于设备的系统调用、文件系统服务进程、文件操作库函数。本文">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2023-05-02T00:34:31.000Z">
<meta property="article:modified_time" content="2023-06-26T02:38:38.376Z">
<meta property="article:author" content="wokron">
<meta property="article:tag" content="MOS">
<meta property="article:tag" content="os">
<meta property="article:tag" content="BUAA">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://wokron.github.io/posts/b72a5f5f/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>BUAA-OS实验笔记之Lab5 | StringCat的博客</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">StringCat的博客</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">学生党踩坑记录</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://wokron.github.io/posts/b72a5f5f/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="wokron">
      <meta itemprop="description" content="StringCat的个人博客。记录学习、分享经验">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="StringCat的博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          BUAA-OS实验笔记之Lab5
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-05-02 08:34:31" itemprop="dateCreated datePublished" datetime="2023-05-02T08:34:31+08:00">2023-05-02</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-06-26 10:38:38" itemprop="dateModified" datetime="2023-06-26T10:38:38+08:00">2023-06-26</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">学习笔记</span></a>
                </span>
            </span>

          
          <span class="post-meta-divider">|</span>
          <span class="post-meta-item-icon">
              <i class="fa fa-fa fa-eye"></i>
          </span>
          <span class="post-meta-item-text">阅读次数：</span>
          <span id="busuanzi_value_page_pv"></span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h2 id="一、Lab5-前言"><a href="#一、Lab5-前言" class="headerlink" title="一、Lab5 前言"></a>一、Lab5 前言</h2><p>这是最长的一篇文章，可就算这么长，文中出现的代码也不过本次 Lab 中新增加的代码的一小部分。幸好完成本次实验不需要熟悉所有代码，一部分练习甚至不需要熟悉要填写的代码的前后文，只需要根据注释就可以填出很多。可是我感觉本篇文章还是有帮助的，毕竟谁也不知道 Exam 会出什么题。</p>
<p>Lab5 主要分为四部分，分别是镜像制作工具、关于设备的系统调用、文件系统服务进程、文件操作库函数。本文对这四个方面都有所涉及，第二章主要讲镜像制作工具，第三章主要讲文件系统服务进程和文件操作库函数，最后一章讲关于设备的系统调用。</p>
<span id="more"></span>
<h2 id="二、磁盘镜像"><a href="#二、磁盘镜像" class="headerlink" title="二、磁盘镜像"></a>二、磁盘镜像</h2><h3 id="（1）镜像制作工具"><a href="#（1）镜像制作工具" class="headerlink" title="（1）镜像制作工具"></a>（1）镜像制作工具</h3><p>在本次实验中我们要实现一个文件系统。广义来说，一切字节序列都可以称为文件，但本次实验中我们还是主要关注在磁盘中存储的数据，将这些数据按一定的结构组织起来，就是本次实验的主要目标。</p>
<p>本文依旧不按照指导书中的顺序。我们先查看位于 tools 文件夹下的磁盘镜像制作工具 fsformat 的源代码，以便我们理解磁盘以及文件系统的组织结构。</p>
<h3 id="（2）磁盘数据初始化"><a href="#（2）磁盘数据初始化" class="headerlink" title="（2）磁盘数据初始化"></a>（2）磁盘数据初始化</h3><p>我们查看 tools/fsformat.c 文件。找到其中的 <code>main</code> 函数。<code>main</code> 函数首先调用了 <code>init_disk</code> 用于初始化磁盘。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span> &#123;</span><br><span class="line">	<span class="keyword">static_assert</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> File) == BY2FILE);</span><br><span class="line">	init_disk();</span><br></pre></td></tr></table></figure></p>
<p>该函数中我们要用到一个数据结构 <code>disk</code>。因此我们先考察 <code>disk</code>。<code>disk</code> 是一个数组，大小为 <code>NBLOCK</code>，每个元素是一个结构体，其中有字段 <code>data</code>，是一个 <code>BY2BLK</code> 字节大小的空间，用于存储一个磁盘块的数据。很容易得知，<code>NBLOCK</code> * <code>BY2BLK</code> = 磁盘空间大小。这样就可以理解 <code>disk</code> 起到的作用了，也就是在构筑磁盘镜像时暂时存储磁盘数据，等到构筑完成后再将 <code>disk</code> 中 <code>data</code> 的内容拼接并输出为二进制镜像文件。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Block</span> &#123;</span></span><br><span class="line">	<span class="type">uint8_t</span> data[BY2BLK];</span><br><span class="line">	<span class="type">uint32_t</span> type;</span><br><span class="line">&#125; disk[NBLOCK];</span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>磁盘块是对磁盘空间的逻辑划分；扇区是对磁盘空间的物理划分</p>
</blockquote>
<p>另外 <code>Block</code> 结构体还有一个字段 <code>type</code>，该字段的值为如下枚举的值<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> &#123;</span></span><br><span class="line">	BLOCK_FREE = <span class="number">0</span>,</span><br><span class="line">	BLOCK_BOOT = <span class="number">1</span>,</span><br><span class="line">	BLOCK_BMAP = <span class="number">2</span>,</span><br><span class="line">	BLOCK_SUPER = <span class="number">3</span>,</span><br><span class="line">	BLOCK_DATA = <span class="number">4</span>,</span><br><span class="line">	BLOCK_FILE = <span class="number">5</span>,</span><br><span class="line">	BLOCK_INDEX = <span class="number">6</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>让我们回到 <code>init_disk</code>。该函数中首先将第一个磁盘块类型设为 <code>BLOCK_BOOT</code>，表示主引导扇区。之后我们要从第三个磁盘块开始（为什么不是第二个？因为第二个磁盘块为 “超级块”，将在后面介绍），设置磁盘块的位图分配机制。在函数中我们计算了在磁盘中存储位图需要的磁盘块数量。<code>NBLOCK</code> 是磁盘块的总数，那么我们同样需要 <code>NBLOCK</code> bit 大小的位图，又因为一个磁盘块有 <code>BIT2BLK</code> bit，那么总共需要 <code>NBLOCK / BIT2BLK</code> 个磁盘块。向上取整，总共需要 <code>(NBLOCK + BIT2BLK - 1) / BIT2BLK</code> 个磁盘块来存储位图。现在我们已经将 0 到 nbitblock-1 的位图分配了用途，那么下一个空闲的磁盘块就是 <code>nextbno = 2 + nbitblock</code> 了。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Step 2: Initialize boundary.</span></span><br><span class="line">nbitblock = (NBLOCK + BIT2BLK - <span class="number">1</span>) / BIT2BLK;</span><br><span class="line">nextbno = <span class="number">2</span> + nbitblock;</span><br></pre></td></tr></table></figure></p>
<p>对于存储位图的磁盘块，我们要将其初始化。首先我们将这些磁盘块标记为 <code>BLOCK_BMAP</code>，表示他们用作存储位图<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Step 2: Initialize bitmap blocks.</span></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; nbitblock; ++i) &#123;</span><br><span class="line">	disk[<span class="number">2</span> + i].type = BLOCK_BMAP;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>对于位图，我们设定 1 表示空闲，0 表示使用。因此我们先将所有的磁盘块数据都设定为 1。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; nbitblock; ++i) &#123;</span><br><span class="line">	<span class="built_in">memset</span>(disk[<span class="number">2</span> + i].data, <span class="number">0xff</span>, BY2BLK);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>最后如果位图不足以占用全部空间，那么我们还需要将最后一个磁盘块末位不作为位图使用的部分置 0。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (NBLOCK != nbitblock * BIT2BLK) &#123;</span><br><span class="line">	diff = NBLOCK % BIT2BLK / <span class="number">8</span>;</span><br><span class="line">	<span class="built_in">memset</span>(disk[<span class="number">2</span> + (nbitblock - <span class="number">1</span>)].data + diff, <span class="number">0x00</span>, BY2BLK - diff);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>我们不要忘记了第二个磁盘块，这个磁盘块会用作 “超级块”，所谓超级块，就是文件系统的起点，该磁盘块中存储了根目录文件的信息（当然还包括其他一些内容）。超级块定义在 user/include/fs.h 中。包含了用于验证文件系统的幻数 <code>s_magic</code>，磁盘的磁盘块总数 <code>s_nblocks</code> 和根目录文件节点 <code>s_root</code>。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Super</span> &#123;</span></span><br><span class="line">	<span class="type">uint32_t</span> s_magic;   <span class="comment">// Magic number: FS_MAGIC</span></span><br><span class="line">	<span class="type">uint32_t</span> s_nblocks; <span class="comment">// Total number of blocks on disk</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">File</span> <span class="title">s_root</span>;</span> <span class="comment">// Root directory node</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>在本文件系统中，文件信息通过 <code>struct File</code> 结构体存储。该结构体同样定义在 user/include/fs.h 中，在本文的后面我们将其称为文件控制块。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">File</span> &#123;</span></span><br><span class="line">	<span class="type">char</span> f_name[MAXNAMELEN]; <span class="comment">// filename</span></span><br><span class="line">	<span class="type">uint32_t</span> f_size;	 <span class="comment">// file size in bytes</span></span><br><span class="line">	<span class="type">uint32_t</span> f_type;	 <span class="comment">// file type</span></span><br><span class="line">	<span class="type">uint32_t</span> f_direct[NDIRECT];</span><br><span class="line">	<span class="type">uint32_t</span> f_indirect;</span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">File</span> *<span class="title">f_dir</span>;</span> <span class="comment">// the pointer to the dir where this file is in, valid only in memory.</span></span><br><span class="line">	<span class="type">char</span> f_pad[BY2FILE - MAXNAMELEN - (<span class="number">3</span> + NDIRECT) * <span class="number">4</span> - <span class="keyword">sizeof</span>(<span class="type">void</span> *)];</span><br><span class="line">&#125; __attribute__((aligned(<span class="number">4</span>), packed));</span><br></pre></td></tr></table></figure></p>
<p>该结构体中包含了文件名 <code>f_name</code>，文件大小 <code>f_size</code>，文件类型 <code>f_type</code>，和用于存储指向存储文件内容的磁盘块的编号的数组 <code>f_direct</code>，以及指向存储 “存储指向存储文件内容的磁盘块的编号的数组” 的磁盘块的编号 <code>f_indirect</code>，还有自己所在的目录 <code>f_dir</code>。最后 <code>f_pad</code> 将文件控制块的大小填充到 <code>BY2FILE</code>，保证多个文件控制块能够填满整个磁盘。</p>
<blockquote>
<p><code>f_direct</code> 和 <code>f_indirect</code> 用一句话来表示似乎有些困难，这里再重新说明一下。文件的内容需要在磁盘中存储，这些内容分布于不同的磁盘块中，因此还需要对这些内容进行管理，也就是要再分配一个磁盘块用于存储文件控制块，该结构体中要存储哪些存储文件内容的磁盘块的地址。<code>f_direct</code> 中就存储了前 <code>NDIRECT</code> 个磁盘块的编号方便快速访问。但如果文件较大，超出了 <code>NDIRECT</code> 个磁盘块的大小的话要怎么办？这就要再分配一个磁盘块，用这个磁盘块的全部空间作为存储磁盘块编号的数组，保存那些存储了文件内容的磁盘块的编号。再使用 <code>f_indirect</code> 保存这个新分配的，作为数组的磁盘块的编号。</p>
<p>为了方便，<code>f_indirect</code> 指向的磁盘块的前 <code>NDIRECT</code> 个元素不保存编号。现在我们就可以计算在这个文件系统中，文件的最大大小了：我们可以有 <code>BY2BLK / 4</code> 个磁盘块用于存储，每个磁盘块又有 <code>BY2BLK</code> 的空间，那么总共就有 <code>BY2BLK**2 / 4</code> 的空间可以用于单一文件的存储。</p>
</blockquote>
<p>在 <code>dist_init</code> 的最后，就设置了超级块的信息，<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">    disk[<span class="number">1</span>].type = BLOCK_SUPER;</span><br><span class="line">	super.s_magic = FS_MAGIC;</span><br><span class="line">	super.s_nblocks = NBLOCK;</span><br><span class="line">	super.s_root.f_type = FTYPE_DIR;</span><br><span class="line">	<span class="built_in">strcpy</span>(super.s_root.f_name, <span class="string">&quot;/&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>其中设置了根目录文件类型 <code>s_root.f_type</code> 为 <code>FTYPE_DIR</code>，表示该文件为目录。此宏定义在 user/include/fs.h 中。类似还有 <code>FTYPE_REG</code>。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// File types</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FTYPE_REG 0 <span class="comment">// Regular file</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FTYPE_DIR 1 <span class="comment">// Directory</span></span></span><br></pre></td></tr></table></figure></p>
<p>最后我们设置根目录的名字为 <code>/</code>，这说明该文件系统的路径是 Linux 的格式。</p>
<h3 id="（3）文件写入"><a href="#（3）文件写入" class="headerlink" title="（3）文件写入"></a>（3）文件写入</h3><p>在 <code>main</code> 函数的后面部分，我们不断读取命令行参数，通过 <code>stat</code> 函数（这是库函数）判断文件类型，分别调用 <code>write_directory</code> 和 <code>write_file</code> 将文件内容写入磁盘镜像中。需要注意这里传入了 <code>&amp;super.s_root</code>，也就是根目录文件作为参数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">   <span class="keyword">if</span> (argc &lt; <span class="number">3</span>) &#123;</span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Usage: fsformat &lt;img-file&gt; [files or directories]...\n&quot;</span>);</span><br><span class="line">	<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt; argc; i++) &#123;</span><br><span class="line">	<span class="type">char</span> *name = argv[i];</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">stat</span> <span class="title">stat_buf</span>;</span></span><br><span class="line">	<span class="type">int</span> r = stat(name, &amp;stat_buf);</span><br><span class="line">	assert(r == <span class="number">0</span>);</span><br><span class="line">	<span class="keyword">if</span> (S_ISDIR(stat_buf.st_mode)) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;writing directory &#x27;%s&#x27; recursively into disk\n&quot;</span>, name);</span><br><span class="line">		write_directory(&amp;super.s_root, name);</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (S_ISREG(stat_buf.st_mode)) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;writing regular file &#x27;%s&#x27; into disk\n&quot;</span>, name);</span><br><span class="line">		write_file(&amp;super.s_root, name);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;&#x27;%s&#x27; has illegal file mode %o\n&quot;</span>, name, stat_buf.st_mode);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">2</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来我们查看 <code>write_directory</code> 和 <code>write_file</code>。<code>write_directory</code> 用于递归地将目录下所有文件写入磁盘，而 <code>write_file</code> 则只将单一文件写入。我们首先查看 <code>write_directory</code>。</p>
<p>一开始只是调用库函数 <code>opendir</code> 打开了目录，不需关注。第一个关注点是调用了 <code>create_file</code> 在 <code>dirf</code> 文件下创建了新文件。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">write_directory</span><span class="params">(<span class="keyword">struct</span> File *dirf, <span class="type">char</span> *path)</span> &#123;</span><br><span class="line">	DIR *dir = opendir(path);</span><br><span class="line">	<span class="keyword">if</span> (dir == <span class="literal">NULL</span>) &#123;</span><br><span class="line">		perror(<span class="string">&quot;opendir&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">File</span> *<span class="title">pdir</span> =</span> create_file(dirf);</span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<p>在 <code>create_file</code> 函数中，遍历了 <code>dirf</code> 文件下用于保存内容（对于目录来说，内容就是文件控制块）的所有磁盘块。这里我们使用 <code>f_direct</code> 和 <code>f_indirect</code> 获取了对应磁盘块的编号。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> File *<span class="title function_">create_file</span><span class="params">(<span class="keyword">struct</span> File *dirf)</span> &#123;</span><br><span class="line">	<span class="type">int</span> nblk = dirf-&gt;f_size / BY2BLK;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Step 1: Iterate through all existing blocks in the directory.</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nblk; ++i) &#123;</span><br><span class="line">		<span class="type">int</span> bno; <span class="comment">// the block number</span></span><br><span class="line">		<span class="comment">// If the block number is in the range of direct pointers (NDIRECT), get the &#x27;bno&#x27;</span></span><br><span class="line">		<span class="comment">// directly from &#x27;f_direct&#x27;. Otherwise, access the indirect block on &#x27;disk&#x27; and get</span></span><br><span class="line">		<span class="comment">// the &#x27;bno&#x27; at the index.</span></span><br><span class="line">		<span class="comment">/* Exercise 5.5: Your code here. (1/3) */</span></span><br><span class="line">		<span class="keyword">if</span> (i &lt; NDIRECT) &#123;</span><br><span class="line">			bno = dirf-&gt;f_direct[i];</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			bno = ((<span class="type">uint32_t</span> *)(disk[dirf-&gt;f_indirect].data))[i];</span><br><span class="line">		&#125;</span><br></pre></td></tr></table></figure></p>
<p>该磁盘块的空间全部用于存储文件控制块。我们再在一个磁盘块中遍历所有文件控制块，看是否有未使用的文件控制块，用该处空间表示我们新创建的文件。这样遍历的原因是可能出现中间磁盘块中文件被删除，或者最后一个磁盘块还未用满的情况。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">	<span class="comment">// Get the directory block using the block number.</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">File</span> *<span class="title">blk</span> =</span> (<span class="keyword">struct</span> File *)(disk[bno].data);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Iterate through all &#x27;File&#x27;s in the directory block.</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">struct</span> File *f = blk; f &lt; blk + FILE2BLK; ++f) &#123;</span><br><span class="line">		<span class="comment">// If the first byte of the file name is null, the &#x27;File&#x27; is unused.</span></span><br><span class="line">		<span class="comment">// Return a pointer to the unused &#x27;File&#x27;.</span></span><br><span class="line">		<span class="comment">/* Exercise 5.5: Your code here. (2/3) */</span></span><br><span class="line">		<span class="keyword">if</span> (f-&gt;f_name[<span class="number">0</span>] == <span class="literal">NULL</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> f;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>最后如果没有找到未使用的文件控制块，就说明所有的已分配给当前目录文件，用于存储文件控制块的磁盘块都被占满了。这时就需要调用 <code>make_link_block</code> 新申请一个磁盘块。该磁盘块中第一个文件控制块的位置就代表了新创建的文件。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">   <span class="comment">// Step 2: If no unused file is found, allocate a new block using &#x27;make_link_block&#x27; function</span></span><br><span class="line"><span class="comment">// and return a pointer to the new block on &#x27;disk&#x27;.</span></span><br><span class="line"><span class="comment">/* Exercise 5.5: Your code here. (3/3) */</span></span><br><span class="line"><span class="keyword">return</span> (<span class="keyword">struct</span> File *)(disk[make_link_block(dirf, nblk)].data);</span><br></pre></td></tr></table></figure></p>
<p><code>make_link_block</code> 很简单，就是获取下一个空闲的磁盘块，调用 <code>save_block_link</code> 为 <code>dirf</code> 目录文件添加该磁盘块。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">next_block</span><span class="params">(<span class="type">int</span> type)</span> &#123;</span><br><span class="line">	disk[nextbno].type = type;</span><br><span class="line">	<span class="keyword">return</span> nextbno++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">make_link_block</span><span class="params">(<span class="keyword">struct</span> File *dirf, <span class="type">int</span> nblk)</span> &#123;</span><br><span class="line">	<span class="type">int</span> bno = next_block(BLOCK_FILE);</span><br><span class="line">	save_block_link(dirf, nblk, bno);</span><br><span class="line">	dirf-&gt;f_size += BY2BLK;</span><br><span class="line">	<span class="keyword">return</span> bno;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>save_block_link</code> 函数就是将新申请的磁盘块设置到 <code>f_direct</code> 中或 <code>f_indirect</code> 对应的磁盘块中的相应位置。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">save_block_link</span><span class="params">(<span class="keyword">struct</span> File *f, <span class="type">int</span> nblk, <span class="type">int</span> bno)</span> &#123;</span><br><span class="line">	assert(nblk &lt; NINDIRECT); <span class="comment">// if not, file is too large !</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (nblk &lt; NDIRECT) &#123;</span><br><span class="line">		f-&gt;f_direct[nblk] = bno;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> (f-&gt;f_indirect == <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="comment">// create new indirect block.</span></span><br><span class="line">			f-&gt;f_indirect = next_block(BLOCK_INDEX);</span><br><span class="line">		&#125;</span><br><span class="line">		((<span class="type">uint32_t</span> *)(disk[f-&gt;f_indirect].data))[nblk] = bno;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<p>这样 <code>create_file</code> 就完成了，让我们回到 <code>write_directory</code>。接下来为新创建的目录文件设置名字和文件类型。途中还判断了文件名是否过长。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">File</span> *<span class="title">pdir</span> =</span> create_file(dirf);</span><br><span class="line"><span class="built_in">strncpy</span>(pdir-&gt;f_name, basename(path), MAXNAMELEN - <span class="number">1</span>);</span><br><span class="line"><span class="keyword">if</span> (pdir-&gt;f_name[MAXNAMELEN - <span class="number">1</span>] != <span class="number">0</span>) &#123;</span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;file name is too long: %s\n&quot;</span>, path);</span><br><span class="line">	<span class="comment">// File already created, no way back from here.</span></span><br><span class="line">	<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">pdir-&gt;f_type = FTYPE_DIR;</span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<p>接下来的步骤很明显，需要遍历宿主机上该路径下的所有文件，如果是目录，则递归执行 <code>write_directory</code>，如果是普通文件，则执行 <code>write_file</code>，这样直到目录下所有文件都被写入镜像中。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">for</span> (<span class="keyword">struct</span> dirent *e; (e = readdir(dir)) != <span class="literal">NULL</span>;) &#123;</span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">strcmp</span>(e-&gt;d_name, <span class="string">&quot;.&quot;</span>) != <span class="number">0</span> &amp;&amp; <span class="built_in">strcmp</span>(e-&gt;d_name, <span class="string">&quot;..&quot;</span>) != <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="type">char</span> *buf = <span class="built_in">malloc</span>(<span class="built_in">strlen</span>(path) + <span class="built_in">strlen</span>(e-&gt;d_name) + <span class="number">2</span>);</span><br><span class="line">			<span class="built_in">sprintf</span>(buf, <span class="string">&quot;%s/%s&quot;</span>, path, e-&gt;d_name);</span><br><span class="line">			<span class="keyword">if</span> (e-&gt;d_type == DT_DIR) &#123;</span><br><span class="line">				write_directory(pdir, buf);</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				write_file(pdir, buf);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="built_in">free</span>(buf);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	closedir(dir);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>接下来转过头查看一下 <code>write_file</code>。首先我们同样调用 <code>create_file</code> 在 <code>dirf</code> 目录文件下创建新文件。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">write_file</span><span class="params">(<span class="keyword">struct</span> File *dirf, <span class="type">const</span> <span class="type">char</span> *path)</span> &#123;</span><br><span class="line">	<span class="type">int</span> iblk = <span class="number">0</span>, r = <span class="number">0</span>, n = <span class="keyword">sizeof</span>(disk[<span class="number">0</span>].data);</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">File</span> *<span class="title">target</span> =</span> create_file(dirf);</span><br></pre></td></tr></table></figure></p>
<p>接下来函数还对 <code>create_file</code> 的结果进行了判断。这似乎只是修改代码后的一个遗留问题而已。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* in case `create_file` is&#x27;t filled */</span></span><br><span class="line"><span class="keyword">if</span> (target == <span class="literal">NULL</span>) &#123;</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>我们打开宿主机上的文件，便于后面复制文件内容到镜像中<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> fd = open(path, O_RDONLY);</span><br></pre></td></tr></table></figure></p>
<p>接着我们复制文件名。这里使用 <code>strrchr</code> 从后往前查找了 <code>&#39;/&#39;</code> 字符的位置，只拷贝该字符之后的内容。但是不知这里为何不与 <code>write_directory</code> 一样使用 <code>basename</code>。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Get file name with no path prefix.</span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span> *fname = <span class="built_in">strrchr</span>(path, <span class="string">&#x27;/&#x27;</span>);</span><br><span class="line"><span class="keyword">if</span> (fname) &#123;</span><br><span class="line">	fname++;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	fname = path;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">strcpy</span>(target-&gt;f_name, fname);</span><br></pre></td></tr></table></figure></p>
<p>接着使用 <code>lseek</code> 获取并设置文件大小，以及文件类型为普通文件<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">target-&gt;f_size = lseek(fd, <span class="number">0</span>, SEEK_END);</span><br><span class="line">target-&gt;f_type = FTYPE_REG;</span><br></pre></td></tr></table></figure></p>
<p>最后读取文件内容，写入镜像文件中。这里我们以 <code>n = sizeof(disk[0].data)</code> 的大小读取，但不知道为何不使用 <code>BY2BLK</code>。值得注意的是，这里我们是先向 <code>disk[nextbno]</code> 中写入了数据，之后才调用 <code>next_block</code> 申请的该磁盘块。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">	<span class="comment">// Start reading file.</span></span><br><span class="line">	lseek(fd, <span class="number">0</span>, SEEK_SET);</span><br><span class="line">	<span class="keyword">while</span> ((r = read(fd, disk[nextbno].data, n)) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">		save_block_link(target, iblk++, next_block(BLOCK_DATA));</span><br><span class="line">	&#125;</span><br><span class="line">	close(fd); <span class="comment">// Close file descriptor.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="（4）收尾工作"><a href="#（4）收尾工作" class="headerlink" title="（4）收尾工作"></a>（4）收尾工作</h3><p>完成文件的写入后，<code>main</code> 函数中还有一些收尾工作。首先是根据磁盘块的使用情况设置位图<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flush_bitmap();</span><br></pre></td></tr></table></figure></p>
<p>置 0 语句看似复杂，实际只是按顺序一位一位置 0 而已。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">flush_bitmap</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line">	<span class="comment">// update bitmap, mark all bit where corresponding block is used.</span></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; nextbno; ++i) &#123;</span><br><span class="line">		((<span class="type">uint32_t</span> *)disk[<span class="number">2</span> + i / BIT2BLK].data)[(i % BIT2BLK) / <span class="number">32</span>] &amp;= ~(<span class="number">1</span> &lt;&lt; (i % <span class="number">32</span>));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>最后还要根据 <code>disk</code> 生成磁盘镜像文件。使用 <code>finish_fs</code> 函数完成<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">	finish_fs(argv[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>一直以来，超级块都没有写入 <code>disk</code>，现在我们将超级块信息写入<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">finish_fs</span><span class="params">(<span class="type">char</span> *name)</span> &#123;</span><br><span class="line">	<span class="type">int</span> fd, i;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Prepare super block.</span></span><br><span class="line">	<span class="built_in">memcpy</span>(disk[<span class="number">1</span>].data, &amp;super, <span class="keyword">sizeof</span>(super));</span><br></pre></td></tr></table></figure></p>
<p>最后我们将 <code>disk</code> 中所有的 <code>data</code> 写入一个新创建的文件中，作为磁盘镜像。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">	<span class="comment">// Dump data in `disk` to target image file.</span></span><br><span class="line">	fd = open(name, O_RDWR | O_CREAT, <span class="number">0666</span>);</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">1024</span>; ++i) &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_REVERSE_ENDIAN</span></span><br><span class="line">		reverse_block(disk + i);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">		<span class="type">ssize_t</span> n = write(fd, disk[i].data, BY2BLK);</span><br><span class="line">		assert(n == BY2BLK);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Finish.</span></span><br><span class="line">	close(fd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p><code>reverse_block</code> 用于宿主机和操作系统大小端不一致的情况，这里我们不需要考虑，就不看了。</p>
</blockquote>
<p>这样我们就实现了磁盘镜像的创建。在阅读 fsformat 工具的代码的同时，我们也了解了磁盘中数据的组织形式以及文件系统的基本概念，这对我们之后了解理解文件系统的代码有很大的帮助。</p>
<h2 id="三、文件系统"><a href="#三、文件系统" class="headerlink" title="三、文件系统"></a>三、文件系统</h2><h3 id="（1）文件操作库函数"><a href="#（1）文件操作库函数" class="headerlink" title="（1）文件操作库函数"></a>（1）文件操作库函数</h3><p>操作系统需要为用户程序提供一系列库函数来完成文件的相关操作。这些函数我们都知道，有 <code>open</code>、<code>read</code>、<code>write</code>、<code>close</code> 等。我们先以 <code>open</code> 为例查看一下文件系统操作的基本流程。</p>
<p><code>open</code> 函数和其他提供给用户的库函数一样，位于 user/lib，定义在 file.c 文件中。首先，该函数调用 <code>fd_alloc</code> 申请了一个文件描述符<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">open</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *path, <span class="type">int</span> mode)</span> &#123;</span><br><span class="line">	<span class="type">int</span> r;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Step 1: Alloc a new &#x27;Fd&#x27; using &#x27;fd_alloc&#x27; in fd.c.</span></span><br><span class="line">	<span class="comment">// Hint: return the error code if failed.</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Fd</span> *<span class="title">fd</span>;</span></span><br><span class="line">	<span class="comment">/* Exercise 5.9: Your code here. (1/5) */</span></span><br><span class="line">	try(fd_alloc(&amp;fd));</span><br></pre></td></tr></table></figure></p>
<p>文件描述符 <code>struct Fd</code> 定义在 user/include/fd.h 中，保存了文件对应的设备 <code>fd_dev_id</code>，文件读写的偏移量 <code>fd_offset</code> 和文件读写的模式 <code>fd_omode</code>。该结构体不表现文件的物理结构，是在用户侧对文件的抽象。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// file descriptor</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Fd</span> &#123;</span></span><br><span class="line">	u_int fd_dev_id;</span><br><span class="line">	u_int fd_offset;</span><br><span class="line">	u_int fd_omode;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p><code>fd_alloc</code> 函数的功能就是遍历所有文件描述符编号（共有 <code>MAXFD</code> 个），找到其中还没有被使用过的最小的一个，返回该文件描述符对应的地址。注意通过文件描述符编号到地址我们使用了宏 <code>INDEX2FD</code>。该宏定义在 user/include/fd.h 中。通过观察相关宏的定义，我们可以得知每个文件描述符占用空间大小为 <code>BY2PG</code>，所有文件描述符位于 <code>[FILEBASE - PDMAP, FILEBASE)</code> 的地址空间中。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> FILEBASE 0x60000000</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FDTABLE (FILEBASE - PDMAP)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INDEX2FD(i) (FDTABLE + (i)*BY2PG)</span></span><br></pre></td></tr></table></figure></p>
<p>这里我们并没有采用任何数据结构用于表示文件描述符的分配，而是通过查看页目录项和页表项是否有效来得知文件描述符是否被使用。这是因为文件描述符并不是在用户进程中被创建的，而是在<strong>文件系统服务进程</strong>中创建，被共享到用户进程的地址区域中的。因此我们只需要找出一处空闲空间，将文件系统服务进程中的对应文件描述符共享到该位置即可。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">fd_alloc</span><span class="params">(<span class="keyword">struct</span> Fd **fd)</span> &#123;</span><br><span class="line">	u_int va;</span><br><span class="line">	u_int fdno;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (fdno = <span class="number">0</span>; fdno &lt; MAXFD - <span class="number">1</span>; fdno++) &#123;</span><br><span class="line">		va = INDEX2FD(fdno);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> ((vpd[va / PDMAP] &amp; PTE_V) == <span class="number">0</span>) &#123;</span><br><span class="line">			*fd = (<span class="keyword">struct</span> Fd *)va;</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> ((vpt[va / BY2PG] &amp; PTE_V) == <span class="number">0</span>) &#123; <span class="comment">// the fd is not used</span></span><br><span class="line">			*fd = (<span class="keyword">struct</span> Fd *)va;</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> -E_MAX_OPEN;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>MOS 采取了微内核设计，因此文件系统的大部分操作并不在内核态中完成，而是交由一个<strong>文件系统服务进程</strong>处理。之后我们会了解这一进程的相关内容。</p>
<p><code>fd_alloc</code> 中我们先查看页目录项，如果页目录项无效，那么整个页目录项对应的地址空间就都没有进行映射，那么只需要返回 <code>va</code> 即可，因为 <code>va</code> 就是该目录项的第一个页表中的第一个页表项对应的地址，即第一个没有被使用的文件描述符的地址。</p>
</blockquote>
<p>需要注意，我们这里只是返回了可以作为文件描述符的地址，还没有实际的文件描述符数据。之后我们就要获取文件描述符。在 <code>open</code> 中调用 <code>fsipc_open</code>。该函数会将 <code>path</code> 对应的文件以 <code>mode</code> 的方式打开，将该文件的文件描述符共享到 <code>fd</code> 指针对应的地址处。</p>
<p>该函数定义在 user/lib/fsipc.c 中。所做的工作很简单，就是通过进程间通信向文件系统服务进程发送一条消息，表示自己希望进行的操作，服务进程再返回一条消息，表示操作的结果。这样一来一回，虽然不是函数调用，却产生了函数调用的效果，很是像系统调用。</p>
<p><code>fsipc_open</code> 中，我们将一块缓冲区 <code>fsipcbuf</code> 视为 <code>struct Fsreq_open</code>，向其中写入了请求打开的文件路径 <code>req_path</code> 和打开方式 <code>req_omode</code>。并调用 <code>fsipc</code> 进行发送。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">fsipc_open</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *path, u_int omode, <span class="keyword">struct</span> Fd *fd)</span> &#123;</span><br><span class="line">	u_int perm;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Fsreq_open</span> *<span class="title">req</span>;</span></span><br><span class="line"></span><br><span class="line">	req = (<span class="keyword">struct</span> Fsreq_open *)fsipcbuf;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// The path is too long.</span></span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">strlen</span>(path) &gt;= MAXPATHLEN) &#123;</span><br><span class="line">		<span class="keyword">return</span> -E_BAD_PATH;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">strcpy</span>((<span class="type">char</span> *)req-&gt;req_path, path);</span><br><span class="line">	req-&gt;req_omode = omode;</span><br><span class="line">	<span class="keyword">return</span> fsipc(FSREQ_OPEN, req, fd, &amp;perm);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<p>缓冲区 <code>fsipcbuf</code> 是一个页面。因为其大小为 <code>BY2PG</code> 字节，又以 <code>BY2PG</code> 为基准对齐。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">u_char fsipcbuf[BY2PG] __attribute__((aligned(BY2PG)));</span><br></pre></td></tr></table></figure></p>
<p><code>Fsreq_open</code> 定义在 user/include/fsreq.h 中，类似的还有 <code>Fsreq_close</code>、<code>Fsreq_map</code> 等等。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Fsreq_open</span> &#123;</span></span><br><span class="line">	<span class="type">char</span> req_path[MAXPATHLEN];</span><br><span class="line">	u_int req_omode;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>在调用 <code>fsipc</code> 时我们的第一个参数表示请求的类型。这些类型也都定义在 user/include/fsreq.h 中。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> FSREQ_OPEN 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FSREQ_MAP 2</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FSREQ_SET_SIZE 3</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FSREQ_CLOSE 4</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FSREQ_DIRTY 5</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FSREQ_REMOVE 6</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FSREQ_SYNC 7</span></span><br></pre></td></tr></table></figure></p>
<p><code>fsipc</code> 函数就是简单的向服务进程发送消息，并接收服务进程返回的消息。注意这里我们通过 <code>envs[1].env_id</code> 获取服务进程的 envid，这说明服务进程必须为第二个进程。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">fsipc</span><span class="params">(u_int type, <span class="type">void</span> *fsreq, <span class="type">void</span> *dstva, u_int *perm)</span> &#123;</span><br><span class="line">	u_int whom;</span><br><span class="line">	<span class="comment">// Our file system server must be the 2nd env.</span></span><br><span class="line">	ipc_send(envs[<span class="number">1</span>].env_id, type, fsreq, PTE_D);</span><br><span class="line">	<span class="keyword">return</span> ipc_recv(&amp;whom, dstva, perm);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="（2）文件系统服务进程的初始化"><a href="#（2）文件系统服务进程的初始化" class="headerlink" title="（2）文件系统服务进程的初始化"></a>（2）文件系统服务进程的初始化</h3><p>文件系统服务进程是一个完整的进程，有自己的 main 函数。该进程的代码都位于 fs 文件夹下。<code>main</code> 函数位于 fs/serv.c 中。我们从这里入手。</p>
<p>首先调用 <code>serve_init</code> 对程序进行初始化。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">	user_assert(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> File) == BY2FILE);</span><br><span class="line"></span><br><span class="line">	debugf(<span class="string">&quot;FS is running\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">	serve_init();</span><br></pre></td></tr></table></figure></p>
<p>在 <code>serve_init</code> 函数中，实际进行初始化的只有 <code>opentab</code>。这是一个 <code>struct Open</code> 类型的数组，用于记录整个操作系统中所有处于打开状态的文件。<code>MAXOPEN</code> 就表示了文件打开的最大数量。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Max number of open files in the file system at once</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXOPEN 1024</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// initialize to force into data section</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Open</span> <span class="title">opentab</span>[<span class="title">MAXOPEN</span>] =</span> &#123;&#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>&#125;&#125;;</span><br></pre></td></tr></table></figure></p>
<p><code>struct Open</code> 定义在同一个文件中。其中保存了打开的文件 <code>o_file</code>、文件的 id <code>o_fileid</code>、文件打开的方式 <code>o_mode</code> 和文件对应的文件描述符 <code>o_ff</code>。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Open</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">File</span> *<span class="title">o_file</span>;</span> <span class="comment">// mapped descriptor for open file</span></span><br><span class="line">	u_int o_fileid;	     <span class="comment">// file id</span></span><br><span class="line">	<span class="type">int</span> o_mode;	     <span class="comment">// open mode</span></span><br><span class="line">	Filefd *o_ff; <span class="comment">// va of filefd page</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p><code>Filefd</code> 是如下所示的结构体。我们在将文件描述符共享到用户进程时，实际上共享的是 <code>Filefd</code>。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// file descriptor + file</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Filefd</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Fd</span> <span class="title">f_fd</span>;</span></span><br><span class="line">	u_int f_fileid;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">File</span> <span class="title">f_file</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>在 <code>serve_init</code> 中，我们就是对 <code>opentab</code> 进行初始化。为其中每个元素设定 <code>o_fileid</code> 和 <code>o_ff</code>。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">serve_init</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line">	u_int va;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Set virtual address to map.</span></span><br><span class="line">	va = FILEVA;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Initial array opentab.</span></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; MAXOPEN; i++) &#123;</span><br><span class="line">		opentab[i].o_fileid = i;</span><br><span class="line">		opentab[i].o_ff = (<span class="keyword">struct</span> Filefd *)va;</span><br><span class="line">		va += BY2PG;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>地址的分配是从 <code>va = FILEVA</code> 开始的，其中 <code>#define FILEVA 0x60000000</code>。每个 <code>Filefd</code> 分配一页 <code>BY2PG</code> 的大小。因此所有的 <code>Filefd</code> 存储在 <code>[FILEVA, FILEVA + PDMAP)</code> 的地址空间中。</p>
<p>在 <code>main</code> 函数中，之后我们又调用 <code>fs_init</code> 完成文件系统的初始化。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fs_init();</span><br></pre></td></tr></table></figure></p>
<p>该函数定义在 fs/fs.c 中。其中又调用了三个函数 <code>read_super</code>、<code>check_write_block</code> 和 <code>read_bitmap</code><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">fs_init</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">	read_super();</span><br><span class="line">	check_write_block();</span><br><span class="line">	read_bitmap();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>read_super</code> 中大部分都是检查，只有如下部分值得关注。该部分读取了第一个磁盘块的内容，赋值给全局变量 <code>super</code>。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Step 1: read super block.</span></span><br><span class="line"><span class="keyword">if</span> ((r = read_block(<span class="number">1</span>, &amp;blk, <span class="number">0</span>)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">	user_panic(<span class="string">&quot;cannot read superblock: %e&quot;</span>, r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">super = blk;</span><br></pre></td></tr></table></figure></p>
<p>其中 <code>read_block</code> 用于读取对应磁盘块编号的磁盘块数据到内存中。我们不看前面的检查。首先使用 <code>diskaddr</code> 获取磁盘块编号应该存储到的地址。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">read_block</span><span class="params">(u_int blockno, <span class="type">void</span> **blk, u_int *isnew)</span> &#123;</span><br><span class="line">    <span class="comment">// omit...</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// Step 3: transform block number to corresponding virtual address.</span></span><br><span class="line">	<span class="type">void</span> *va = diskaddr(blockno);</span><br></pre></td></tr></table></figure></p>
<p><code>diskaddr</code> 函数很简单。这里只是人为规定的地址，我们将 <code>[DISKMAP, DISKMAP+DISKMAX)</code> 的地址空间用作缓冲区，当磁盘读入内存时，用来映射相关的页。因为该缓冲区与内存空间是一一映射的，所以我们也可以得知实验中支持的最大磁盘大小为 <code>DISKMAX</code> = 1GB。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> *<span class="title function_">diskaddr</span><span class="params">(u_int blockno)</span> &#123;</span><br><span class="line">	<span class="comment">/* Exercise 5.6: Your code here. */</span></span><br><span class="line">	<span class="keyword">return</span> DISKMAP + blockno * BY2BLK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>回到 <code>read_block</code>，接下来通过 <code>block_is_mapped</code> 判断编号对应的磁盘块是否已经被映射，如果没有，则我们需要为其分配内存，并将硬盘中的数据读入该内存空间中。最后我们设置 <code>*blk</code> 以返回读取的磁盘块数据对应的内存地址。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">	<span class="keyword">if</span> (block_is_mapped(blockno)) &#123; <span class="comment">// the block is in memory</span></span><br><span class="line">		<span class="keyword">if</span> (isnew) &#123;</span><br><span class="line">			*isnew = <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123; <span class="comment">// the block is not in memory</span></span><br><span class="line">		<span class="keyword">if</span> (isnew) &#123;</span><br><span class="line">			*isnew = <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		syscall_mem_alloc(<span class="number">0</span>, va, PTE_D);</span><br><span class="line">		ide_read(<span class="number">0</span>, blockno * SECT2BLK, va, SECT2BLK);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Step 5: if blk != NULL, assign &#x27;va&#x27; to &#x27;*blk&#x27;.</span></span><br><span class="line">	<span class="keyword">if</span> (blk) &#123;</span><br><span class="line">		*blk = va;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这一部分使用的 <code>block_is_mapped</code> 函数比较简单。和我们在 <code>fd_alloc</code> 中遇到的通过页表来判断是否被使用相同。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Overview:</span></span><br><span class="line"><span class="comment">//  Check if this virtual address is mapped to a block. (check PTE_V bit)</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">va_is_mapped</span><span class="params">(<span class="type">void</span> *va)</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> (vpd[PDX(va)] &amp; PTE_V) &amp;&amp; (vpt[VPN(va)] &amp; PTE_V);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Overview:</span></span><br><span class="line"><span class="comment">//  Check if this disk block is mapped in cache.</span></span><br><span class="line"><span class="comment">//  Returns the virtual address of the cache page if mapped, 0 otherwise.</span></span><br><span class="line"><span class="type">void</span> *<span class="title function_">block_is_mapped</span><span class="params">(u_int blockno)</span> &#123;</span><br><span class="line">	<span class="type">void</span> *va = diskaddr(blockno);</span><br><span class="line">	<span class="keyword">if</span> (va_is_mapped(va)) &#123;</span><br><span class="line">		<span class="keyword">return</span> va;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>如果没有映射，则我们调用 <code>syscall_mem_alloc</code> 为该地址分配一页空间，之后调用 <code>ide_read</code> 函数从磁盘中读取数据。这一部分内容属于磁盘驱动，我们会在下一章讲解。</p>
<p>现在让我们回到 <code>fs_init</code>。<code>check_write_block</code> 函数只是一个插入到基本流程中的测试代码，不需要考虑。我们考虑 <code>read_bitmap</code>。该函数会将管理磁盘块分配的位图读取到内存中。</p>
<p>这里很奇怪的使用了 <code>super-&gt;s_nblocks / BIT2BLK + 1</code> 来计算作为位图的磁盘块数量。但是对于 <code>super-&gt;s_nblocks</code> 是 <code>BIT2BLK</code> 整倍数的情况，不是会多计算一个磁盘块吗？不懂。（不过 nbitmap 多了 1 似乎也不会产生什么大的影响，因为各个磁盘块数据在内存中的空间并不重合。）之后就是调用 <code>read_block</code> 将磁盘上的数据读取到内存缓冲区中，最后设定全局变量 <code>bitmap</code> 的值为位图的首地址。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">read_bitmap</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">	u_int i;</span><br><span class="line">	<span class="type">void</span> *blk = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Step 1: Calculate the number of the bitmap blocks, and read them into memory.</span></span><br><span class="line">	u_int nbitmap = super-&gt;s_nblocks / BIT2BLK + <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; nbitmap; i++) &#123;</span><br><span class="line">		read_block(i + <span class="number">2</span>, blk, <span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	bitmap = diskaddr(<span class="number">2</span>);</span><br></pre></td></tr></table></figure></p>
<p><code>read_bitmap</code> 中之后的内容都是一些检查，这里就不详细说明了。</p>
<h3 id="（3）文件系统服务进程的服务"><a href="#（3）文件系统服务进程的服务" class="headerlink" title="（3）文件系统服务进程的服务"></a>（3）文件系统服务进程的服务</h3><p>初始化终于完成了，接下来我们调用 <code>serve</code> 以开启服务<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">serve();</span><br></pre></td></tr></table></figure></p>
<p>很容易理解，这样的服务进程就是一个死循环。不断地调用 <code>ipc_recv</code> 以接收其他进程发来的请求，根据请求类型的不同分发给不同的处理函数进行处理，并进行回复。<code>serve</code> 函数中只需要注意一点，那就是在完成处理后需要进行系统调用 <code>syscall_mem_unmap</code> 以取消接收消息时的页面共享，为下一次接收请求做准备。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">serve</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">	u_int req, whom, perm;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (;;) &#123;</span><br><span class="line">		perm = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">		req = ipc_recv(&amp;whom, (<span class="type">void</span> *)REQVA, &amp;perm);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// All requests must contain an argument page</span></span><br><span class="line">		<span class="keyword">if</span> (!(perm &amp; PTE_V)) &#123;</span><br><span class="line">			debugf(<span class="string">&quot;Invalid request from %08x: no argument page\n&quot;</span>, whom);</span><br><span class="line">			<span class="keyword">continue</span>; <span class="comment">// just leave it hanging, waiting for the next request.</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">switch</span> (req) &#123;</span><br><span class="line">		<span class="keyword">case</span> FSREQ_OPEN:</span><br><span class="line">			serve_open(whom, (<span class="keyword">struct</span> Fsreq_open *)REQVA);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// omit...</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		syscall_mem_unmap(<span class="number">0</span>, (<span class="type">void</span> *)REQVA);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里我们只考虑 <code>FSREQ_OPEN</code> 请求的处理函数 <code>serve_open</code>。在该函数中，我们首先调用 <code>alloc_open</code> 申请一个存储文件打开信息的 <code>struct Open</code> 控制块。需要注意这里的 <code>ipc_send</code> 类似于发生错误时的返回。只不过不知为何此处不和下面调用 <code>file_open</code> 时一样有 <code>return</code> 语句。这或许是一个<strong>错误</strong>，不过既然此处并没有让人写代码，那还是不要擅自改动好了<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">serve_open</span><span class="params">(u_int envid, <span class="keyword">struct</span> Fsreq_open *rq)</span> &#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">File</span> *<span class="title">f</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Filefd</span> *<span class="title">ff</span>;</span></span><br><span class="line">	<span class="type">int</span> r;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Open</span> *<span class="title">o</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// Find a file id.</span></span><br><span class="line">	<span class="keyword">if</span> ((r = open_alloc(&amp;o)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		ipc_send(envid, r, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>open_alloc</code> 函数用于申请一个未使用的 <code>struct Open</code> 元素。这里由于 <code>opentab</code> 和 存储在 <code>[FILEVA, FILEVA + PDMAP)</code> 中的 <code>Filefd</code> 是一一对应的关系，所以通过查看 <code>Filefd</code> 地址的页表项是否有效（第三次！！！）就可以得知 <code>struct Open</code> 元素是否被使用了。（注意这里不能查看 <code>opentab</code> 中各元素的页表项，因为 <code>opentab</code> 作为数组，占用的空间已经被分配了。）<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">open_alloc</span><span class="params">(<span class="keyword">struct</span> Open **o)</span> &#123;</span><br><span class="line">	<span class="type">int</span> i, r;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Find an available open-file table entry</span></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; MAXOPEN; i++) &#123;</span><br><span class="line">		<span class="keyword">switch</span> (pageref(opentab[i].o_ff)) &#123;</span><br><span class="line">		<span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">			<span class="keyword">if</span> ((r = syscall_mem_alloc(<span class="number">0</span>, opentab[i].o_ff, PTE_D | PTE_LIBRARY)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">				<span class="keyword">return</span> r;</span><br><span class="line">			&#125;</span><br><span class="line">		<span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">			opentab[i].o_fileid += MAXOPEN;</span><br><span class="line">			*o = &amp;opentab[i];</span><br><span class="line">			<span class="built_in">memset</span>((<span class="type">void</span> *)opentab[i].o_ff, <span class="number">0</span>, BY2PG);</span><br><span class="line">			<span class="keyword">return</span> (*o)-&gt;o_fileid;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> -E_MAX_OPEN;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>通过 <code>pageref</code> 我们可以得知某一页的引用数量。该函数定义在 user/lib/pageref.c 中，不需要多言。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">pageref</span><span class="params">(<span class="type">void</span> *v)</span> &#123;</span><br><span class="line">	u_int pte;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!(vpd[PDX(v)] &amp; PTE_V)) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	pte = vpt[VPN(v)];</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!(pte &amp; PTE_V)) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> pages[PPN(pte)].pp_ref;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>我必须解释一下 <code>open_alloc</code> 中 <code>switch</code> 的使用。首先要再次明确 <code>pageref</code> 返回的是某一页的引用数量。那么除了 0、1 以外，还可能有 2、3 等等，即物理页在不同进程间共享的情况。在我们的文件系统中，是会出现将 <code>Filefd</code> 共享到用户进程的情况，这时因为 <code>switch</code> 的 <code>case</code> 中只有 1、2，因此便会跳过这次循环。这样我们就将正在使用的文件排除在外了。</p>
<p>我们知道在最开始，所有的 <code>Filefd</code> 都没有被访问过，他们的引用数量为 0。只有当使用过之后，引用数量才大于 0。那么 <code>case 1</code> 表示的情况就很明显了，那就是曾经被使用过，但现在不被任何用户进程使用的文件，只有服务进程还保存着引用。这种情况的 <code>struct Open</code> 就没有被使用，因此可以被申请。但是之前使用时的 <code>o_fileid</code> 这次就不能使用了，需要更新 <code>opentab[i].o_fileid += MAXOPEN</code>，同时将对应的文件描述符 <code>o_ff</code> 的内容清零。</p>
<p>最后是还没有被访问过的情况，这种情况下我们先要使用系统调用 <code>syscall_mem_alloc</code> 申请一个物理页。注意申请时我们使用的权限位 <code>PTE_D | PTE_LIBRARY</code>。<code>PTE_LIBRARY</code> 表示该页面可以被共享。之后呢？我们还需要和引用数量为 1 的情况一样，将 <code>o_ff</code> 对应的空间清零，返回 <code>o_fileid</code> 和 <code>opentab[i]</code>。这里采用了一个巧妙的方法，在 <code>case 0</code> 和 <code>case 1</code> 之间没有使用 <code>break</code> 分隔，直接让 <code>case 0</code> 的执行穿透到了 <code>case 1</code> 中。</p>
<p>现在让我们回到 <code>serve_open</code>。接下来调用 <code>file_open</code> 来打开文件。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Open the file.</span></span><br><span class="line"><span class="keyword">if</span> ((r = file_open(rq-&gt;req_path, &amp;f)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">	ipc_send(envid, r, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>file_open</code> 定义在 fs/fs.c 中，只是调用了 <code>walk_path</code> 而已。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">file_open</span><span class="params">(<span class="type">char</span> *path, <span class="keyword">struct</span> File **file)</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> walk_path(path, <span class="number">0</span>, file, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>walk_path</code> 函数位于同一个文件中，主要内容就是解析路径，根据路径不断找到目录下的文件，找到最后得到的就是表示路径对应的文件的文件控制块。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">walk_path</span><span class="params">(<span class="type">char</span> *path, <span class="keyword">struct</span> File **pdir, <span class="keyword">struct</span> File **pfile, <span class="type">char</span> *lastelem)</span> &#123;</span><br><span class="line">	<span class="type">char</span> *p;</span><br><span class="line">	<span class="type">char</span> name[MAXNAMELEN];</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">File</span> *<span class="title">dir</span>, *<span class="title">file</span>;</span></span><br><span class="line">	<span class="type">int</span> r;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// start at the root.</span></span><br><span class="line">	path = skip_slash(path);</span><br><span class="line">	file = &amp;super-&gt;s_root;</span><br><span class="line">	dir = <span class="number">0</span>;</span><br><span class="line">	name[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (pdir) &#123;</span><br><span class="line">		*pdir = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	*pfile = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// find the target file by name recursively.</span></span><br><span class="line">	<span class="keyword">while</span> (*path != <span class="string">&#x27;\0&#x27;</span>) &#123;</span><br><span class="line">		dir = file;</span><br><span class="line">		p = path;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">while</span> (*path != <span class="string">&#x27;/&#x27;</span> &amp;&amp; *path != <span class="string">&#x27;\0&#x27;</span>) &#123;</span><br><span class="line">			path++;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (path - p &gt;= MAXNAMELEN) &#123;</span><br><span class="line">			<span class="keyword">return</span> -E_BAD_PATH;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="built_in">memcpy</span>(name, p, path - p);</span><br><span class="line">		name[path - p] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">		path = skip_slash(path);</span><br><span class="line">		<span class="keyword">if</span> (dir-&gt;f_type != FTYPE_DIR) &#123;</span><br><span class="line">			<span class="keyword">return</span> -E_NOT_FOUND;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> ((r = dir_lookup(dir, name, &amp;file)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span> (r == -E_NOT_FOUND &amp;&amp; *path == <span class="string">&#x27;\0&#x27;</span>) &#123;</span><br><span class="line">				<span class="keyword">if</span> (pdir) &#123;</span><br><span class="line">					*pdir = dir;</span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">				<span class="keyword">if</span> (lastelem) &#123;</span><br><span class="line">					<span class="built_in">strcpy</span>(lastelem, name);</span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">				*pfile = <span class="number">0</span>;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">return</span> r;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (pdir) &#123;</span><br><span class="line">		*pdir = dir;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	*pfile = file;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>该函数大部分工作都用于完成路径解析和异常处理，不用解释相信各位也能理解。唯一需要注意的是 <code>dir_lookup</code> 函数。该函数用于找到指定目录下的指定名字的文件。该函数也位于同一个文件中，也是我们需要填写代码的函数。</p>
<p>该函数本身很简单，与 tools/fsformat.c 中的 <code>create_file</code> 类似。都是获取文件的所有磁盘块，遍历其中所有的文件控制块。只不过这里需要返回指定名字的文件对应的文件控制块。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">dir_lookup</span><span class="params">(<span class="keyword">struct</span> File *dir, <span class="type">char</span> *name, <span class="keyword">struct</span> File **file)</span> &#123;</span><br><span class="line">	<span class="type">int</span> r;</span><br><span class="line">	<span class="comment">// Step 1: Calculate the number of blocks in &#x27;dir&#x27; via its size.</span></span><br><span class="line">	u_int nblock;</span><br><span class="line">	<span class="comment">/* Exercise 5.8: Your code here. (1/3) */</span></span><br><span class="line">	nblock = dir-&gt;f_size / BY2BLK;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Step 2: Iterate through all blocks in the directory.</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nblock; i++) &#123;</span><br><span class="line">		<span class="comment">// Read the i&#x27;th block of &#x27;dir&#x27; and get its address in &#x27;blk&#x27; using &#x27;file_get_block&#x27;.</span></span><br><span class="line">		<span class="type">void</span> *blk;</span><br><span class="line">		<span class="comment">/* Exercise 5.8: Your code here. (2/3) */</span></span><br><span class="line">		try(file_get_block(dir, i, &amp;blk));</span><br><span class="line"></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">File</span> *<span class="title">files</span> =</span> (<span class="keyword">struct</span> File *)blk;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Find the target among all &#x27;File&#x27;s in this block.</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">struct</span> File *f = files; f &lt; files + FILE2BLK; ++f) &#123;</span><br><span class="line">			<span class="comment">/* Exercise 5.8: Your code here. (3/3) */</span></span><br><span class="line">			<span class="keyword">if</span> (<span class="built_in">strcmp</span>(name, f-&gt;f_name) == <span class="number">0</span>) &#123;</span><br><span class="line">				*file = f;</span><br><span class="line">				f-&gt;f_dir = dir;</span><br><span class="line">				<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> -E_NOT_FOUND;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>唯一需要注意的是 <code>file_get_block</code> 函数。该函数用于获取文件中第几个磁盘块。其中首先调用 <code>file_map_block</code> 获取了文件中使用的第几个磁盘块对应的磁盘块编号（请注意这两者的区别，一个是相对于文件中其他部分的编号，另一个是相对于磁盘来说的编号）。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">file_get_block</span><span class="params">(<span class="keyword">struct</span> File *f, u_int filebno, <span class="type">void</span> **blk)</span> &#123;</span><br><span class="line">	<span class="type">int</span> r;</span><br><span class="line">	u_int diskbno;</span><br><span class="line">	u_int isnew;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Step 1: find the disk block number is `f` using `file_map_block`.</span></span><br><span class="line">	<span class="keyword">if</span> ((r = file_map_block(f, filebno, &amp;diskbno, <span class="number">1</span>)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> r;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure></p>
<p>在 <code>file_map_block</code> 中首先调用 <code>file_block_walk</code> 获取对应的磁盘块编号<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">file_map_block</span><span class="params">(<span class="keyword">struct</span> File *f, u_int filebno, u_int *diskbno, u_int alloc)</span> &#123;</span><br><span class="line">	<span class="type">int</span> r;</span><br><span class="line">	<span class="type">uint32_t</span> *ptr;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Step 1: find the pointer for the target block.</span></span><br><span class="line">	<span class="keyword">if</span> ((r = file_block_walk(f, filebno, &amp;ptr, alloc)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> r;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>file_block_walk</code> 中用到了之前着重解释的 <code>f_direct</code> 和 <code>f_indirect</code>。容易发现此函数的与 fsformat 中的 <code>save_block_link</code> 函数结构类似。此函数我们已经在之前说明过了。需要注意的是这里当 <code>f_indirect</code> 还未申请时，我们使用了 <code>alloc_block</code> 来申请一个新的磁盘块，并使用 <code>read_block</code> 将该磁盘块数据读入内存中。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">file_block_walk</span><span class="params">(<span class="keyword">struct</span> File *f, u_int filebno, <span class="type">uint32_t</span> **ppdiskbno, u_int alloc)</span> &#123;</span><br><span class="line">	<span class="type">int</span> r;</span><br><span class="line">	<span class="type">uint32_t</span> *ptr;</span><br><span class="line">	<span class="type">uint32_t</span> *blk;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (filebno &lt; NDIRECT) &#123;</span><br><span class="line">		<span class="comment">// Step 1: if the target block is corresponded to a direct pointer, just return the</span></span><br><span class="line">		<span class="comment">// disk block number.</span></span><br><span class="line">		ptr = &amp;f-&gt;f_direct[filebno];</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (filebno &lt; NINDIRECT) &#123;</span><br><span class="line">		<span class="comment">// Step 2: if the target block is corresponded to the indirect block, but there&#x27;s no</span></span><br><span class="line">		<span class="comment">//  indirect block and `alloc` is set, create the indirect block.</span></span><br><span class="line">		<span class="keyword">if</span> (f-&gt;f_indirect == <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span> (alloc == <span class="number">0</span>) &#123;</span><br><span class="line">				<span class="keyword">return</span> -E_NOT_FOUND;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> ((r = alloc_block()) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">				<span class="keyword">return</span> r;</span><br><span class="line">			&#125;</span><br><span class="line">			f-&gt;f_indirect = r;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Step 3: read the new indirect block to memory.</span></span><br><span class="line">		<span class="keyword">if</span> ((r = read_block(f-&gt;f_indirect, (<span class="type">void</span> **)&amp;blk, <span class="number">0</span>)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> r;</span><br><span class="line">		&#125;</span><br><span class="line">		ptr = blk + filebno;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> -E_INVAL;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Step 4: store the result into *ppdiskbno, and return 0.</span></span><br><span class="line">	*ppdiskbno = ptr;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>read_block</code> 我们之前已经提及了，现在我们就考察一下 <code>alloc_block</code>。该函数首先调用 <code>alloc_block_num</code> 在磁盘块管理位图上找到空闲的磁盘块，更新位图并将位图写入内存<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">alloc_block_num</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">	<span class="type">int</span> blockno;</span><br><span class="line">	<span class="comment">// walk through this bitmap, find a free one and mark it as used, then sync</span></span><br><span class="line">	<span class="comment">// this block to IDE disk (using `write_block`) from memory.</span></span><br><span class="line">	<span class="keyword">for</span> (blockno = <span class="number">3</span>; blockno &lt; super-&gt;s_nblocks; blockno++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (bitmap[blockno / <span class="number">32</span>] &amp; (<span class="number">1</span> &lt;&lt; (blockno % <span class="number">32</span>))) &#123; <span class="comment">// the block is free</span></span><br><span class="line">			bitmap[blockno / <span class="number">32</span>] &amp;= ~(<span class="number">1</span> &lt;&lt; (blockno % <span class="number">32</span>));</span><br><span class="line">			write_block(blockno / BIT2BLK + <span class="number">2</span>); <span class="comment">// write to disk.</span></span><br><span class="line">			<span class="keyword">return</span> blockno;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// no free blocks.</span></span><br><span class="line">	<span class="keyword">return</span> -E_NO_DISK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">alloc_block</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">	<span class="type">int</span> r, bno;</span><br><span class="line">	<span class="comment">// Step 1: find a free block.</span></span><br><span class="line">	<span class="keyword">if</span> ((r = alloc_block_num()) &lt; <span class="number">0</span>) &#123; <span class="comment">// failed.</span></span><br><span class="line">		<span class="keyword">return</span> r;</span><br><span class="line">	&#125;</span><br><span class="line">	bno = r;</span><br></pre></td></tr></table></figure></p>
<p>之后 <code>alloc_block</code> 函数调用 <code>map_block</code> 将获取的编号所对应的空闲磁盘块从磁盘中读入内存。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">	<span class="comment">// Step 2: map this block into memory.</span></span><br><span class="line">	<span class="keyword">if</span> ((r = map_block(bno)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		free_block(bno);</span><br><span class="line">		<span class="keyword">return</span> r;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Step 3: return block number.</span></span><br><span class="line">	<span class="keyword">return</span> bno;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>map_block</code> 函数申请一个页面用于存储磁盘块内容，类似的含有 <code>unmap_block</code> 函数。这两个函数较为简单，唯一需要注意的是 <code>unmap_block</code> 会将内存中对磁盘块的修改写回磁盘。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">map_block</span><span class="params">(u_int blockno)</span> &#123;</span><br><span class="line">	<span class="comment">// Step 1: If the block is already mapped in cache, return 0.</span></span><br><span class="line">	<span class="comment">// Hint: Use &#x27;block_is_mapped&#x27;.</span></span><br><span class="line">	<span class="comment">/* Exercise 5.7: Your code here. (1/5) */</span></span><br><span class="line">	<span class="keyword">if</span> (block_is_mapped(blockno)) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Step 2: Alloc a page in permission &#x27;PTE_D&#x27; via syscall.</span></span><br><span class="line">	<span class="comment">// Hint: Use &#x27;diskaddr&#x27; for the virtual address.</span></span><br><span class="line">	<span class="comment">/* Exercise 5.7: Your code here. (2/5) */</span></span><br><span class="line">	try(syscall_mem_alloc(env-&gt;env_id, diskaddr(blockno), PTE_D));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">unmap_block</span><span class="params">(u_int blockno)</span> &#123;</span><br><span class="line">	<span class="comment">// Step 1: Get the mapped address of the cache page of this block using &#x27;block_is_mapped&#x27;.</span></span><br><span class="line">	<span class="type">void</span> *va;</span><br><span class="line">	<span class="comment">/* Exercise 5.7: Your code here. (3/5) */</span></span><br><span class="line">	va = block_is_mapped(blockno);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Step 2: If this block is used (not free) and dirty in cache, write it back to the disk</span></span><br><span class="line">	<span class="comment">// first.</span></span><br><span class="line">	<span class="comment">/* Exercise 5.7: Your code here. (4/5) */</span></span><br><span class="line">	<span class="keyword">if</span> (!block_is_free(blockno) &amp;&amp; block_is_dirty(blockno)) &#123;</span><br><span class="line">		write_block(blockno);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Step 3: Unmap the virtual address via syscall.</span></span><br><span class="line">	<span class="comment">/* Exercise 5.7: Your code here. (5/5) */</span></span><br><span class="line">	syscall_mem_unmap(env-&gt;env_id, diskaddr(blockno));</span><br><span class="line"></span><br><span class="line">	user_assert(!block_is_mapped(blockno));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>最后 <code>free_block</code> 则是重新将位图对应位置置 1，表示空闲。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">free_block</span><span class="params">(u_int blockno)</span> &#123;</span><br><span class="line">	<span class="comment">// You can refer to the function &#x27;block_is_free&#x27; above.</span></span><br><span class="line">	<span class="comment">// Step 1: If &#x27;blockno&#x27; is invalid (0 or &gt;= the number of blocks in &#x27;super&#x27;), return.</span></span><br><span class="line">	<span class="comment">/* Exercise 5.4: Your code here. (1/2) */</span></span><br><span class="line">	<span class="keyword">if</span> (super == <span class="number">0</span> || blockno &gt;= super-&gt;s_nblocks) &#123;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Step 2: Set the flag bit of &#x27;blockno&#x27; in &#x27;bitmap&#x27;.</span></span><br><span class="line">	<span class="comment">// Hint: Use bit operations to update the bitmap, such as b[n / W] |= 1 &lt;&lt; (n % W).</span></span><br><span class="line">	<span class="comment">/* Exercise 5.4: Your code here. (2/2) */</span></span><br><span class="line">	bitmap[blockno / <span class="number">32</span>] |= <span class="number">1</span> &lt;&lt; (blockno % <span class="number">32</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>我在看这一部分的时候有点想要吐槽一下，为什么 <code>map_block</code> 函数和 <code>read_block</code> 函数如此相似？<code>map_block</code> 分明完全是 <code>read_block</code> 的弱化版。后来回看 <code>file_block_walk</code> 的时候就明白原因了。在 <code>file_block_walk</code> 中我们同时使用了 <code>alloc_block</code>（其中用到 <code>read_block</code>） 和 <code>read_block</code>。其中 <code>alloc_block</code> 只是申请了一个磁盘块，但因为是新申请，所以对应地址空间中的数据没有用处，并不从磁盘中读取数据，只需要申请对应地址的物理页即可。而 <code>read_block</code> 则进行了数据的读取。如在 <code>file_block_walk</code> 中需要读取间接磁盘块中的数据来确定。</p>
<p>经过了这么艰辛的历程，我们重新回到 <code>file_map_block</code>。文件的第几个磁盘块对应的磁盘块编号现在已经被存储在了 <code>*ptr</code>。这里还考虑了未找到时再调用 <code>alloc_block</code> 申请一个磁盘块的情况。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Step 2: if the block not exists, and create is set, alloc one.</span></span><br><span class="line"><span class="keyword">if</span> (*ptr == <span class="number">0</span>) &#123;</span><br><span class="line">	<span class="keyword">if</span> (alloc == <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> -E_NOT_FOUND;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> ((r = alloc_block()) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> r;</span><br><span class="line">	&#125;</span><br><span class="line">	*ptr = r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>最后将文件的第几个磁盘块对应的磁盘块编号传给 <code>*diskbno</code>，这样就找到了对应的磁盘块编号。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">	<span class="comment">// Step 3: set the pointer to the block in *diskbno and return 0.</span></span><br><span class="line">	*diskbno = *ptr;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>还记得我们是从哪里调用的吗？我们返回到 <code>file_get_block</code>，现在我们已经找到了文件中第几个磁盘块对应的磁盘块编号，最后只需要调用 <code>read_block</code> 将该磁盘块的内容从磁盘中读取到内存即可。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">	<span class="comment">// Step 2: read the data in this disk to blk.</span></span><br><span class="line">	<span class="keyword">if</span> ((r = read_block(diskbno, blk, &amp;isnew)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> r;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>之后，我们的 <code>dir_lookup</code> 函数就可以遍历目录文件下所有的文件，找到和目标文件名相同的文件了。而 <code>dir_lookup</code> 作为 <code>walk_path</code> 的重要组成部分，使 <code>walk_path</code> 完成了根据路径获取对应文件的功能。<code>file_open</code> 函数调用 <code>walk_path</code> 之后返回。我们终于又回到了 <code>serve_open</code> 函数。</p>
<p><code>serve_open</code> 接下来的内容就比较简单了，只是将 <code>file_open</code> 返回的文件控制块结构体设置到 <code>struct Open</code> 结构体，表示新打开的文件为该文件，接着设置一系列字段的值。最后调用 <code>ipc_send</code> 返回，将文件描述符 <code>o-&gt;o_ff</code> 与用户进程共享。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">	<span class="comment">// Save the file pointer.</span></span><br><span class="line">	o-&gt;o_file = f;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Fill out the Filefd structure</span></span><br><span class="line">	ff = (<span class="keyword">struct</span> Filefd *)o-&gt;o_ff;</span><br><span class="line">	ff-&gt;f_file = *f;</span><br><span class="line">	ff-&gt;f_fileid = o-&gt;o_fileid;</span><br><span class="line">	o-&gt;o_mode = rq-&gt;req_omode;</span><br><span class="line">	ff-&gt;f_fd.fd_omode = o-&gt;o_mode;</span><br><span class="line">	ff-&gt;f_fd.fd_dev_id = devfile.dev_id;</span><br><span class="line"></span><br><span class="line">	ipc_send(envid, <span class="number">0</span>, o-&gt;o_ff, PTE_D | PTE_LIBRARY);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>只需要注意 <code>ff-&gt;f_fd.fd_dev_id = devfile.dev_id;</code> 这一句，我们设置文件描述符对应的设备为 <code>devfile</code>。该变量定义在 user/lib/file.c 中<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Dev</span> <span class="title">devfile</span> =</span> &#123;</span><br><span class="line">    .dev_id = <span class="string">&#x27;f&#x27;</span>,</span><br><span class="line">    .dev_name = <span class="string">&quot;file&quot;</span>,</span><br><span class="line">    .dev_read = file_read,</span><br><span class="line">    .dev_write = file_write,</span><br><span class="line">    .dev_close = file_close,</span><br><span class="line">    .dev_stat = file_stat,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>其中 <code>struct Dev</code> 定义在 user/include/fd.h 中<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Dev</span> &#123;</span></span><br><span class="line">	<span class="type">int</span> dev_id;</span><br><span class="line">	<span class="type">char</span> *dev_name;</span><br><span class="line">	<span class="type">int</span> (*dev_read)(<span class="keyword">struct</span> Fd *, <span class="type">void</span> *, u_int, u_int);</span><br><span class="line">	<span class="type">int</span> (*dev_write)(<span class="keyword">struct</span> Fd *, <span class="type">const</span> <span class="type">void</span> *, u_int, u_int);</span><br><span class="line">	<span class="type">int</span> (*dev_close)(<span class="keyword">struct</span> Fd *);</span><br><span class="line">	<span class="type">int</span> (*dev_stat)(<span class="keyword">struct</span> Fd *, <span class="keyword">struct</span> Stat *);</span><br><span class="line">	<span class="type">int</span> (*dev_seek)(<span class="keyword">struct</span> Fd *, u_int);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>这样看就很容易理解了。这实际上通过结构体实现了类似抽象类的功能。</p>
<h3 id="（4）open-的后续"><a href="#（4）open-的后续" class="headerlink" title="（4）open 的后续"></a>（4）open 的后续</h3><p>不要忘了，我们的 <code>open</code> 函数还没有结束呢。接着上一节，获取到的文件描述符与用户进程共享，那么共享到哪里了呢？如果你还记得 <code>fd_alloc</code> 函数，那么应该知道共享到了 <code>struct Fd *fd</code> 所指向的地址处。虽然我们获得了服务进程共享给用户进程的文件描述符，可文件的内容还没有被一同共享过来。我们还需要使用 <code>fsipc_map</code> 进行映射。</p>
<p>在此之前我们先做准备工作。我们通过 <code>fd2data</code> 获取文件内容应该映射到的地址<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Step 3: Set &#x27;va&#x27; to the address of the page where the &#x27;fd&#x27;&#x27;s data is cached, using</span></span><br><span class="line"><span class="comment">// &#x27;fd2data&#x27;. Set &#x27;size&#x27; and &#x27;fileid&#x27; correctly with the value in &#x27;fd&#x27; as a &#x27;Filefd&#x27;.</span></span><br><span class="line"><span class="type">char</span> *va;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Filefd</span> *<span class="title">ffd</span>;</span></span><br><span class="line">u_int size, fileid;</span><br><span class="line"><span class="comment">/* Exercise 5.9: Your code here. (3/5) */</span></span><br><span class="line">va = fd2data(fd);</span><br></pre></td></tr></table></figure></p>
<p>由定义可知，该函数为不同的文件描述符提供不同的地址用于映射。整体的映射区间为 <code>[FILEBASE, FILEBASE+1024*PDMAP)</code>。这正好在存储文件描述符的空间 <code>[FILEBASE - PDMAP, FILEBASE)</code> 的上面。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// user/lib/fd.c</span></span><br><span class="line"><span class="type">void</span> *<span class="title function_">fd2data</span><span class="params">(<span class="keyword">struct</span> Fd *fd)</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> (<span class="type">void</span> *)INDEX2DATA(fd2num(fd));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">fd2num</span><span class="params">(<span class="keyword">struct</span> Fd *fd)</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> ((u_int)fd - FDTABLE) / BY2PG;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// user/include/fd.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FILEBASE 0x60000000</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INDEX2DATA(i) (FILEBASE + (i)*PDMAP)</span></span><br></pre></td></tr></table></figure></p>
<p>接着我们将文件所有的内容都从磁盘中映射到内存。使用的函数为 <code>fsipc_map</code>。映射的过程和得到文件描述符的过程类似，就不详述了。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ffd = (<span class="keyword">struct</span> Filefd *)fd;</span><br><span class="line">size = ffd-&gt;f_file.f_size;</span><br><span class="line">fileid = ffd-&gt;f_fileid;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Step 4: Alloc pages and map the file content using &#x27;fsipc_map&#x27;.</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; size; i += BY2PG) &#123;</span><br><span class="line">	<span class="comment">/* Exercise 5.9: Your code here. (4/5) */</span></span><br><span class="line">	try(fsipc_map(fileid, i, va + i));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>注意这里要映射到的地址为 <code>va + i</code> 而非 <code>va</code>，使用后者在 Lab6 中加载更大文件时会出现 bug，但却可以通过 Lab5 的评测……</p>
</blockquote>
<p>在最后，使用 <code>fd2num</code> 方法获取文件描述符在文件描述符 “数组” 中的索引<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">	<span class="comment">// Step 5: Return the number of file descriptor using &#x27;fd2num&#x27;.</span></span><br><span class="line">	<span class="comment">/* Exercise 5.9: Your code here. (5/5) */</span></span><br><span class="line">	<span class="keyword">return</span> fd2num(fd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这样，<code>open</code> 函数就终于完成了。</p>
<h3 id="（5）read-的实现"><a href="#（5）read-的实现" class="headerlink" title="（5）read 的实现"></a>（5）read 的实现</h3><p>文件系统的最后一部分，让我们再举 <code>read</code> 做一个例子。该函数位于 user/lib/fd.c 中。</p>
<p><code>read</code> 函数给了文件描述符序号作为参数，我们首先要根据该序号找到文件描述符，并根据文件描述符中的设备序号 <code>fd_dev_id</code> 找到对应的设备。这两个操作分别通过 <code>fd_lookup</code> 和 <code>dev_lookup</code> 实现。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">read</span><span class="params">(<span class="type">int</span> fdnum, <span class="type">void</span> *buf, u_int n)</span> &#123;</span><br><span class="line">	<span class="type">int</span> r;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Similar to the &#x27;write&#x27; function below.</span></span><br><span class="line">	<span class="comment">// Step 1: Get &#x27;fd&#x27; and &#x27;dev&#x27; using &#x27;fd_lookup&#x27; and &#x27;dev_lookup&#x27;.</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Dev</span> *<span class="title">dev</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Fd</span> *<span class="title">fd</span>;</span></span><br><span class="line">	<span class="comment">/* Exercise 5.10: Your code here. (1/4) */</span></span><br><span class="line">	<span class="keyword">if</span> ((r = fd_lookup(fdnum, &amp;fd)) &lt; <span class="number">0</span> || (r = dev_lookup(fd-&gt;fd_dev_id, &amp;dev)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> r;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure></p>
<p>因为文件描述符存储在内存中的连续空间中，所以 <code>fd_lookup</code> 函数只是根据序号找到对应的文件描述符，并且判断文件描述符是否被使用而已，这一点函数中又一次使用页表判断。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">fd_lookup</span><span class="params">(<span class="type">int</span> fdnum, <span class="keyword">struct</span> Fd **fd)</span> &#123;</span><br><span class="line">	u_int va;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (fdnum &gt;= MAXFD) &#123;</span><br><span class="line">		<span class="keyword">return</span> -E_INVAL;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	va = INDEX2FD(fdnum);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> ((vpt[va / BY2PG] &amp; PTE_V) != <span class="number">0</span>) &#123; <span class="comment">// the fd is used</span></span><br><span class="line">		*fd = (<span class="keyword">struct</span> Fd *)va;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> -E_INVAL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>对于 <code>dev_lookup</code>，首先我们应该了解到所有的设备都被存储到了全局变量 <code>devtab</code> 中。（这里出现了我们之前见到过的 <code>devfile</code>。<code>devcons</code> 类似。）<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">Dev</span> *<span class="title">devtab</span>[] =</span> &#123;&amp;devfile, &amp;devcons,</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> !defined(LAB) || LAB &gt;= 6</span></span><br><span class="line">			       &amp;devpipe,</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">			       <span class="number">0</span>&#125;;</span><br></pre></td></tr></table></figure></p>
<p>那么在 <code>dev_lookup</code> 中，我们就只是遍历该数组，找到和传入的参数 <code>dev_id</code> 相同的设备而已。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">dev_lookup</span><span class="params">(<span class="type">int</span> dev_id, <span class="keyword">struct</span> Dev **dev)</span> &#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; devtab[i]; i++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (devtab[i]-&gt;dev_id == dev_id) &#123;</span><br><span class="line">			*dev = devtab[i];</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	debugf(<span class="string">&quot;[%08x] unknown device type %d\n&quot;</span>, env-&gt;env_id, dev_id);</span><br><span class="line">	<span class="keyword">return</span> -E_INVAL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>回到 <code>read</code>，接下来我们判断文件的打开方式是否是只写，如果是那么我们就不能够进行读取，应该返回异常。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Step 2: Check the open mode in &#x27;fd&#x27;.</span></span><br><span class="line"><span class="comment">// Return -E_INVAL if the file is opened for writing only (O_WRONLY).</span></span><br><span class="line"><span class="comment">/* Exercise 5.10: Your code here. (2/4) */</span></span><br><span class="line"><span class="keyword">if</span> ((fd-&gt;fd_omode &amp; O_ACCMODE) == O_WRONLY) &#123;</span><br><span class="line">	<span class="keyword">return</span> -E_INVAL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>接着我们调用设备对应的 <code>dev_read</code> 函数，完成数据的读取。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Step 3: Read from &#x27;dev&#x27; into &#x27;buf&#x27; at the seek position (offset in &#x27;fd&#x27;).</span></span><br><span class="line"><span class="comment">/* Exercise 5.10: Your code here. (3/4) */</span></span><br><span class="line">r = dev-&gt;dev_read(fd, buf, n, fd-&gt;fd_offset);</span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<p>根据之前我们展示的 <code>devfile</code> 的定义，普通文件的读取函数为 <code>file_read</code>。该函数位于 user/lib/file.c 中，只是简单地读取被映射到内存中的文件内容而已。（还记得 <code>fsipc_map</code> 吗？）<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">file_read</span><span class="params">(<span class="keyword">struct</span> Fd *fd, <span class="type">void</span> *buf, u_int n, u_int offset)</span> &#123;</span><br><span class="line">	u_int size;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Filefd</span> *<span class="title">f</span>;</span></span><br><span class="line">	f = (<span class="keyword">struct</span> Filefd *)fd;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Avoid reading past the end of file.</span></span><br><span class="line">	size = f-&gt;f_file.f_size;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (offset &gt; size) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (offset + n &gt; size) &#123;</span><br><span class="line">		n = size - offset;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">memcpy</span>(buf, (<span class="type">char</span> *)fd2data(fd) + offset, n);</span><br><span class="line">	<span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>再次回到 <code>read</code>，我们读取完了内容，现在我们要更新文件的指针 <code>fd_offset</code>。在调用读取函数的时候，我们使用 <code>fd_offset</code> 确定了读取的位置（ <code>dev_read(fd, buf, n, fd-&gt;fd_offset)</code>）。那么下一次读取时，就应该从还未被读取的地方读取了。更新完成后，我们返回读到的数据的字节数。这样 <code>read</code> 函数也完成了。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">	<span class="comment">// Step 4: Update the offset in &#x27;fd&#x27; if the read is successful.</span></span><br><span class="line">	<span class="comment">/* Hint: DO NOT add a null terminator to the end of the buffer!</span></span><br><span class="line"><span class="comment">	 *  A character buffer is not a C string. Only the memory within [buf, buf+n) is safe to</span></span><br><span class="line"><span class="comment">	 *  use. */</span></span><br><span class="line">	<span class="comment">/* Exercise 5.10: Your code here. (4/4) */</span></span><br><span class="line">	<span class="keyword">if</span> (r &gt; <span class="number">0</span>) &#123;</span><br><span class="line">		fd-&gt;fd_offset += r;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="四、磁盘驱动"><a href="#四、磁盘驱动" class="headerlink" title="四、磁盘驱动"></a>四、磁盘驱动</h2><h3 id="（1）设备读写系统调用"><a href="#（1）设备读写系统调用" class="headerlink" title="（1）设备读写系统调用"></a>（1）设备读写系统调用</h3><p>我们在前面的许多 Lab 中都见到了与外部设备进行交互的代码。我们只需要在对应的物理地址位置写入或读取某些数值，就可以完成与设备的信息传递。现在我们要规范化这一过程，让用户程序也能够实现与设备的直接交互。也就是说，要实现设备读写的系统调用。</p>
<p>这一部分十分简单。根据指导书和注释我们可以得知，只需要完成对三个设备的读写即可。这三个设备是终端、磁盘和时钟。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *  All valid device and their physical address ranges:</span></span><br><span class="line"><span class="comment"> *	* ---------------------------------*</span></span><br><span class="line"><span class="comment"> *	|   device   | start addr | length |</span></span><br><span class="line"><span class="comment"> *	* -----------+------------+--------*</span></span><br><span class="line"><span class="comment"> *	|  console   | 0x10000000 | 0x20   | (dev_cons.h)</span></span><br><span class="line"><span class="comment"> *	|  IDE disk  | 0x13000000 | 0x4200 | (dev_disk.h)</span></span><br><span class="line"><span class="comment"> *	|    rtc     | 0x15000000 | 0x200  | (dev_rtc.h)</span></span><br><span class="line"><span class="comment"> *	* ---------------------------------*</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure></p>
<p>在内核中，我们要完成系统调用的实现。这里我们要判断内存的虚拟地址是否处于用户空间以及设备的物理地址是否处于那三个设备的范围内。如果所有检查都合法，则调用 <code>memcpy</code> 从内存向设备写入或从设备向内存读取即可，系统调用函数依旧在 kern/syscall_all.c 中实现。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sys_write_dev</span><span class="params">(u_int va, u_int pa, u_int len)</span> &#123;</span><br><span class="line">	<span class="comment">/* Exercise 5.1: Your code here. (1/2) */</span></span><br><span class="line">	<span class="keyword">if</span> (is_illegal_va_range(va, len)) &#123;</span><br><span class="line">		<span class="keyword">return</span> -E_INVAL;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> ((<span class="number">0x10000000</span> &lt;= pa &amp;&amp; pa + len &lt;= <span class="number">0x10000020</span>) ||</span><br><span class="line">	    (<span class="number">0x13000000</span> &lt;= pa &amp;&amp; pa + len &lt;= <span class="number">0x13004200</span>) ||</span><br><span class="line">	    (<span class="number">0x15000000</span> &lt;= pa &amp;&amp; pa + len &lt;= <span class="number">0x15000200</span>)) &#123;</span><br><span class="line">		<span class="built_in">memcpy</span>((<span class="type">void</span> *)(KSEG1 | pa), (<span class="type">void</span> *)va, len);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> -E_INVAL;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">sys_read_dev</span><span class="params">(u_int va, u_int pa, u_int len)</span> &#123;</span><br><span class="line">	<span class="comment">/* Exercise 5.1: Your code here. (2/2) */</span></span><br><span class="line">	<span class="keyword">if</span> (is_illegal_va_range(va, len)) &#123;</span><br><span class="line">		<span class="keyword">return</span> -E_INVAL;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> ((<span class="number">0x10000000</span> &lt;= pa &amp;&amp; pa + len &lt;= <span class="number">0x10000020</span>) ||</span><br><span class="line">	    (<span class="number">0x13000000</span> &lt;= pa &amp;&amp; pa + len &lt;= <span class="number">0x13004200</span>) ||</span><br><span class="line">	    (<span class="number">0x15000000</span> &lt;= pa &amp;&amp; pa + len &lt;= <span class="number">0x15000200</span>)) &#123;</span><br><span class="line">		<span class="built_in">memcpy</span>((<span class="type">void</span> *)va, (<span class="type">void</span> *)(KSEG1 | pa), len);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> -E_INVAL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>另外不要忘记在用户库函数中实现接口，用户的系统调用接口同样还在 user/lib/syscall_lib.c<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">syscall_write_dev</span><span class="params">(<span class="type">void</span> *va, u_int dev, u_int len)</span> &#123;</span><br><span class="line">	<span class="comment">/* Exercise 5.2: Your code here. (1/2) */</span></span><br><span class="line">	<span class="keyword">return</span> msyscall(SYS_write_dev, va, dev, len);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">syscall_read_dev</span><span class="params">(<span class="type">void</span> *va, u_int dev, u_int len)</span> &#123;</span><br><span class="line">	<span class="comment">/* Exercise 5.2: Your code here. (2/2) */</span></span><br><span class="line">	<span class="keyword">return</span> msyscall(SYS_read_dev, va, dev, len);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="（2）IDE-磁盘读写"><a href="#（2）IDE-磁盘读写" class="headerlink" title="（2）IDE 磁盘读写"></a>（2）IDE 磁盘读写</h3><p>最后我们需要实现磁盘的读写操作。在上一章中我们就遇到了 <code>ide_read</code> 函数。该函数通过调用系统操作，实现了从磁盘中读取数据到内存中。类似的还有 <code>ide_write</code> 函数。这两个函数都是磁盘驱动。</p>
<p>在指导书中给出了操作 IDE 磁盘可能用到的地址偏移。我们只需要读写这些地址即可。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">偏移</th>
<th>效果</th>
<th style="text-align:center">数据位宽</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">0x0000</td>
<td>写：设置下一次读写操作时的磁盘镜像偏移的字节数</td>
<td style="text-align:center">4 字节</td>
</tr>
<tr>
<td style="text-align:center">0x0008</td>
<td>写：设置高 32 位的偏移的字节数</td>
<td style="text-align:center">4 字节</td>
</tr>
<tr>
<td style="text-align:center">0x0010</td>
<td>写：设置下一次读写操作的磁盘编号</td>
<td style="text-align:center">4 字节</td>
</tr>
<tr>
<td style="text-align:center">0x0020</td>
<td>写：开始一次读写操作（写 0 表示读操作，1 表示写操作）</td>
<td style="text-align:center">4 字节</td>
</tr>
<tr>
<td style="text-align:center">0x0030</td>
<td>读：获取上一次操作的状态返回值（读 0 表示失败，非 0 则表示成功）</td>
<td style="text-align:center">4 字节</td>
</tr>
<tr>
<td style="text-align:center">0x4000-0x41ff</td>
<td>读/写：512 字节的读写缓存</td>
<td style="text-align:center">/</td>
</tr>
</tbody>
</table>
</div>
<p><code>ide_read</code> 和 <code>ide_write</code> 定义在 fs/ide.c 中。这两个函数都需要我们自己实现<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">ide_read</span><span class="params">(u_int diskno, u_int secno, <span class="type">void</span> *dst, u_int nsecs)</span> &#123;</span><br><span class="line">	u_int begin = secno * BY2SECT;</span><br><span class="line">	u_int end = begin + nsecs * BY2SECT;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (u_int off = <span class="number">0</span>; begin + off &lt; end; off += BY2SECT) &#123;</span><br><span class="line">		<span class="type">uint32_t</span> temp = diskno;</span><br><span class="line">		<span class="comment">/* Exercise 5.3: Your code here. (1/2) */</span></span><br><span class="line">		syscall_write_dev(&amp;temp, DEV_DISK_ADDRESS | DEV_DISK_ID, <span class="number">4</span>);</span><br><span class="line">		temp = begin + off;</span><br><span class="line">		syscall_write_dev(&amp;temp, DEV_DISK_ADDRESS | DEV_DISK_OFFSET, <span class="number">4</span>);</span><br><span class="line">		temp = DEV_DISK_OPERATION_READ;</span><br><span class="line">		syscall_write_dev(&amp;temp, DEV_DISK_ADDRESS | DEV_DISK_START_OPERATION, <span class="number">4</span>);</span><br><span class="line">		syscall_read_dev(&amp;temp, DEV_DISK_ADDRESS | DEV_DISK_STATUS, <span class="number">4</span>);</span><br><span class="line">		<span class="keyword">if</span> (temp == <span class="number">0</span>) &#123;</span><br><span class="line">			panic_on(<span class="string">&quot;fail to read from disk&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		syscall_read_dev(dst + off, DEV_DISK_ADDRESS | DEV_DISK_BUFFER, BY2SECT);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">ide_write</span><span class="params">(u_int diskno, u_int secno, <span class="type">void</span> *src, u_int nsecs)</span> &#123;</span><br><span class="line">	u_int begin = secno * BY2SECT;</span><br><span class="line">	u_int end = begin + nsecs * BY2SECT;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (u_int off = <span class="number">0</span>; begin + off &lt; end; off += BY2SECT) &#123;</span><br><span class="line">		<span class="type">uint32_t</span> temp = diskno;</span><br><span class="line">		<span class="comment">/* Exercise 5.3: Your code here. (2/2) */</span></span><br><span class="line">		syscall_write_dev(&amp;temp, DEV_DISK_ADDRESS | DEV_DISK_ID, <span class="number">4</span>);</span><br><span class="line">		temp = begin + off;</span><br><span class="line">		syscall_write_dev(&amp;temp, DEV_DISK_ADDRESS | DEV_DISK_OFFSET, <span class="number">4</span>);</span><br><span class="line">		syscall_write_dev(src + off, DEV_DISK_ADDRESS | DEV_DISK_BUFFER, BY2SECT);</span><br><span class="line">		temp = DEV_DISK_OPERATION_WRITE;</span><br><span class="line">		syscall_write_dev(&amp;temp, DEV_DISK_ADDRESS | DEV_DISK_START_OPERATION, <span class="number">4</span>);</span><br><span class="line">		syscall_read_dev(&amp;temp, DEV_DISK_ADDRESS| DEV_DISK_STATUS, <span class="number">4</span>);</span><br><span class="line">		<span class="keyword">if</span> (temp == <span class="number">0</span>) &#123;</span><br><span class="line">			panic_on(<span class="string">&quot;fail to write disk&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里的代码看上去复杂，实际上只实现了简单的步骤，比如对于 <code>ide_read</code>，只不过实现了 1. 设定要读的磁盘编号；2. 设定要读取的地址；3. 开始读取；4. 获取读取后状态（返回值），如果读取失败则 panic；5. 将缓冲区中的内容读到内存中。</p>
<p>这样 Lab5 就完成了。</p>

    </div>

    
    
    
        

<div>
<ul class="post-copyright">
  <li class="post-copyright-author">
    <strong>本文作者： </strong>wokron
  </li>
  <li class="post-copyright-link">
    <strong>本文链接：</strong>
    <a href="https://wokron.github.io/posts/b72a5f5f/" title="BUAA-OS实验笔记之Lab5">https://wokron.github.io/posts/b72a5f5f/</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/zh-CN" rel="noopener" target="_blank"><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！
  </li>
</ul>
</div>


      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/MOS/" rel="tag"># MOS</a>
              <a href="/tags/os/" rel="tag"># os</a>
              <a href="/tags/BUAA/" rel="tag"># BUAA</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/posts/2594d393/" rel="prev" title="后端开发笔记之脚本">
      <i class="fa fa-chevron-left"></i> 后端开发笔记之脚本
    </a></div>
      <div class="post-nav-item">
    <a href="/posts/961aefad/" rel="next" title="奇技淫巧——RNN求解常微分方程组">
      奇技淫巧——RNN求解常微分方程组 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%80%E3%80%81Lab5-%E5%89%8D%E8%A8%80"><span class="nav-number">1.</span> <span class="nav-text">一、Lab5 前言</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%8C%E3%80%81%E7%A3%81%E7%9B%98%E9%95%9C%E5%83%8F"><span class="nav-number">2.</span> <span class="nav-text">二、磁盘镜像</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%881%EF%BC%89%E9%95%9C%E5%83%8F%E5%88%B6%E4%BD%9C%E5%B7%A5%E5%85%B7"><span class="nav-number">2.1.</span> <span class="nav-text">（1）镜像制作工具</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%882%EF%BC%89%E7%A3%81%E7%9B%98%E6%95%B0%E6%8D%AE%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="nav-number">2.2.</span> <span class="nav-text">（2）磁盘数据初始化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%883%EF%BC%89%E6%96%87%E4%BB%B6%E5%86%99%E5%85%A5"><span class="nav-number">2.3.</span> <span class="nav-text">（3）文件写入</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%884%EF%BC%89%E6%94%B6%E5%B0%BE%E5%B7%A5%E4%BD%9C"><span class="nav-number">2.4.</span> <span class="nav-text">（4）收尾工作</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%89%E3%80%81%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F"><span class="nav-number">3.</span> <span class="nav-text">三、文件系统</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%881%EF%BC%89%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C%E5%BA%93%E5%87%BD%E6%95%B0"><span class="nav-number">3.1.</span> <span class="nav-text">（1）文件操作库函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%882%EF%BC%89%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%9C%8D%E5%8A%A1%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="nav-number">3.2.</span> <span class="nav-text">（2）文件系统服务进程的初始化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%883%EF%BC%89%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%9C%8D%E5%8A%A1%E8%BF%9B%E7%A8%8B%E7%9A%84%E6%9C%8D%E5%8A%A1"><span class="nav-number">3.3.</span> <span class="nav-text">（3）文件系统服务进程的服务</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%884%EF%BC%89open-%E7%9A%84%E5%90%8E%E7%BB%AD"><span class="nav-number">3.4.</span> <span class="nav-text">（4）open 的后续</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%885%EF%BC%89read-%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="nav-number">3.5.</span> <span class="nav-text">（5）read 的实现</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9B%9B%E3%80%81%E7%A3%81%E7%9B%98%E9%A9%B1%E5%8A%A8"><span class="nav-number">4.</span> <span class="nav-text">四、磁盘驱动</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%881%EF%BC%89%E8%AE%BE%E5%A4%87%E8%AF%BB%E5%86%99%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8"><span class="nav-number">4.1.</span> <span class="nav-text">（1）设备读写系统调用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%882%EF%BC%89IDE-%E7%A3%81%E7%9B%98%E8%AF%BB%E5%86%99"><span class="nav-number">4.2.</span> <span class="nav-text">（2）IDE 磁盘读写</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="wokron"
      src="/images/avatar.jpg">
  <p class="site-author-name" itemprop="name">wokron</p>
  <div class="site-description" itemprop="description">StringCat的个人博客。记录学习、分享经验</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">67</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">8</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">70</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/wokron" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;wokron" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="/stringcatwok@gmail.com" title="E-Mail → stringcatwok@gmail.com"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>
  <div class="cc-license motion-element" itemprop="license">
    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/zh-CN" class="cc-opacity" rel="noopener" target="_blank"><img src="/images/cc-by-nc-sa.svg" alt="Creative Commons"></a>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">wokron</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item-icon">
      <i class="fa fa-fa fa-user"></i>
    </span>
    <span class="site-uv" title="总访客量">
      总访问人数：<span id="busuanzi_value_site_uv"></span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-fa fa-eye"></i>
    </span>
    <span class="site-pv" title="总访问量">
      总阅读次数：<span id="busuanzi_value_site_pv"></span>
    </span>
</div>







      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

  

<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"log":false,"model":{"jsonPath":"/live2dw/assets/hijiki.model.json"},"display":{"position":"right","width":150,"height":300},"mobile":{"show":true}});</script></body>
</html>
