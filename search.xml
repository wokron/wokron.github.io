<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>2D物理引擎基础之刚体力学与碰撞约束</title>
    <url>/posts/704144f6/</url>
    <content><![CDATA[<h2 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h2><p>本文是“2D物理引擎基础”的第三篇文章，主要介绍物体刚体力学的相关知识以及碰撞发生后的处理办法。后者背后的数学原理较为复杂，因此这里大多情况只是罗列公式并做简要说明。</p>
<h2 id="二、刚体力学"><a href="#二、刚体力学" class="headerlink" title="二、刚体力学"></a>二、刚体力学</h2><h3 id="连续的刚体力学"><a href="#连续的刚体力学" class="headerlink" title="连续的刚体力学"></a>连续的刚体力学</h3><p>我们考虑二维的情况。假设有一刚体，质量为 $M$，转动惯量为 $I$，在距质心 $\vec{r}$ 处受到一力 $\vec{F}$ 的作用。</p>
<p>那么刚体所受相对于质心的力矩 $\vec{M}$ 为：</p>
<script type="math/tex; mode=display">
    \vec{M} = \vec{r} \times \vec{F}</script><p>注意 $\vec{M}$ 的方向垂直于平面，后面的角速度同理。</p>
<p>在 $\Delta{t}$ 时间内速度变化 $\Delta{\vec{v}}$ 有</p>
<script type="math/tex; mode=display">
    \Delta{\vec{v}} = \int_{t_0}^{t0+\Delta{t}} \frac{\vec{F}(t)}{M} dt</script><p>同样的，角速度变化 $\Delta{\vec{w}}$ 有</p>
<script type="math/tex; mode=display">
    \Delta{\vec{w}} = \int_{t_0}^{t0+\Delta{t}} \frac{\vec{M(t)}}{I} dt</script><p>类似的，也有位置和角度的变化</p>
<script type="math/tex; mode=display">
    \Delta{\vec{p}} = \int_{t_0}^{t0+\Delta{t}} \vec{v}(t) dt</script><script type="math/tex; mode=display">
    \Delta{\vec{\theta}} = \int_{t_0}^{t0+\Delta{t}} \vec{w}(t) dt</script><p>还有冲量</p>
<script type="math/tex; mode=display">
    \vec{I} = \int_{t_0}^{t0+\Delta{t}} \vec{F}(t) dt</script><p>以及角冲量（或称冲量矩）</p>
<script type="math/tex; mode=display">
    \vec{H} = \int_{t_0}^{t0+\Delta{t}} \vec{M}(t) dt</script><p>并有等式</p>
<script type="math/tex; mode=display">
    \vec{I} = M \Delta{\vec{v}}</script><script type="math/tex; mode=display">
    \vec{H} = I \Delta{\vec{w}}</script><h3 id="离散的刚体模拟"><a href="#离散的刚体模拟" class="headerlink" title="离散的刚体模拟"></a>离散的刚体模拟</h3><p>正如第一篇文章中说过的，一般情况下计算机无法计算连续，只能通过离散的方式进行近似。物理引擎中进行的模拟会导致误差，但这对于视觉效果来说已经足够了。</p>
<h4 id="力的视角"><a href="#力的视角" class="headerlink" title="力的视角"></a>力的视角</h4><p>同样的，我们假设有一刚体，质量为 $M$，转动惯量为 $I$，在距质心 $\vec{r}$ 处受到一力 $\vec{F}$ 的作用。在 $\Delta{t}$ 的时间间隔下，有力矩</p>
<script type="math/tex; mode=display">
    \vec{M} = \vec{r} \times \vec{F}</script><p>速度和角速度的变化为</p>
<script type="math/tex; mode=display">
    \Delta{\vec{v}} = \frac{\vec{F}}{M} \Delta{t}</script><script type="math/tex; mode=display">
    \Delta{\vec{w}} = \frac{\vec{M}}{I} \Delta{t}</script><p>位置和角度的变化为</p>
<script type="math/tex; mode=display">
    \Delta{\vec{p}} =  \vec{v} \Delta{t}</script><script type="math/tex; mode=display">
    \Delta{\vec{\theta}} =  \vec{w} \Delta{t}</script><h4 id="冲量的视角"><a href="#冲量的视角" class="headerlink" title="冲量的视角"></a>冲量的视角</h4><p>假设物体在距质心 $\vec{r}$ 处极短的时间内受到一冲量 $\vec{I}$ 的作用，这个冲量将直接引起速度和角速度的变化。</p>
<p>首先，这个冲量相对于质心的冲量矩为</p>
<script type="math/tex; mode=display">
    \vec{H} = \vec{r} \times \vec{I}</script><p>冲量更新速度</p>
<script type="math/tex; mode=display">
    \Delta{\vec{v}} = \frac{\vec{I}}{M}</script><p>冲量矩更新角速度</p>
<script type="math/tex; mode=display">
    \Delta{\vec{w}} = \frac{\vec{H}}{I}</script><p>最后需要提一句，距离质点 $\vec{r}$ 处在全局坐标系的速度为</p>
<script type="math/tex; mode=display">
    \vec{v}_p = \vec{v} + \vec{w} \times \vec{r}</script><blockquote>
<p>这些概念和公式并不复杂，只是有些时候难以准确记忆。罗列公式的意义也就在于此</p>
</blockquote>
<h2 id="三、碰撞约束"><a href="#三、碰撞约束" class="headerlink" title="三、碰撞约束"></a>三、碰撞约束</h2><p>约束是物理引擎中的重要概念，指的是在一些情况下，通过某些手段，改变物体的位置、速度等数据，实现物体满足某种限制效果的方法。</p>
<p>本部分专门介绍碰撞约束，研究物体与物体发生碰撞后，限制物体不相互穿透的方法。我们的输入是碰撞的物体的物理属性、接触点、碰撞法线和穿透深度；输出是对碰撞物体的速度、角速度进行的修改。一般来说，物理引擎使用冲量对物体速度进行修改。</p>
<h3 id="一个例子"><a href="#一个例子" class="headerlink" title="一个例子"></a>一个例子</h3><p>我们首先考虑一个简单的问题，两个小球在平面上发生正碰，他们的初始速度分别为 $\vec{v}_a, \vec{v}_b$，由 A 到 B 的碰撞法线为 $\vec{n}$。恢复系数为 $C_r$。他们碰撞后速度改变，这等效于对两者施加怎样的冲量？</p>
<p>首先，我们计算两物体的相对速度</p>
<script type="math/tex; mode=display">
\begin{equation}
    \vec{v}_{ab} = \vec{v}_b - \vec{v}_a
\end{equation}</script><p>那么反弹后的相对速度应为</p>
<script type="math/tex; mode=display">
\begin{equation}
    \vec{u}_{ab} = -C_r \vec{v}_{ab}
\end{equation}</script><p>另一方面我们要对两物体施加冲量，因为牛顿第三定理，两个作用力等大反向，因此冲量的大小也相等，设为 $\lambda_n$</p>
<p>则冲量的作用效果为</p>
<script type="math/tex; mode=display">
\begin{equation}
    \vec{u}_a = \vec{v}_a - \frac{\lambda_n \vec{n}}{m_a}
\end{equation}</script><script type="math/tex; mode=display">
\begin{equation}
    \vec{u}_b = \vec{v}_b + \frac{\lambda_n \vec{n}}{m_b}
\end{equation}</script><p>$(4)-(3)$ 得</p>
<script type="math/tex; mode=display">
\begin{equation}
    \vec{u}_b - \vec{u}_a = \vec{v}_b - \vec{v}_a + (\frac{1}{m_a} + \frac{1}{m_b}) \lambda_n \vec{n}
\end{equation}</script><p>带入 $(1), (2)$ 式得</p>
<script type="math/tex; mode=display">
\begin{equation}
    \lambda_n = \frac{-(1+C_r)\vec{v}_{ab}}{(\frac{1}{m_a} + \frac{1}{m_b})\vec{n}}
\end{equation}</script><p>等式右侧上下同点乘 $\vec{n}$ 得</p>
<script type="math/tex; mode=display">
\begin{equation}
    \lambda_n = \frac{-(1+C_r)(\vec{v}_b - \vec{v}_a) \cdot \vec{n}}{(\frac{1}{m_a} + \frac{1}{m_b})}
\end{equation}</script><p>因此我们只需对物体 A 施加 $-\lambda_n \vec{n}$，对 B 施加 $\lambda_n \vec{n}$ 大小的冲量就足以实现碰撞后分开的约束效果。</p>
<h3 id="刚体力学的碰撞约束"><a href="#刚体力学的碰撞约束" class="headerlink" title="刚体力学的碰撞约束"></a>刚体力学的碰撞约束</h3><p>上一小节的例子只考虑了一个很简化的情况。只有正碰，而没有考虑斜碰时的摩擦力和旋转等问题。更一般的公式是如下所示的：</p>
<p>首先我们定义切向方向，它是与碰撞法线垂直，且位于速度同侧的单位向量或零向量，即</p>
<script type="math/tex; mode=display">
    \vec{v}_R = \vec{v}_b - \vec{v}_a</script><script type="math/tex; mode=display">
    \vec{t} = normalize(\vec{v}_R - (\vec{v}_R \cdot \vec{n}) \vec{n})</script><p>那么法向的冲量大小为</p>
<script type="math/tex; mode=display">
    \lambda_n = \frac{-(1+C_r)(\vec{v}_b - \vec{v}_a) \cdot \vec{n}}{\frac{1}{m_a} + \frac{1}{m_b} + \frac{(\vec{r}_a \times \vec{n})^2}{I_a} + \frac{(\vec{r}_b \times \vec{n})^2}{I_b}}</script><p>切向的冲量大小为</p>
<script type="math/tex; mode=display">
    \lambda_t = \frac{-(\vec{v}_b - \vec{v}_a) \cdot \vec{t}}{\frac{1}{m_a} + \frac{1}{m_b} + \frac{(\vec{r}_a \times \vec{t})^2}{I_a} + \frac{(\vec{r}_b \times \vec{t})^2}{I_b}}</script><p>其中 $\vec{r}_a, \vec{r}_b$ 表示从物体质心到接触点的位置向量。</p>
<blockquote>
<p>注意两个公式中 $\vec{n}$ 和 $\vec{t}$ 的不同。并且注意这里的速度 $\vec{v}_a, \vec{v}_b$ 考虑了角速度，即</p>
<script type="math/tex; mode=display">
    \vec{v} = \vec{v}_{\text{linear}} + \vec{w}_{\text{rotate}} \times \vec{r}</script></blockquote>
<p>这样只要对物体 A 施加 $-(\lambda_n \vec{n} + \lambda_t \vec{t})$，对物体 B 施加 $\lambda_n \vec{n} + \lambda_t \vec{t}$ 大小的冲量就可以实现物体的碰撞的约束。</p>
<p>值得注意的是，我们在上面的公式中多次看到质量的倒数和转动惯量的倒数，这一数值在物理引擎中经常使用，我们可以将其在一开始便计算并储存起来。另外，冲量等式中分母部分也较为常见，我们同样可以将其提出作为单独的参数。此参数被称为（法向/切向）有效质量。</p>
<script type="math/tex; mode=display">
    M_n^{-1} = \frac{1}{\frac{1}{m_a} + \frac{1}{m_b} + \frac{(\vec{r}_a \times \vec{n})^2}{I_a} + \frac{(\vec{r}_b \times \vec{n})^2}{I_b}}</script><script type="math/tex; mode=display">
    M_t^{-1} = \frac{1}{\frac{1}{m_a} + \frac{1}{m_b} + \frac{(\vec{r}_a \times \vec{t})^2}{I_a} + \frac{(\vec{r}_b \times \vec{t})^2}{I_b}}</script><p>我们修改原有的 Body 类<br><figure class="highlight py"><table><tr><td class="code"><pre><span class="line">self.mass = density * get_area(self.points)</span><br><span class="line">self.inv_mass = <span class="number">1</span> / self.mass <span class="comment"># add inv_mass</span></span><br><span class="line">self.inertia = get_moments_of_inertia(self.points, self.mass)</span><br><span class="line">self.inv_inertia = <span class="number">1</span> / self.inertia <span class="comment"># add inv_inertia</span></span><br></pre></td></tr></table></figure></p>
<p>并编写计算有效质量的函数<br><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">get_effective_mass</span>(<span class="params">body_a, ra, body_b, rb, unit_vect</span>):</span><br><span class="line">    ma = body_a.inv_mass</span><br><span class="line">    mb = body_b.inv_mass</span><br><span class="line"></span><br><span class="line">    ia = (np.cross(ra, unit_vect))**<span class="number">2</span> * body_a.inv_inertia</span><br><span class="line">    ib = (np.cross(rb, unit_vect))**<span class="number">2</span> * body_b.inv_inertia</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span> / (ma + mb + ia + ib)</span><br></pre></td></tr></table></figure></p>
<p>其中 <code>unit_vect</code> 表示切向量或者法向量。</p>
<h3 id="摩擦力的模拟"><a href="#摩擦力的模拟" class="headerlink" title="摩擦力的模拟"></a>摩擦力的模拟</h3><p>很多时候我们还需要考虑摩擦力的影响，这样我们就需要对切向的冲量进行调整。具体来说，我们假设最大静摩擦系数等于动摩擦系数，那么就需要满足</p>
<script type="math/tex; mode=display">
    F_f \le \mu F_n</script><blockquote>
<p>注意 $F_f, F_n$ 是力的大小，不考虑方向</p>
</blockquote>
<p>不等式两边同乘 $\Delta{t}$ 就变成冲量不等式，即</p>
<script type="math/tex; mode=display">
    \lambda_t \le \mu \lambda_n</script><p>因此对摩擦力的限制即为</p>
<script type="math/tex; mode=display">
    \lambda'_t = clamp_{[-\mu\lambda_n, \mu\lambda_n]}(\lambda_t)</script><blockquote>
<p>clamp 函数将 $\lambda_t$ 限制在区间 $[-\mu\lambda_n, \mu\lambda_n]$ 间。</p>
</blockquote>
<h3 id="速度约束"><a href="#速度约束" class="headerlink" title="速度约束"></a>速度约束</h3><p>据此我们可以编写实施约束的代码。首先，我们将碰撞相关的信息打包成一个类。在物理引擎理论中，这似乎被称作 Manifold。<br><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Manifold</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, body_a, body_b, collide_result</span>):</span><br><span class="line">        self.body_a = body_a</span><br><span class="line">        self.body_b = body_b</span><br><span class="line">        self.normal, self.contact_points = collide_result</span><br><span class="line"></span><br><span class="line">        self.ra = []</span><br><span class="line">        self.rb = []</span><br><span class="line">        <span class="keyword">for</span> point, depth <span class="keyword">in</span> self.contact_points:</span><br><span class="line">            self.ra.append(point - body_a.position)</span><br><span class="line">            self.rb.append(point - body_b.position)</span><br></pre></td></tr></table></figure><br>其中传入的 <code>collide_result</code> 参数即 <code>sat3</code> 函数的输出。</p>
<p>接着，我们编写碰撞中约束速度的函数：<br><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">velocity_constrain</span>(<span class="params">manifold</span>):</span><br><span class="line">    body_a = manifold.body_a</span><br><span class="line">    body_b = manifold.body_b</span><br><span class="line">    contact_points = manifold.contact_points</span><br><span class="line">    n = manifold.normal</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(contact_points)):</span><br><span class="line">        p, depth = contact_points[i]</span><br><span class="line"></span><br><span class="line">        ra = manifold.ra[i]</span><br><span class="line">        rb = manifold.rb[i]</span><br><span class="line"></span><br><span class="line">        va = body_a.v + cross_product(body_a.w, ra)</span><br><span class="line">        vb = body_b.v + cross_product(body_b.w, rb)</span><br><span class="line"></span><br><span class="line">        rv = vb - va</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> np.dot(rv, n) &gt; <span class="number">0</span>: <span class="comment"># 如果速度方向背离了碰撞方向，则说明物体已经分离</span></span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        </span><br><span class="line">        t = normalize(rv - np.dot(rv, n) * n)</span><br><span class="line"></span><br><span class="line">        effective_mass_n = get_effective_mass(body_a, ra, body_b, rb, n)</span><br><span class="line">        effective_mass_t = get_effective_mass(body_a, ra, body_b, rb, t)</span><br><span class="line"></span><br><span class="line">        cr = <span class="built_in">min</span>(body_a.restitution, body_b.restitution)</span><br><span class="line"></span><br><span class="line">        lambda_n = -(<span class="number">1</span> + cr) * np.dot(rv, n) * effective_mass_n</span><br><span class="line"></span><br><span class="line">        body_a.apply_impulse(-lambda_n * n, p)</span><br><span class="line">        body_b.apply_impulse(lambda_n * n, p)</span><br><span class="line"></span><br><span class="line">        lambda_t = - np.dot(rv, t) * effective_mass_t</span><br><span class="line"></span><br><span class="line">        mu = np.sqrt(body_a.friction * body_b.friction)</span><br><span class="line"></span><br><span class="line">        max_friction = <span class="built_in">abs</span>(mu * lambda_n)</span><br><span class="line"></span><br><span class="line">        lambda_t = clamp(lambda_t, -max_friction, max_friction)</span><br><span class="line"></span><br><span class="line">        body_a.apply_impulse(-lambda_t * t, p)</span><br><span class="line">        body_b.apply_impulse(lambda_t * t, p)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">cross_product</span>(<span class="params">s, a</span>):</span><br><span class="line">    <span class="keyword">return</span> np.array([-s * a[<span class="number">1</span>], s * a[<span class="number">0</span>]])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">clamp</span>(<span class="params">value, smallest, largest</span>):</span><br><span class="line">    <span class="keyword">if</span> value &lt; smallest:</span><br><span class="line">        <span class="keyword">return</span> smallest</span><br><span class="line">    <span class="keyword">elif</span> largest &lt; value:</span><br><span class="line">        <span class="keyword">return</span> largest</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> value</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p><strong>十分需要注意的是</strong>，碰撞约束的求解是一个迭代的过程，这是因为每次碰撞检测只会考虑某两个物体；对于多对物体，我们需要先求出所有发生碰撞的物体对，将碰撞信息存入 <code>Manifold</code> 类中。接着多次迭代，每一次迭代对所有的 Manifold 求解速度约束。只有这样才能尽量求得全局的约束结果。</p>
</blockquote>
<h3 id="穿透问题与位置约束"><a href="#穿透问题与位置约束" class="headerlink" title="穿透问题与位置约束"></a>穿透问题与位置约束</h3><p>容易发现，我们上面的代码并没有使用穿透深度。在一些情况下，因为在碰撞后的第一帧就进行了速度处理，此时穿透深度较小，很快就能修正，所以视觉上并无大碍。但很多时候，如施加了重力的情况下，单纯的修改速度不足以抵消重力的影响，此时穿透深度会越来越大，最终会使物体陷入地面。</p>
<p>因此，我们除了进行速度约束以外，还需要根据穿透深度进行位置的修正。这就是位置约束。</p>
<p>我们设当前穿透深度为 $x$，最大允许穿透深度为 $x_{max}$，则有</p>
<script type="math/tex; mode=display">
    \lambda_{pos} = \beta M^{-1}_{n} max(x - x_{max}, 0) \quad (0 \lt \beta \lt 1)</script><p>其中 $\beta$ 是人为穿透的解决程度（虽然不太理解这有什么意义）。</p>
<p>类似于冲量，最终的位置的变化量为</p>
<script type="math/tex; mode=display">
    \Delta \vec{p}_a = -\frac{\lambda_{pos}\vec{n}}{m_a}</script><script type="math/tex; mode=display">
    \Delta \vec{p}_b = \frac{\lambda_{pos}\vec{n}}{m_b}</script><blockquote>
<p>本方法的数学原理并不清楚，但似乎 box2d 中是这样做的？</p>
</blockquote>
<p>据此我们能写出代码。需要注意一点，位置变化会引起接触点的变化，我们希望得知接触点分离的时刻，这通过保留物体质心到接触点的向量实现。这也是我们在 <code>Manifold</code> 类中加入 <code>ra, rb</code> 的原因。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">position_constrain</span>(<span class="params">manifold</span>):</span><br><span class="line">    body_a = manifold.body_a</span><br><span class="line">    body_b = manifold.body_b</span><br><span class="line">    contact_points = manifold.contact_points</span><br><span class="line">    n = manifold.normal</span><br><span class="line"></span><br><span class="line">    bias_factor = <span class="number">0.8</span></span><br><span class="line">    max_depth = <span class="number">0.005</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(contact_points)):</span><br><span class="line">        p, depth = contact_points[i]</span><br><span class="line"></span><br><span class="line">        ra = manifold.ra[i]</span><br><span class="line">        rb = manifold.rb[i]</span><br><span class="line"></span><br><span class="line">        pa = ra + body_a.position</span><br><span class="line">        pb = rb + body_b.position</span><br><span class="line"></span><br><span class="line">        c = pa - pb</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> np.dot(c, n) &lt; <span class="number">0</span>: <span class="comment"># 判断接触点是否分离</span></span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">        bias = bias_factor * <span class="built_in">max</span>((depth - max_depth), <span class="number">0</span>)</span><br><span class="line">        lambda_p = get_effective_mass(body_a, ra, body_b, rb, n) * bias</span><br><span class="line"></span><br><span class="line">        correction = lambda_p * n</span><br><span class="line"></span><br><span class="line">        body_a.position = body_a.position - body_a.inv_mass * correction</span><br><span class="line"></span><br><span class="line">        body_b.position = body_b.position + body_b.inv_mass * correction</span><br></pre></td></tr></table></figure>
<blockquote>
<p>位置约束的求解也是一个迭代过程。发生在速度约束的迭代完成后。</p>
</blockquote>
<h2 id="四、总结"><a href="#四、总结" class="headerlink" title="四、总结"></a>四、总结</h2><p>这一篇文章内容较多，简单介绍了一下刚体力学的知识，接着主要是碰撞约束的求解方法。在一些应详细解释的地方因能力不足，未能详述，实在抱歉。但还是希望这篇文章能对自己和他人有所帮助吧。</p>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>数学</tag>
        <tag>物理引擎</tag>
      </tags>
  </entry>
  <entry>
    <title>2D物理引擎基础之碰撞检测</title>
    <url>/posts/f58966b1/</url>
    <content><![CDATA[<h2 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h2><p>本篇是“2D物理引擎基础”的第二篇文章，将主要讲解碰撞检测的基本原理和算法。</p>
<p>碰撞检测是物理引擎十分重要的组成部分。碰撞检测及后续的碰撞约束反映了物质的不可入性，是物理模拟真实性的基础。另外碰撞检测也能有效用于游戏逻辑的实现，如触发陷阱、探测障碍等等。</p>
<h2 id="二、碰撞检测的基本概念"><a href="#二、碰撞检测的基本概念" class="headerlink" title="二、碰撞检测的基本概念"></a>二、碰撞检测的基本概念</h2><p>碰撞检测的目标就是判断两个几何体是否存在重合部分，如果存在重合部分，则得到接触点、碰撞法线和穿透深度。</p>
<p>接触点（Contact Point）指的是两个几何体相接触的位置。当然对于碰撞检测而言，接触的部分并非点而是区域，但是我们可以通过算法从中近似地取出接触点，一般位于其中一个几何体的顶点或边上。</p>
<p>碰撞法线指示了一个物体与另一个物体发生碰撞后，后者为了分离而应该采取的运动方向。这一法线大多是几何体中某一条边的法线</p>
<p>穿透深度是沿碰撞法线方向最终分离所需的距离，这一数值常用来修正碰撞后两几何体的位置，避免两几何体在视觉上发生重叠。</p>
<h2 id="三、分离轴定理（SAT，Separating-Axis-Theorem）"><a href="#三、分离轴定理（SAT，Separating-Axis-Theorem）" class="headerlink" title="三、分离轴定理（SAT，Separating Axis Theorem）"></a>三、分离轴定理（SAT，Separating Axis Theorem）</h2><p>分离轴定理是如下内容：若两个凸物体没有重合，则总会存在一条直线，能将两个物体分离。这样的直线称为分离轴。对于高维物体来说这同样适用，只不过分离轴将变为分离超平面。</p>
<p>利用分离轴定理可以实现凸几何体的碰撞检测。对于多边形，算法是这样的：</p>
<ol>
<li>对两个多边形的每一条边，做垂直于该边的直线</li>
<li>对两个多边形的每一个顶点，分别做到步骤1中所得直线的投影</li>
<li>如果存在一条直线，两个多边形对这条直线的投影并不重合，则两个多边形不重合</li>
<li>如果不存在步骤3中的直线，则两个多边形重合。</li>
</ol>
<p>完全按照算法思路得到代码如下<br><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">sat</span>(<span class="params">body_a, body_b</span>):</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">not</span> find_separate_axis(body_a, body_a, body_b) <span class="keyword">and</span> <span class="keyword">not</span> find_separate_axis(body_b, body_a, body_b)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">find_separate_axis</span>(<span class="params">lines_body, body_a, body_b</span>):</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(lines_body) - <span class="number">1</span>):</span><br><span class="line">        p1 = lines_body[i]</span><br><span class="line">        p2 = lines_body[i] + get_normal(lines_body[i+<span class="number">1</span>] - lines_body[i])</span><br><span class="line"></span><br><span class="line">        a_min, a_max = body_cast(p1, p2, body_a)</span><br><span class="line"></span><br><span class="line">        b_min, b_max = body_cast(p1, p2, body_b)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> p1[<span class="number">0</span>] != p2[<span class="number">0</span>]:</span><br><span class="line">            max_min = a_min <span class="keyword">if</span> a_min[<span class="number">0</span>] &gt; b_min[<span class="number">0</span>] <span class="keyword">else</span> b_min</span><br><span class="line">            min_max = a_max <span class="keyword">if</span> a_max[<span class="number">0</span>] &lt; b_max[<span class="number">0</span>] <span class="keyword">else</span> b_max</span><br><span class="line">            <span class="keyword">if</span> max_min[<span class="number">0</span>] &lt; min_max[<span class="number">0</span>]:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            max_min = a_min <span class="keyword">if</span> a_min[<span class="number">1</span>] &gt; b_min[<span class="number">1</span>] <span class="keyword">else</span> b_min</span><br><span class="line">            min_max = a_max <span class="keyword">if</span> a_max[<span class="number">1</span>] &lt; b_max[<span class="number">1</span>] <span class="keyword">else</span> b_max</span><br><span class="line">            <span class="keyword">if</span> max_min[<span class="number">1</span>] &lt; min_max[<span class="number">1</span>]:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">body_cast</span>(<span class="params">a, b, body</span>):</span><br><span class="line">    body_min = body_max = point_cast(a, b, body[<span class="number">0</span>])</span><br><span class="line">    <span class="keyword">for</span> p <span class="keyword">in</span> body:</span><br><span class="line">        p_cast = point_cast(a, b, p)</span><br><span class="line">        <span class="keyword">if</span> p_cast[<span class="number">0</span>] &lt; body_min[<span class="number">0</span>] <span class="keyword">or</span> (p_cast[<span class="number">0</span>] == body_min[<span class="number">0</span>] <span class="keyword">and</span> p_cast[<span class="number">1</span>] &lt; body_min[<span class="number">1</span>]):</span><br><span class="line">            body_min = p_cast</span><br><span class="line">        <span class="keyword">if</span> p_cast[<span class="number">0</span>] &gt; body_max[<span class="number">0</span>] <span class="keyword">or</span> (p_cast[<span class="number">0</span>] == body_max[<span class="number">0</span>] <span class="keyword">and</span> p_cast[<span class="number">1</span>] &gt; body_max[<span class="number">1</span>]):</span><br><span class="line">            body_max = p_cast</span><br><span class="line">    <span class="keyword">return</span> body_min, body_max</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">point_cast</span>(<span class="params">a, b, p</span>):</span><br><span class="line">    u = p - a</span><br><span class="line">    v = b - a</span><br><span class="line">    p_cast = a + v * (np.dot(v, u) / np.dot(v, v))</span><br><span class="line">    <span class="keyword">return</span> p_cast</span><br></pre></td></tr></table></figure></p>
<p>我们还需要得到接触点、碰撞法线和穿透深度。这需要对原算法进行微小的改造。</p>
<h2 id="四、分离轴定理的优化"><a href="#四、分离轴定理的优化" class="headerlink" title="四、分离轴定理的优化"></a>四、分离轴定理的优化</h2><p>如果有重合部分，我们需要做的是记录所有投影的重合部分的长度，取重合长度最短的，这个长度即穿透深度；所投影到的直线的方向即为法线的正/反方向；而接触点就是重合部分其中一个端点所对应的顶点（另一个端点所对应的一定是一条边）。</p>
<p>另外我们也需要对算法进行优化，因为上面的代码将大部分步骤用于判断是否重合。实际上，引出直线的边已经是到直线的一个投影了；另外我们也不需要得到实际的投影位置，而只需要得到在这条直线方向上每个多边形的最远点即可。</p>
<p>首先，我们要引入求点到平面距离的方法，设平面上一点为 $s$，平面法向量 $n$，要求距离的点为 $t$ 。那么有</p>
<script type="math/tex; mode=display">
    d = t \cdot n - s \cdot n</script><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">get_point_to_line_distance</span>(<span class="params">pos, normal, point</span>):</span><br><span class="line">    d = np.dot(pos, normal)</span><br><span class="line">    <span class="keyword">return</span> np.dot(point, normal) - d</span><br></pre></td></tr></table></figure>
<p>这也是 box2d 中用到的方法。求得距离的同时还可以判断点在直线的方向。我们用这求点到直线的距离的同时，还可以判断点在多边形的位置。</p>
<p>接着，我们依旧要对每一条边求直线方向，但这次我们取法线的反方向为正方向，求另一个多边形上各点到这条边的距离。并取距离最大的顶点和对应的边。如果对某一条边，如果距离最大的顶点依旧小于零，则说明在这个方向上存在一条分离轴。</p>
<p>如果距离都大于等于零，那么找到这些顶点中距离最小的，这个顶点就是接触点、这个顶点对应的距离就是穿透距离、这个顶点所对应的边的法线就是碰撞法线。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">sat2</span>(<span class="params">body_a, body_b</span>):</span><br><span class="line">    e1, s1, d1 = get_separate_axis(body_a, body_b)</span><br><span class="line">    e2, s2, d2 = get_separate_axis(body_b, body_a)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> d1 &lt; <span class="number">0</span> <span class="keyword">or</span> d2 &lt; <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> d1 &lt; d2:</span><br><span class="line">        <span class="keyword">return</span> body_b[s1], get_normal(body_a[e1+<span class="number">1</span>] - body_a[e1]), d1</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> body_a[s2], -get_normal(body_b[e2+<span class="number">1</span>] - body_b[e2]), d2</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_separate_axis</span>(<span class="params">body_a, body_b</span>):</span><br><span class="line">    best_dist = np.Infinity</span><br><span class="line">    best_edge_idx = -<span class="number">1</span></span><br><span class="line">    best_support_point_idx = -<span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(body_a.shape[<span class="number">0</span>] - <span class="number">1</span>):</span><br><span class="line">        n = get_normal(body_a[i + <span class="number">1</span>] - body_a[i])</span><br><span class="line"></span><br><span class="line">        support_idx, dist = get_support_point_idx(body_a[i], -n, body_b)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> dist &lt; best_dist:</span><br><span class="line">            best_dist = dist</span><br><span class="line">            best_edge_idx = i</span><br><span class="line">            best_support_point_idx = support_idx</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> best_edge_idx, best_support_point_idx, best_dist</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_support_point_idx</span>(<span class="params">pos, normal, body</span>):</span><br><span class="line">    best_dist = -np.Infinity</span><br><span class="line">    support_point_idx = -<span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(body.shape[<span class="number">0</span>]-<span class="number">1</span>):</span><br><span class="line">        dist = get_point_to_line_distance(pos, normal, body[i])</span><br><span class="line">        <span class="keyword">if</span> dist &gt; best_dist:</span><br><span class="line">            best_dist = dist</span><br><span class="line">            support_point_idx = i</span><br><span class="line">    <span class="keyword">return</span> support_point_idx, best_dist</span><br></pre></td></tr></table></figure>
<h2 id="五、最近内部顶点法"><a href="#五、最近内部顶点法" class="headerlink" title="五、最近内部顶点法"></a>五、最近内部顶点法</h2><p>在现实当中，很多时候一个物体并非只有一个点与其他物体接触，而是一个平面都与其他物体接触。我们也可以认为这等同于有两个接触点（可以证明最多只有两个接触点）。因此我们还需要在原碰撞检测算法上进一步做改进。我们使用的方法可以是最近内部顶点法（这并非一个正式的名字）。</p>
<p>算法是在进行完分离轴定理，获得了第一个接触点等信息后进行的。具体步骤如下：</p>
<ol>
<li>在第一个接触点所在的多边形顶点中找出在碰撞法线方向上，距离对应边第二大的顶点（第一大的已为第一个接触点）</li>
<li>判断该顶点是否在另一个多边形内部，如果是，则这个顶点也是一个碰撞点，算法结束</li>
<li>否则，取碰撞法线对应边上两点，判断其是否在另一个多边形内部，如果在则加入接触点</li>
</ol>
<p>关键的问题是如何判断点在多边形内部。我们假定多边形均为凸多边形，这样问题就有一个 $O(n)$ 的解法，不会对碰撞检测主体 $O(n^2)$ 的时间复杂度产生较大影响。具体来说，我们需要用到叉积的性质。</p>
<p>算法如下：我们遍历每一条边，设边为 $(e<em>i, e</em>{i+1})$，要判断的点为 $p$ 那么取边起点到终点的向量 $e_{i+1} - e_i$ 和起点到要判断的点的向量 $p - e_i$，将前者叉乘后者。如果点在多边形内，则所有叉积的结果符号应相同；反之若点不在多边形内，则叉积的结果符号应有不同。特别的，当多边形由逆时针的顶点序列所表示，所有的叉积结果大于等于零时点在多边形内。</p>
<p>我们可以简单地编程实现：</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">check_point_on_convex_polygon</span>(<span class="params">point, poly_points</span>):</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(poly_points.shape[<span class="number">0</span>] - <span class="number">1</span>):</span><br><span class="line">        right = poly_points[i + <span class="number">1</span>] - poly_points[i]</span><br><span class="line">        left = point - poly_points[i]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> np.cross(right, left) &lt; <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure>
<p>这样我们就能继续实现“最近内部顶点法”了。具体代码如下：</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">sat3</span>(<span class="params">body_a, body_b</span>):</span><br><span class="line">    e1, s1, d1 = get_separate_axis(body_a, body_b)</span><br><span class="line">    e2, s2, d2 = get_separate_axis(body_b, body_a)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> d1 &lt; <span class="number">0</span> <span class="keyword">or</span> d2 &lt; <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> d1 &lt; d2:</span><br><span class="line">        edge_body = body_a</span><br><span class="line">        s_point_body = body_b</span><br><span class="line">        e, s, d = e1, s1, d1</span><br><span class="line">        <span class="built_in">dir</span> = <span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        edge_body = body_b</span><br><span class="line">        s_point_body = body_a</span><br><span class="line">        e, s, d = e2, s2, d2</span><br><span class="line">        <span class="built_in">dir</span> = -<span class="number">1</span></span><br><span class="line"></span><br><span class="line">    contact_points = [(s_point_body[s], d)]</span><br><span class="line"></span><br><span class="line">    second_point = closest_internal_vertices_method(edge_body, s_point_body, e, s)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> second_point <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">        contact_points.append(second_point)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">dir</span> * get_normal(edge_body[e + <span class="number">1</span>] - edge_body[e]), contact_points</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">closest_internal_vertices_method</span>(<span class="params">edge_body, s_point_body, e_idx, s_idx</span>):</span><br><span class="line">    n = get_normal(edge_body[e_idx + <span class="number">1</span>] - edge_body[e_idx])</span><br><span class="line">    s_point_num = s_point_body.shape[<span class="number">0</span>] - <span class="number">1</span></span><br><span class="line">    dist1 = get_point_to_line_distance(edge_body[e_idx], -n, s_point_body[(s_idx - <span class="number">1</span>) % s_point_num])</span><br><span class="line">    dist2 = get_point_to_line_distance(edge_body[e_idx], -n, s_point_body[s_idx + <span class="number">1</span>])</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> dist1 &gt; dist2 <span class="keyword">and</span> check_point_on_convex_polygon(s_point_body[(s_idx - <span class="number">1</span>) % s_point_num], edge_body):</span><br><span class="line">        <span class="keyword">return</span> s_point_body[(s_idx - <span class="number">1</span>) % s_point_num], dist1</span><br><span class="line">    <span class="keyword">elif</span> dist2 &gt; dist1 <span class="keyword">and</span> check_point_on_convex_polygon(s_point_body[s_idx + <span class="number">1</span>], edge_body):</span><br><span class="line">        <span class="keyword">return</span> s_point_body[s_idx + <span class="number">1</span>], dist2</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> check_point_on_convex_polygon(edge_body[e_idx], s_point_body):</span><br><span class="line">        <span class="keyword">return</span> edge_body[e_idx], <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> check_point_on_convex_polygon(edge_body[e_idx + <span class="number">1</span>], s_point_body):</span><br><span class="line">        <span class="keyword">return</span> edge_body[e_idx + <span class="number">1</span>], <span class="number">0</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>需要注意的是这一方法无法求得每一个接触点的穿透深度。</p>
</blockquote>
<h2 id="六、总结"><a href="#六、总结" class="headerlink" title="六、总结"></a>六、总结</h2><p>本篇文章介绍了一个碰撞检测所用的算法，但是这只是物理引擎使用的碰撞检测算法中很小的一部分，因本人的精力、能力以及篇幅所限，还有许多更加精妙有效的算法并未涉及。就实现一个简单的2d物理引擎来说，本文所讲的算法已经足够了。</p>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>数学</tag>
        <tag>物理引擎</tag>
      </tags>
  </entry>
  <entry>
    <title>2D物理引擎基础之物理属性</title>
    <url>/posts/367b3d22/</url>
    <content><![CDATA[<h2 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h2><p>本系列是我学习物理引擎相关知识的总结。虽说最初的目标是自己实现一个完整的物理引擎，但是随着学习的深入我认识到，为了让引擎更好地模拟实际，所需要的各种数学原理和处理技巧远远超出了“涉猎”的程度。因此我决定就此止步，但是还是留下了自己的实践成果和经验总结，就在这系列文章中。</p>
<p>本文是“2D物理引擎基础”的第一篇，将介绍物理引擎中物体所需的物理属性</p>
<h2 id="二、物理引擎中的物体"><a href="#二、物理引擎中的物体" class="headerlink" title="二、物理引擎中的物体"></a>二、物理引擎中的物体</h2><p>在物理引擎中，模拟的物体对象被假定为刚体。刚体是如此致密坚硬的一种物体，以至于任何碰撞都无法改变其形状。同时物理引擎还常常假定对象的密度均匀，这样对象的质心将只由其几何形状决定。通过这样的假设，物理引擎将能够通过算法优化高效地进行计算模拟：</p>
<ul>
<li>刚体说明物体不会改变形状，这样当物体受到力的作用时，力的作用效果就不会造成改变物体运动之外的其他影响，如质心改变。</li>
<li>密度均匀使得质心的求解更为方便，将质心位置和偏转角度作为物体属性，就可以完全表示物体上各点的位置信息</li>
</ul>
<p>接下来所说的物理属性也是在如上约定的基础上的。</p>
<h2 id="三、运动学属性"><a href="#三、运动学属性" class="headerlink" title="三、运动学属性"></a>三、运动学属性</h2><h3 id="形状的表示"><a href="#形状的表示" class="headerlink" title="形状的表示"></a>形状的表示</h3><p>物理引擎中的形状用描述物体边界的属性表示。不同形状的物体通过不同的几何参数进行表示，如矩形可用长宽表示，圆可用半径长度表示，这些较为简单。更一般地我们考虑多边形，多边形可用顶点坐标表示，但是我们希望形状是位置无关的，那么多边形的顶点坐标也不能在坐标轴上随意选取。虽然 $(0, 0), (1, 0), (1, 1), (0, 1)$ 和 $(1, 1), (2, 1), (2, 2), (1, 2)$ 表示相同形状的多边形，但我们需要选择与位置无关的那一个。我们可以选择使多边形的质心在坐标原点的顶点集合，因为我们后续需要通过质心确定运动学属性。对于均质物体来说，这也就是多边形的几何中心在原点。</p>
<p>我们不能人为地在设置形状时就限制顶点围成的形状中心必须在原点，这对于复杂的形状来说十分困难。我们可以根据顶点集合先确定几何中心位置，再对每一顶点减去中心坐标以将物体平移到集合中心为原点的位置。</p>
<p>对于多边形，计算几何中心的公式为</p>
<script type="math/tex; mode=display">
    A = \frac{1}{2} \sum_{i=0}^{N-1}(x_iy_{i+1} - x_{i+1}y_i)</script><script type="math/tex; mode=display">
    c_x = \frac{1}{6A} \sum_{i=0}^{N-1}(x_i + x_{i+1})(x_iy_{i+1} - x_{i+1}y_i)</script><script type="math/tex; mode=display">
    c_y = \frac{1}{6A} \sum_{i=0}^{N-1}(y_i + y_{i+1})(x_iy_{i+1} - x_{i+1}y_i)</script><p>其中 $A$ 为多边形面积， $(c_x, c_y)$ 即几何中心位置。需要注意的是，在这个公式中，顶点序列为逆时针，且第一个和最后一个应是同一个坐标，以暗示这是一个闭合图形并且方便公式表示。$N$ 是不重合的顶点个数/边数。</p>
<p>如下是求集合中心的 python 代码</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">get_geometric_center</span>(<span class="params">points</span>):</span><br><span class="line">    area = <span class="number">0</span></span><br><span class="line">    c_x = c_y = <span class="number">0</span></span><br><span class="line">    n = points.shape[<span class="number">0</span>] - <span class="number">1</span>  <span class="comment"># edge num</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">        cross = np.cross(points[i], points[i+<span class="number">1</span>])</span><br><span class="line">        area += cross</span><br><span class="line">        c_x += (points[i][<span class="number">0</span>] + points[i + <span class="number">1</span>][<span class="number">0</span>]) * cross</span><br><span class="line">        c_y += (points[i][<span class="number">1</span>] + points[i + <span class="number">1</span>][<span class="number">1</span>]) * cross</span><br><span class="line">    area = area / <span class="number">2</span></span><br><span class="line">    c_x = c_x / (<span class="number">6</span> * area)</span><br><span class="line">    c_y = c_y / (<span class="number">6</span> * area)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> np.array([c_x, c_y])</span><br></pre></td></tr></table></figure>
<p>这样得到无视位置的多边形顶点集合<br><figure class="highlight py"><table><tr><td class="code"><pre><span class="line">mass_point = get_geometric_center(points)</span><br><span class="line">points = points - mass_point</span><br></pre></td></tr></table></figure></p>
<h3 id="位置和运动"><a href="#位置和运动" class="headerlink" title="位置和运动"></a>位置和运动</h3><p>我们需要属性来表示物体的位置，对于二维空间而言，就需要二维的坐标表示位置；另外，我们还需要表示物体旋转的角度，在二维空间只需要一个标量即可。</p>
<p>对于物体的运动状态，包括速度、加速度、角速度和角加速度。前两者为二维向量，后两者为标量（虽说本质上它们是垂直于二维平面的第三维度方向的向量）。</p>
<p>加速度和角加速度是速度的改变方式，也就是力/力矩的作用的表现。它们随力/力矩的产生而产生，随力/力矩的消失而消失，因此并不是物体的本质属性。对物理引擎而言，我们可以在一帧里添加一定的力，由这力产生加速度与角加速度。</p>
<p>速度和角速度是对物体位置状态改变的度量。在物理引擎的刚体模拟中，我们特指速度为质心的速度，角速度为围绕质心旋转的角速度。</p>
<p>物理引擎以离散的时间间隔更新物体的位置和运动，如下所示</p>
<script type="math/tex; mode=display">
    \vec{v} = \vec{v}_0 + \vec{a}\Delta t</script><script type="math/tex; mode=display">
    \vec{p} = \vec{p}_0 +\vec{v} \Delta t</script><script type="math/tex; mode=display">
    w = w_0 + \beta \Delta t</script><script type="math/tex; mode=display">
    \theta = \theta_0 + w \Delta t</script><p>当然，这种更新是存在误差的，我们以加速度-速度-位置为例，根据</p>
<script type="math/tex; mode=display">
    v = v_0 + \int_0^{\Delta t} a \mathrm{d} t</script><script type="math/tex; mode=display">
    p = p_0 + \int_0^{\Delta t} v(t) \mathrm{d} t</script><p>可得</p>
<script type="math/tex; mode=display">
    p = p_0 + v_0\Delta{t} + \frac{1}{2} a \Delta{t}^2</script><p>可是将物理引擎的更新方式中的前两个式子可得</p>
<script type="math/tex; mode=display">
    p = p_0 + v_0\Delta{t} + a \Delta{t}^2</script><p>两者之间存在着误差，这是由物理引擎的离散性决定的，看似也可以直接用带有二分之一的式子来更新位置，但是这也是在假定在这段时间内加速度不变的情况下得到的，在由万有引力作用的情境下，这样的结果同样不够精确。</p>
<p>但是物理引擎的目的本就不是十分精确的模拟，因此这样的误差可以接受。</p>
<h2 id="四、动力学属性"><a href="#四、动力学属性" class="headerlink" title="四、动力学属性"></a>四、动力学属性</h2><h3 id="密度、质量和转动惯量"><a href="#密度、质量和转动惯量" class="headerlink" title="密度、质量和转动惯量"></a>密度、质量和转动惯量</h3><p>物体的质量由物体的形状和各点的密度决定，而物体围绕质心的转动惯量又由物体的形状和质量决定。又因为物理引擎中假设物体为刚体，物体形状确定不变，因此我们只需要确定密度就可以计算出质量和转动惯量了。</p>
<p>当然，对于二维，我们这里说的密度是面密度（$\sigma$）。有公式</p>
<script type="math/tex; mode=display">
    M = \int_S \sigma \mathrm{d} s</script><p>对于物理引擎假设的均质物体</p>
<script type="math/tex; mode=display">
    M = \sigma S</script><p>特别的，对于多边形我们有面积公式，在求几何中心时也有提及。</p>
<script type="math/tex; mode=display">
    A = \frac{1}{2} \sum_{i=0}^{N-1}(x_iy_{i+1} - x_{i+1}y_i)</script><p>对于转动惯量，情况就有些复杂了，不同的形状有不同的计算公式。一般的形状如圆形的公式较为简单，但对于形状不定的多边形而言就比较难以确定了。但是依旧有公式，这一点似乎网上很少有文章提及</p>
<script type="math/tex; mode=display">
    I = M \frac{\sum_{n=0}^{N-1} (P_{n+1} \times P_n) ((P_n · P_n) + (P_n ·P_{n+1}) + (P_{n+1} · P_{n+1}))}{6 \sum_{n=1}^N (P_{n+1} \times P_n)}</script><p>其中 $P_i$ 为各顶点， $\times$ 为向量叉积，$\cdot$ 为向量点积，$M$ 为质量，$N$ 依旧为不相同的顶点数/边数。</p>
<p>如下有代码<br><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">get_moments_of_inertia</span>(<span class="params">points, mass</span>):</span><br><span class="line">    p = points</span><br><span class="line">    n = points.shape[<span class="number">0</span>] - <span class="number">1</span></span><br><span class="line">    sum1 = <span class="number">0</span></span><br><span class="line">    sum2 = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">        cross = np.cross(p[i + <span class="number">1</span>], p[i])</span><br><span class="line">        sum1 += cross * (np.dot(p[i], p[i]) + np.dot(p[i], p[i + <span class="number">1</span>]) + np.dot(p[i + <span class="number">1</span>], p[i + <span class="number">1</span>]))</span><br><span class="line">        sum2 += cross</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> mass * (sum1 / (<span class="number">6</span> * sum2))</span><br></pre></td></tr></table></figure></p>
<p>这样，密度、质量和转动惯量实际只需要一个量来表示。</p>
<h3 id="恢复系数与摩擦系数"><a href="#恢复系数与摩擦系数" class="headerlink" title="恢复系数与摩擦系数"></a>恢复系数与摩擦系数</h3><p>我们考虑一个简单的问题，两个球体质量分别为 $m_1, m_2$，碰撞前速度为 $v_1, v_2$，碰撞后速度为 $u_1, U_2$。那么我们由动量守恒和能量守恒得</p>
<script type="math/tex; mode=display">
    m_1u_1 + m_2u_2 = m_1v_1 + m_2v_2</script><script type="math/tex; mode=display">
    \frac{1}{2}m_1v_1^2 + \frac{1}{2}m_2v_2^2 =  (\frac{1}{2}m_1v_1^2 + \frac{1}{2}m_2v_2^2)</script><p>联立可得</p>
<script type="math/tex; mode=display">
    u_1 = \frac{(m_1 - m_2)v_1 + 2m_2v_2}{m_1 + m_2}</script><script type="math/tex; mode=display">
    u_2 = \frac{(m_2 - m_1)v_2 + 2m_1v_1}{m_1 + m_2}</script><p>这是完全弹性碰撞的情况，我们还需要考虑存在能量损失的情况。我们引入恢复系数（coefficient of restitution） $C_r = \frac{u_1 - u_2}{v_1 - v_2}$。这代表了相对速度在碰撞后的损失率。此时有</p>
<script type="math/tex; mode=display">
    u_1 = \frac{m_1v_1 + m_2v_2 + C_r m_2 (v_2 - v_1)}{m_1 + m_2}</script><script type="math/tex; mode=display">
    u_2 = \frac{m_1v_1 + m_2v_2 + C_r m_1 (v_1 - v_2)}{m_1 + m_2}</script><p>当 $C_r = 1$ 时，退化为完全弹性碰撞时的式子，当 $C_r = 0$ 时，碰撞后速度相同，为完全非弹性碰撞的情况。$0 &lt; C_r &lt; 1$ 时则为非完全弹性碰撞。</p>
<p>恢复系数反映了碰撞时物体弹力所产生的物体运动状态改变的效果，它与物体材质有关。当两不同材质物体发生碰撞时，我们取其恢复系数为两者中的较小值</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">cr = <span class="built_in">min</span>(body_a.restitution, body_b.restitution)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>在 box2d 引擎中还设置了 <code>restitutionThreshold</code>，只有在该值速度之上才会应用恢复系数进行反弹，当然这应该只是为了保持物体状态稳定所做的限制，并不具有实际物理意义</p>
</blockquote>
<p>当两个物体接触时，在切向上会有摩擦力的作用。在物理引擎中，可以忽略动摩擦系数和静摩擦系数间的微小差别，用单一的摩擦系数表示。</p>
<p>摩擦系数与接触面的属性有关，因此两个不同材质的接触面可能会有所不同。为了简化程序，物理引擎可能会为每个物体设置单独的摩擦系数，并通过计算得出接触面的实际摩擦系数。如在 box2d 引擎中，就使用了将两个摩擦力相乘再开方的方式得到摩擦系数。</p>
<script type="math/tex; mode=display">
    friction = \sqrt{friction1 * friction2}</script><h2 id="五、总结"><a href="#五、总结" class="headerlink" title="五、总结"></a>五、总结</h2><p>本文章介绍了 2d 物理引擎中的对象应该具有的基本属性，最后总结一下这些属性。</p>
<ul>
<li>形状：物体的几何形状，不同形状表示方式不同，其中多边形用顶点序列表示</li>
<li>位置：（质点的）空间位置和（相对质点的）旋转角度</li>
<li>速度：（质点的）线速度和（相对质点的）角速度</li>
<li>加速度：线加速度和角加速度，由力所产生</li>
<li>密度：物体的面密度</li>
<li>质量：质量由密度和形状求出</li>
<li>转动惯量：转动惯量由质量和形状求出</li>
<li>恢复系数：表示物体的弹性程度</li>
<li>摩擦系数：表示物体的粗糙程度</li>
</ul>
<p>由此我们可以定义物理引擎的主体类 Body。为了方便，这里只使用多边形作为形状。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Body</span>:</span><br><span class="line">    force = np.zeros(<span class="number">2</span>)</span><br><span class="line">    torque = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, points, position, density,</span></span><br><span class="line"><span class="params">                 rotate=<span class="number">0</span>, v=<span class="number">0</span>, w=<span class="number">0</span>, restitution=<span class="number">0</span>, friction=<span class="number">0.66</span></span>):</span><br><span class="line">        mass_point = get_geometric_center(points)</span><br><span class="line">        points = points - mass_point</span><br><span class="line"></span><br><span class="line">        self.points = points</span><br><span class="line">        self.position = position</span><br><span class="line">        self.density = density</span><br><span class="line">        self.mass = density * get_area(self.points)</span><br><span class="line">        self.inv_mass = <span class="number">1</span> / self.mass</span><br><span class="line">        self.inertia = get_moments_of_inertia(self.points, self.mass)</span><br><span class="line">        self.inv_inertia = <span class="number">1</span> / self.inertia</span><br><span class="line">        self.rotate = rotate</span><br><span class="line">        self.v = v</span><br><span class="line">        self.w = w</span><br><span class="line">        self.restitution = restitution</span><br><span class="line">        self.friction = friction</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">apply_force</span>(<span class="params">self, force, pos</span>):</span><br><span class="line">        self.force += force</span><br><span class="line">        self.torque += np.cross(pos - self.position, force)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">step</span>(<span class="params">self, dt</span>):</span><br><span class="line">        self.v = self.v + self.force / self.mass * dt</span><br><span class="line">        self.position = self.position + self.v * dt</span><br><span class="line"></span><br><span class="line">        self.w = self.w + self.torque / self.inertia * dt</span><br><span class="line">        self.rotate = self.rotate + self.w * dt</span><br><span class="line"></span><br><span class="line">        self.force = np.zeros(<span class="number">2</span>)</span><br><span class="line">        self.torque = <span class="number">0</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意这里并未存储线加速度和角加速度，而是存储了力和力矩。</p>
</blockquote>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>数学</tag>
        <tag>物理引擎</tag>
      </tags>
  </entry>
  <entry>
    <title>BUAA OS实验笔记之Lab1</title>
    <url>/posts/a08f03c8/</url>
    <content><![CDATA[<h2 id="一、总前言"><a href="#一、总前言" class="headerlink" title="一、总前言"></a>一、总前言</h2><p>操作系统是一门重课，我并不知晓自己是否做好了准备。“在这样的情况下就开始写文章，是否太着急了？” 我这样想，不知道对这门课自己是否有写文章的水平，也不知道自己是否会半途而废。</p>
<p>但我还是决定开始，并不是因为有什么十足的信心，而是希望这一系列文章能帮助自己更深入的理解操作系统的知识，在讲解的过程中发现自己的不足。我希望这系列能持续下去，希望未来的自己看到结果时能够满意；希望他人也能从中得到收获。<br><span id="more"></span></p>
<h2 id="二、进入操作系统"><a href="#二、进入操作系统" class="headerlink" title="二、进入操作系统"></a>二、进入操作系统</h2><h3 id="（1）操作系统的启动"><a href="#（1）操作系统的启动" class="headerlink" title="（1）操作系统的启动"></a>（1）操作系统的启动</h3><p>操作系统的 boot 过程是一个复杂繁琐的过程，从 bios 从上电后的启动地址开始执行，初始化硬件，读取磁盘的主引导记录，跳转到 bootloader；到加载内核程序，跳转到操作系统入口。这一整个过程难以详述……</p>
<p>不过幸好在本实验中，这些都不是问题，因为我们所使用的 GXemul 模拟器不会去执行上述环节，它可以直接加载 ELF 格式内核。也就是说，我们的操作系统实验是从跳转到操作系统入口开始的。</p>
<h3 id="（2）内核的入口和内存布局"><a href="#（2）内核的入口和内存布局" class="headerlink" title="（2）内核的入口和内存布局"></a>（2）内核的入口和内存布局</h3><p>所以，哪里是操作系统入口？内核入口的设置在 kernel.lds 中，这是一个链接器脚本，用于帮助链接器确定最终生成的文件的组织形式。</p>
<p>我们看一下该文件的开头。<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Set the architecture to mips.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">OUTPUT_ARCH(mips)</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Set the ENTRY point of the program to _start.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">ENTRY(_start)</span><br></pre></td></tr></table></figure><br>其中 <code>OUTPUT_ARCH(mips)</code> 设置了最终生成的文件采用的架构，对于 MOS 来说就是 mips。而 <code>ENTRY(_start)</code> 便设置了程序的入口函数。因此 MOS 内核的入口即 <code>_start</code>。这是一个符号，对应的是 init/start.S 中的<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">.text</span><br><span class="line"><span class="title function_">EXPORT</span><span class="params">(_start)</span></span><br><span class="line">.<span class="built_in">set</span> at</span><br><span class="line">.<span class="built_in">set</span> reorder</span><br><span class="line">	<span class="comment">/* disable interrupts */</span></span><br><span class="line">	mtc0    zero, CP0_STATUS</span><br><span class="line">	<span class="comment">/* omit... */</span></span><br></pre></td></tr></table></figure></p>
<p><code>EXPORT</code> 是一个宏，该宏将符号设置为全局符号，这样才对链接器可见。<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> EXPORT(symbol) \</span></span><br><span class="line"><span class="meta">	.globl symbol; \</span></span><br><span class="line"><span class="meta">	symbol:</span></span><br></pre></td></tr></table></figure></p>
<p>现在让我们回到 kernel.lds，原来其中还定义了其他内容。<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">SECTIONS &#123;</span><br><span class="line">	<span class="comment">/* Exercise 3.10: Your code here. */</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* fill in the correct address of the key sections: text, data, bss. */</span></span><br><span class="line">	<span class="comment">/* Exercise 1.2: Your code here. */</span></span><br><span class="line">	. = <span class="number">0x80010000</span>;</span><br><span class="line">	.text : &#123; *(.text) &#125;</span><br><span class="line">	.data : &#123; *(.data) &#125;</span><br><span class="line">	.bss : &#123; *(.bss) &#125;</span><br><span class="line"></span><br><span class="line">	bss_end = .;</span><br><span class="line">	. = <span class="number">0x80400000</span>;</span><br><span class="line">	end = . ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这一部分是用来设置程序中的段位置的，它将<code>.text</code> <code>.data</code> <code>.bss</code> 段设置在以 <code>0x8001 0000</code> 为开始的地址空间中。另外它还设置了 <code>bss_end</code> 和 <code>end</code> 符号的地址，这将在之后的实验中起作用。</p>
<p>这些设置的依据是什么呢？实际上只是人为的规定。在裸机上，我们事先规定好了不同区域的内存用于何种功能。内存布局图可在 include/mmu.h 中找到<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> o     4G -----------&gt;  +----------------------------+------------0x100000000</span></span><br><span class="line"><span class="comment"> o                      |       ...                  |  kseg2</span></span><br><span class="line"><span class="comment"> o      KSEG2    -----&gt; +----------------------------+------------0xc000 0000</span></span><br><span class="line"><span class="comment"> o                      |          Devices           |  kseg1</span></span><br><span class="line"><span class="comment"> o      KSEG1    -----&gt; +----------------------------+------------0xa000 0000</span></span><br><span class="line"><span class="comment"> o                      |      Invalid Memory        |   /|\</span></span><br><span class="line"><span class="comment"> o                      +----------------------------+----|-------Physical Memory Max</span></span><br><span class="line"><span class="comment"> o                      |       ...                  |  kseg0</span></span><br><span class="line"><span class="comment"> o      KSTACKTOP-----&gt; +----------------------------+----|-------0x8040 0000-------end</span></span><br><span class="line"><span class="comment"> o                      |       Kernel Stack         |    | KSTKSIZE            /|\</span></span><br><span class="line"><span class="comment"> o                      +----------------------------+----|------                |</span></span><br><span class="line"><span class="comment"> o                      |       Kernel Text          |    |                    PDMAP</span></span><br><span class="line"><span class="comment"> o      KERNBASE -----&gt; +----------------------------+----|-------0x8001 0000    |</span></span><br><span class="line"><span class="comment"> o                      |      Exception Entry       |   \|/                    \|/</span></span><br><span class="line"><span class="comment"> o      ULIM     -----&gt; +----------------------------+------------0x8000 0000-------</span></span><br><span class="line"><span class="comment"> o                      |         User VPT           |     PDMAP                /|\</span></span><br><span class="line"><span class="comment"> o      UVPT     -----&gt; +----------------------------+------------0x7fc0 0000    |</span></span><br><span class="line"><span class="comment"> o                      |           pages            |     PDMAP                 |</span></span><br><span class="line"><span class="comment"> o      UPAGES   -----&gt; +----------------------------+------------0x7f80 0000    |</span></span><br><span class="line"><span class="comment"> o                      |           envs             |     PDMAP                 |</span></span><br><span class="line"><span class="comment"> o  UTOP,UENVS   -----&gt; +----------------------------+------------0x7f40 0000    |</span></span><br><span class="line"><span class="comment"> o  UXSTACKTOP -/       |     user exception stack   |     BY2PG                 |</span></span><br><span class="line"><span class="comment"> o                      +----------------------------+------------0x7f3f f000    |</span></span><br><span class="line"><span class="comment"> o                      |                            |     BY2PG                 |</span></span><br><span class="line"><span class="comment"> o      USTACKTOP ----&gt; +----------------------------+------------0x7f3f e000    |</span></span><br><span class="line"><span class="comment"> o                      |     normal user stack      |     BY2PG                 |</span></span><br><span class="line"><span class="comment"> o                      +----------------------------+------------0x7f3f d000    |</span></span><br><span class="line"><span class="comment"> a                      |                            |                           |</span></span><br><span class="line"><span class="comment"> a                      ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~                           |</span></span><br><span class="line"><span class="comment"> a                      .                            .                           |</span></span><br><span class="line"><span class="comment"> a                      .                            .                         kuseg</span></span><br><span class="line"><span class="comment"> a                      .                            .                           |</span></span><br><span class="line"><span class="comment"> a                      |~~~~~~~~~~~~~~~~~~~~~~~~~~~~|                           |</span></span><br><span class="line"><span class="comment"> a                      |                            |                           |</span></span><br><span class="line"><span class="comment"> o       UTEXT   -----&gt; +----------------------------+------------0x0040 0000    |</span></span><br><span class="line"><span class="comment"> o                      |      reserved for COW      |     BY2PG                 |</span></span><br><span class="line"><span class="comment"> o       UCOW    -----&gt; +----------------------------+------------0x003f f000    |</span></span><br><span class="line"><span class="comment"> o                      |   reversed for temporary   |     BY2PG                 |</span></span><br><span class="line"><span class="comment"> o       UTEMP   -----&gt; +----------------------------+------------0x003f e000    |</span></span><br><span class="line"><span class="comment"> o                      |       invalid memory       |                          \|/</span></span><br><span class="line"><span class="comment"> a     0 ------------&gt;  +----------------------------+ ----------------------------</span></span><br><span class="line"><span class="comment"> o</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><br>同时在该头文件中，还定义了一些和内存相关的宏常量和宏函数。在本次实验中用到的有<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> KSTACKTOP (ULIM + PDMAP)</span></span><br></pre></td></tr></table></figure></p>
<h2 id="三、内核初始化"><a href="#三、内核初始化" class="headerlink" title="三、内核初始化"></a>三、内核初始化</h2><p>现在我们已经进入到 <code>_start</code> 函数中了。这一部分内容不多。在 init/start.S 中只有这些内容。<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">.text</span><br><span class="line"><span class="title function_">EXPORT</span><span class="params">(_start)</span></span><br><span class="line">.<span class="built_in">set</span> at</span><br><span class="line">.<span class="built_in">set</span> reorder</span><br><span class="line">	<span class="comment">/* disable interrupts */</span></span><br><span class="line">	mtc0    zero, CP0_STATUS</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* hint: you can reference the memory layout in include/mmu.h */</span></span><br><span class="line">	<span class="comment">/* set up the kernel stack */</span></span><br><span class="line">	<span class="comment">/* Exercise 1.3: Your code here. (1/2) */</span></span><br><span class="line">	la	sp, KSTACKTOP</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/* jump to mips_init */</span></span><br><span class="line">	<span class="comment">/* Exercise 1.3: Yoiur code here. (2/2) */</span></span><br><span class="line">	j	mips_init</span><br></pre></td></tr></table></figure></p>
<p><code>.text</code> 表示一下内容都是可执行的汇编指令。<code>.set at</code> 设置允许汇编器使用 <code>at</code> 寄存器。<code>.set reorder</code> 设置允许汇编器进行指令重排。<code>mtc0    zero, CP0_STATUS</code> 正如注释所言，停用了中断。这些并不重要。</p>
<p>更重要的是本实验中需要填写的部分。首先，我们需要初始化 <code>sp</code> 寄存器的地址。<code>sp</code> 用于实现栈帧，是完成函数调用的基础。通过查看内存布局图，我们可以得知内核的栈处在 <code>0x8040 0000</code> 以下的位置。</p>
<p>可是，我们不应该将 <code>sp</code> 初始化到栈底所在的位置吗？为什么加载地址所用的符号名称为 <code>KSTACKTOP</code>？这是因为 <code>sp</code> 是低地址增长的，所以其栈底地址就在“顶”了。</p>
<p>另外还需要注意一点，这里只能使用 <code>la</code> 指令设置地址。因为 <code>0x8040 0000</code> 数值超出了立即数所能表达的范围，不能使用 <code>lui</code>、<code>li</code> 等指令。</p>
<p>最后，<code>j    mips_init</code> 是一条跳转语句，跳转到的符号是一个 c 语言函数，定义在 init/init.c 中。记得第一次看到 c 语言和汇编相互调用的时候，感到十分惊奇。<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">mips_init</span><span class="params">()</span> &#123;</span><br><span class="line">	printk(<span class="string">&quot;init.c:\tmips_init() is called\n&quot;</span>);</span><br><span class="line">	<span class="comment">/* omit... */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>这个函数在本实验中几乎毫无内容，因此本实验中内核的程序便到此为止了。</p>
<p>最后还需要说明一点，跳转到 <code>mips_init</code> 使用的是 <code>j</code> 而非 <code>jal</code>。这是因为按照操作系统的设计，根本不存在 mips_init 函数返回的情况。</p>
<h2 id="四、printk-的实现"><a href="#四、printk-的实现" class="headerlink" title="四、printk 的实现"></a>四、printk 的实现</h2><p>GXemul 的调试只有汇编码，打桩调试又成了大多数时候的手段。为此实验贴心地让我们在最开始就实现一个类 <code>printf</code> 函数（这当然是假的，主要目的是提供一个输出评测的方式）。</p>
<p>在 kern/printk.c 中有 <code>printk</code> 的定义<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">printk</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *fmt, ...)</span> &#123;</span><br><span class="line">	va_list ap;</span><br><span class="line">	va_start(ap, fmt);</span><br><span class="line">	vprintfmt(outputk, <span class="literal">NULL</span>, fmt, ap);</span><br><span class="line">	va_end(ap);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>和 <code>printf</code> 一样，这是一个具有边长参数的函数。<code>va_list ap</code> 是变长参数列表。<code>va_start</code> 和 <code>va_end</code> 是用来初始化和结束变长参数列表的宏。真正重要的只有第三条语句 <code>vprintfmt(outputk, NULL, fmt, ap);</code></p>
<p>值得注意的是这条语句的第一个参数。这是一个回调函数，其定义同在kern/printk.c。是一个输出字符串的函数。其中 <code>printcharc</code> 一定是一个输出单个字符的函数。<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">outputk</span><span class="params">(<span class="type">void</span> *data, <span class="type">const</span> <span class="type">char</span> *buf, <span class="type">size_t</span> len)</span> &#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">		printcharc(buf[i]);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>更深入一层，在 kern/console.c 中有 <code>printcharc</code> 的定义，这样就完全到达底层了。输出字符本质上是向一个地址写入该字符所对应的数值。在同一个文件中还有读取字符的函数，是读取同一个地址的数值作为字符。<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">printcharc</span><span class="params">(<span class="type">char</span> ch)</span> &#123;</span><br><span class="line">	*((<span class="keyword">volatile</span> <span class="type">char</span> *)(KSEG1 + DEV_CONS_ADDRESS + DEV_CONS_PUTGETCHAR)) = ch;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>让我们回到 <code>printk</code>。不，应该是进入到 <code>vprintfmt</code>。这个函数定义在 lib/print.c。是需要我们填空的函数。首先看到一些定义的变量。我们需要设置这些变量的数值。<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">vprintfmt</span><span class="params">(<span class="type">fmt_callback_t</span> out, <span class="type">void</span> *data, <span class="type">const</span> <span class="type">char</span> *fmt, va_list ap)</span> &#123;</span><br><span class="line">	<span class="type">char</span> c;</span><br><span class="line">	<span class="type">const</span> <span class="type">char</span> *s;</span><br><span class="line">	<span class="type">long</span> num;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> width;</span><br><span class="line">	<span class="type">int</span> long_flag; <span class="comment">// output is long (rather than int)</span></span><br><span class="line">	<span class="type">int</span> neg_flag;  <span class="comment">// output is negative</span></span><br><span class="line">	<span class="type">int</span> ladjust;   <span class="comment">// output is left-aligned</span></span><br><span class="line">	<span class="type">char</span> padc;     <span class="comment">// padding char</span></span><br></pre></td></tr></table></figure></p>
<p>接着是一个循环，很明显是用来处理 <code>fmt</code> 字符串并按照格式进行输出的。这里我们翻一下指导书，可以找到格式的定义。<br><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">%[flags][width][length]&lt;specifier&gt;</span><br></pre></td></tr></table></figure></p>
<p>在编写代码前仔细思考一下：</p>
<ul>
<li>flags 有三种情况，<code>-</code>、<code>0</code> 或没有</li>
<li>width 只可能出现数字</li>
<li>length 只有两种情况 <code>l</code> 或没有。</li>
</ul>
<p>我们很容易可以写出 for 循环中的代码。需要注意这里使用了回调函数 <code>out</code> 进行输出。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* scan for the next &#x27;%&#x27; */</span></span><br><span class="line"><span class="comment">/* Exercise 1.4: Your code here. (1/8) */</span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span> * p = fmt;</span><br><span class="line"><span class="keyword">while</span> (*p != <span class="string">&#x27;%&#x27;</span> &amp;&amp; *p != <span class="string">&#x27;\0&#x27;</span>) &#123;</span><br><span class="line">	p++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* flush the string found so far */</span></span><br><span class="line"><span class="comment">/* Exercise 1.4: Your code here. (2/8) */</span></span><br><span class="line">out(data, fmt, p - fmt);</span><br><span class="line">fmt = p;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* check &quot;are we hitting the end?&quot; */</span></span><br><span class="line"><span class="comment">/* Exercise 1.4: Your code here. (3/8) */</span></span><br><span class="line"><span class="keyword">if</span> (*fmt == <span class="string">&#x27;\0&#x27;</span>) &#123;</span><br><span class="line">	<span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* we found a &#x27;%&#x27; */</span></span><br><span class="line"><span class="comment">/* Exercise 1.4: Your code here. (4/8) */</span></span><br><span class="line">fmt++;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* check format flag */</span></span><br><span class="line"><span class="comment">/* Exercise 1.4: Your code here. (5/8) */</span></span><br><span class="line">ladjust = <span class="number">0</span>;</span><br><span class="line">padc = <span class="string">&#x27; &#x27;</span>;</span><br><span class="line"><span class="keyword">if</span> (*fmt == <span class="string">&#x27;-&#x27;</span>) &#123;</span><br><span class="line">	ladjust = <span class="number">1</span>;</span><br><span class="line">	fmt++;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (*fmt == <span class="string">&#x27;0&#x27;</span>) &#123;</span><br><span class="line">	padc = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">	fmt++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* get width */</span></span><br><span class="line"><span class="comment">/* Exercise 1.4: Your code here. (6/8) */</span></span><br><span class="line">width = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (<span class="string">&#x27;0&#x27;</span> &lt;= *fmt &amp;&amp; *fmt &lt;= <span class="string">&#x27;9&#x27;</span> &amp;&amp; *fmt != <span class="string">&#x27;\0&#x27;</span>) &#123;</span><br><span class="line">	width *= <span class="number">10</span>;</span><br><span class="line">	width += *fmt - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">	fmt++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* check for long */</span></span><br><span class="line"><span class="comment">/* Exercise 1.4: Your code here. (7/8) */</span></span><br><span class="line">long_flag = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (*fmt == <span class="string">&#x27;l&#x27;</span>) &#123;</span><br><span class="line">	long_flag = <span class="number">1</span>;</span><br><span class="line">	fmt++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>之后根据 specifier 判断输出类型。不同的输出类型有不同的函数。感兴趣的可以深入研究。算法比较基本。</p>
<p>最后还有一个输出 <code>%d</code> 类型的部分需要填写。唯一有不同的地方是需要根据正负号设置 <code>print_num</code> 的 <code>neg_flag</code> 参数。</p>
<h2 id="五、编写-readelf-工具"><a href="#五、编写-readelf-工具" class="headerlink" title="五、编写 readelf 工具"></a>五、编写 readelf 工具</h2><p>本实验的还有一个和内核关系不大的内容，需要自己编写一个读取 elf 文件头的工具。该程序的相关代码在 tools/readelf 文件夹中。</p>
<p>程序的入口在 tools/readelf/main.c 文件中。<code>main</code> 函数首先判断参数是否合法，随后</p>
<ol>
<li>打开文件</li>
<li>获取文件大小</li>
<li>将文件内容读取到内存中</li>
<li>调用 <code>readelf</code> 函数进行处理<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> (argc &lt; <span class="number">2</span>) &#123;</span><br><span class="line">		<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Usage: %s &lt;elf-file&gt;\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	FILE *fp = fopen(argv[<span class="number">1</span>], <span class="string">&quot;rb&quot;</span>);</span><br><span class="line">	<span class="keyword">if</span> (fp == <span class="literal">NULL</span>) &#123;</span><br><span class="line">		perror(argv[<span class="number">1</span>]);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (fseek(fp, <span class="number">0</span>, SEEK_END)) &#123;</span><br><span class="line">		perror(<span class="string">&quot;fseek&quot;</span>);</span><br><span class="line">		<span class="keyword">goto</span> err;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> fsize = ftell(fp);</span><br><span class="line">	<span class="keyword">if</span> (fsize &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		perror(<span class="string">&quot;ftell&quot;</span>);</span><br><span class="line">		<span class="keyword">goto</span> err;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="type">char</span> *p = <span class="built_in">malloc</span>(fsize + <span class="number">1</span>);</span><br><span class="line">	<span class="keyword">if</span> (p == <span class="literal">NULL</span>) &#123;</span><br><span class="line">		perror(<span class="string">&quot;malloc&quot;</span>);</span><br><span class="line">		<span class="keyword">goto</span> err;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (fseek(fp, <span class="number">0</span>, SEEK_SET)) &#123;</span><br><span class="line">		perror(<span class="string">&quot;fseek&quot;</span>);</span><br><span class="line">		<span class="keyword">goto</span> err;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (fread(p, fsize, <span class="number">1</span>, fp) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		perror(<span class="string">&quot;fread&quot;</span>);</span><br><span class="line">		<span class="keyword">goto</span> err;</span><br><span class="line">	&#125;</span><br><span class="line">	p[fsize] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> readelf(p, fsize);</span><br><span class="line">err:</span><br><span class="line">	fclose(fp);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
值得注意的是异常处理使用到了 <code>goto</code> 语句。</li>
</ol>
<p><code>readelf</code> 函数是功能的主要实现函数，也是我们需要补全的部分。首先，将传入的 <code>binary</code> 指针转换为 elf 格式结构体的指针。c 语言中通过结构体实现二进制内容的划分。<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">readelf</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *binary, <span class="type">size_t</span> size)</span> &#123;</span><br><span class="line">	Elf32_Ehdr *ehdr = (Elf32_Ehdr *)binary;</span><br></pre></td></tr></table></figure></p>
<p>随后判断文件是否是 elf 格式。<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Check whether `binary` is a ELF file.</span></span><br><span class="line"><span class="keyword">if</span> (!is_elf_format(binary, size)) &#123;</span><br><span class="line">	<span class="built_in">fputs</span>(<span class="string">&quot;not an elf file\n&quot;</span>, <span class="built_in">stderr</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>其中 <code>is_elf_format</code> 函数通过文件大小和魔数来进行判断<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">is_elf_format</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *binary, <span class="type">size_t</span> size)</span> &#123;</span><br><span class="line">	Elf32_Ehdr *ehdr = (Elf32_Ehdr *)binary;</span><br><span class="line">	<span class="keyword">return</span> size &gt;= <span class="keyword">sizeof</span>(Elf32_Ehdr) &amp;&amp; ehdr-&gt;e_ident[EI_MAG0] == ELFMAG0 &amp;&amp;</span><br><span class="line">	       ehdr-&gt;e_ident[EI_MAG1] == ELFMAG1 &amp;&amp; ehdr-&gt;e_ident[EI_MAG2] == ELFMAG2 &amp;&amp;</span><br><span class="line">	       ehdr-&gt;e_ident[EI_MAG3] == ELFMAG3;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>回到 <code>readelf</code> 函数，我们希望读取节表（section table）的内容。首先要确定节表的位置、节表头的数量和大小。<code>Elf32_Ehdr</code> 结构体中有 <code>e_shoff</code> 用来记录节表位置相对于 elf 整体地址的偏移量。另有 <code>e_shnum</code>、<code>e_shentsize</code> 分别表示节表的数量和大小。<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Get the address of the section table, the number of section headers and the size of a</span></span><br><span class="line"><span class="comment">// section header.</span></span><br><span class="line"><span class="type">const</span> <span class="type">void</span> *sh_table;</span><br><span class="line">Elf32_Half sh_entry_count;</span><br><span class="line">Elf32_Half sh_entry_size;</span><br><span class="line"><span class="comment">/* Exercise 1.1: Your code here. (1/2) */</span></span><br><span class="line">sh_table = binary + ehdr-&gt;e_shoff;</span><br><span class="line">sh_entry_count = ehdr-&gt;e_shnum;</span><br><span class="line">sh_entry_size = ehdr-&gt;e_shentsize;</span><br></pre></td></tr></table></figure></p>
<p>之后我们遍历所有的节表，每个节表头的地址由节表头地址加上多个节表头的大小得到 <code>sh_table + i * sh_entry_size</code>。我们将其转化为节表头结构体的指针，获取该节表头所对应的节的地址 <code>addr = shdr-&gt;sh_addr</code>。最后输出结果。<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">	<span class="comment">// For each section header, output its index and the section address.</span></span><br><span class="line">	<span class="comment">// The index should start from 0.</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; sh_entry_count; i++) &#123;</span><br><span class="line">		<span class="type">const</span> Elf32_Shdr *shdr;</span><br><span class="line">		<span class="type">unsigned</span> <span class="type">int</span> addr;</span><br><span class="line">		<span class="comment">/* Exercise 1.1: Your code here. (2/2) */</span></span><br><span class="line">		shdr = (Elf32_Shdr*)(sh_table + i * sh_entry_size);</span><br><span class="line">		addr = shdr-&gt;sh_addr;</span><br><span class="line">		</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d:0x%x\n&quot;</span>, i, addr);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在其中唯一需要明确的是，节表存储了节的相关信息，但并不是节本身。如下的图片就很好地说明了节表和节的关系。节是文件中间的部分，而节表的位置则在文件的最后，section header table 的位置。程序表的内容也与节表类似。</p>
<img src="/posts/a08f03c8/elf.png" class="" title="elf">]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>MOS</tag>
        <tag>os</tag>
        <tag>BUAA</tag>
      </tags>
  </entry>
  <entry>
    <title>BUAA OS实验笔记之Lab2</title>
    <url>/posts/db841b3c/</url>
    <content><![CDATA[<h2 id="一、Lab2-前言"><a href="#一、Lab2-前言" class="headerlink" title="一、Lab2 前言"></a>一、Lab2 前言</h2><p>这篇文章应该是我目前写过的文章中长度排行前几的了。Lab2 的内容着实繁多，不仅是分页内存管理本身的理论和实现细节颇多；操作系统的基本知识和注意事项也占据了很大的篇幅。后者在不理解的情况下实在会对本次实验产生许多困惑。本人也是在逐步地探索之后才得以有了较多的认识——当然，这一认识或许也只是片面的。</p>
<p>本文逐函数、逐代码地讲解了 Lab2 中新增的内容。主要在于内核初始化中关于内存的部分以及分页内存管理的实现。在本文中，关于链表宏和虚拟/物理内存的辨析也占据了比较多的内容。</p>
<span id="more"></span>
<h2 id="二、内核初始化（续）"><a href="#二、内核初始化（续）" class="headerlink" title="二、内核初始化（续）"></a>二、内核初始化（续）</h2><p>在 Lab1 中，我们的内核初始化过程只进行了一部分。因为 Lab1 中 <code>mips_init</code> 函数几乎没有任何功能。在 Lab2 中，我们会继续推进这一过程。</p>
<p>在 Lab2 中，我们会建立操作系统的内存管理机制。具体来说，我们会在 <code>mips_init</code> 中调用三个函数 <code>mips_detect_memory</code>、<code>mips_vm_init</code> 和 <code>page_init</code>。这三个函数会分别完成探测内存、初始化虚拟地址和初始化页的工作。接下来我们会分别介绍这三个函数。</p>
<p>Lab2 中 <code>mips_init</code> 的结构如下：<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">mips_init</span><span class="params">()</span> &#123;</span><br><span class="line">	printk(<span class="string">&quot;init.c:\tmips_init() is called\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// lab2:</span></span><br><span class="line">	mips_detect_memory();</span><br><span class="line">	mips_vm_init();</span><br><span class="line">	page_init();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="（1）探测内存"><a href="#（1）探测内存" class="headerlink" title="（1）探测内存"></a>（1）探测内存</h3><p><code>mips_detect_memory</code> 的作用是获取总物理内存大小，并根据物理内存计算分页数。</p>
<blockquote>
<p>注意！是物理内存</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">mips_detect_memory</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="comment">/* Step 1: Initialize memsize. */</span></span><br><span class="line">	memsize = *(<span class="keyword">volatile</span> u_int *)(KSEG1 | DEV_MP_ADDRESS | DEV_MP_MEMORY)</span><br></pre></td></tr></table></figure>
<p>第一步中的这条语句似乎使人困惑。为什么这样就可以获得物理内存大小了呢？我们可以查看一下 <code>DEV_MP_ADDRESS</code> 和 <code>DEV_MP_MEMORY</code> 所在的头文件。它们定义在 include/driver/dev_mp.h 中。</p>
<p>恰好 include/driver 目录下有一个 README，其中提到<br><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">The files in this directory describe the devices found in GXemul&#x27;s &quot;test</span><br><span class="line">machines&quot;. These machines do not match any real-world machines, but they</span><br><span class="line">have devices that are similar to those found in real machines:</span><br><span class="line"></span><br><span class="line">omit...</span><br><span class="line"></span><br><span class="line">  o)  mp (dev_mp):</span><br><span class="line">	A multiprocessor inter-processor communication device.</span><br><span class="line">	It also contains other useful functionality, such as retrieving</span><br><span class="line">	the amount of &quot;physical&quot; RAM installed in the emulated machine.</span><br><span class="line"></span><br><span class="line">omit...</span><br></pre></td></tr></table></figure><br>这就说明 dev_mp.h 中的信息应该是关于 multiprocessor inter-processor communication device (mp) 的相关信息的。这是 GXemul 定义的虚拟设备。mp 能够检索（retrive）RAM 数量（？amount）。这就足够了。</p>
<p>再看 dev_mp.h。通过注释我们可以得知，这个头文件中定义的 <code>DEV_MP_ADDRESS</code> 是（mp 设备）默认的物理基地址。而 <code>DEV_MP_MEMORY</code> 是物理基地址到 “设备寄存器” 的偏移量。<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *  Default (physical) base address and length:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEV_MP_ADDRESS 0x11000000ULL</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEV_MP_LENGTH 0x00000100ULL</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// omit...</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *  Offsets from the base address to reach the MP device&#x27; registers:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEV_MP_MEMORY 0x0090</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// omit...</span></span><br></pre></td></tr></table></figure></p>
<p>现在我们就可以解释 <code>DEV_MP_ADDRESS | DEV_MP_MEMORY</code> 的含义了。这表示一个物理地址，该地址正好对应 mp 设备的 <code>MEMORY</code> 寄存器。其中存储了物理内存大小的相关的信息。</p>
<p>但是在代码中，我们只能使用虚拟地址进行访存。因此我们需要得到该物理地址对应的虚拟地址。这时候 <code>KSEG1</code> 就派上用场了。根据指导书我们知道，kseg1 段的虚拟地址转换为物理地址只需要将最高 3 位置 0，不通过 TLB，同时也不通过 cache。实际上，kseg1 段就是为访问外设准备的。</p>
<p>我们将物理地址 <code>DEV_MP_ADDRESS | DEV_MP_MEMORY</code> 转换为虚拟地址 <code>KSEG1 |</code>，指明该地址指向的是一个无符号整数 <code>(volatile u_int *)</code>，最后取出该位置的值 <code>memsize = *</code>。这就是这一条语句的含义。</p>
<p>话说回来，在 Lab1 的 <code>printcharc</code> 函数中我们也遇到过类似的写法：<code>KSEG1 + DEV_CONS_ADDRESS + DEV_CONS_PUTGETCHAR</code>。但是当时没有进一步说明。本使用中的使用的是按位或而非加法，也进一步加深了代码的迷惑程度。</p>
<blockquote>
<p>我在这里需要插一句，因为我不知道要把这部分内容放到哪里。</p>
<p>根据指导书可以知道，kseg1 段位于 <code>0xa0000000~0xbfffffff</code>，映射的物理地址为 <code>0x00000000~0x1fffffff</code>。同样 kseg0 段位于 <code>0x80000000~0x9fffffff</code>，但映射的物理地址也为 <code>0x00000000~0x1fffffff</code>。这是否出错了呢？其实不是。</p>
<p>kseg0 和 kseg1 中两个不同的虚拟地址，其实就对应同一个物理地址。区分 kseg0 和 kseg1 的目的，就在于区分是否使用 cache。</p>
<p>同样的，其实 kuseg 映射的物理地址也和 kseg0 和 kseg1 相同。你可能会想：“不对呀，kuseg 的虚拟地址空间明显大于 kseg0 和 kseg1。怎么可能映射到同样的物理地址空间？” 其实解决问题的关键就在于页表。这在本篇文章的后面会详细讲解。</p>
</blockquote>
<p>终于分析完第一条语句了。<code>mips_detect_memory</code> 中剩下的部分就比较简单了。<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">	<span class="comment">/* Step 2: Calculate the corresponding &#x27;npage&#x27; value. */</span></span><br><span class="line">	<span class="comment">/* Exercise 2.1: Your code here. */</span></span><br><span class="line">	npage = memsize / BY2PG;</span><br><span class="line"></span><br><span class="line">	printk(<span class="string">&quot;Memory size: %lu KiB, number of pages: %lu\n&quot;</span>, memsize / <span class="number">1024</span>, npage);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>在这部分中，我们将总物理内存大小除以页大小，得到总页数。并调用 Lab1 中编写的 <code>printk</code> 输出相关信息。需要注意的是 <code>BY2PG</code> 是一个宏，定义在 include/mmu.h 中。根据注释可以得知这表示一页的字节数。因此除以 <code>BY2PG</code> 即可得到总页数。<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> BY2PG 4096		<span class="comment">// bytes to a page</span></span></span><br></pre></td></tr></table></figure></p>
<h3 id="（2）初始化虚拟地址"><a href="#（2）初始化虚拟地址" class="headerlink" title="（2）初始化虚拟地址"></a>（2）初始化虚拟地址</h3><p>接着我们考虑 <code>mips_vm_init</code> 函数。这个函数将申请一部分空间用作页控制块。页控制块是 <code>struct Page</code> 类型的结构体。每一个页控制块对应一个物理页。</p>
<p><code>struct Page</code> 的结构很简单，只不过因为使用了链表宏（链表宏会在之后讲解），导致不容易理解。如下是展开后的 <code>struct Page</code><br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Page</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">Page</span> *<span class="title">le_next</span>;</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">Page</span> **<span class="title">le_prev</span>;</span></span><br><span class="line">	&#125; pp_link;</span><br><span class="line">	u_short pp_ref;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>其中只有一个用于表示链表前后节点的结构体 <code>pp_link</code>；以及用于引用计数，反映页的使用情况的 <code>pp_ref</code>。</p>
<p>这么简单的结构是如何映射到物理页的呢？其实也很简单。在 include/pmap.h 中我们可以得知，所有的页控制块都保存在一个数组中 <code>extern struct Page *pages</code>（这也是我们将要在<code>mips_vm_init</code>申请的数组）。</p>
<p>通过指针减法，可以得到对应的页控制块是第几个页<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> u_long <span class="title function_">page2ppn</span><span class="params">(<span class="keyword">struct</span> Page *pp)</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> pp - pages;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>一个物理页有确定的大小，我们将第几个页乘以物理页大小即可得到对应物理页的基地址。<code>page2pa</code> 表示 “page to physical addresss” 的意思。<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// in mmu.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PGSHIFT 12</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// in pmap.h</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> u_long <span class="title function_">page2pa</span><span class="params">(<span class="keyword">struct</span> Page *pp)</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> page2ppn(pp) &lt;&lt; PGSHIFT;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>同样的，还有反过程。通过物理地址获取对应的页控制块。<code>PPN</code> 宏获取物理地址对应的页数，<code>pa2page</code> 根据该页数求对应的页控制块。<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// in mmu.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PPN(va) (((u_long)(va)) &gt;&gt; 12)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// in pmap.h</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="keyword">struct</span> Page *<span class="title function_">pa2page</span><span class="params">(u_long pa)</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> (PPN(pa) &gt;= npage) &#123;</span><br><span class="line">		panic(<span class="string">&quot;pa2page called with invalid pa: %x&quot;</span>, pa);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> &amp;pages[PPN(pa)];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这样页控制块就大概讲清楚了。让我们回到 <code>mips_vm_init</code>。其中真正重要的只有第一句。在这一句中，我们调用了 <code>alloc</code> 函数申请了 <code>npage</code> 个 <code>struct Page</code> 大小的内存。并以 <code>BY2PG</code>（页的大小）进行对齐。同时将申请的内存中内容初始化为 0。这到底是什么意思？还是让我们看一下 <code>alloc</code> 的定义。<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">mips_vm_init</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="comment">/* Allocate proper size of physical memory for global array `pages`,</span></span><br><span class="line"><span class="comment">	 * for physical memory management. Then, map virtual address `UPAGES` to</span></span><br><span class="line"><span class="comment">	 * physical address `pages` allocated before. For consideration of alignment,</span></span><br><span class="line"><span class="comment">	 * you should round up the memory size before map. */</span></span><br><span class="line">	pages = (<span class="keyword">struct</span> Page *)alloc(npage * <span class="keyword">sizeof</span>(<span class="keyword">struct</span> Page), BY2PG, <span class="number">1</span>);</span><br><span class="line">	printk(<span class="string">&quot;to memory %x for struct Pages.\n&quot;</span>, freemem);</span><br><span class="line">	printk(<span class="string">&quot;pmap.c:\t mips vm init success\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在内核启动阶段，我们还没有什么像样的内存申请方式。因此只能自己写一个。在 <code>alloc</code> 函数中，我们首先定义了两个变量。<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> *<span class="title function_">alloc</span><span class="params">(u_int n, u_int align, <span class="type">int</span> clear)</span> &#123;</span><br><span class="line">	<span class="keyword">extern</span> <span class="type">char</span> end[];</span><br><span class="line">	u_long alloced_mem;</span><br></pre></td></tr></table></figure></p>
<p><code>alloced_mem</code> 是在程序中表示已分配内存的变量。<code>end</code> 是一个外部定义的变量，我们可以在 kernel.lds 中找到其对应的值。这在 Lab1 中也有所提及。需要注意的是，这里使用的是虚拟地址。查看内存分布表可知，此虚拟地址位于 kseg0 中。我们将内核的代码与数据结构都存储到 kseg0。接下来的内容都是在 kseg0 中进行。<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">. = <span class="number">0x80400000</span>;</span><br><span class="line">end = . ;</span><br></pre></td></tr></table></figure></p>
<p>回到 <code>alloc</code>。第一步，我们先对 <code>freemem</code> 的值进行初始化。<code>freemem</code> 是用来表示可用内存地址的全局变量。<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (freemem == <span class="number">0</span>) &#123;</span><br><span class="line">	freemem = (u_long)end; <span class="comment">// end</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>接着，我们把 <code>freemem</code> 以参数 <code>align</code> 对齐。这样接下来我们分配的内存才能从能被参数 <code>align</code> 整除的地址开始。<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Step 1: Round up `freemem` up to be aligned properly */</span></span><br><span class="line">freemem = ROUND(freemem, align);</span><br></pre></td></tr></table></figure></p>
<p><code>ROUND</code> 宏定义在 include/types.h 中。只能对齐 2 的整数幂。主要原理是将低位抹零。<code>ROUND</code> 宏还有一个对应的宏 <code>ROUNDDOWN</code>。前者向上对齐，后者向下对齐。<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Rounding; only works for n = power of two */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ROUND(a, n) (((((u_long)(a)) + (n)-1)) &amp; ~((n)-1))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ROUNDDOWN(a, n) (((u_long)(a)) &amp; ~((n)-1))</span></span><br></pre></td></tr></table></figure></p>
<p>在 <code>align</code> 中，我们现在确定已分配空间的上界，继续分配参数 <code>n</code> 个字节的内存。<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Step 2: Save current value of `freemem` as allocated chunk. */</span></span><br><span class="line">alloced_mem = freemem;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Step 3: Increase `freemem` to record allocation. */</span></span><br><span class="line">freemem = freemem + n;</span><br></pre></td></tr></table></figure></p>
<p>如果需要清零，则使用 <code>memset</code> 函数清零。接着返回 <code>alloced_mem</code> 的地址。<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Step 4: Clear allocated chunk if parameter `clear` is set. */</span></span><br><span class="line">	<span class="keyword">if</span> (clear) &#123;</span><br><span class="line">		<span class="built_in">memset</span>((<span class="type">void</span> *)alloced_mem, <span class="number">0</span>, n);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Step 5: return allocated chunk. */</span></span><br><span class="line">	<span class="keyword">return</span> (<span class="type">void</span> *)alloced_mem;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>值得注意的是中间还有一个类似于 <code>assert</code> 的语句<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Panic if we&#x27;re out of memory.</span></span><br><span class="line">panic_on(PADDR(freemem) &gt;= memsize);</span><br></pre></td></tr></table></figure></p>
<p>需要说明的是其中用到的的 <code>PADDR</code> 宏。这个宏将 kseg0 中的虚拟地址转化为物理地址。<code>ULIM</code> 是 kseg0 的基地址，因此 <code>a - ULIM</code> 等价于最高三位抹零。<code>PADDR</code> 还有一个对应宏 <code>KADDR</code>，将物理地址转换为 kseg0 中的内核虚拟地址，只不过是将减号改为加号。<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> PADDR(kva) \</span></span><br><span class="line"><span class="meta">	(&#123; \</span></span><br><span class="line"><span class="meta">		u_long a = (u_long)(kva); \</span></span><br><span class="line"><span class="meta">		<span class="keyword">if</span> (a &lt; ULIM) \</span></span><br><span class="line"><span class="meta">			panic(<span class="string">&quot;PADDR called with invalid kva %08lx&quot;</span>, a); \</span></span><br><span class="line"><span class="meta">		a - ULIM; \</span></span><br><span class="line"><span class="meta">	&#125;)</span></span><br></pre></td></tr></table></figure></p>
<p><code>memsize</code> 是物理内存的大小，当物理地址大于 <code>memsize</code> 时也就说明其超出了内存。</p>
<p>好了，现在 <code>alloc</code> 也讲解完了。你可能会想：“这分配了什么，不是就直接返回了个指针么？” 确实。说白了内存你本就可以随意使用，申请内存不过是为了避免内存使用冲突的机制罢了。</p>
<p>当讲完了 <code>alloc</code> 后，<code>mips_vm_init</code> 的内容也就明了了。我们创建了一个 <code>struct Page</code> 的数组，大小为 <code>npage</code>。</p>
<h3 id="（3）初始化页"><a href="#（3）初始化页" class="headerlink" title="（3）初始化页"></a>（3）初始化页</h3><p>在 <code>page_init</code> 中，我们将对 <code>mips_vm_init</code> 中申请的数组内容进行初始化，并维护一个存储所有空闲页的链表。</p>
<p>在正式开始之前，需要介绍一下在 include/queue.h 中定义的双向链表宏。通过使用宏，我们在 c 语言中实现了泛型。</p>
<p>为了使用链表，我们需要定义两个结构 <code>LIST_HEAD</code> 和 <code>LIST_ENTRY</code>。前者表示链表头或链表本身的类型，后者表示链表中元素的类型。通过宏定义可知，<code>LIST_HEAD(name, type)</code> 表示创建一个元素类型为 <code>type</code> 的链表，这个链表类型名为 <code>name</code>。<code>LIST_ENTRY(type)</code> 表示创建一个类型为 <code>type</code> 的链表元素。<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> LIST_HEAD(name, type) \</span></span><br><span class="line"><span class="meta">	struct name &#123; \</span></span><br><span class="line"><span class="meta">		struct type *lh_first; <span class="comment">/* first element */</span> \</span></span><br><span class="line"><span class="meta">	&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LIST_ENTRY(type) \</span></span><br><span class="line"><span class="meta">	struct &#123; \</span></span><br><span class="line"><span class="meta">		struct type *le_next;  <span class="comment">/* next element */</span> \</span></span><br><span class="line"><span class="meta">		struct type **le_prev; <span class="comment">/* address of previous next element */</span> \</span></span><br><span class="line"><span class="meta">	&#125;</span></span><br></pre></td></tr></table></figure></p>
<p>我们在 include/pmap.h 中就定义了元素为 <code>Page</code>，类型名为 <code>Page_list</code> 的链表。可以注意到 <code>struct Page</code> 的原始定义中包含了链表元素类型 <code>Page_LIST_entry_t</code><br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">LIST_HEAD(Page_list, Page);</span><br><span class="line"><span class="keyword">typedef</span> <span class="title function_">LIST_ENTRY</span><span class="params">(Page)</span> Page_LIST_entry_t;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Page</span> &#123;</span></span><br><span class="line">	Page_LIST_entry_t pp_link; <span class="comment">/* free list link */</span></span><br><span class="line"></span><br><span class="line">	u_short pp_ref;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="class"><span class="keyword">struct</span> <span class="title">Page_list</span> <span class="title">page_free_list</span>;</span></span><br></pre></td></tr></table></figure></p>
<p>include/queue.h 中也定义了一些链表操作，因为原理相似，在这里只介绍 <code>LIST_INSERT_AFTER(listelm, elm, field)</code>。这个函数也是我们需要填写的。<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> LIST_INSERT_AFTER(listelm, elm, field)                                                     \</span></span><br><span class="line"><span class="meta">	<span class="comment">/* Exercise 2.2: Your code here. */</span>  \</span></span><br><span class="line"><span class="meta">	do &#123; \</span></span><br><span class="line"><span class="meta">		<span class="keyword">if</span> ((LIST_NEXT((elm), field) = LIST_NEXT((listelm), field)) != NULL) \</span></span><br><span class="line"><span class="meta">			LIST_NEXT((listelm), field)-&gt;field.le_prev = &amp;LIST_NEXT((elm), field); \</span></span><br><span class="line"><span class="meta">		LIST_NEXT((listelm), field) = (elm); \</span></span><br><span class="line"><span class="meta">		(elm)-&gt;field.le_prev = &amp;LIST_NEXT((listelm), field); \</span></span><br><span class="line"><span class="meta">	&#125; while (0)</span></span><br></pre></td></tr></table></figure></p>
<p>对于代码的第一行，我们是容易理解的。在这两行中，我们先让 <code>elm</code> 的下一个元素指向 <code>listelm</code> 的下一个元素。若下一个元素不是 <code>NULL</code>，则还需要将这下一个元素的前一个元素设置为 <code>elm</code>。<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> ((LIST_NEXT((elm), field) = LIST_NEXT((listelm), field)) != <span class="literal">NULL</span>) \</span><br><span class="line">			LIST_NEXT((listelm), field)-&gt;field.le_prev = &amp;LIST_NEXT((elm), field); \</span><br></pre></td></tr></table></figure></p>
<p>但这里出现了问题，为什么第二行使用的是 <code>&amp;LIST_NEXT((elm), field)</code> 而非 <code>&amp;elm</code>？重新看一下 <code>LIST_ENTRY</code> 的定义，可以发现对 le_prev 的注释是 <code>/* address of previous next element */</code>。(前一个(下一个元素))的地址，也就是说本来 <code>le_prev</code> 的地址就是上一个元素的 <code>le_next</code> 的地址。这样做有什么意义呢？叶gg说这样方便定义头指针。因为 <code>LIST_HEAD</code> 和 <code>LIST_ENTRY</code> 不是同一个类型，如果 <code>le_prev</code> 的类型是 <code>struct type *</code>，那么头结点也必须是 <code>type</code> 类型，这会浪费一个指针大小的空间。</p>
<blockquote>
<p>有些文章可能会认为这个链表无法直接访问前节点，其实这应该是错的（因为如果是单向链表，那么根本没必要设计 <code>le_prev</code>）。</p>
</blockquote>
<p>这样的话，代码的第三四行也可以理解了。<code>listelm</code> 的下一个元素是 <code>elm</code>。<code>elm</code> 的 <code>le_prev</code> 的值是前一个元素，<code>listelm</code> 的 <code>le_next</code> 的地址。<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">LIST_NEXT((listelm), field) = (elm); \</span><br><span class="line">(elm)-&gt;field.le_prev = &amp;LIST_NEXT((listelm), field); \</span><br></pre></td></tr></table></figure></p>
<p>现在我们理解了链表宏的含义，可以回来看 <code>page_init</code> 函数了。我们想一下接下来要做什么。我们有物理内存，并将其划分成了许多的页，这些页的信息通过页控制块保存在 <code>pages</code> 数组中。可是现在页控制块还没有被设置，具体来说，我们还没有明确哪些页是可用的，哪些页是已经被使用的。因此接下来我们要做到就是将页划分成可用和不可用的，并将可用的页控制块放入 <code>page_free_list</code> 中（这样想要申请新的页，只需要取出该链表的头结点即可）。</p>
<p>第一步，我们初始化链表（实际上只是将头结点的指针值设为 <code>NULL</code>）。<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">page_init</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">	<span class="comment">/* Step 1: Initialize page_free_list. */</span></span><br><span class="line">	<span class="comment">/* Hint: Use macro `LIST_INIT` defined in include/queue.h. */</span></span><br><span class="line">	<span class="comment">/* Exercise 2.3: Your code here. (1/4) */</span></span><br><span class="line">	LIST_INIT(&amp;page_free_list);</span><br></pre></td></tr></table></figure></p>
<p>然后我们确定已使用内存的最大地址，为了适配页的大小，需要进行对齐<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Step 2: Align `freemem` up to multiple of BY2PG. */</span></span><br><span class="line"><span class="comment">/* Exercise 2.3: Your code here. (2/4) */</span></span><br><span class="line">freemem = ROUND(freemem, BY2PG);</span><br></pre></td></tr></table></figure></p>
<p>接着，我们需要将已使用的页的引用数设为 1，表示页已经被使用。首先我们计算有多少已使用的页，我们先使用 <code>PADDR</code> 将 <code>freemem</code> 转换为物理地址，接着使用 <code>PPN</code> 获取该地址属于第几个页表。使用一个循环将前 <code>usedpage</code> 个页控制块的 <code>pp_ref</code> 设置为 1。<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Step 3: Mark all memory below `freemem` as used (set `pp_ref` to 1) */</span></span><br><span class="line"><span class="comment">/* Exercise 2.3: Your code here. (3/4) */</span></span><br><span class="line">u_long usedpage = PPN(PADDR(freemem));</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (u_long i = <span class="number">0</span>; i &lt; usedpage; i++) &#123;</span><br><span class="line">	pages[i].pp_ref = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>最后，我们将剩下的页控制块的 <code>pp_ref</code> 设置为 0，并将这些页控制块插入到 <code>page_free_list</code> 中。<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">	<span class="comment">/* Step 4: Mark the other memory as free. */</span></span><br><span class="line">	<span class="comment">/* Exercise 2.3: Your code here. (4/4) */</span></span><br><span class="line">	<span class="keyword">for</span> (u_long i = usedpage; i &lt; npage; i++) &#123;</span><br><span class="line">		pages[i].pp_ref = <span class="number">0</span>;</span><br><span class="line">		LIST_INSERT_HEAD(&amp;page_free_list, &amp;pages[i], pp_link);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="三、页式内存管理"><a href="#三、页式内存管理" class="headerlink" title="三、页式内存管理"></a>三、页式内存管理</h2><p>当我们使用 kuseg 地址空间的虚拟地址访问内存时，我们会通过 TLB 将其转换为物理地址。当 TLB 中查询不到对应的物理地址时，就会发生 TLB Miss 异常。这时将跳转到异常处理函数，执行 TLB 重填。在 Lab2，我们的代码还未启用异常处理，因此无法真正运行页式内存管理机制，但是代码中已经定义了 TLB 重填函数。我们将从此开始解读 MOS 中的页式内存管理。</p>
<blockquote>
<p>注意，页式内存管理部分各类函数杂糅在一起。水平有限，以调用过程叙述时实在难以保证行文结构，因此小节题目不一定完全概括小节内容</p>
</blockquote>
<h3 id="（1）TLB-重填"><a href="#（1）TLB-重填" class="headerlink" title="（1）TLB 重填"></a>（1）TLB 重填</h3><p>TLB 的重填过程由 kern/tlb_asm.S 中的 <code>do_tlb_refill</code> 函数完成。该函数是汇编实现的。首先，定义了一个字的变量，标签为 <code>tlb_refill_ra</code><br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">.data</span><br><span class="line">tlb_refill_ra:</span><br><span class="line">.word <span class="number">0</span></span><br></pre></td></tr></table></figure></p>
<p>接着是代码部分。首先我们使用 <code>NESTED</code> 定义函数标签。<code>NESTED</code> 与 <code>LEAF</code> 宏相对应。前者表示非叶函数，后者表示叶函数。<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">.text</span><br><span class="line"><span class="title function_">NESTED</span><span class="params">(do_tlb_refill, <span class="number">0</span>, zero)</span></span><br></pre></td></tr></table></figure></p>
<p>我们希望汇编尽可能少，因此希望 <code>do_tlb_refill</code> 只做必要的处理，随后调用 c 函数进一步处理。因此首先我们设置参数。第一个参数是 <code>BadVAddr</code> 寄存器的值，即发生 TLB Miss 的虚拟地址；第二个参数是 <code>EntryHi</code> 寄存器的 6-11 位。即当前进程的 ASID。<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">mfc0    a0, CP0_BADVADDR</span><br><span class="line">mfc0    a1, CP0_ENTRYHI</span><br><span class="line">srl     a1, a1, <span class="number">6</span></span><br><span class="line">andi    a1, a1, <span class="number">0b111111</span></span><br></pre></td></tr></table></figure></p>
<p>接着我们调用 c 函数 <code>_do_tlb_refill</code>（这个函数会在后面说明）。注意这里存储了原来的 <code>ra</code> 寄存器值。<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">sw      ra, tlb_refill_ra</span><br><span class="line">jal     _do_tlb_refill</span><br><span class="line">lw      ra, tlb_refill_ra</span><br></pre></td></tr></table></figure></p>
<p><code>_do_tlb_refill</code> 会返回虚拟地址对应的页表项。我们将该返回值存入 <code>EntryLo</code>，并将 <code>EntryHi</code> 和 <code>EntryLo</code> 的值写入 TLB。<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">	mtc0    v0, CP0_ENTRYLO0</span><br><span class="line">	<span class="comment">// See &lt;IDT R30xx Family Software Reference Manual&gt; Chapter 6-8</span></span><br><span class="line">	nop</span><br><span class="line">	<span class="comment">/* Hint: use &#x27;tlbwr&#x27; to write CP0.EntryHi/Lo into a random tlb entry. */</span></span><br><span class="line">	<span class="comment">/* Exercise 2.10: Your code here. */</span></span><br><span class="line">	tlbwr</span><br><span class="line"></span><br><span class="line">	jr      ra</span><br><span class="line"><span class="title function_">END</span><span class="params">(do_tlb_refill)</span></span><br></pre></td></tr></table></figure></p>
<p>这样就完成了 TLB 重填。跳回到正常程序后，此前产生异常的虚拟地址就可以通过 TLB 访问内存了。</p>
<p>接着我们详细深入 <code>_do_tlb_refill</code>，这个函数在 kern/tlbex.c 中。正如 hints 所说，在这个函数中，我们会不断查找虚拟地址对应的页表项，如果未找到，则试图申请一个新的页表项。最终返回申请到的页表项的内容。<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Pte _do_tlb_refill(u_long va, u_int asid) &#123;</span><br><span class="line">	Pte *pte;</span><br><span class="line">	<span class="comment">/* Hints:</span></span><br><span class="line"><span class="comment">	 *  Invoke &#x27;page_lookup&#x27; repeatedly in a loop to find the page table entry &#x27;pte&#x27; associated</span></span><br><span class="line"><span class="comment">	 *  with the virtual address &#x27;va&#x27; in the current address space &#x27;cur_pgdir&#x27;.</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 *  **While** &#x27;page_lookup&#x27; returns &#x27;NULL&#x27;, indicating that the &#x27;pte&#x27; could not be found,</span></span><br><span class="line"><span class="comment">	 *  allocate a new page using &#x27;passive_alloc&#x27; until &#x27;page_lookup&#x27; succeeds.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Exercise 2.9: Your code here. */</span></span><br><span class="line">	<span class="keyword">while</span> (page_lookup(cur_pgdir, va, &amp;pte) == <span class="literal">NULL</span>) &#123;</span><br><span class="line">		passive_alloc(va, cur_pgdir, asid);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> *pte;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="（2）页的查找"><a href="#（2）页的查找" class="headerlink" title="（2）页的查找"></a>（2）页的查找</h3><p>接着我们详细讨论 <code>_do_tlb_refill</code> 中所使用的函数。</p>
<p><code>page_lookup</code> 函数在 kern/pmap.c 中定义。这个函数用于查找虚拟地址对应的页控制块及页表项。函数的参数是页目录的（虚拟）基地址，想要转换的虚拟地址和用于返回对应页表项的指针。值得注意的是，<code>_do_tlb_refill</code> 调用该函数时页目录基地址参数使用的是全局变量 <code>cur_pgdir</code>。可是这个全局变量并没有任何被赋值。这也是在 Lab2 中页式内存管理无法使用的一个原因。</p>
<p>我们继续看 <code>page_lookup</code> 的内容。其中首先调用了另一个函数 <code>pgdir_walk</code>。这个函数会获取想要转换的虚拟地址对应的（二级）页表项地址，通过 <code>pte</code> 返回。其中第三个参数 <code>create</code> 表示若未找到对应页表是否创建新的页表，此处为 0 表示不创建。<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> Page *<span class="title function_">page_lookup</span><span class="params">(Pde *pgdir, u_long va, Pte **ppte)</span> &#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Page</span> *<span class="title">pp</span>;</span></span><br><span class="line">	Pte *pte;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Step 1: Get the page table entry. */</span></span><br><span class="line">	pgdir_walk(pgdir, va, <span class="number">0</span>, &amp;pte);</span><br></pre></td></tr></table></figure></p>
<p>接着 <code>page_lookup</code> 检查是否获取到对应的页表项，未获取到返回 <code>NULL</code><br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Hint: Check if the page table entry doesn&#x27;t exist or is not valid. */</span></span><br><span class="line"><span class="keyword">if</span> (pte == <span class="literal">NULL</span> || (*pte &amp; PTE_V) == <span class="number">0</span>) &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>如果获取到，我们找到页表项对应的页控制块，并返回。<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">	<span class="comment">/* Step 2: Get the corresponding Page struct. */</span></span><br><span class="line">	<span class="comment">/* Hint: Use function `pa2page`, defined in include/pmap.h . */</span></span><br><span class="line">	pp = pa2page(*pte);</span><br><span class="line">	<span class="keyword">if</span> (ppte) &#123;</span><br><span class="line">		*ppte = pte;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> pp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>需要注意这里有一个容易引起困惑的地方，<code>pte</code> 是虚拟地址对应的页表项的地址，<code>*pte</code> 是页表项的内容。我们知道页表项中除了物理地址之外还存储有其他信息。怎么就把其当做物理地址传入 <code>pa2page</code> 函数了呢？</p>
<p>让我们回到 <code>pa2page</code> 就知道了。在 <code>pa2page</code> 中我们通过 <code>PPN</code> 获取物理地址对应的第几页，而 <code>PPN</code> 是通过右移 12 位实现的。这样我们就将页表项中低位的用于表示权限等信息的内容消去，而只剩下页数了。（或许也正是因为 <code>*pte</code> 的低位无用，才将其用作其他内容。）</p>
</blockquote>
<p>接着我们考察 <code>pgdir_walk</code> 函数，这个函数也在 kern/pmap.c 中定义。并且是需要我们填写的函数。如前所述，这个函数要实现查找对应虚拟地址对应的（二级）页表项，并根据 <code>create</code> 参数的设置在未找到二级页表时创建二级页表。</p>
<p>首先，我们根据虚拟地址确定对应的页目录项的地址。<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">pgdir_walk</span><span class="params">(Pde *pgdir, u_long va, <span class="type">int</span> create, Pte **ppte)</span> &#123;</span><br><span class="line">	Pde *pgdir_entryp;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Page</span> *<span class="title">pp</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Step 1: Get the corresponding page directory entry. */</span></span><br><span class="line">	<span class="comment">/* Exercise 2.6: Your code here. (1/3) */</span></span><br><span class="line">	pgdir_entryp = pgdir + PDX(va);</span><br></pre></td></tr></table></figure></p>
<p>其中使用了 <code>PDX</code> 宏。这个宏定义在 include/mmu.h 中。用于获取虚拟地址的 22-31 位的数值，这是虚拟地址对应的页目录项相对于页目录基地址的偏移。<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> PDX(va) ((((u_long)(va)) &gt;&gt; 22) &amp; 0x03FF)</span></span><br></pre></td></tr></table></figure></p>
<p>随后我们判断该页目录项是否有效。如果无效，判断是否需要创建新的二级页表。如需要则使用 <code>page_alloc</code> 函数申请一个物理页，并设置虚拟地址对应页目录项的内容 <code>*pgdir_entryp = page2pa(pp) | PTE_D | PTE_V</code>，使其与该物理页关联。<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (!(*pgdir_entryp &amp; PTE_V)) &#123;</span><br><span class="line">		<span class="keyword">if</span> (create) &#123;</span><br><span class="line">			<span class="keyword">if</span> (page_alloc(&amp;pp) != <span class="number">0</span>) &#123;</span><br><span class="line">				<span class="keyword">return</span> -E_NO_MEM;</span><br><span class="line">			&#125;</span><br><span class="line">			pp-&gt;pp_ref++;</span><br><span class="line">			*pgdir_entryp = page2pa(pp) | PTE_D | PTE_V;</span><br></pre></td></tr></table></figure></p>
<p><code>page_alloc</code> 函数是一个简单的函数，用于从 <code>page_free_list</code> 中抽取第一个空闲的页控制块，将页控制块对应的物理内存作为分配的内存。将该内存初始化为 0。唯一需要注意的是 <code>page2kva</code>。此函数实际上只是 <code>KADDR(page2pa(pp))</code>。<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">page_alloc</span><span class="params">(<span class="keyword">struct</span> Page **new)</span> &#123;</span><br><span class="line">	<span class="comment">/* Step 1: Get a page from free memory. If fails, return the error code.*/</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Page</span> *<span class="title">pp</span>;</span></span><br><span class="line">	<span class="comment">/* Exercise 2.4: Your code here. (1/2) */</span></span><br><span class="line">	<span class="keyword">if</span> (LIST_EMPTY(&amp;page_free_list)) &#123;</span><br><span class="line">		<span class="keyword">return</span> -E_NO_MEM;</span><br><span class="line">	&#125;</span><br><span class="line">	pp = LIST_FIRST(&amp;page_free_list);</span><br><span class="line"></span><br><span class="line">	LIST_REMOVE(pp, pp_link);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Step 2: Initialize this page with zero.</span></span><br><span class="line"><span class="comment">	 * Hint: use `memset`. */</span></span><br><span class="line">	<span class="comment">/* Exercise 2.4: Your code here. (2/2) */</span></span><br><span class="line">	<span class="built_in">memset</span>((<span class="type">void</span> *)page2kva(pp), <span class="number">0</span>, BY2PG);</span><br><span class="line"></span><br><span class="line">	*new = pp;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>回到 <code>pgdir_walk</code>，如果不需要创建，则直接返回<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		*ppte = <span class="literal">NULL</span>;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>函数中剩下的流程中，二级页表必然存在了。我们获取二级页表的虚拟基地址，并找到虚拟地址 <code>va</code> 对应的二级页表项，返回。<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">	<span class="comment">/* Step 3: Assign the kernel virtual address of the page table entry to &#x27;*ppte&#x27;. */</span></span><br><span class="line">	<span class="comment">/* Exercise 2.6: Your code here. (3/3) */</span></span><br><span class="line">	Pte *pgtable = (Pte *)KADDR(PTE_ADDR(*pgdir_entryp));</span><br><span class="line">	*ppte = pgtable + PTX(va);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>需要注意这里我们使用了两个宏来获取二级页表基地址。第一个宏 <code>PTE_ADDR</code> 定义在 include/mmu.h 中。它返回页目录项对应的二级页表的基地址。实际上就是将页目录项内容的低 12 位抹零。如果是新申请的物理页作为二级页表，则该值实际上等于 <code>page2pa(pp)</code>。另一个宏 <code>KADDR</code> 将物理地址转换为 kseg0 的虚拟地址，不用细说。<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> PTE_ADDR(pte) ((u_long)(pte) &amp; ~0xFFF)</span></span><br></pre></td></tr></table></figure></p>
<p>与 <code>PDX</code> 类似，<code>PTX</code> 宏返回虚拟地址 12-21 位的数值，<code>pgtable</code> 二级页表基地址加上偏移得到虚拟地址 <code>va</code> 对应的二级页表项。</p>
<h3 id="（3）页的申请"><a href="#（3）页的申请" class="headerlink" title="（3）页的申请"></a>（3）页的申请</h3><p><code>pgdir_walk</code> 的内容我们已经分析完成，现在 <code>page_lookup</code> 函数也没有需要讲解的部分了。接下来我们分析 <code>_do_tlb_refill</code> 中的 <code>passive_alloc</code>。</p>
<p><code>passive_alloc</code> 定义在 kern/tlbex.c 中。这是一个用于为虚拟地址申请物理页的函数。它的参数是：想要关联物理地址的虚拟地址、页目录的基地址和标识进程的 asid。<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">passive_alloc</span><span class="params">(u_int va, Pde *pgdir, u_int asid)</span> &#123;</span><br></pre></td></tr></table></figure></p>
<p>函数一开头就是好几条检查地址是否非法的判断语句，这里就不列出了。接下来的内容是，函数通过 <code>page_alloc</code> 申请一个物理页，并试图通过 <code>page_insert</code> 建立物理页和虚拟地址的联系。<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">	panic_on(page_alloc(&amp;p));</span><br><span class="line">	panic_on(page_insert(pgdir, asid, p, PTE_ADDR(va), PTE_D));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>page_alloc</code> 已经在之前介绍过了，现在介绍 <code>page_insert</code>。这个函数定义在 kern/pmap.c 中。是我们需要补完的函数。</p>
<p>该函数首先调用 <code>pgdir_walk</code>，试图获取当前虚拟地址对应的二级页表项。<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">page_insert</span><span class="params">(Pde *pgdir, u_int asid, <span class="keyword">struct</span> Page *pp, u_long va, u_int perm)</span> &#123;</span><br><span class="line">	Pte *pte;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/* Step 1: Get corresponding page table entry. */</span></span><br><span class="line">	pgdir_walk(pgdir, va, <span class="number">0</span>, &amp;pte);</span><br></pre></td></tr></table></figure></p>
<p>如果确实获得了虚拟地址对应的二级页表项，并且是有效的，那么判断该页表项对应的物理页是否就是 <code>va</code> 想要映射的物理页（通过比较页控制块）。如果不一样，那么调用 <code>page_remove</code> 移除虚拟地址到原有的页的映射。<code>page_remove</code> 将在后续说明。<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (pte &amp;&amp; (*pte &amp; PTE_V)) &#123;</span><br><span class="line">	<span class="keyword">if</span> (pa2page(*pte) != pp) &#123;</span><br><span class="line">		page_remove(pgdir, asid, va);</span><br></pre></td></tr></table></figure></p>
<p>如果相同，说明虚拟地址已经映射到了对应的物理页。这时我们只需要更新一下页表项的权限 <code>*pte = page2pa(pp) | perm | PTE_V</code>。为了保证对页表的修改都能反映到 TLB 中，我们要调用 <code>tlb_invalidate</code> 函数将原有的关于 <code>va</code> 和 <code>asid</code> 的 TLB 表项清除。<code>tlb_invalidate</code> 将在后面说明。<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		tlb_invalidate(asid, va);</span><br><span class="line">		*pte = page2pa(pp) | perm | PTE_V;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>程序执行 <code>page_insert</code> 的后续语句时，一定不存在虚拟地址 <code>va</code> 到页控制块对应的物理页的映射。于是接下来，我们就要建立这样的映射。首先我们还是要调用 <code>tlb_invalidate</code> 清除原有内容。<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Step 2: Flush TLB with &#x27;tlb_invalidate&#x27;. */</span></span><br><span class="line"><span class="comment">/* Exercise 2.7: Your code here. (1/3) */</span></span><br><span class="line">tlb_invalidate(asid, va);</span><br></pre></td></tr></table></figure></p>
<p>随后再调用一次 <code>pgdir_walk</code>，只不过这次 <code>create=1</code>。这将获得 <code>va</code> 对应的二级页表项<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Step 3: Re-get or create the page table entry. */</span></span><br><span class="line"><span class="comment">/* If failed to create, return the error. */</span></span><br><span class="line"><span class="comment">/* Exercise 2.7: Your code here. (2/3) */</span></span><br><span class="line"><span class="keyword">if</span> (pgdir_walk(pgdir, va, <span class="number">1</span>, &amp;pte) != <span class="number">0</span>) &#123;</span><br><span class="line">	<span class="keyword">return</span> -E_NO_MEM;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>最后，我们只需要建立二级页表项到物理页的联系即可。我们只需修改二级页表项的内容，修改为物理页的物理地址和权限设置即可。同时不要忘记递增页控制块的引用计数。<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">	<span class="comment">/* Step 4: Insert the page to the page table entry with &#x27;perm | PTE_V&#x27; and increase its</span></span><br><span class="line"><span class="comment">	 * &#x27;pp_ref&#x27;. */</span></span><br><span class="line">	<span class="comment">/* Exercise 2.7: Your code here. (3/3) */</span></span><br><span class="line">	*pte = page2pa(pp) | perm | PTE_V;</span><br><span class="line">	pp-&gt;pp_ref++;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="（4）页的移除"><a href="#（4）页的移除" class="headerlink" title="（4）页的移除"></a>（4）页的移除</h3><p>结束了 <code>page_insert</code> 的说明，让我们重新拾起按下不表的 <code>page_remove</code> 和 <code>tlb_invalidate</code>。我们首先考察 <code>page_remove</code>，此函数定义在 kern/pmap.c 中。用于取消虚拟地址 <code>va</code> 到物理页的映射。</p>
<p>首先该函数调用 <code>page_lookup</code> 查找与 <code>va</code> 和 <code>asid</code> 映射的物理页。如果不存在这样的页，则直接返回<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">page_remove</span><span class="params">(Pde *pgdir, u_int asid, u_long va)</span> &#123;</span><br><span class="line">	Pte *pte;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Step 1: Get the page table entry, and check if the page table entry is valid. */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Page</span> *<span class="title">pp</span> =</span> page_lookup(pgdir, va, &amp;pte);</span><br><span class="line">	<span class="keyword">if</span> (pp == <span class="literal">NULL</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure></p>
<p>如果存在，则调用 <code>page_decref</code> 以递减该页的引用数。当引用数等于零时，将该物理页重新放入未使用页的链表。因为对页表进行了修改，需要调用 <code>tlb_invalidate</code> 确保 TLB 中不保留原有内容。<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">	<span class="comment">/* Step 2: Decrease reference count on &#x27;pp&#x27;. */</span></span><br><span class="line">	page_decref(pp);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Step 3: Flush TLB. */</span></span><br><span class="line">	*pte = <span class="number">0</span>;</span><br><span class="line">	tlb_invalidate(asid, va);</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>page_decref</code> 定义如下，该函数和 <code>page_free</code> 都定义在 kern/pmap.c 中。这两个函数不需要讲解。<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">page_free</span><span class="params">(<span class="keyword">struct</span> Page *pp)</span> &#123;</span><br><span class="line">	assert(pp-&gt;pp_ref == <span class="number">0</span>);</span><br><span class="line">	<span class="comment">/* Just insert it into &#x27;page_free_list&#x27;. */</span></span><br><span class="line">	<span class="comment">/* Exercise 2.5: Your code here. */</span></span><br><span class="line">	LIST_INSERT_HEAD(&amp;page_free_list, pp, pp_link);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">page_decref</span><span class="params">(<span class="keyword">struct</span> Page *pp)</span> &#123;</span><br><span class="line">	assert(pp-&gt;pp_ref &gt; <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* If &#x27;pp_ref&#x27; reaches to 0, free this page. */</span></span><br><span class="line">	<span class="keyword">if</span> (--pp-&gt;pp_ref == <span class="number">0</span>) &#123;</span><br><span class="line">		page_free(pp);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>还剩 <code>tlb_invalidate</code> 函数需要说明。这个函数主要用于调用另一个汇编函数 <code>tlb_out</code>。<code>tlb_invalidate</code> 将参数 <code>asid</code> 和 <code>va</code> 结合在了一起，传入 <code>tlb_out</code>。实际上这个结合在一起的参数就是 <code>EntryHi</code> 寄存器的结构。<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">tlb_invalidate</span><span class="params">(u_int asid, u_long va)</span> &#123;</span><br><span class="line">	tlb_out(PTE_ADDR(va) | (asid &lt;&lt; <span class="number">6</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>我们再考察 <code>tlb_out</code> 的内容。这部分定义在 kern/tlb_asm.S 中。首先可知，<code>tlb_out</code> 是一个叶函数。<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">LEAF(tlb_out)</span><br></pre></td></tr></table></figure></p>
<p>函数在一开始将原有的 <code>EnryHi</code> 寄存器中的值保存，并将传入的参数设置为 <code>EnryHi</code> 新的值。然后根据新的值查找 TLB 表项。<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">set</span> noreorder</span><br><span class="line">	mfc0    t0, CP0_ENTRYHI</span><br><span class="line">	mtc0    a0, CP0_ENTRYHI</span><br><span class="line">	nop</span><br><span class="line">	<span class="comment">/* Step 1: Use &#x27;tlbp&#x27; to probe TLB entry */</span></span><br><span class="line">	<span class="comment">/* Exercise 2.8: Your code here. (1/2) */</span></span><br><span class="line">	tlbp <span class="comment">// 这条指令根据 EntryHi 中的 Key，查找 TLB 中对应的表项，将该项的索引存入 Index 寄存器</span></span><br><span class="line">	</span><br><span class="line">	nop</span><br></pre></td></tr></table></figure></p>
<p>随后将 <code>Index</code> 寄存器中的查询结果存储到 <code>t1</code> 寄存器，如果结果小于 0，说明未找到对应的表项，跳转到 NO_SUCH_ENTRY，不需要进行清零操作。<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">	mfc0    t1, CP0_INDEX</span><br><span class="line">.<span class="built_in">set</span> reorder</span><br><span class="line">	bltz    t1, NO_SUCH_ENTRY </span><br></pre></td></tr></table></figure></p>
<p>这里分别将 <code>EntryHi</code> 和 <code>EntryLo</code> 设置为 0。并将内容写入对应的表项，实现清零。<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">.<span class="built_in">set</span> noreorder</span><br><span class="line">	mtc0    zero, CP0_ENTRYHI</span><br><span class="line">	mtc0    zero, CP0_ENTRYLO0</span><br><span class="line">	nop</span><br><span class="line">	</span><br><span class="line">	tlbwi</span><br></pre></td></tr></table></figure></p>
<p>最后，恢复进入函数时 <code>EntryHi</code> 存储的值，函数返回。<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">.<span class="built_in">set</span> reorder</span><br><span class="line"></span><br><span class="line">NO_SUCH_ENTRY:</span><br><span class="line">	mtc0    t0, CP0_ENTRYHI</span><br><span class="line"></span><br><span class="line">	j       ra</span><br><span class="line"><span class="title function_">END</span><span class="params">(tlb_out)</span></span><br></pre></td></tr></table></figure></p>
<p>这样就完成了 Lab2 中所有涉及到的代码的讲解。</p>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>MOS</tag>
        <tag>os</tag>
        <tag>BUAA</tag>
      </tags>
  </entry>
  <entry>
    <title>BUAA-OS实验笔记之Lab3</title>
    <url>/posts/5e49fa6a/</url>
    <content><![CDATA[<h2 id="一、Lab3-前言"><a href="#一、Lab3-前言" class="headerlink" title="一、Lab3 前言"></a>一、Lab3 前言</h2><p>不知道为什么，虽然写 Lab3 所用的时间比 Lab2 少，但这次的笔记居然比 Lab2 长。我认为可能是因为自己在本篇文章中讲了更多和实验本身无关的东西。不过既然讲了，应该也会对进一步认识操作系统起到一些作用吧。希望本篇文章不会显得太啰嗦。<br><span id="more"></span></p>
<h2 id="二、内核初始化（再续）"><a href="#二、内核初始化（再续）" class="headerlink" title="二、内核初始化（再续）"></a>二、内核初始化（再续）</h2><p>Lab2 中，我们在内核初始化阶段初始化了虚拟内存的相关信息，Lab3 中我们要继续这一过程。本次实验中我们会完成进程控制的初始化。</p>
<h3 id="（1）再度-mips-init"><a href="#（1）再度-mips-init" class="headerlink" title="（1）再度 mips_init"></a>（1）再度 mips_init</h3><p>我们查看 Lab3 中 init/init.c 的 <code>mips_init</code> 函数的内容变化。与 Lab2 相比，其中多调用了如下的方法 <code>env_init</code>、<code>ENV_CREATE_PRIORITY</code>、<code>kclock_init</code> 和 <code>enable_irq</code>。<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">mips_init</span><span class="params">()</span> &#123;</span><br><span class="line">	printk(<span class="string">&quot;init.c:\tmips_init() is called\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// lab2:</span></span><br><span class="line">	mips_detect_memory();</span><br><span class="line">	mips_vm_init();</span><br><span class="line">	page_init();</span><br><span class="line"></span><br><span class="line">	<span class="comment">// lab3:</span></span><br><span class="line">	env_init();</span><br><span class="line"></span><br><span class="line">	<span class="comment">// lab3:</span></span><br><span class="line">	ENV_CREATE_PRIORITY(user_bare_loop, <span class="number">1</span>);</span><br><span class="line">	ENV_CREATE_PRIORITY(user_bare_loop, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// lab3:</span></span><br><span class="line">	kclock_init();</span><br><span class="line">	enable_irq();</span><br><span class="line">	<span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>其中 <code>env_init</code> 用于进程控制的初始化，<code>ENV_CREATE_PRIORITY</code> 手工创建了两个进程，<code>kclock_init</code> 和 <code>enable_irq</code> 设置了时钟中断并启用了中断。后两者将分别在第三和四节介绍。本届只介绍前者。</p>
<h3 id="（2）进程管理的数据结构"><a href="#（2）进程管理的数据结构" class="headerlink" title="（2）进程管理的数据结构"></a>（2）进程管理的数据结构</h3><p>让我们深入在 kern/env.c 中的 <code>env_init</code>，在该函数中，首先初始化了两个列表<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">env_init</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line">	<span class="comment">/* Step 1: Initialize &#x27;env_free_list&#x27; with &#x27;LIST_INIT&#x27; and &#x27;env_sched_list&#x27; with</span></span><br><span class="line"><span class="comment">	 * &#x27;TAILQ_INIT&#x27;. */</span></span><br><span class="line">	<span class="comment">/* Exercise 3.1: Your code here. (1/2) */</span></span><br><span class="line">	LIST_INIT(&amp;env_free_list);</span><br><span class="line">	TAILQ_INIT(&amp;env_sched_list);</span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<p>这两个列表，准确来说是一个链表和一个尾队列（此类型的定义可以在 include/queue.h 中找到），其中的元素都是同一类型。我们可以在 include/env.h 中找到<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">LIST_HEAD(Env_list, Env);</span><br><span class="line">TAILQ_HEAD(Env_sched_list, Env);</span><br></pre></td></tr></table></figure></p>
<p>其中 <code>Env</code> 是如下的结构体，它被称为进程控制块（Process Control Block，PCB），其中保存了一个进程所拥有的不同的资源。或许因为是附属于进程，为进程提供支持的结构，就像是进程所处的环境一样，因此这里类型名为Env(ironment)。<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Env</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Trapframe</span> <span class="title">env_tf</span>;</span>  <span class="comment">// Saved registers</span></span><br><span class="line">	LIST_ENTRY(Env) env_link; <span class="comment">// Free list</span></span><br><span class="line">	u_int env_id;		  <span class="comment">// Unique environment identifier</span></span><br><span class="line">	u_int env_asid;		  <span class="comment">// ASID</span></span><br><span class="line">	u_int env_parent_id;	  <span class="comment">// env_id of this env&#x27;s parent</span></span><br><span class="line">	u_int env_status;	  <span class="comment">// Status of the environment</span></span><br><span class="line">	Pde *env_pgdir;		  <span class="comment">// Kernel virtual address of page dir</span></span><br><span class="line">	TAILQ_ENTRY(Env) env_sched_link;</span><br><span class="line">	u_int env_pri;</span><br><span class="line">	<span class="comment">// Lab 4 IPC</span></span><br><span class="line">	u_int env_ipc_value;   <span class="comment">// data value sent to us</span></span><br><span class="line">	u_int env_ipc_from;    <span class="comment">// envid of the sender</span></span><br><span class="line">	u_int env_ipc_recving; <span class="comment">// env is blocked receiving</span></span><br><span class="line">	u_int env_ipc_dstva;   <span class="comment">// va at which to map received page</span></span><br><span class="line">	u_int env_ipc_perm;    <span class="comment">// perm of page mapping received</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// Lab 4 fault handling</span></span><br><span class="line">	u_int env_user_tlb_mod_entry; <span class="comment">// user tlb mod handler</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// Lab 6 scheduler counts</span></span><br><span class="line">	u_int env_runs; <span class="comment">// number of times been env_run&#x27;ed</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>进程控制块中内容众多，不好一一解释。因此这里只稍微介绍一下和本次实验有关的字段。</p>
<ul>
<li><code>env_link</code>、<code>env_sched_link</code>：根据类型就可以看出，这两个字段就是存储链表信息的字段</li>
<li><code>env_tf</code>：此字段用于在陷入内核时保存当前进程所处状态的相关信息，比如寄存器的值、pc寄存器中的地址等等。它的类型名为 <code>Trapframe</code>，与栈帧（stack frame）类似，都是存储一段信息的结构，只不过此类型存储的是发生在陷入内核（trap）时的信息罢了。<code>Trapframe</code> 定义在 include/trap.h 中  <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Trapframe</span> &#123;</span></span><br><span class="line">    <span class="comment">/* Saved main processor registers. */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> regs[<span class="number">32</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Saved special registers. */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> cp0_status;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> hi;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> lo;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> cp0_badvaddr;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> cp0_cause;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> cp0_epc;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
<li><code>env_id</code>：此字段是进程的标识符，每个进程都唯一</li>
<li><code>env_status</code>：此字段中存储进程的当前状态，包括空闲、阻塞和可运行  <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> ENV_FREE 0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ENV_RUNNABLE 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ENV_NOT_RUNNABLE 2</span></span><br></pre></td></tr></table></figure></li>
<li><code>env_asid</code>：表示进程的 asid，用于 tlb 中</li>
<li><code>env_pgdir</code>：存储了当前进程拥有的页目录的虚拟地址</li>
<li><code>env_pri</code>：表示当前进程的优先级</li>
</ul>
<p>在本实验接下来的代码中，我们都会使用或看到这些字段。</p>
<p>现在让我们回到 <code>env_init</code>。看一下我们初始化的两个数据结构的名称。<code>env_free_list</code> 表示其中存储了所有空闲的进程控制块，<code>env_sched_list</code> 则意味着该列表用于组织进程的调度（schedule）。</p>
<h3 id="（3）map-segment-函数"><a href="#（3）map-segment-函数" class="headerlink" title="（3）map_segment 函数"></a>（3）map_segment 函数</h3><p>我们查看 <code>env_init</code> 的后续内容。首先，我们将所有的进程控制块都插入 <code>env_free_list</code> 中。并且标记所有块都为 <code>ENV_FREE</code>。这里插入时顺序反向，这只是指导书的要求而已。<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (i = NENV - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">	LIST_INSERT_HEAD(&amp;env_free_list, envs + i, env_link);</span><br><span class="line">	envs[i].env_status = ENV_FREE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在 <code>env_init</code> 中我们还需要做一件事，就是创建一个 “模板页目录”，设置该页将 pages 和 envs （即所有页控制块和所有进程控制块的内存空间）分别映射到 <code>UPAGES</code> 和 <code>UENVS</code> 的空间中。并且在后续进程创建新的页目录时，也要首先复制模板页目录中的内容。这样做的目的是使得用户程序也能够通过 <code>UPAGES</code> 和 <code>UENVS</code> 的用户地址空间获取 <code>Page</code> 和 <code>Env</code> 的信息。</p>
<p>我们首先调用 <code>page_alloc</code> 申请一个页<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Page</span> *<span class="title">p</span>;</span></span><br><span class="line">panic_on(page_alloc(&amp;p));</span><br><span class="line">p-&gt;pp_ref++;</span><br></pre></td></tr></table></figure></p>
<p>该页即 “模板页目录”，我们把它的地址存储到全局变量 <code>base_pgdir</code> 中<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">base_pgdir = (Pde *)page2kva(p);</span><br></pre></td></tr></table></figure></p>
<p>最后我们调用 <code>map_segment</code> 函数，该函数在指定的页目录中创建虚拟地址空间 <code>[va, va+size)</code> 到物理地址空间 <code>[pa, pa+size)</code> 的映射。并设置其权限（在这里我们设置其为只读，因为不希望用户程序修改内核空间的内容）。<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">	map_segment(base_pgdir, <span class="number">0</span>, PADDR(pages), UPAGES, ROUND(npage * <span class="keyword">sizeof</span>(<span class="keyword">struct</span> Page), BY2PG),</span><br><span class="line">		    PTE_G);</span><br><span class="line">	map_segment(base_pgdir, <span class="number">0</span>, PADDR(envs), UENVS, ROUND(NENV * <span class="keyword">sizeof</span>(<span class="keyword">struct</span> Env), BY2PG),</span><br><span class="line">		    PTE_G);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这样 <code>env_init</code> 函数就结束了。我们初始化了两个列表；将所有进程控制块插入空闲进程表；创建了一个 “模板页目录” 并将一部分内核空间的内容映射到用户空间。</p>
<p>接着我们考察 <code>map_segment</code> 函数。可以认为该函数是一个广义的 <code>page_insert</code>。它的功能是，在页目录 <code>pgdir</code> 中，将虚拟地址空间 <code>[va, va+size)</code> 映射到到物理地址空间 <code>[pa, pa+size)</code>，并赋予 <code>perm</code> 权限。<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">map_segment</span><span class="params">(Pde *pgdir, u_int asid, u_long pa, u_long va, u_int size, u_int perm)</span> &#123;</span><br></pre></td></tr></table></figure></p>
<p>它的实现也很简单，就是通过循环不断调用 <code>page_insert</code> 创建一个页大小的 <code>va</code> 到 <code>pa</code> 的映射，直到达到期望的 <code>size</code> 大小<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; size; i += BY2PG) &#123;</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * Hint:</span></span><br><span class="line"><span class="comment">		 *  Map the virtual page &#x27;va + i&#x27; to the physical page &#x27;pa + i&#x27; using &#x27;page_insert&#x27;.</span></span><br><span class="line"><span class="comment">		 *  Use &#x27;pa2page&#x27; to get the &#x27;struct Page *&#x27; of the physical address.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="comment">/* Exercise 3.2: Your code here. */</span></span><br><span class="line">		page_insert(pgdir, asid, pa2page(pa + i), va + i, perm);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这样进程控制的初始化就完成了。</p>
<h2 id="三、进程的创建"><a href="#三、进程的创建" class="headerlink" title="三、进程的创建"></a>三、进程的创建</h2><h3 id="（1）再再度-mips-init"><a href="#（1）再再度-mips-init" class="headerlink" title="（1）再再度 mips_init"></a>（1）再再度 mips_init</h3><p>我们再回到 <code>mips_init</code> 函数。进程控制初始化完成后，我们又调用 <code>ENV_CREATE_PRIORITY</code> 宏创建了两个进程。<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// lab3:</span></span><br><span class="line">ENV_CREATE_PRIORITY(user_bare_loop, <span class="number">1</span>);</span><br><span class="line">ENV_CREATE_PRIORITY(user_bare_loop, <span class="number">2</span>);</span><br></pre></td></tr></table></figure></p>
<p>该宏定义在 include/env.h 中。在同一个文件夹中还有另一个类似的宏 <code>ENV_CREATE</code>，相当于把 <code>ENV_CREATE_PRIORITY</code> 中的 <code>y</code> 设为 1。<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> ENV_CREATE_PRIORITY(x, y) \</span></span><br><span class="line"><span class="meta">	(&#123; \</span></span><br><span class="line"><span class="meta">		extern u_char binary_##x##_start[]; \</span></span><br><span class="line"><span class="meta">		extern u_int binary_##x##_size; \</span></span><br><span class="line"><span class="meta">		env_create(binary_##x##_start, (u_int)binary_##x##_size, y); \</span></span><br><span class="line"><span class="meta">	&#125;)</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<p>我们可以看出宏中定义了两个外部引用变量 <code>binary_##x##_start</code> 和 <code>binary_##x##_size</code>，对于 <code>mips_init</code> 中的使用来说即 <code>binary_user_bare_loop_start</code> 和 <code>binary_user_bare_loop_size</code>。接着我们调用了 <code>env_create</code> 函数。很明显该函数用于创建一个进程。</p>
<h3 id="（2）一种神奇的操作"><a href="#（2）一种神奇的操作" class="headerlink" title="（2）一种神奇的操作"></a>（2）一种神奇的操作</h3><p><code>env_create</code> 定义在 kern/env.c 中。在介绍该函数的内容之前，我们可以解释一下该函数的参数。<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> Env *<span class="title function_">env_create</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *binary, <span class="type">size_t</span> size, <span class="type">int</span> priority)</span> &#123;</span><br></pre></td></tr></table></figure></p>
<p>首先，<code>const void *binary</code> 是一个二进制的数据数组，该数组的大小为 <code>size_t size</code>，实际上此二进制数据即我们想要创建的进程的程序。最后一个参数 <code>int priority</code> 表示我们想要设置的进程的优先级，对应 <code>Env</code> 中的 <code>env_pri</code> 字段。</p>
<p>你可能会想，“不对呀，我们从哪里读入的程序？” 确实，我们根本没有进行磁盘操作。我们还没有实现文件系统，我们所 “加载” 的程序实际上是被一同编译到内核中的一段 ELF 格式的数据。这段数据中存在标签 <code>binary_user_bare_loop_start</code> 和 <code>binary_user_bare_loop_size</code>，所以我们才可以只通过引用外部变量的形式就 “加载” 了程序文件。</p>
<p>将 ELF 文件转化为 c 数组一同编译进内核程序的过程似乎较为复杂。本人也并不像如此深入此与操作系统无关的技术。但是经过简单的探索，我们还是可以了解到实现这一过程的程序的源代码为 tools/bintoc.c。此代码实现了一个程序，可以读取某一 ELF 文件的二进制内容，将其转化为一个 c 语言源代码文件。bintoc.c 的代码片段如下：<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">   <span class="type">size_t</span> n = fread(binary, <span class="keyword">sizeof</span>(<span class="type">char</span>), size, bin);</span><br><span class="line">assert(n == size);</span><br><span class="line"><span class="built_in">fprintf</span>(out,</span><br><span class="line">	<span class="string">&quot;unsigned int binary_%s_%s_size = %d;\n&quot;</span></span><br><span class="line">	<span class="string">&quot;unsigned char binary_%s_%s_start[] = &#123;&quot;</span>,</span><br><span class="line">	prefix, bin_file, size, prefix, bin_file);</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">	<span class="built_in">fprintf</span>(out, <span class="string">&quot;0x%x%c&quot;</span>, binary[i], i &lt; size - <span class="number">1</span> ? <span class="string">&#x27;,&#x27;</span> : <span class="string">&#x27;&#125;&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>另外，我们可以在 user/bar/Makefile 中找到如下内容<br><figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">INCLUDES    := -I../../<span class="keyword">include</span></span><br><span class="line"></span><br><span class="line"><span class="section">%.b.c: %.b</span></span><br><span class="line">	<span class="variable">$(tools_dir)</span>/bintoc -f <span class="variable">$&lt;</span> -o <span class="variable">$@</span> -p user_bare</span><br></pre></td></tr></table></figure></p>
<p>这些内容就足以使人察觉 “将 ELF 文件转化为 c 数组一同编译进内核程序” 的方法了。</p>
<h3 id="（3）进入-env-alloc-函数"><a href="#（3）进入-env-alloc-函数" class="headerlink" title="（3）进入 env_alloc 函数"></a>（3）进入 env_alloc 函数</h3><p>说了这么多没用的，我们还是回到 <code>env_create</code> 吧。首先，该函数通过调用 <code>env_alloc</code> 申请了一个新的空闲进程控制块。<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Env</span> *<span class="title">e</span>;</span></span><br><span class="line"><span class="comment">/* Step 1: Use &#x27;env_alloc&#x27; to alloc a new env. */</span></span><br><span class="line"><span class="comment">/* Exercise 3.7: Your code here. (1/3) */</span></span><br><span class="line">env_alloc(&amp;e, <span class="number">0</span>);</span><br></pre></td></tr></table></figure></p>
<p><code>env_alloc</code> 与 <code>page_alloc</code> 类似，都从空闲块列表中取出一个空闲块。但是 <code>env_alloc</code> 的后续处理更加复杂。首先 <code>env_alloc</code> 中同样取出一个空闲块。<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">env_alloc</span><span class="params">(<span class="keyword">struct</span> Env **new, u_int parent_id)</span> &#123;</span><br><span class="line">	<span class="type">int</span> r;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Env</span> *<span class="title">e</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Step 1: Get a free Env from &#x27;env_free_list&#x27; */</span></span><br><span class="line">	<span class="comment">/* Exercise 3.4: Your code here. (1/4) */</span></span><br><span class="line">	<span class="keyword">if</span> (LIST_EMPTY(&amp;env_free_list)) &#123;</span><br><span class="line">		<span class="keyword">return</span> -E_NO_FREE_ENV;</span><br><span class="line">	&#125;</span><br><span class="line">	e = LIST_FIRST(&amp;env_free_list);</span><br></pre></td></tr></table></figure></p>
<p>接着我们调用 <code>env_setup_vm</code> 初始化进程控制块的用户地址空间。也就是为进程控制块创建对应的二级页表。<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Step 2: Call a &#x27;env_setup_vm&#x27; to initialize the user address space for this new Env. */</span></span><br><span class="line"><span class="comment">/* Exercise 3.4: Your code here. (2/4) */</span></span><br><span class="line"><span class="keyword">if</span> ((r = env_setup_vm(e)) != <span class="number">0</span>) &#123;</span><br><span class="line">	<span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="（4）env-setup-vm-与页表自映射"><a href="#（4）env-setup-vm-与页表自映射" class="headerlink" title="（4）env_setup_vm 与页表自映射"></a>（4）env_setup_vm 与页表自映射</h3><p><code>env_setup_vm</code> 函数值得关注一下，我们查看一下该函数的内容。首先我们申请一个物理页作为页目录。可以看到我们这里设置了 <code>Env</code> 中 <code>env_pgdir</code> 字段的值<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">env_setup_vm</span><span class="params">(<span class="keyword">struct</span> Env *e)</span> &#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Page</span> *<span class="title">p</span>;</span></span><br><span class="line">	try(page_alloc(&amp;p));</span><br><span class="line">	<span class="comment">/* Exercise 3.3: Your code here. */</span></span><br><span class="line">	p-&gt;pp_ref++;</span><br><span class="line">	e-&gt;env_pgdir = (Pde *)page2kva(p);</span><br></pre></td></tr></table></figure></p>
<p>值得讲解的在后面。是否还记得我们之前花大篇幅讲解的 “模板页目录”？现在正在创建二级页表，我们可以将 “模板页目录” 中的内容复制到当前进程的页目录中。我们复制了 <code>UTOP</code> 到 <code>UVPT</code> 的虚拟地址空间对应的页表项。这就是我们之前在 “模板页目录” 中映射的区域。<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">memcpy</span>(e-&gt;env_pgdir + PDX(UTOP), base_pgdir + PDX(UTOP),</span><br><span class="line">       <span class="keyword">sizeof</span>(Pde) * (PDX(UVPT) - PDX(UTOP)));</span><br></pre></td></tr></table></figure></p>
<p><code>env_setup_vm</code> 函数还没有结束。在最后我们还执行了这样的语句<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">	e-&gt;env_pgdir[PDX(UVPT)] = PADDR(e-&gt;env_pgdir) | PTE_V;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>我们将 <code>UVPT</code> 虚拟地址映射到页目录本身的物理地址，并设置只读权限。这样的话，页目录中的项所对应的，就不只是二级页表，还包含有一个一级页表，也就是页目录自身。这就是自映射。我们在 Lab2 时从指导书上学到了关于自映射的理论。但到了 Lab3 才把它用代码表示了出来。</p>
<p>所以，自映射有什么用？指导书上的表达有些模糊不清，虽然我也没有信心能够表述明白，但我还是试一下吧。</p>
<blockquote>
<p>假设现在我们用比 <code>UVPT</code> 地址高一些的地址 <code>va</code> 进行访存，那么我们会取到那些信息呢？首先，这个地址会经过页目录，<code>PDX(va)</code> 的结果和 <code>UVPT</code> 相同，我们进入到索引对应的二级页表……不对，还是页目录自身！</p>
<p>好的，我们在页目录中重新来一遍，这次通过 <code>PTX(va)</code> 计算索引，结果就不一定还是页目录项了。我们找到了一个物理页，取出了其中的数据。可是等等，这个物理页却不再是一般的物理页了，而是作为二级页表的物理页。</p>
<p>另外假如我们恰好取得的 <code>PTX(va)</code> 值与 <code>PDX(va)</code> 相同，那么我们绕了两圈，最终还是处在页目录之中，我们取得的数据也是页目录中的内容。</p>
<p>这样我们就可以明白自映射的作用了。它在用户内存空间中划分出一部分，使得用户可以通过访问这部分空间得到二级页表以及页目录中的数据。</p>
<p>在 include/mmu.h 的内存分布图中，我们可以看出 <code>UVPT</code> 以上的 4kb（1024 个页表的大小）空间被标记为 <code>User VPT</code>。VPT 或为 virtual page table（虚拟页表）的意思。</p>
</blockquote>
<h3 id="（5）进程控制块的初始化"><a href="#（5）进程控制块的初始化" class="headerlink" title="（5）进程控制块的初始化"></a>（5）进程控制块的初始化</h3><p>我们回到 <code>env_alloc</code> 函数。此后的内容是初始化新申请的进程控制块。我们要设置一些字段的值后才算完成了进程控制块的申请。</p>
<p>一些内容和后续的实验有关，我们先不考虑，我们考虑本次试验中涉及的部分。这里我们设置了 <code>env_id</code>、<code>env_parent_id</code> 和 <code>env_asid</code> 的值。其中 <code>env_parent_id</code> 设置为 <code>env_alloc</code> 的参数。而 <code>env_id</code> 和 <code>env_asid</code> 因为需要不重复，所以通过两个函数分别申请。<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">e-&gt;env_user_tlb_mod_entry = <span class="number">0</span>; <span class="comment">// for lab4</span></span><br><span class="line">e-&gt;env_runs = <span class="number">0</span>;	       <span class="comment">// for lab6</span></span><br><span class="line"><span class="comment">/* Exercise 3.4: Your code here. (3/4) */</span></span><br><span class="line">e-&gt;env_id = mkenvid(e);</span><br><span class="line">e-&gt;env_parent_id = parent_id;</span><br><span class="line"><span class="keyword">if</span> ((r = asid_alloc(&amp;e-&gt;env_asid)) != <span class="number">0</span>) &#123;</span><br><span class="line">	<span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>mkenvid</code> 的内容较为简单，只是通过一个函数内的静态变量实现不重复的。<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">u_int <span class="title function_">mkenvid</span><span class="params">(<span class="keyword">struct</span> Env *e)</span> &#123;</span><br><span class="line">	<span class="type">static</span> u_int i = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">return</span> ((++i) &lt;&lt; (<span class="number">1</span> + LOG2NENV)) | (e - envs);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>而 <code>asid_alloc</code> 则是设置了一个 <code>asid_bitmap</code> 用来管理 asid 的分配情况，这是因为 asid 是有限的（2^6=64）。当所有的 asid 都被分配以后，应该返回异常。<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">uint32_t</span> asid_bitmap[NASID / <span class="number">32</span>] = &#123;<span class="number">0</span>&#125;; <span class="comment">// 64</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Overview:</span></span><br><span class="line"><span class="comment"> *  Allocate an unused ASID.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Post-Condition:</span></span><br><span class="line"><span class="comment"> *   return 0 and set &#x27;*asid&#x27; to the allocated ASID on success.</span></span><br><span class="line"><span class="comment"> *   return -E_NO_FREE_ENV if no ASID is available.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">asid_alloc</span><span class="params">(u_int *asid)</span> &#123;</span><br><span class="line">	<span class="keyword">for</span> (u_int i = <span class="number">0</span>; i &lt; NASID; ++i) &#123;</span><br><span class="line">		<span class="type">int</span> index = i &gt;&gt; <span class="number">5</span>;</span><br><span class="line">		<span class="type">int</span> inner = i &amp; <span class="number">31</span>;</span><br><span class="line">		<span class="keyword">if</span> ((asid_bitmap[index] &amp; (<span class="number">1</span> &lt;&lt; inner)) == <span class="number">0</span>) &#123;</span><br><span class="line">			asid_bitmap[index] |= <span class="number">1</span> &lt;&lt; inner;</span><br><span class="line">			*asid = i;</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> -E_NO_FREE_ENV;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>继续 <code>env_alloc</code> 函数，在最后，我们设置进程的 <code>status</code> 寄存器和 <code>sp</code> 寄存器的值。<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">	<span class="comment">/* Step 4: Initialize the sp and &#x27;cp0_status&#x27; in &#x27;e-&gt;env_tf&#x27;. */</span></span><br><span class="line">	<span class="comment">// Timer interrupt (STATUS_IM4) will be enabled.</span></span><br><span class="line">	e-&gt;env_tf.cp0_status = STATUS_IM4 | STATUS_KUp | STATUS_IEp;</span><br><span class="line">	<span class="comment">// Keep space for &#x27;argc&#x27; and &#x27;argv&#x27;.</span></span><br><span class="line">	e-&gt;env_tf.regs[<span class="number">29</span>] = USTACKTOP - <span class="keyword">sizeof</span>(<span class="type">int</span>) - <span class="keyword">sizeof</span>(<span class="type">char</span> **);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Step 5: Remove the new Env from env_free_list. */</span></span><br><span class="line">	<span class="comment">/* Exercise 3.4: Your code here. (4/4) */</span></span><br><span class="line">	LIST_REMOVE(e, env_link);</span><br><span class="line"></span><br><span class="line">	*new = e;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>将<code>status</code> 寄存器的值设置为 <code>STATUS_IM4 | STATUS_KUp | STATUS_IEp</code>，表示响应 4 号中断，是用户状态且开启中断。所有的通用寄存器状态在 <code>Trapframe</code> 中存储在 <code>regs</code> 数组中，其中第 29 号寄存器为 <code>sp</code> 寄存器。这一点可从 include/asm/regdef.h 中得知<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> sp $29 <span class="comment">/* stack pointer */</span></span></span><br></pre></td></tr></table></figure></p>
<p>在未执行的情况下，用户程序的 sp 寄存器应该处于栈顶 <code>USTACKTOP</code> 的位置。但为了给程序的 <code>main</code> 函数的参数 <code>argc</code> 和 <code>argv</code> 留出空间，需要减去 <code>sizeof(int) + sizeof(char **)</code> 的大小。</p>
<p>这样我们就完成了对 <code>env_alloc</code> 函数的讲解。</p>
<h3 id="（6）加载-ELF-文件"><a href="#（6）加载-ELF-文件" class="headerlink" title="（6）加载 ELF 文件"></a>（6）加载 ELF 文件</h3><p>经历了这么多，我们都快忘记最开始我们的目标，<code>env_create</code> 函数了。让我们接着 <code>env_alloc</code> 之后的内容。现在对于调用 <code>env_alloc</code> 得到的新进程控制块，我们设置它的优先级以及状态。<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Step 2: Assign the &#x27;priority&#x27; to &#x27;e&#x27; and mark its &#x27;env_status&#x27; as runnable. */</span></span><br><span class="line"><span class="comment">/* Exercise 3.7: Your code here. (2/3) */</span></span><br><span class="line">e-&gt;env_pri = priority;</span><br><span class="line">e-&gt;env_status = ENV_RUNNABLE;</span><br></pre></td></tr></table></figure></p>
<p>最后，我们调用 <code>load_icode</code> 为进程加载 ELF 程序，同时使用 <code>TAILQ_INSERT_HEAD</code> 宏将进程控制块加入到调度队列中<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">	<span class="comment">/* Step 3: Use &#x27;load_icode&#x27; to load the image from &#x27;binary&#x27;, and insert &#x27;e&#x27; into</span></span><br><span class="line"><span class="comment">	 * &#x27;env_sched_list&#x27; using &#x27;TAILQ_INSERT_HEAD&#x27;. */</span></span><br><span class="line">	<span class="comment">/* Exercise 3.7: Your code here. (3/3) */</span></span><br><span class="line">	load_icode(e, binary, size);</span><br><span class="line">	TAILQ_INSERT_HEAD(&amp;env_sched_list, e, env_sched_link);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> e;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>我们就差最后一步就完成了 “进程的创建” 这一节的内容了，现在我们要分析 <code>load_icode</code> 中加载二进制镜像功能的实现。函数名中 icode 似乎指 image code 的意思。<code>load_icode</code> 同样在 kern/env.c 中。</p>
<p>首先该函数调用了 <code>elf_from</code> 函数从二进制数据中读取了页表信息。<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">load_icode</span><span class="params">(<span class="keyword">struct</span> Env *e, <span class="type">const</span> <span class="type">void</span> *binary, <span class="type">size_t</span> size)</span> &#123;</span><br><span class="line">	<span class="comment">/* Step 1: Use &#x27;elf_from&#x27; to parse an ELF header from &#x27;binary&#x27;. */</span></span><br><span class="line">	<span class="type">const</span> Elf32_Ehdr *ehdr = elf_from(binary, size);</span><br><span class="line">	<span class="keyword">if</span> (!ehdr) &#123;</span><br><span class="line">		panic(<span class="string">&quot;bad elf at %x&quot;</span>, binary);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>elf_from</code> 函数定义在 lib/elfloader.c 中。只是简单地对二进制数据做类型转换，并检查是否确为 ELF 文件头。<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> Elf32_Ehdr *<span class="title function_">elf_from</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *binary, <span class="type">size_t</span> size)</span> &#123;</span><br><span class="line">	<span class="type">const</span> Elf32_Ehdr *ehdr = (<span class="type">const</span> Elf32_Ehdr *)binary;</span><br><span class="line">	<span class="keyword">if</span> (size &gt;= <span class="keyword">sizeof</span>(Elf32_Ehdr) &amp;&amp; ehdr-&gt;e_ident[EI_MAG0] == ELFMAG0 &amp;&amp;</span><br><span class="line">	    ehdr-&gt;e_ident[EI_MAG1] == ELFMAG1 &amp;&amp; ehdr-&gt;e_ident[EI_MAG2] == ELFMAG2 &amp;&amp;</span><br><span class="line">	    ehdr-&gt;e_ident[EI_MAG3] == ELFMAG3 &amp;&amp; ehdr-&gt;e_type == <span class="number">2</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> ehdr;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>接着在 <code>load_icode</code> 中使用了一个宏 <code>ELF_FOREACH_PHDR_OFF</code> 来遍历所有的程序头表<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Step 2: Load the segments using &#x27;ELF_FOREACH_PHDR_OFF&#x27; and &#x27;elf_load_seg&#x27;.</span></span><br><span class="line"><span class="comment"> * As a loader, we just care about loadable segments, so parse only program headers here.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">size_t</span> ph_off;</span><br><span class="line">ELF_FOREACH_PHDR_OFF (ph_off, ehdr) &#123;</span><br></pre></td></tr></table></figure></p>
<p>这个宏定义在 include/elf.h 中。很容易看出作用<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> ELF_FOREACH_PHDR_OFF(ph_off, ehdr) \</span></span><br><span class="line"><span class="meta">	(ph_off) = (ehdr)-&gt;e_phoff; \</span></span><br><span class="line"><span class="meta">	for (int _ph_idx = 0; _ph_idx <span class="string">&lt; (ehdr)-&gt;</span>e_phnum; ++_ph_idx, (ph_off) += (ehdr)-&gt;e_phentsize)</span></span><br></pre></td></tr></table></figure></p>
<p>在循环中，取出对应的程序头，如果其中的 <code>p_type</code> 类型为 <code>PT_LOAD</code>，说明其对应的程序需要被加载到内存中。我们调用 <code>elf_load_seg</code> 函数来进行加载<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">	Elf32_Phdr *ph = (Elf32_Phdr *)(binary + ph_off);</span><br><span class="line">	<span class="keyword">if</span> (ph-&gt;p_type == PT_LOAD) &#123;</span><br><span class="line">		<span class="comment">// &#x27;elf_load_seg&#x27; is defined in lib/elfloader.c</span></span><br><span class="line">		<span class="comment">// &#x27;load_icode_mapper&#x27; defines the way in which a page in this segment</span></span><br><span class="line">		<span class="comment">// should be mapped.</span></span><br><span class="line">		panic_on(elf_load_seg(ph, binary + ph-&gt;p_offset, load_icode_mapper, e));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在 <code>load_icode</code> 函数的最后，我们将进程控制块中 trap frame 的 epc cp0 寄存器的值设置为 ELF 文件中设定的程序入口地址<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">	<span class="comment">/* Step 3: Set &#x27;e-&gt;env_tf.cp0_epc&#x27; to &#x27;ehdr-&gt;e_entry&#x27;. */</span></span><br><span class="line">	<span class="comment">/* Exercise 3.6: Your code here. */</span></span><br><span class="line">	e-&gt;env_tf.cp0_epc = ehdr-&gt;e_entry;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这样 <code>load_icode</code> 部分也完成了。让我们回过头查看一下 <code>elf_load_seg</code> 函数。该函数定义在 lib/elfloader.c 中。作用是根据程序头表中的信息将 <code>bin</code> 中的数据加载到指定位置。值得关注该函数的参数，<code>elf_mapper_t map_page</code> 是一个回调函数，用于将数据映射到虚拟地址所在的页上；<code>void *data</code> 则是回调函数中使用的参数。<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">elf_load_seg</span><span class="params">(Elf32_Phdr *ph, <span class="type">const</span> <span class="type">void</span> *bin, <span class="type">elf_mapper_t</span> map_page, <span class="type">void</span> *data)</span> &#123;</span><br><span class="line">	u_long va = ph-&gt;p_vaddr;</span><br><span class="line">	<span class="type">size_t</span> bin_size = ph-&gt;p_filesz;</span><br><span class="line">	<span class="type">size_t</span> sgsize = ph-&gt;p_memsz;</span><br><span class="line">	u_int perm = PTE_V;</span><br><span class="line">	<span class="keyword">if</span> (ph-&gt;p_flags &amp; PF_W) &#123;</span><br><span class="line">		perm |= PTE_D;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>elf_mapper_t</code> 定义在 include/elf.h 中。此类型的函数接受数据要加载到的虚拟地址 <code>va</code>，数据加载的起始位置相对于页的偏移 <code>offset</code>，页的权限 <code>prem</code>，所要加载的数据 <code>src</code> 和要加载的数据大小 <code>len</code>。当然还有 <code>data</code>，但这个让我们留到后面。<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="title function_">int</span> <span class="params">(*<span class="type">elf_mapper_t</span>)</span><span class="params">(<span class="type">void</span> *data, u_long va, <span class="type">size_t</span> offset, u_int perm, <span class="type">const</span> <span class="type">void</span> *src,</span></span><br><span class="line"><span class="params">			    <span class="type">size_t</span> len)</span>;</span><br></pre></td></tr></table></figure></p>
<p>在 <code>elf_load_seg</code> 中，我们首先需要处理要加载的虚拟地址不与页对齐的情况。我们将最开头不对齐的部分 “剪切” 下来，先映射到内存的页中。<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> r;</span><br><span class="line"><span class="type">size_t</span> i;</span><br><span class="line">u_long offset = va - ROUNDDOWN(va, BY2PG);</span><br><span class="line"><span class="keyword">if</span> (offset != <span class="number">0</span>) &#123;</span><br><span class="line">	<span class="keyword">if</span> ((r = map_page(data, va, offset, perm, bin, MIN(bin_size, BY2PG - offset))) !=</span><br><span class="line">	    <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> r;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>接着我们处理数据中间完整的部分。我们通过循环不断将数据加载到页上。<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Step 1: load all content of bin into memory. */</span></span><br><span class="line"><span class="keyword">for</span> (i = offset ? MIN(bin_size, BY2PG - offset) : <span class="number">0</span>; i &lt; bin_size; i += BY2PG) &#123;</span><br><span class="line">	<span class="keyword">if</span> ((r = map_page(data, va + i, <span class="number">0</span>, perm, bin + i, MIN(bin_size - i, BY2PG))) != <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> r;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>最后我们处理段大小大于数据大小的情况。在这一部分，我们不断创建新的页，但是并不向其中加载任何内容。<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">	<span class="comment">/* Step 2: alloc pages to reach `sgsize` when `bin_size` &lt; `sgsize`. */</span></span><br><span class="line">	<span class="keyword">while</span> (i &lt; sgsize) &#123;</span><br><span class="line">		<span class="keyword">if</span> ((r = map_page(data, va + i, <span class="number">0</span>, perm, <span class="literal">NULL</span>, MIN(bin_size - i, BY2PG))) != <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> r;</span><br><span class="line">		&#125;</span><br><span class="line">		i += BY2PG;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这节的最最后，我们查看一下在本次实验中使用的回调函数 <code>load_icode_mapper</code>。根据 <code>load_icode</code> 中 <code>elf_load_seg</code> 传入的参数可知，此时我们的 <code>data</code> 为要加载程序镜像的进程对应的进程控制块。<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">panic_on(elf_load_seg(ph, binary + ph-&gt;p_offset, load_icode_mapper, e));</span><br></pre></td></tr></table></figure></p>
<p><code>load_icode_mapper</code> 定义在 kern/env.c 中。在函数的一开始，我们就将 <code>data</code> 还原为进程控制块<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">load_icode_mapper</span><span class="params">(<span class="type">void</span> *data, u_long va, <span class="type">size_t</span> offset, u_int perm, <span class="type">const</span> <span class="type">void</span> *src,</span></span><br><span class="line"><span class="params">			     <span class="type">size_t</span> len)</span> &#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Env</span> *<span class="title">env</span> =</span> (<span class="keyword">struct</span> Env *)data;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Page</span> *<span class="title">p</span>;</span></span><br><span class="line">	<span class="type">int</span> r;</span><br></pre></td></tr></table></figure></p>
<p>我们想要将数据加载到内存，首先需要申请物理页。调用 <code>page_alloc</code> 函数申请空闲页<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Step 1: Allocate a page with &#x27;page_alloc&#x27;. */</span></span><br><span class="line"><span class="comment">/* Exercise 3.5: Your code here. (1/2) */</span></span><br><span class="line"><span class="keyword">if</span> ((r = page_alloc(&amp;p)) != <span class="number">0</span>) &#123;</span><br><span class="line">	<span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>接着，如果存在需要拷贝的数据，则将该数据复制到新申请的页所对应的内存空间中。我们使用 <code>page2kva</code> 获取页所对应的内核虚拟地址。另外注意这里需要考虑 <code>offset</code>。<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Step 2: If &#x27;src&#x27; is not NULL, copy the &#x27;len&#x27; bytes started at &#x27;src&#x27; into &#x27;offset&#x27; at this</span></span><br><span class="line"><span class="comment"> * page. */</span></span><br><span class="line"><span class="comment">// Hint: You may want to use &#x27;memcpy&#x27;.</span></span><br><span class="line"><span class="keyword">if</span> (src != <span class="literal">NULL</span>) &#123;</span><br><span class="line">	<span class="comment">/* Exercise 3.5: Your code here. (2/2) */</span></span><br><span class="line">	<span class="built_in">memcpy</span>((<span class="type">void</span> *)(page2kva(p) + offset), src, len);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>最后我们调用 <code>page_insert</code> 将虚拟地址映射到页上。为了区别不同进程的相同虚拟地址，我们需要附加 asid 信息，asid 保存在进程控制块中，这也是我们需要将进程控制块传入回调函数的原因。<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">	<span class="comment">/* Step 3: Insert &#x27;p&#x27; into &#x27;env-&gt;env_pgdir&#x27; at &#x27;va&#x27; with &#x27;perm&#x27;. */</span></span><br><span class="line">	<span class="keyword">return</span> page_insert(env-&gt;env_pgdir, env-&gt;env_asid, p, va, perm);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>到此为止，我们终于完成了进程创建的流程。在这一过程中，我们申请了新的进程控制块，初始化了该控制块的虚拟内存管理机制以及 trap frame 等其他信息。并将程序镜像加载到了该进程独占的虚拟内存空间中。</p>
<p>但是到目前为止，我们的进程还未运行起来，还不是动态的程序；仅是在内存空间中的一些有组织的数据而已。在接下来的小节中，我们会让进程运行起来。</p>
<h2 id="四、异常处理"><a href="#四、异常处理" class="headerlink" title="四、异常处理"></a>四、异常处理</h2><h3 id="（1）中断的初始化"><a href="#（1）中断的初始化" class="headerlink" title="（1）中断的初始化"></a>（1）中断的初始化</h3><p>让我们在这一次实验中最后一次查看一下 <code>mips_init</code> 函数。在该函数的最后是一个死循环。这样的程序要如何退出呢？看似在这种情况下，其他程序都不能执行。这似乎是正确的，如果在没有开启中断的情况下。</p>
<p>然而，我们在死循环之前调用了两个函数 <code>kclock_init</code>，<code>enable_irq</code>。这两个函数是跳出死循环，实现进程运行的关键。</p>
<p>让我们深入 <code>kclock_init</code>，这是一个用汇编编写的函数，定义在 kern/kclock.S 中。该函数的作用是启用时钟。使其以 200Hz 的频率触发时钟中断。<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">LEAF(kclock_init)</span><br><span class="line">	li      t0, <span class="number">200</span> <span class="comment">// the timer interrupt frequency in Hz</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Write &#x27;t0&#x27; into the timer (RTC) frequency register.</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * Hint:</span></span><br><span class="line"><span class="comment">	 *   You may want to use &#x27;sw&#x27; instruction and constants &#x27;DEV_RTC_ADDRESS&#x27; and</span></span><br><span class="line"><span class="comment">	 *   &#x27;DEV_RTC_HZ&#x27; defined in include/drivers/dev_rtc.h.</span></span><br><span class="line"><span class="comment">	 *   To access device through mmio, a physical address must be converted to a</span></span><br><span class="line"><span class="comment">	 *   kseg1 address.</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * Reference: http://gavare.se/gxemul/gxemul-stable/doc/experiments.html#expdevices</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="comment">/* Exercise 3.11: Your code here. */</span></span><br><span class="line">	sw	t0, (KSEG1 | DEV_RTC_ADDRESS | DEV_RTC_HZ)</span><br><span class="line"></span><br><span class="line">	jr      ra</span><br><span class="line"><span class="title function_">END</span><span class="params">(kclock_init)</span></span><br></pre></td></tr></table></figure></p>
<p>这个函数的内容很简单，只是将数值 200 存入内存中的某一地址。地址 <code>KSEG1 | DEV_RTC_ADDRESS | DEV_RTC_HZ</code> 的形式我们已经在 Lab1 和 Lab2 遇到过类似的了。唯一需要注意的是这里汇编的写法，直接将一个表达式作为汇编指令的参数。如果事先未见过这种写法似乎很难想到。</p>
<p>但是现在 cpu 依旧无法收到时钟异常。如果还记得 Lab1 中关于 <code>_start</code> 函数的内容，应该可以记得我们在最开始便屏蔽了中断<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">EXPORT(_start)</span><br><span class="line">.<span class="built_in">set</span> at</span><br><span class="line">.<span class="built_in">set</span> reorder</span><br><span class="line">	<span class="comment">/* disable interrupts */</span></span><br><span class="line">	mtc0    zero, CP0_STATUS</span><br></pre></td></tr></table></figure></p>
<p>现在我们要中断使能，实现该功能的函数即 <code>enable_irq</code>，位于 kern/env_asm.S 中。irq 为 interrupt request 的缩写。<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">LEAF(enable_irq)</span><br><span class="line">	li      t0, (STATUS_CU0 | STATUS_IM4 | STATUS_IEc)</span><br><span class="line">	mtc0    t0, CP0_STATUS</span><br><span class="line">	jr      ra</span><br><span class="line"><span class="title function_">END</span><span class="params">(enable_irq)</span></span><br></pre></td></tr></table></figure></p>
<p>可以看到该函数的内容与 <code>_start</code> 中的指令相对应。这里我们为 cp0 寄存器 <code>status</code> 设置了值 <code>STATUS_CU0 | STATUS_IM4 | STATUS_IEc</code>。如果对 <code>status</code> 寄存器还有印象，应该能记得在 “进程控制块的初始化” 一节中我们设置了 trap frame 中的 <code>status</code> 寄存器的值。那时我们似乎已经设置了 4 号中断（4 号中断就是时钟中断），也使能了中断，为何现在还要设置？</p>
<p>因为那时我们只是设置了进程开始运行时，<code>status</code> 的状态；而还未设置当前的内核初始化环境中的状态。当系统切换到用户态，运行进程的时候，我们会用进程的状态覆盖之前的状态。现在设置 <code>status</code> 寄存器后，我们才能通过时钟中断进行上下文切换。也就是说，<code>enable_irq</code> 只是开启了内核初始化程序的中断，而开启中断的唯一目的就是通过时钟中断切换到第一个进程。</p>
<p>另外请注意，在之前我们设置的值为 <code>STATUS_IEp</code>，而此处为 <code>STATUS_IEc</code>，为什么两者位置却同样表示中断使能？实际上这来自于用户态和内核态的区别，具体可见实验指导书。</p>
<h3 id="（2）异常处理流程"><a href="#（2）异常处理流程" class="headerlink" title="（2）异常处理流程"></a>（2）异常处理流程</h3><p>中断是一种异常，当产生时钟中断时，cpu 就将执行异常处理流程。具体来说，当异常产生时，cpu 就会自动跳转到虚拟地址 <code>0x80000080</code> 处（特别的，当在用户态产生 TLB miss 异常时，会跳转到 <code>0x80000000</code>），从此处执行程序。这一程序应该完成异常的处理，并使 cpu 返回正常程序。</p>
<p>对于 MOS 来说，此处实现了一个异常分发函数，根据异常的不同类型选择不同的异常处理函数。此函数在 init/entry.S 中。<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">.section .text.tlb_miss_entry</span><br><span class="line">tlb_miss_entry:</span><br><span class="line">	j       exc_gen_entry</span><br><span class="line"></span><br><span class="line">.section .text.exc_gen_entry</span><br><span class="line">exc_gen_entry:</span><br><span class="line">	SAVE_ALL</span><br><span class="line"><span class="comment">/* Exercise 3.9: Your code here. */</span></span><br><span class="line">	mfc0 	t0, CP0_CAUSE</span><br><span class="line">	andi 	t0, <span class="number">0x7c</span></span><br><span class="line">	lw 	t0, exception_handlers(t0)</span><br><span class="line">	jr 	t0</span><br></pre></td></tr></table></figure></p>
<p><code>tlb_miss_entry</code> 用于处理 TLB miss 异常，但实际上就是跳转到 <code>exc_gen_entry</code>。而在 <code>exc_gen_entry</code> 中，我们首先使用了一个宏 <code>SAVE_ALL</code>，该宏定义了一大段指令，用于将所有的寄存器值存储到栈帧中。这样我们便保存了异常发生时的上下文。唯一需要注意的是，在 <code>SAVE_ALL</code> 中，我们将栈帧的初始位置设置为 <code>KSTACKTOP</code>（之前的 <code>sp</code> 位置保存在 <code>TF_REG29(sp)</code>）。<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// clang-format off</span></span><br><span class="line">.macro SAVE_ALL</span><br><span class="line">.<span class="built_in">set</span> noreorder</span><br><span class="line">.<span class="built_in">set</span> noat</span><br><span class="line">	move    k0, sp</span><br><span class="line">.<span class="built_in">set</span> reorder</span><br><span class="line">	bltz    sp, <span class="number">1f</span></span><br><span class="line">	li      sp, KSTACKTOP</span><br><span class="line">.<span class="built_in">set</span> noreorder</span><br><span class="line"><span class="number">1</span>:</span><br><span class="line">	subu    sp, sp, TF_SIZE</span><br><span class="line">	sw      k0, TF_REG29(sp)</span><br><span class="line">	mfc0    k0, CP0_STATUS</span><br><span class="line">	sw      k0, TF_STATUS(sp)</span><br><span class="line"><span class="comment">// omit...</span></span><br><span class="line">	sw      $<span class="number">0</span>, TF_REG0(sp)</span><br><span class="line">	sw      $<span class="number">1</span>, TF_REG1(sp)</span><br><span class="line">	sw      $<span class="number">2</span>, TF_REG2(sp)</span><br><span class="line">	sw      $<span class="number">3</span>, TF_REG3(sp)</span><br><span class="line"><span class="comment">// omit...</span></span><br></pre></td></tr></table></figure></p>
<p>接下来我们获取 <code>cause</code> 寄存器的值，取其 2-6 位，这部分对应异常码，用于区别不同的异常。<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">mfc0 	t0, CP0_CAUSE</span><br><span class="line">andi 	t0, <span class="number">0x7c</span></span><br></pre></td></tr></table></figure></p>
<p>接下来的这一部分，我们从 <code>exception_handlers</code> 数组中取出异常码对应的处理函数，并跳转到该异常处理函数。<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">lw 	t0, exception_handlers(t0)</span><br><span class="line">jr 	t0</span><br></pre></td></tr></table></figure></p>
<p>其中 <code>exception_handlers</code> 定义在 kern/traps.c 中。该数组是一个函数数组，其中每个元素都是异常码对应的异常处理函数。此数组称为异常向量组。<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">handle_int</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">handle_tlb</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">handle_sys</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">handle_mod</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">handle_reserved</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> (*exception_handlers[<span class="number">32</span>])(<span class="type">void</span>) = &#123;</span><br><span class="line">    [<span class="number">0</span> ... <span class="number">31</span>] = handle_reserved,</span><br><span class="line">    [<span class="number">0</span>] = handle_int,</span><br><span class="line">    [<span class="number">2</span> ... <span class="number">3</span>] = handle_tlb,</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> !defined(LAB) || LAB &gt;= 4</span></span><br><span class="line">    [<span class="number">1</span>] = handle_mod,</span><br><span class="line">    [<span class="number">8</span>] = handle_sys,</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>需要注意的有两点。</p>
<ul>
<li>第一是此数组的定义似乎语法很奇怪。此语法是 GNU C 的扩展语法，<code>[first ... last] = value</code> 用于对数组上某个区间上元素赋同一个值。</li>
<li>第二是 <code>exc_gen_entry</code> 中我们直接将 <code>andi     t0, 0x7c</code> 的结果作为索引。这里需要注意一个地址 4 字节。</li>
</ul>
<p>最后，<code>tlb_miss_entry</code> 和 <code>exc_gen_entry</code> 还未被放在 <code>0x80000000</code> 和 <code>0x80000080</code> 处。我们需要在 kernel.lds 中添加内容，将这两个标签固定在特定的地址位置。<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">SECTIONS &#123;</span><br><span class="line">	<span class="comment">/* Exercise 3.10: Your code here. */</span></span><br><span class="line">	. = <span class="number">0x80000000</span>;</span><br><span class="line">	.tlb_miss_entry : &#123;</span><br><span class="line">		*(.text.tlb_miss_entry)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	. = <span class="number">0x80000080</span>;</span><br><span class="line">	.exc_gen_entry : &#123;</span><br><span class="line">		*(.text.exc_gen_entry)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// omit...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="（3）异常处理函数在哪里定义？"><a href="#（3）异常处理函数在哪里定义？" class="headerlink" title="（3）异常处理函数在哪里定义？"></a>（3）异常处理函数在哪里定义？</h3><p>如果你想了解一下不同异常的异常处理函数，可能会发现自己根本找不到 <code>handle_tlb</code>、<code>handle_mod</code> 等函数的定义。实际上这些函数都定义在 kern/genex.S 中。</p>
<p>当然，<code>handle_int</code> 的定义我们可以很直接地找到，此函数与中断有关，因此我们放到后面。</p>
<p>请关注位于该文件开头的宏 <code>BUILD_HANDLER</code>，构建处理函数。我们可以看到该宏有两个参数，<code>exception</code> 和 <code>handler</code>。在该宏中，我们定义了一个 <code>handle_\exception</code> 的函数，该函数调用 <code>\handler</code> 函数。返回后再调用 <code>ret_from_exception</code>（并且不返回？！）。<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">.macro BUILD_HANDLER exception handler</span><br><span class="line"><span class="title function_">NESTED</span><span class="params">(handle_\exception, TF_SIZE, zero)</span></span><br><span class="line">	move    a0, sp</span><br><span class="line">	jal     \handler</span><br><span class="line">	j       ret_from_exception</span><br><span class="line"><span class="title function_">END</span><span class="params">(handle_\exception)</span></span><br><span class="line">.endm</span><br></pre></td></tr></table></figure></p>
<p>让我们先不关注对 <code>ret_from_exception</code> 的调用。通过查看该宏的定义，应该可以理解 <code>handle_tlb</code> 是在哪里定义的了。我们可以在 genex.S 的最后看到如下语句。这就是异常处理函数的定义。<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">BUILD_HANDLER tlb do_tlb_refill</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> !defined(LAB) || LAB &gt;= 4</span></span><br><span class="line">BUILD_HANDLER mod do_tlb_mod</span><br><span class="line">BUILD_HANDLER sys do_syscall</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">BUILD_HANDLER reserved do_reserved</span><br></pre></td></tr></table></figure></p>
<p>我们可以看到一个似曾相识的名字 <code>do_tlb_refill</code>。这个函数可以说是 Lab2 的核心。在 Lab2 的测试中我们只是模拟 tlb 的重填，而在 Lab3 中，我们终于将该函数实际应用了。</p>
<p>其他的异常处理函数与本次实验无关，因此在本篇文章中就不考虑了。</p>
<h3 id="（4）ret-from-exception-函数"><a href="#（4）ret-from-exception-函数" class="headerlink" title="（4）ret_from_exception 函数"></a>（4）ret_from_exception 函数</h3><p>当异常处理完成后，我们便希望能返回到正常的程序中。<code>ret_from_exception</code> 便用于从异常处理程序中返回，除了使用 <code>BUILD_HANDLER</code> 创建的处理函数，<code>handle_int</code> 的处理过程中也使用了 <code>ret_from_exception</code>，这我们留到下一节介绍。</p>
<p>现在我们分析 <code>ret_from_exception</code> 函数。该函数定义在 kern/genex.S 中。首先该函数调用了一个宏 <code>RESTORE_SOME</code>，用于还原栈帧中通过调用 <code>SAVE_ALL</code> 保存的（部分）上下文。该宏和 <code>SAVE_ALL</code> 一样定义在 include/stackframe.h 中，不再详细介绍。<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">FEXPORT(ret_from_exception)</span><br><span class="line">	RESTORE_SOME</span><br></pre></td></tr></table></figure></p>
<p>接着将 epc 寄存器的值加载到 k0 寄存器，epc 寄存器中存储有异常处理结束后的返回地址（各位应该还对 <code>TrapFrame</code> 结构体中的 <code>cp0_epc</code> 字段有印象）；随后将所有栈帧中关于上下文的内容弹出。<code>TF_REG29(sp)</code> 地址中保存了 sp 寄存器在调用 <code>SAVE_ALL</code> 之前的地址。<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">lw      k0, TF_EPC(sp)</span><br><span class="line">lw      sp, TF_REG29(sp) <span class="comment">/* Deallocate stack */</span></span><br></pre></td></tr></table></figure></p>
<p>最后，跳转到 k0 中的返回地址。但在此之后还有另一条指令 <code>rfe</code>，用来从异常中恢复（恢复 <code>status</code> 寄存器，从内核态恢复到用户态）。<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">.<span class="built_in">set</span> noreorder</span><br><span class="line">	jr      k0</span><br><span class="line">	rfe</span><br><span class="line">.<span class="built_in">set</span> reorder</span><br></pre></td></tr></table></figure></p>
<p>这样关于异常处理的部分我们就介绍完成了。</p>
<h2 id="五、进程的调度"><a href="#五、进程的调度" class="headerlink" title="五、进程的调度"></a>五、进程的调度</h2><h3 id="（1）从-handle-int-函数继续"><a href="#（1）从-handle-int-函数继续" class="headerlink" title="（1）从 handle_int 函数继续"></a>（1）从 handle_int 函数继续</h3><p>在操作系统中，使用时钟来划分时间片。当时钟中断发生时，就需要进行进程调度。在上一节中我们分析了 MOS 中的异常处理原理。在这一节中我们会从 <code>handle_int</code> 函数继续，讨论进程的调度机制的实现。</p>
<p>我们查看 <code>handle_int</code> 函数。首先经过一系列运算，从 <code>status</code> 寄存器中获得了 IM4 的值。正如前面提到过的，此值表示是否开启 4 号中断。<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">NESTED(handle_int, TF_SIZE, zero)</span><br><span class="line">	mfc0    t0, CP0_CAUSE</span><br><span class="line">	mfc0    t2, CP0_STATUS</span><br><span class="line">	and     t0, t2</span><br><span class="line">	andi    t1, t0, STATUS_IM4</span><br></pre></td></tr></table></figure></p>
<p>那么，如果是 4 号中断，也就是时钟中断，就转到时钟中断的处理。<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">bnez    t1, timer_irq</span><br><span class="line"><span class="comment">// <span class="doctag">TODO:</span> handle other irqs</span></span><br></pre></td></tr></table></figure></p>
<p>在对时钟中断的处理中，我们首先将 <code>KSEG1 | DEV_RTC_ADDRESS | DEV_RTC_INTERRUPT_ACK</code> 地址的值置零。此地址中数值存储了本次中断的相关信息。清零说明我们已经完成了对中断的处理。随后我们调用 <code>schedule</code> 函数，进行进程的调度。<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">timer_irq:</span><br><span class="line">	sw      zero, (KSEG1 | DEV_RTC_ADDRESS | DEV_RTC_INTERRUPT_ACK)</span><br><span class="line">	li      a0, <span class="number">0</span></span><br><span class="line">	j       schedule</span><br><span class="line"><span class="title function_">END</span><span class="params">(handle_int)</span></span><br></pre></td></tr></table></figure></p>
<h3 id="（2）调度方法"><a href="#（2）调度方法" class="headerlink" title="（2）调度方法"></a>（2）调度方法</h3><p><code>schedule</code> 函数位于 kern/sched.c 中。它有一个参数 <code>int yield</code>，用于表示是否强制让出当前进程的运行，了解过 java 多线程的应该对 yield 这个词有所认识。接下来就让我们深入这个函数。</p>
<p>首先，<code>schedule</code> 函数中存在一个静态变量 <code>count</code>，用于表示当前进程剩余的时间片。而 <code>curenv</code> 则是一个 <code>Env *</code> 类型的全局变量，用于表示当前运行的进程。<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">schedule</span><span class="params">(<span class="type">int</span> yield)</span> &#123;</span><br><span class="line">	<span class="type">static</span> <span class="type">int</span> count = <span class="number">0</span>; <span class="comment">// remaining time slices of current env</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Env</span> *<span class="title">e</span> =</span> curenv;</span><br></pre></td></tr></table></figure></p>
<p>接着就是进程调度方法的主体，这也是本次实验我们需要填写的部分。实际上，注释已经将如何实现写得很清楚了。我们现在就分析一下该方法的原理。</p>
<p>首先我们考虑需要进行进程切换的情况，这在注释中有说明。</p>
<ul>
<li>yield 为真时：此时当前进程必须让出</li>
<li>count 减为 0 时：此时分给进程的时间片被用完，将执行权让给其他进程</li>
<li>无当前进程：这必然是内核刚刚完成初始化，第一次产生时钟中断的情况，需要分配一个进程执行</li>
<li>进程状态不是可运行：当前进程不能再继续执行，让给其他进程<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (yield || count &lt;= <span class="number">0</span> || e == <span class="literal">NULL</span> || e-&gt;env_status != ENV_RUNNABLE) &#123;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>首先我们考虑发生进程切换的情况。我们需要从进程调度队列中取出头部的进程控制块。这时我们需要判断一些情况。当之前的进程还是可运行的时，我们需要将其插入调度队列队尾，等待下一次轮到其执行，注意在此之前需要判断 <code>e</code> 非空。而当调度队列为空时，内核崩溃，因为操作系统中必须至少有一个进程。</p>
<p>这里需要着重注意的是，<code>env_sched_list</code> 要存储所有状态为 <code>ENV_RUNNABLE</code> 的进程控制块，这也包括当前正在运行的进程控制块 <code>curenv</code>。这样做主要是因为在 <code>env_free</code> 函数（这个函数在 Lab4 中介绍）和之后的实验中我们预设所有状态为 <code>ENV_RUNNABLE</code> 的进程控制块都在 <code>env_sched_list</code> 中，这样就可以毫无顾忌地使用类似 <code>TAILQ_REMOVE(&amp;env_sched_list, (e), env_sched_link)</code> 的语句了。而假若对不在队列中的元素调用 <code>TAILQ_REMOVE</code>，则可能发生异常情况，使得列表中其他元素被一并删除。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (e != <span class="literal">NULL</span>) &#123;</span><br><span class="line">	TAILQ_REMOVE(&amp;env_sched_list, e, env_sched_link);</span><br><span class="line">	<span class="keyword">if</span> (e-&gt;env_status == ENV_RUNNABLE) &#123;</span><br><span class="line">		TAILQ_INSERT_TAIL(&amp;env_sched_list, e, env_sched_link);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (TAILQ_EMPTY(&amp;env_sched_list)) &#123;</span><br><span class="line">	panic(<span class="string">&quot;schedule: no runnable envs&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>随后，我们设定调度队列头部的进程控制块为将要运行的进程（不要在这里使用 <code>TAILQ_REMOVE</code>），将剩余时间片更新为新的进程的优先级。你可能会想：“所谓优先级就是时间片的多少？” 确实，就是这样，背后并没有什么复杂的算法。真正的操作系统中的进程优先级也仅仅是这样的作用。<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">	e = TAILQ_FIRST(&amp;env_sched_list);</span><br><span class="line"></span><br><span class="line">	count = e-&gt;env_pri;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>最后，不管发不发生进程切换，我们都要让 <code>count</code> 自减，表示当前进程用去了一个时间片的时间，之后我们调用 <code>env_run</code> 运行进程，来真正的消耗这一时间片的时间。这个调用位于判断语句之外，也就是说不论是否发生进程切换，都需要执行 <code>env_run</code>。<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">	count--;</span><br><span class="line">	env_run(e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="（3）进程的运行"><a href="#（3）进程的运行" class="headerlink" title="（3）进程的运行"></a>（3）进程的运行</h3><p><code>env_run</code> 是如何让进程运行的？让我们查看这个函数，它位于 kern/env.c 中。</p>
<p>唠叨一句无关的。在该函数的开头调用了 <code>pre_env_run</code> 用于打印评测信息。说实话有点丑。<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">env_run</span><span class="params">(<span class="keyword">struct</span> Env *e)</span> &#123;</span><br><span class="line">	assert(e-&gt;env_status == ENV_RUNNABLE);</span><br><span class="line">	pre_env_run(e); <span class="comment">// WARNING: DO NOT MODIFY THIS LINE!</span></span><br></pre></td></tr></table></figure></p>
<p>此时全局变量 <code>curenv</code> 中还是切换前的进程控制块，我们保存该进程的上下文，将栈帧中 trap frame 的信息转换为 <code>Trapframe</code> 存储在 <code>env_tf</code> 中。至于为什么 trap frame 的信息存储在 <code>[KSTACKTOP - 1, KSTACKTOP)</code> 的范围内，参考关于 <code>SAVE_ALL</code> 宏的内容。<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Step 1:</span></span><br><span class="line"><span class="comment"> *   If &#x27;curenv&#x27; is NULL, this is the first time through.</span></span><br><span class="line"><span class="comment"> *   If not, we may be switching from a previous env, so save its context into</span></span><br><span class="line"><span class="comment"> *   &#x27;curenv-&gt;env_tf&#x27; first.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (curenv) &#123;</span><br><span class="line">	curenv-&gt;env_tf = *((<span class="keyword">struct</span> Trapframe *)KSTACKTOP - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>接着，我们将 <code>curenv</code> 的值变为 <code>e</code> 的值，实现当前进程的切换。注释 <code>lab6</code> 的内容暂不考虑。<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Step 2: Change &#x27;curenv&#x27; to &#x27;e&#x27;. */</span></span><br><span class="line">curenv = e;</span><br><span class="line">curenv-&gt;env_runs++; <span class="comment">// lab6</span></span><br></pre></td></tr></table></figure></p>
<p>之后，我们将全局变量 <code>cur_pgdir</code> 设置为当前进程对应的页目录，实现页目录的切换。各位或许还对 <code>cur_pgdir</code> 有印象，在 Lab2 的笔记中有提到。那时我说</p>
<blockquote>
<p>值得注意的是，<code>_do_tlb_refill</code> 调用该函数时页目录基地址参数使用的是全局变量 <code>cur_pgdir</code>。可是这个全局变量并没有任何被赋值。这也是在 Lab2 中页式内存管理无法使用的一个原因。<br>现在我们为 <code>cur_pgdir</code> 赋了值，就可以愉快地使用用户内存空间范围的虚拟地址了。<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Step 3: Change &#x27;cur_pgdir&#x27; to &#x27;curenv-&gt;env_pgdir&#x27;, switching to its address space. */</span></span><br><span class="line"><span class="comment">/* Exercise 3.8: Your code here. (1/2) */</span></span><br><span class="line">cur_pgdir = curenv-&gt;env_pgdir;</span><br></pre></td></tr></table></figure></p>
</blockquote>
<p>最后，我们调用 <code>env_pop_tf</code> 函数，根据栈帧还原进程上下文，并运行程序。<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">	<span class="comment">/* Step 4: Use &#x27;env_pop_tf&#x27; to restore the curenv&#x27;s saved context (registers) and return/go</span></span><br><span class="line"><span class="comment">	 * to user mode.</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * Hint:</span></span><br><span class="line"><span class="comment">	 *  - You should use &#x27;curenv-&gt;env_asid&#x27; here.</span></span><br><span class="line"><span class="comment">	 *  - &#x27;env_pop_tf&#x27; is a &#x27;noreturn&#x27; function: it restores PC from &#x27;cp0_epc&#x27; thus not</span></span><br><span class="line"><span class="comment">	 *    returning to the kernel caller, making &#x27;env_run&#x27; a &#x27;noreturn&#x27; function as well.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="comment">/* Exercise 3.8: Your code here. (2/2) */</span></span><br><span class="line">	env_pop_tf(&amp;curenv-&gt;env_tf, curenv-&gt;env_asid);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>env_pop_tf</code> 函数定义在 kern/env_asm.S 中，内容较为简单。该函数将传入的 asid 值设置到 <code>EntryHi</code> 寄存器中，表示之后的虚拟内存访问都来自于 asid 所对应的进程。另外该函数将<code>sp</code> 寄存器地址设置为当前进程的 trap frame 地址，这样在最后调用 <code>ret_from_exception</code> 从异常处理中返回时，将使用当前进程的 trap frame 恢复上下文。程序也将从当前进程的 epc 中执行（epc 的值在 <code>load_icode</code> 中根据 elf 头设置为程序入口地址）。<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">LEAF(env_pop_tf)</span><br><span class="line">.<span class="built_in">set</span> reorder</span><br><span class="line">.<span class="built_in">set</span> at</span><br><span class="line">	sll     a1, a1, <span class="number">6</span></span><br><span class="line">	mtc0    a1, CP0_ENTRYHI</span><br><span class="line">	move    sp, a0</span><br><span class="line">	j       ret_from_exception</span><br><span class="line"><span class="title function_">END</span><span class="params">(env_pop_tf)</span></span><br></pre></td></tr></table></figure></p>
<p>最后，所有的寄存器都恢复成了当前进程所需要的状态，cpu 就像只知道当前进程这一个程序一样不断执行一条条指令，直到经过了一个时钟周期，又一个中断发生……</p>
<p><strong>（Lab3 完）</strong></p>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>MOS</tag>
        <tag>os</tag>
        <tag>BUAA</tag>
      </tags>
  </entry>
  <entry>
    <title>BUAA-OS实验笔记之Lab4</title>
    <url>/posts/c02d6fc9/</url>
    <content><![CDATA[<h2 id="一、Lab4-前言"><a href="#一、Lab4-前言" class="headerlink" title="一、Lab4 前言"></a>一、Lab4 前言</h2><p>Lab4 主要实现了系统调用，并通过系统调用实现了进程的创建和通信等操作。按照提示编写代码的难度应该不大（除非你的 Lab3 <code>schedule</code> 函数有 bug，很可惜我就是这样 <code>:(</code>），所以本次的笔记更多的讨论了一些和实验无关的代码。希望不会显得太啰嗦。</p>
<span id="more"></span>
<h2 id="二、系统调用"><a href="#二、系统调用" class="headerlink" title="二、系统调用"></a>二、系统调用</h2><h3 id="（1）从一个用户程序引入"><a href="#（1）从一个用户程序引入" class="headerlink" title="（1）从一个用户程序引入"></a>（1）从一个用户程序引入</h3><p>在之前的几篇文章中，我们大致循着内核初始化的过程进行分析。可是在这 Lab4 中这一思路就不适用了。因为在本次实验中我们所要实现的，不过是一些由内核提供的，可供用户程序调用的接口而已。这种调用被称为系统调用。</p>
<p>但是为了保持文章行文的一致性，我们还是希望确定一个入口开始讲解。正好在 <code>mips_init</code> 中有这样的语句，那我们就从被创建的这个用户程序开始。<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// lab4:</span></span><br><span class="line"><span class="comment">// ENV_CREATE(user_tltest);</span></span><br></pre></td></tr></table></figure></p>
<p>这里需要插一嘴，在 Lab3 中我们就已经使用 <code>ENV_CREATE</code> 完成了一些程序的加载，可你有没有仔细看过被加载的程序的源代码是什么样的？代码在 user/bare 路径下。我们查看其中的 put_a.c 程序<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> _start() &#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">unsigned</span> i = <span class="number">0</span>;; ++i) &#123;</span><br><span class="line">		<span class="keyword">if</span> ((i &amp; ((<span class="number">1</span> &lt;&lt; <span class="number">16</span>) - <span class="number">1</span>)) == <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="comment">// Requires `e-&gt;env_tf.cp0_status &amp;= ~STATUS_KUp;` in kernel to work</span></span><br><span class="line">			*(<span class="keyword">volatile</span> <span class="type">char</span> *)<span class="number">0xb0000000</span> = <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">			*(<span class="keyword">volatile</span> <span class="type">char</span> *)<span class="number">0xb0000000</span> = <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<p>你会发现这些所谓的程序并没有 <code>main</code> 函数，而是 <code>_start</code>。实际上和内核一样，我们同样在用于用户程序编译的链接器脚本中将程序入口设定为 <code>_start</code>。该脚本为 user/user.lds，其中同样有<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">ENTRY(_start)</span><br></pre></td></tr></table></figure></p>
<p>但是如果你查看一下我们将要查看的 user/tltest.c 程序，就会发现其中又是以 <code>main</code> 函数为入口了。这是为什么呢？</p>
<p>这是因为我们在 user/lib/entry.S 中定义了统一的 <code>_start</code> 函数。<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">.text</span><br><span class="line"><span class="title function_">EXPORT</span><span class="params">(_start)</span></span><br><span class="line">	lw      a0, 0<span class="params">(sp)</span></span><br><span class="line">	lw      a1, 4<span class="params">(sp)</span></span><br><span class="line">	jal     libmain</span><br></pre></td></tr></table></figure></p>
<p>值得注意跳转前的两条指令。这两条指令加载了 <code>argc</code> 和 <code>argv</code>。你可能还记得 Lab3 中 <code>env_alloc</code> 函数的这条语句，它将栈底的 8 个字节留给 <code>argc</code> 和 <code>argv</code>。<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Keep space for &#x27;argc&#x27; and &#x27;argv&#x27;.</span></span><br><span class="line">e-&gt;env_tf.regs[<span class="number">29</span>] = USTACKTOP - <span class="keyword">sizeof</span>(<span class="type">int</span>) - <span class="keyword">sizeof</span>(<span class="type">char</span> **);</span><br></pre></td></tr></table></figure></p>
<p>在 <code>_start</code> 函数的最后，跳转到 <code>libmain</code>。这个函数定义在 user/lib/libos.c 中。在这个函数中，我们通过一个函数 <code>syscall_getenvid</code> 获取了当前进程的 envid。此函数是一个系统调用，我们留到之后讲解。之后使用宏 <code>ENVX</code> 根据 envid 获取到该 envid 对应的进程控制块相对于进程控制块数组的索引值，并取得当前进程的进程控制块。<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">libmain</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span> &#123;</span><br><span class="line">	<span class="comment">// set env to point at our env structure in envs[].</span></span><br><span class="line">	env = &amp;envs[ENVX(syscall_getenvid())];</span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<p>你可能没找到 <code>env</code> 和 <code>envs</code> 的定义，它们都在 user/include/lib.h 中。你可能还记得 Lab3 中我们将页控制块数组和进程控制块数组映射到用户虚拟地址空间的某一位置，这里 <code>envs</code> 就是映射到的用户虚拟地址，同理还有 <code>pages</code>。注意不要与内核空间中的 <code>envs</code> 和 <code>pages</code> 搞混。虽然它们确实表示同一物理地址的相同数据，但是用户程序无法访问内核地址空间中的 <code>envs</code> 和 <code>pages</code>，如果访问会产生异常。</p>
<p>另外 <code>env</code> 用于表示本用户程序的进程控制块。我们可以通过访问 <code>env</code> 获取当前进程的信息。<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> envs ((volatile struct Env *)UENVS)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pages ((volatile struct Page *)UPAGES)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">volatile</span> <span class="class"><span class="keyword">struct</span> <span class="title">Env</span> *<span class="title">env</span>;</span></span><br></pre></td></tr></table></figure></p>
<p>之后，<code>libmain</code> 函数便调用了 <code>main</code> 函数<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// call user main routine</span></span><br><span class="line">main(argc, argv);</span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<p>最后，当 main 函数返回后，我们调用 <code>exit</code> 函数结束进程<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">	<span class="comment">// exit gracefully</span></span><br><span class="line">	<span class="built_in">exit</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<p><code>exit</code> 函数同样定义在 user/lib/libos.c 中。<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">exit</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">	<span class="comment">// After fs is ready (lab5), all our open files should be closed before dying.</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> !defined(LAB) || LAB &gt;= 5</span></span><br><span class="line">	close_all();</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	syscall_env_destroy(<span class="number">0</span>);</span><br><span class="line">	user_panic(<span class="string">&quot;unreachable code&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>我们不考虑 Lab5 之后才用到的内容。<code>exit</code> 函数只调用了一个 <code>syscall_env_destroy</code>，该函数也是一个系统调用，用于销毁进程，释放进程资源。这里传入了一个参数 asid = 0，表示销毁的是当前进程。在之后还会多次出现 asid = 0 表示当前进程（调用函数的进程）的用法。</p>
<p>值得注意，在 <code>syscall_env_destroy</code> 之后还多出一条语句 <code>user_panic</code>。此函数类似于 <code>panic</code>，不过用于表示用户程序出现了难以恢复的错误。在调用该函数打印错误信息后，就会结束该进程。<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// user/include/lib.h</span></span><br><span class="line"><span class="type">void</span> _user_panic(<span class="type">const</span> <span class="type">char</span> *, <span class="type">int</span>, <span class="type">const</span> <span class="type">char</span> *, ...) __attribute__((<span class="keyword">noreturn</span>));</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> user_panic(...) _user_panic(__FILE__, __LINE__, __VA_ARGS__)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// user/lib/debug.c</span></span><br><span class="line"><span class="type">void</span> _user_panic(<span class="type">const</span> <span class="type">char</span> *file, <span class="type">int</span> line, <span class="type">const</span> <span class="type">char</span> *fmt, ...) &#123;</span><br><span class="line">	debugf(<span class="string">&quot;panic at %s:%d: &quot;</span>, file, line);</span><br><span class="line">	va_list ap;</span><br><span class="line">	va_start(ap, fmt);</span><br><span class="line">	vdebugf(fmt, ap);</span><br><span class="line">	va_end(ap);</span><br><span class="line">	debugf(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">	<span class="built_in">exit</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<p>在 <code>exit</code> 函数中出现的 <code>user_panic</code> 很明显的指出 <code>syscall_env_destroy</code> 是一个不会返回的函数。</p>
<p>这样，用户程序的入口的故事我们就讲完了。你现在应该就可以理解 Lab3 中使用的用户程序位于 bare 路径下的原因了。因为他们没有被 <code>libmain</code> 包裹，是赤裸裸地暴露在外运行的。</p>
<p>之后还是让我们看一下 user/tltest.c 的程序吧<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">	debugf(<span class="string">&quot;Smashing some kernel codes...\n&quot;</span></span><br><span class="line">	       <span class="string">&quot;If your implementation is correct, you may see unknown exception here:\n&quot;</span>);</span><br><span class="line">	*(<span class="type">int</span> *)KERNBASE = <span class="number">0</span>;</span><br><span class="line">	debugf(<span class="string">&quot;My mission completed!\n&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<p>这里用户程序试图向内核空间写入数据，于是就会产生异常。运行的结果如下。<code>do_reserved</code> 函数用于处理除了定义过异常处理函数的其他异常。5 号异常表示地址错误。<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Smashing some kernel codes...</span><br><span class="line">If your implementation is correct, you may see unknown exception here:</span><br><span class="line">...</span><br><span class="line">panic at traps.c:<span class="number">24</span> (do_reserved): Unknown ExcCode <span class="number">5</span></span><br></pre></td></tr></table></figure></p>
<p>这里出现了一个新函数 <code>debugf</code>，该函数在用户程序的地位相当于内核中的 <code>printk</code>。它定义在 user/lib/debugf.c 中。为了避免这篇文章过程，不详细解释该函数，只是提一下 <code>debugf</code> 和相关函数的调用关系。这里有 <code>debugf -&gt; vdebugf -&gt; vprintfmt -&gt; debug_output -&gt; debug_flush -&gt; syscall_print_cons</code>。最终，为了向屏幕输出字符，我们的用户程序还是使用了系统调用 <code>syscall_print_cons</code>。<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">debug_flush</span><span class="params">(<span class="keyword">struct</span> debug_ctx *ctx)</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> (ctx-&gt;pos == <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> r;</span><br><span class="line">	<span class="keyword">if</span> ((r = syscall_print_cons(ctx-&gt;buf, ctx-&gt;pos)) != <span class="number">0</span>) &#123;</span><br><span class="line">		user_panic(<span class="string">&quot;syscall_print_cons: %d&quot;</span>, r);</span><br><span class="line">	&#125;</span><br><span class="line">	ctx-&gt;pos = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">debug_output</span><span class="params">(<span class="type">void</span> *data, <span class="type">const</span> <span class="type">char</span> *s, <span class="type">size_t</span> l)</span> &#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">debug_ctx</span> *<span class="title">ctx</span> =</span> (<span class="keyword">struct</span> debug_ctx *)data;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (ctx-&gt;pos + l &gt; BUF_LEN) &#123;</span><br><span class="line">		<span class="type">size_t</span> n = BUF_LEN - ctx-&gt;pos;</span><br><span class="line">		<span class="built_in">memcpy</span>(ctx-&gt;buf + ctx-&gt;pos, s, n);</span><br><span class="line">		s += n;</span><br><span class="line">		l -= n;</span><br><span class="line">		ctx-&gt;pos = BUF_LEN;</span><br><span class="line">		debug_flush(ctx);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">memcpy</span>(ctx-&gt;buf + ctx-&gt;pos, s, l);</span><br><span class="line">	ctx-&gt;pos += l;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">vdebugf</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *fmt, va_list ap)</span> &#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">debug_ctx</span> <span class="title">ctx</span>;</span></span><br><span class="line">	ctx.pos = <span class="number">0</span>;</span><br><span class="line">	vprintfmt(debug_output, &amp;ctx, fmt, ap);</span><br><span class="line">	debug_flush(&amp;ctx);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">debugf</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *fmt, ...)</span> &#123;</span><br><span class="line">	va_list ap;</span><br><span class="line">	va_start(ap, fmt);</span><br><span class="line">	vdebugf(fmt, ap);</span><br><span class="line">	va_end(ap);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<p>你可能会想，系统调用到底有什么用？为什么用户程序的许多操作都需要由内核经手？在我看来，系统调用，乃至其他操作系统的许多其他功能，目的都是安全性。这体现在两个方面。一是系统的安全，保证计算机不会被非法篡改；二是操作的安全，保证用户的大部分操作都不会破坏计算机系统本身。为了做到这两点，我们就需要将一些更加重要的数据结构和算法隐藏在内核中，与用户隔离。从而避免有意或无意的操作对数据造成无法挽回的破坏。</p>
<h3 id="（2）系统调用的实现"><a href="#（2）系统调用的实现" class="headerlink" title="（2）系统调用的实现"></a>（2）系统调用的实现</h3><p>在上一小节中我们见识了一些系统调用函数，在 MOS 的提供给用户程序的库中，所有的系统调用均为 syscall_* 的形式。所以，这些函数就是内核提供给用户程序的接口吗？</p>
<p>答案是否定的。所有的系统调用都定义在 user/lib/syscall_lib.c 中。我们取之前看到过的系统调用函数为例<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">syscall_print_cons</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *str, u_int num)</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> msyscall(SYS_print_cons, str, num);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">u_int <span class="title function_">syscall_getenvid</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> msyscall(SYS_getenvid);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">syscall_env_destroy</span><span class="params">(u_int envid)</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> msyscall(SYS_env_destroy, envid);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<p>可以看到，这些函数（其实是所有的系统调用函数）都调用了 <code>msyscall</code> 一个函数。为其传入了不同数量、类型的参数。你可能已经想到了，这是一个拥有变长参数的函数。我们可以在 user/include/lib.h 中找到该函数的声明。<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/// syscalls</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> <span class="title function_">msyscall</span><span class="params">(<span class="type">int</span>, ...)</span>;</span><br></pre></td></tr></table></figure></p>
<p>你可能会想，“原来内核提供给用户程序的接口其实只有 <code>msyscall</code> 函数一个。第一个参数表示系统调用的类型，剩下的参数根据系统调用不同也有所区别。内核只对用户程序暴露这一个函数，最大程度限制了用户程序对内核的访问。” 事实是这样吗？</p>
<p>其实也不是。还是让我们看一看 <code>msyscall</code> 的定义吧。<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">LEAF(msyscall)</span><br><span class="line">	<span class="comment">// Just use &#x27;syscall&#x27; instruction and return.</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Exercise 4.1: Your code here. */</span></span><br><span class="line">	syscall</span><br><span class="line">	jr	ra</span><br><span class="line"><span class="title function_">END</span><span class="params">(msyscall)</span></span><br></pre></td></tr></table></figure></p>
<p>该函数只有两条指令，第二条指令 <code>jr    ra</code> 只是从该函数返回。真正关键的只有第一条 <code>syscall</code>。这条指令用于让程序自行产生一个异常，该异常被称为系统异常。这样进行异常处理，才进入了内核态。实际上经过了几个实验，应该明白一点，<strong>内核态提供给用户程序的接口，只有异常</strong>。</p>
<p>插一句嘴，虽然 <code>msyscall</code> 是一个拥有可变参数的函数，可我们并没有使用可变参数宏来进行处理。由此可见，所谓的可变参数，不过是编译器的特殊处理罢了。</p>
<p>接下来我们就要处理系统异常。还记得我们在 Lab3 中略过不讲的两个异常处理函数吗？这两个函数将在本次实验中起到大用处。这里我们先看 <code>do_syscall</code><br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">if</span> !defined(LAB) || LAB &gt;= 4</span></span><br><span class="line">BUILD_HANDLER mod do_tlb_mod</span><br><span class="line">BUILD_HANDLER sys do_syscall</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure></p>
<p>回忆一下 Lab3 中从进入异常到进入特定异常的处理函数中间的过程。在这中间我们使用 <code>SAVE_ALL</code> 宏保存了发生异常时的现场。对于系统异常来说，需要着重强调，我们保存了调用 <code>msyscall</code> 函数时的参数信息。对于这一点，请回忆 mips 函数调用的相关知识。</p>
<p><code>do_syscall</code> 函数位于 kern/syscall_all.c 中。该函数用于实现系统调用的分发和运行。</p>
<p>首先，我们取出用户程序 trap frame 中的 <code>a0</code> 寄存器的值。该值即调用 <code>msyscall</code> 函数时的第一个参数，确实用于表示系统调用的类型。之后我们判断 <code>sysno</code> 是否处于范围内，如果不是则 “返回”。需要注意这里返回值的设定方法。我们为 trap frame 中的 <code>v0</code> 寄存器赋值。在 mips 函数调用中，该寄存器存储返回值。<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">do_syscall</span><span class="params">(<span class="keyword">struct</span> Trapframe *tf)</span> &#123;</span><br><span class="line">	<span class="type">int</span> (*func)(u_int, u_int, u_int, u_int, u_int);</span><br><span class="line">	<span class="type">int</span> sysno = tf-&gt;regs[<span class="number">4</span>];</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (sysno &lt; <span class="number">0</span> || sysno &gt;= MAX_SYSNO) &#123;</span><br><span class="line">		tf-&gt;regs[<span class="number">2</span>] = -E_NO_SYS;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<p>之后，我们将 <code>epc</code> 寄存器的地址加 4。如果还记得 Lab3，应该知道 <code>epc</code> 寄存器存储了发生异常的指令地址。当完成异常处理，调用 <code>ret_from_exception</code> 从异常中返回时，也是回到 <code>epc</code> 指向的指令再次执行。这里将 <code>epc</code> 寄存器的地址加 4，意味着从异常返回后并不重新执行 <code>syscall</code> 指令，而是其下一条指令。<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Step 1: Add the EPC in &#x27;tf&#x27; by a word (size of an instruction). */</span></span><br><span class="line"><span class="comment">/* Exercise 4.2: Your code here. (1/4) */</span></span><br><span class="line">tf-&gt;cp0_epc += <span class="number">4</span>;</span><br></pre></td></tr></table></figure></p>
<p>然后，我们根据 <code>sysno</code> 取得对应的系统调用函数。<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Step 2: Use &#x27;sysno&#x27; to get &#x27;func&#x27; from &#x27;syscall_table&#x27;. */</span></span><br><span class="line"><span class="comment">/* Exercise 4.2: Your code here. (2/4) */</span></span><br><span class="line">func = syscall_table[sysno];</span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<p>其中 <code>syscall_table</code> 中存储了所有的系统调用函数<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> *syscall_table[MAX_SYSNO] = &#123;</span><br><span class="line">    [SYS_putchar] = sys_putchar,</span><br><span class="line">    [SYS_print_cons] = sys_print_cons,</span><br><span class="line">    [SYS_getenvid] = sys_getenvid,</span><br><span class="line">    [SYS_yield] = sys_yield,</span><br><span class="line">    [SYS_env_destroy] = sys_env_destroy,</span><br><span class="line">    [SYS_set_tlb_mod_entry] = sys_set_tlb_mod_entry,</span><br><span class="line">    [SYS_mem_alloc] = sys_mem_alloc,</span><br><span class="line">    [SYS_mem_map] = sys_mem_map,</span><br><span class="line">    [SYS_mem_unmap] = sys_mem_unmap,</span><br><span class="line">    [SYS_exofork] = sys_exofork,</span><br><span class="line">    [SYS_set_env_status] = sys_set_env_status,</span><br><span class="line">    [SYS_set_trapframe] = sys_set_trapframe,</span><br><span class="line">    [SYS_panic] = sys_panic,</span><br><span class="line">    [SYS_ipc_try_send] = sys_ipc_try_send,</span><br><span class="line">    [SYS_ipc_recv] = sys_ipc_recv,</span><br><span class="line">    [SYS_cgetc] = sys_cgetc,</span><br><span class="line">    [SYS_write_dev] = sys_write_dev,</span><br><span class="line">    [SYS_read_dev] = sys_read_dev,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>最后，我们从用户程序的 trap frame 中取出调用 <code>msyscall</code> 时传入的参数。按照 mips 函数调用规范，函数调用的前四个参数存储在 <code>a0-a3</code> 寄存器中。更多的参数被存储在 <code>sp</code> 寄存器的对应地址中。因为我们的系统调用最多有 5 个参数，因此需要取得 arg1 到 arg5 的值。最后我们调用根据 <code>sysno</code> 取得的系统调用函数，调用该函数，将其返回值存储在 <code>v0</code> 寄存器中。<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">	<span class="comment">/* Step 3: First 3 args are stored at $a1, $a2, $a3. */</span></span><br><span class="line">	u_int arg1 = tf-&gt;regs[<span class="number">5</span>];</span><br><span class="line">	u_int arg2 = tf-&gt;regs[<span class="number">6</span>];</span><br><span class="line">	u_int arg3 = tf-&gt;regs[<span class="number">7</span>];</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Step 4: Last 2 args are stored in stack at [$sp + 16 bytes], [$sp + 20 bytes] */</span></span><br><span class="line">	u_int arg4, arg5;</span><br><span class="line">	<span class="comment">/* Exercise 4.2: Your code here. (3/4) */</span></span><br><span class="line">	arg4 = *(u_int *)(tf-&gt;regs[<span class="number">29</span>]+<span class="number">16</span>);</span><br><span class="line">	arg5 = *(u_int *)(tf-&gt;regs[<span class="number">29</span>]+<span class="number">20</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Step 5: Invoke &#x27;func&#x27; with retrieved arguments and store its return value to $v0 in &#x27;tf&#x27;.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="comment">/* Exercise 4.2: Your code here. (4/4) */</span></span><br><span class="line">	tf-&gt;regs[<span class="number">2</span>] = func(arg1, arg2, arg3, arg4, arg5);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>实际上我们不难看出，在 <code>do_syscall</code> 函数中我们修改了用户程序 trap frame 的值，其目的就是模拟函数调用的效果。这样在恢复现场，用户程序继续运行时，就会感觉和平常的函数调用没有不同之处。异常的处理过程，就仿佛变成了内核暴露给用户程序的接口了。可是我们还是要明确这一点，系统调用的本质，就是异常处理。</p>
<h3 id="（3）补充-env-destroy"><a href="#（3）补充-env-destroy" class="headerlink" title="（3）补充 env_destroy"></a>（3）补充 env_destroy</h3><p>Lab3 的笔记中没有讲解 <code>env_destroy</code>，主要是因为我们确实没有用到该函数。现在我们将其封装成系统调用，作为 main 函数之后的资源回收函数，就是时候考虑该函数了。</p>
<p>我们使用的系统调用为 <code>sys_env_destroy</code>，可以看出只是封装了一下 <code>env_destroy</code>。<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sys_env_destroy</span><span class="params">(u_int envid)</span> &#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Env</span> *<span class="title">e</span>;</span></span><br><span class="line">	try(envid2env(envid, &amp;e, <span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">	printk(<span class="string">&quot;[%08x] destroying %08x\n&quot;</span>, curenv-&gt;env_id, e-&gt;env_id);</span><br><span class="line">	env_destroy(e);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<p>那么 <code>env_destroy</code> 呢？该函数主要作用是调用了 <code>env_free</code> 函数。另外对于是当前函数被销毁的情况，我们就需要进行进程调度。<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">env_destroy</span><span class="params">(<span class="keyword">struct</span> Env *e)</span> &#123;</span><br><span class="line">	<span class="comment">/* Hint: free e. */</span></span><br><span class="line">	env_free(e);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Hint: schedule to run a new environment. */</span></span><br><span class="line">	<span class="keyword">if</span> (curenv == e) &#123;</span><br><span class="line">		curenv = <span class="literal">NULL</span>;</span><br><span class="line">		printk(<span class="string">&quot;i am killed ... \n&quot;</span>);</span><br><span class="line">		schedule(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>对于 <code>env_free</code> 函数。首先遍历所有页表项，使用 <code>page_remove</code> 删除虚拟地址到物理页的映射；另外使用 <code>page_decref</code> 释放页表和页目录本身。其中还使用 <code>asid_free</code> 释放了 asid。对页表项进行修改后，使用了 <code>tlb_invalidate</code> 将对应的项无效化。<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">env_free</span><span class="params">(<span class="keyword">struct</span> Env *e)</span> &#123;</span><br><span class="line">	Pte *pt;</span><br><span class="line">	u_int pdeno, pteno, pa;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Hint: Note the environment&#x27;s demise.*/</span></span><br><span class="line">	printk(<span class="string">&quot;[%08x] free env %08x\n&quot;</span>, curenv ? curenv-&gt;env_id : <span class="number">0</span>, e-&gt;env_id);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Hint: Flush all mapped pages in the user portion of the address space */</span></span><br><span class="line">	<span class="keyword">for</span> (pdeno = <span class="number">0</span>; pdeno &lt; PDX(UTOP); pdeno++) &#123;</span><br><span class="line">		<span class="comment">/* Hint: only look at mapped page tables. */</span></span><br><span class="line">		<span class="keyword">if</span> (!(e-&gt;env_pgdir[pdeno] &amp; PTE_V)) &#123;</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">/* Hint: find the pa and va of the page table. */</span></span><br><span class="line">		pa = PTE_ADDR(e-&gt;env_pgdir[pdeno]);</span><br><span class="line">		pt = (Pte *)KADDR(pa);</span><br><span class="line">		<span class="comment">/* Hint: Unmap all PTEs in this page table. */</span></span><br><span class="line">		<span class="keyword">for</span> (pteno = <span class="number">0</span>; pteno &lt;= PTX(~<span class="number">0</span>); pteno++) &#123;</span><br><span class="line">			<span class="keyword">if</span> (pt[pteno] &amp; PTE_V) &#123;</span><br><span class="line">				page_remove(e-&gt;env_pgdir, e-&gt;env_asid,</span><br><span class="line">					    (pdeno &lt;&lt; PDSHIFT) | (pteno &lt;&lt; PGSHIFT));</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">/* Hint: free the page table itself. */</span></span><br><span class="line">		e-&gt;env_pgdir[pdeno] = <span class="number">0</span>;</span><br><span class="line">		page_decref(pa2page(pa));</span><br><span class="line">		<span class="comment">/* Hint: invalidate page table in TLB */</span></span><br><span class="line">		tlb_invalidate(e-&gt;env_asid, UVPT + (pdeno &lt;&lt; PGSHIFT));</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/* Hint: free the page directory. */</span></span><br><span class="line">	page_decref(pa2page(PADDR(e-&gt;env_pgdir)));</span><br><span class="line">	<span class="comment">/* Hint: free the ASID */</span></span><br><span class="line">	asid_free(e-&gt;env_asid);</span><br><span class="line">	<span class="comment">/* Hint: invalidate page directory in TLB */</span></span><br><span class="line">	tlb_invalidate(e-&gt;env_asid, UVPT + (PDX(UVPT) &lt;&lt; PGSHIFT));</span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<p>最后修改进程控制块的状态为 <code>ENV_FREE</code>，将该控制块从调度队列中删除，重新放回空闲列表中。<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">	<span class="comment">/* Hint: return the environment to the free list. */</span></span><br><span class="line">	e-&gt;env_status = ENV_FREE;</span><br><span class="line">	LIST_INSERT_HEAD((&amp;env_free_list), (e), env_link);</span><br><span class="line">	TAILQ_REMOVE(&amp;env_sched_list, (e), env_sched_link);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<h2 id="二、fork-的实现"><a href="#二、fork-的实现" class="headerlink" title="二、fork 的实现"></a>二、fork 的实现</h2><h3 id="（1）用户态异常处理的实现"><a href="#（1）用户态异常处理的实现" class="headerlink" title="（1）用户态异常处理的实现"></a>（1）用户态异常处理的实现</h3><p><code>fork</code> 是创建进程的基本方法。某一进程调用该函数后，就会创建一个该进程的复制作为调用进程的子进程。子进程也会从 <code>fork</code> 后的时刻开始执行。但会具有和父进程不同的返回值。父进程的返回值为子进程的 进程标识符 envid，而子进程的返回值为 0。当然之后我们就会知道，envid = 0 可以表示当前进程。这样的话我们也可以理解成不管在父进程还是子进程，返回值都为指示子进程的 envid。</p>
<p>上面的内容可能有些难以理解，指导书里给出了一段样例代码用于帮助理解，这里也贴出来<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="type">int</span> var = <span class="number">1</span>;</span><br><span class="line">	<span class="type">long</span> pid;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Before fork, var = %d.\n&quot;</span>, var);</span><br><span class="line">	pid = fork();</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;After fork, var = %d.\n&quot;</span>, var);</span><br><span class="line">	<span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line">		var = <span class="number">2</span>;</span><br><span class="line">		sleep(<span class="number">3</span>);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;child got %ld, var = %d&quot;</span>, pid, var);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		sleep(<span class="number">2</span>);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;parent got %ld, var = %d&quot;</span>, pid, var);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;, pid: %ld\n&quot;</span>, (<span class="type">long</span>) getpid());</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<p>我们还是查看一下 <code>fork</code> 函数的代码吧，它位于 user/lib/fork.c 中。<code>fork</code> 本身不是系统调用，但该函数使用了许多系统调用来完成子进程的创建。</p>
<p>首先我们就遇到了一个系统调用 <code>env_user_tlb_mod_entry</code>，这个系统调用的作用是设置一个 TLB Mod 异常的处理函数。TLB Mod 异常即页写入（Modify）异常，会在程序试图写入不可写入（对应页表项无 <code>PTE_D</code>）的物理页面时产生。<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">fork</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">	u_int child;</span><br><span class="line">	u_int i;</span><br><span class="line">	<span class="keyword">extern</span> <span class="keyword">volatile</span> <span class="class"><span class="keyword">struct</span> <span class="title">Env</span> *<span class="title">env</span>;</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">/* Step 1: Set our TLB Mod user exception entry to &#x27;cow_entry&#x27; if not done yet. */</span></span><br><span class="line">	<span class="keyword">if</span> (env-&gt;env_user_tlb_mod_entry != (u_int)cow_entry) &#123;</span><br><span class="line">		try(syscall_set_tlb_mod_entry(<span class="number">0</span>, cow_entry));</span><br><span class="line">	&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<p>该系统调用对应的函数为 <code>sys_set_tlb_mod_entry</code>，这个函数很简单，只是设置了进程控制块的 <code>env_user_tlb_mod_entry</code> 参数。<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sys_set_tlb_mod_entry</span><span class="params">(u_int envid, u_int func)</span> &#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Env</span> *<span class="title">env</span>;</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">/* Step 1: Convert the envid to its corresponding &#x27;struct Env *&#x27; using &#x27;envid2env&#x27;. */</span></span><br><span class="line">	<span class="comment">/* Exercise 4.12: Your code here. (1/2) */</span></span><br><span class="line">	try(envid2env(envid, &amp;env, <span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Step 2: Set its &#x27;env_user_tlb_mod_entry&#x27; to &#x27;func&#x27;. */</span></span><br><span class="line">	<span class="comment">/* Exercise 4.12: Your code here. (2/2) */</span></span><br><span class="line">	env-&gt;env_user_tlb_mod_entry = func;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>你可能会想，为什么要在用户程序中设置异常处理函数呢？这不是应该交由内核处理吗？设置了之后又要如何使用？我们需要查看一下内核中 TLB Mod 异常的处理函数 <code>do_tlb_mod</code>，位于 kern/tlbex.c 中。</p>
<p>在该函数中，我们首先将 <code>sp</code> 寄存器设置到 <code>UXSTACKTOP</code> 的位置。<code>UXSTACKTOP</code> 和 <code>KSTACKTOP</code> 类似，都是在处理异常时使用的调用栈，因为我们要将异常处理交由用户态执行，因此需要在用户的地址空间中分配。另外这里添加判断语句是考虑到在异常处理的过程中再次出现异常的情况，我们不希望之前的异常处理过程的信息丢失，而希望在处理了后一个异常后再次继续处理前一个异常，于是对于 <code>sp</code> 已经在异常栈中的情况，就不再从异常栈顶开始。<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">do_tlb_mod</span><span class="params">(<span class="keyword">struct</span> Trapframe *tf)</span> &#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Trapframe</span> <span class="title">tmp_tf</span> =</span> *tf;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (tf-&gt;regs[<span class="number">29</span>] &lt; USTACKTOP || tf-&gt;regs[<span class="number">29</span>] &gt;= UXSTACKTOP) &#123;</span><br><span class="line">		tf-&gt;regs[<span class="number">29</span>] = UXSTACKTOP;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<p>随后我们在用户异常栈底分配一块空间，用于存储 trap frame。这里和在 <code>KSTACKTOP</code> 底使用 <code>SAVE_ALL</code> 类似。<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">tf-&gt;regs[<span class="number">29</span>] -= <span class="keyword">sizeof</span>(<span class="keyword">struct</span> Trapframe);</span><br><span class="line">*(<span class="keyword">struct</span> Trapframe *)tf-&gt;regs[<span class="number">29</span>] = tmp_tf;</span><br></pre></td></tr></table></figure></p>
<p>最后我们从当前进程的进程控制块的 <code>env_user_tlb_mod_entry</code> 取出由 <code>syscall_set_tlb_mod_entry</code> 设定的当前进程的 TLB Mod 异常处理函数，“调用” 该处理函数。当然，因为处于异常处理过程中，所以这里我们采用和一般系统调用类似的处理方法。首先我们设定 <code>a0</code> 寄存器的值为 trap frame 所在的地址，接着 <code>sp</code> 寄存器自减，留出第一个参数的空间。最后设定 <code>epc</code> 寄存器的值为用户的 TLB Mod 函数的地址，使得恢复现场后跳转到该函数的位置继续执行。<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">	<span class="keyword">if</span> (curenv-&gt;env_user_tlb_mod_entry) &#123;</span><br><span class="line">		tf-&gt;regs[<span class="number">4</span>] = tf-&gt;regs[<span class="number">29</span>];</span><br><span class="line">		tf-&gt;regs[<span class="number">29</span>] -= <span class="keyword">sizeof</span>(tf-&gt;regs[<span class="number">4</span>]);</span><br><span class="line">		<span class="comment">// Hint: Set &#x27;cp0_epc&#x27; in the context &#x27;tf&#x27; to &#x27;curenv-&gt;env_user_tlb_mod_entry&#x27;.</span></span><br><span class="line">		<span class="comment">/* Exercise 4.11: Your code here. */</span></span><br><span class="line">		tf-&gt;cp0_epc = curenv-&gt;env_user_tlb_mod_entry;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		panic(<span class="string">&quot;TLB Mod but no user handler registered&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>应当注意，作为用户态异常处理函数的参数的 <code>TrapFrame * tf</code> 和当前进程的 <code>tf</code> 是不同的。前者依旧是产生 TLB Mod 异常时的现场；而后者则经过了修改，以便在从异常处理返回时跳转到用户态异常处理函数而非产生异常的位置。在用户态异常处理函数完成异常处理后，我们会通过前者返回产生异常的位置。</p>
<p>最后我们还需要注意 <code>sys_set_tlb_mod_entry</code> 中使用了 <code>envid2env</code> 函数来根据进程标识符获取对应的进程。这里出现了 envid = 0 时直接返回当前进程的实现。正是因为以 envid 作为参数的函数都会使用本函数获取对应的进程控制块，所以才会有 envid = 0 表示当前进程的说法。另外，因为 envid = 0 有特殊含义，所以生成进程标识符的函数 <code>mkenvid</code> 永远不可能生成为 0 的 envid。对于 envid 不为 0 的情况，我们通过 <code>ENVX</code> 宏获取 envid 对应的进程控制块相对于进程控制块数组的索引。<code>mkenvid</code> 的算法中，envid 的低十位就是进程控制块的索引，因此我们才可以通过 envid 获取对应的进程控制块。<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">envid2env</span><span class="params">(u_int envid, <span class="keyword">struct</span> Env **penv, <span class="type">int</span> checkperm)</span> &#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Env</span> *<span class="title">e</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Step 1: Assign value to &#x27;e&#x27; using &#x27;envid&#x27;. */</span></span><br><span class="line">	<span class="comment">/* Hint:</span></span><br><span class="line"><span class="comment">	 *   If envid is zero, set &#x27;penv&#x27; to &#x27;curenv&#x27;.</span></span><br><span class="line"><span class="comment">	 *   You may want to use &#x27;ENVX&#x27;.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="comment">/* Exercise 4.3: Your code here. (1/2) */</span></span><br><span class="line">	<span class="keyword">if</span> (envid == <span class="number">0</span>) &#123;</span><br><span class="line">		*penv = curenv;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		e = envs + ENVX(envid);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure></p>
<p>在 <code>envid2env</code> 的后半部分，我们进行了一系列进程控制块的有效性检查。注意这里的 <code>e-&gt;env_id != envid</code>，按说我们是通过 <code>envid</code> 获取的进程控制块，怎么可能进程控制块的 <code>env_id</code> 不相同呢？这实际上考虑了这样一种情况，某一进程完成运行，资源被回收，这时其对应的进程控制块会插入回 <code>env_free_list</code> 中。当我们需要再次创建内存时，就可能重新取得该进程控制块，并为其赋予不同的 envid。这时，已销毁进程的 envid 和新创建进程的 envid 都能通过 <code>ENVX</code> 宏取得相同的值，对应了同一个进程控制块。可是已销毁进程的 envid 却不应当再次出现，<code>e-&gt;env_id != envid</code> 就处理了 <code>envid</code> 属于已销毁进程的情况。<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (e-&gt;env_status == ENV_FREE || e-&gt;env_id != envid) &#123;</span><br><span class="line">	<span class="keyword">return</span> -E_BAD_ENV;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>对于设置了 <code>checkperm</code> 的情况，我们还需要额外检查传入的 <code>envid</code> 是否与当前进程具有直接亲缘关系。由此也可以得知，对于一些操作，只有父进程对子进程具有权限。<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Step 2: Check when &#x27;checkperm&#x27; is non-zero. */</span></span><br><span class="line"><span class="comment">/* Hints:</span></span><br><span class="line"><span class="comment"> *   Check whether the calling env has sufficient permissions to manipulate the</span></span><br><span class="line"><span class="comment"> *   specified env, i.e. &#x27;e&#x27; is either &#x27;curenv&#x27; or its immediate child.</span></span><br><span class="line"><span class="comment"> *   If violated, return &#x27;-E_BAD_ENV&#x27;.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/* Exercise 4.3: Your code here. (2/2) */</span></span><br><span class="line"><span class="keyword">if</span> (checkperm &amp;&amp; e-&gt;env_id != curenv-&gt;env_id  &amp;&amp;e-&gt;env_parent_id != curenv-&gt;env_id) &#123;</span><br><span class="line">	<span class="keyword">return</span> -E_BAD_ENV;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>最后返回取得的进程控制块。<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">	<span class="comment">/* Step 3: Assign &#x27;e&#x27; to &#x27;*penv&#x27;. */</span></span><br><span class="line">	*penv = e;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="（2）写时复制技术（Copy-on-Write-COW）"><a href="#（2）写时复制技术（Copy-on-Write-COW）" class="headerlink" title="（2）写时复制技术（Copy on Write, COW）"></a>（2）写时复制技术（Copy on Write, COW）</h3><p>所以说，我们为什么需要设置 TLB Mod 的异常处理函数呢？在这里我们的目的是实现进程的写时复制。我们知道，<code>fork</code> 会根据复制调用进程来创建一个新进程。可如果每创建一个新的进程就要在内存中复制一份相同的数据，开销就太大了。所以我们可以在创建子进程时只是让子进程映射到和父进程相同的物理页。这样如果父进程和子进程只是读取其中的内容，就可以共享同一片物理空间。那么如果有进程想要修改该空间内的数据要怎么办？这时我们才需要将这块物理空间复制一份，让想要修改的进程只修改属于自己的数据。</p>
<p>在 MOS 中，对于可以共享的页，我们会去掉其写入（<code>PTE_D</code>）权限，为其赋予写时复制标记（<code>PTE_COW</code>），这样当共享该页面的某一个进程尝试修改该页的数据时，因为不具有 <code>PTE_D</code> 权限，就会产生 TLB Mod 异常。转到异常处理函数。根据 <code>fork</code> 中的语句可知，我们的异常处理函数为 <code>cow_entry</code>，同样位于 user/lib/fork.c 中。</p>
<p>首先，我们取得发生异常时尝试写入的虚拟地址位置，使用 <code>VPN</code> 宏获取该虚拟地址对应的页表项索引。之后使用 <code>vpt</code> 获取页表项的内容，通过位操作取出该页表项的权限。发生 TLB Mod 的必然是被共享的页面，因此如果不具有 <code>PTE_COW</code> 则产生一个 <code>user_panic</code>。<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> __attribute__((<span class="keyword">noreturn</span>)) cow_entry(<span class="keyword">struct</span> Trapframe *tf) &#123;</span><br><span class="line">	u_int va = tf-&gt;cp0_badvaddr;</span><br><span class="line">	u_int perm;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Step 1: Find the &#x27;perm&#x27; in which the faulting address &#x27;va&#x27; is mapped. */</span></span><br><span class="line">	<span class="comment">/* Hint: Use &#x27;vpt&#x27; and &#x27;VPN&#x27; to find the page table entry. If the &#x27;perm&#x27; doesn&#x27;t have</span></span><br><span class="line"><span class="comment">	 * &#x27;PTE_COW&#x27;, launch a &#x27;user_panic&#x27;. */</span></span><br><span class="line">	<span class="comment">/* Exercise 4.13: Your code here. (1/6) */</span></span><br><span class="line">	perm = vpt[VPN(va)] &amp; <span class="number">0xfff</span>;</span><br><span class="line">	<span class="keyword">if</span> (!(perm &amp; PTE_COW)) &#123;</span><br><span class="line">		user_panic(<span class="string">&quot;perm doesn&#x27;t have PTE_COW&quot;</span>);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure></p>
<p>值得注意的是 <code>vpt</code>。从表现上来看，<code>vpt</code> 是一个 <code>Pte</code> 类型的数组，其中按虚拟地址的顺序存储了所有的页表项。从本质上看，<code>vpt</code> 是用户空间中的地址，并且正是页表自映射时设置的基地址。这样我们就不难理解为什么可以通过这取得所有列表项了。类似的还有 <code>vpd</code>，是存储页目录项的数组。<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> vpt ((volatile Pte *)UVPT)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> vpd ((volatile Pde *)(UVPT + (PDX(UVPT) &lt;&lt; PGSHIFT)))</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<p>如果你忘了页表自映射，可以回头看看 Lab2 和 Lab3。在 MOS 中实现页表自映射的语句位于 kern/env.c 的 <code>env_setup_vm</code> 中。<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Step 3: Map its own page table at &#x27;UVPT&#x27; with readonly permission.</span></span><br><span class="line"><span class="comment"> * As a result, user programs can read its page table through &#x27;UVPT&#x27; */</span></span><br><span class="line">e-&gt;env_pgdir[PDX(UVPT)] = PADDR(e-&gt;env_pgdir) | PTE_V;</span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<p>让我们回到 <code>cow_entry</code>，接下来重新设置页的权限，再去掉 <code>PTE_COW</code>，加上 <code>PTE_D</code>。<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Step 2: Remove &#x27;PTE_COW&#x27; from the &#x27;perm&#x27;, and add &#x27;PTE_D&#x27; to it. */</span></span><br><span class="line"><span class="comment">/* Exercise 4.13: Your code here. (2/6) */</span></span><br><span class="line">perm = (perm &amp; ~PTE_COW) | PTE_D;</span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<p>接着再申请一页新的物理页，该物理页对应的虚拟地址为 <code>UCOW</code>。因为处于用户程序中，所以不能使用 <code>page_alloc</code>，而需要使用系统调用。需要注意，因为 asid = 0，所以新物理页是属于当前调用进程的。<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/* Step 3: Allocate a new page at &#x27;UCOW&#x27;. */</span></span><br><span class="line"><span class="comment">/* Exercise 4.13: Your code here. (3/6) */</span></span><br><span class="line">syscall_mem_alloc(<span class="number">0</span>, (<span class="type">void</span> *)UCOW, perm);</span><br></pre></td></tr></table></figure></p>
<p>还有一点值得思考，这里我们申请的物理页不在发生异常的 <code>va</code> 的位置，而是特定的 <code>UCOW</code>。之后又通过一系列映射操作将该物理页映射到 <code>va</code>。为什么要这样做呢？很简单，如果我们一开始就映射到 <code>va</code>，那么如果你还记得 <code>page_insert</code> 内容的话，就会知道这样会使原本的映射丢失，我们就不能访问原本 <code>va</code> 映射到的物理页的内容了。这样的话我们又要如何复制呢？所以要先映射到一个完全无关的地址 <code>UCOW</code>。该地址之上 <code>BY2PG</code> 大小的空间专门用于写时复制时申请新的物理页。</p>
<p><code>syscall_mem_alloc</code> 系统调用较为简单，只是单纯的申请物理页，并插入到对应进程中。<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sys_mem_alloc</span><span class="params">(u_int envid, u_int va, u_int perm)</span> &#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Env</span> *<span class="title">env</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Page</span> *<span class="title">pp</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Step 1: Check if &#x27;va&#x27; is a legal user virtual address using &#x27;is_illegal_va&#x27;. */</span></span><br><span class="line">	<span class="comment">/* Exercise 4.4: Your code here. (1/3) */</span></span><br><span class="line">	<span class="keyword">if</span> (is_illegal_va(va)) &#123;</span><br><span class="line">		<span class="keyword">return</span> -E_INVAL;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Step 2: Convert the envid to its corresponding &#x27;struct Env *&#x27; using &#x27;envid2env&#x27;. */</span></span><br><span class="line">	<span class="comment">/* Hint: **Always** validate the permission in syscalls! */</span></span><br><span class="line">	<span class="comment">/* Exercise 4.4: Your code here. (2/3) */</span></span><br><span class="line">	try(envid2env(envid, &amp;env, <span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Step 3: Allocate a physical page using &#x27;page_alloc&#x27;. */</span></span><br><span class="line">	<span class="comment">/* Exercise 4.4: Your code here. (3/3) */</span></span><br><span class="line">	try(page_alloc(&amp;pp));</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Step 4: Map the :allocated page at &#x27;va&#x27; with permission &#x27;perm&#x27; using &#x27;page_insert&#x27;. */</span></span><br><span class="line">	<span class="keyword">return</span> page_insert(env-&gt;env_pgdir, env-&gt;env_asid, pp, va, perm);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>is_illegal_va</code> 函数用于判断虚拟地址是否位于用户空间中<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">int</span> <span class="title function_">is_illegal_va</span><span class="params">(u_long va)</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> va &lt; UTEMP || va &gt;= UTOP;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>回到 <code>cow_entry</code>，接下来我们将 <code>va</code> 所在物理页的内容复制到新申请的页面中。注意 <code>va</code> 可能只是随意的一个虚拟地址，不一定以 <code>BY2PG</code> 对齐，因此还需要使用 <code>ROUNDDOWN</code> 将其对齐。<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Step 4: Copy the content of the faulting page at &#x27;va&#x27; to &#x27;UCOW&#x27;. */</span></span><br><span class="line"><span class="comment">/* Hint: &#x27;va&#x27; may not be aligned to a page! */</span></span><br><span class="line"><span class="comment">/* Exercise 4.13: Your code here. (4/6) */</span></span><br><span class="line"><span class="built_in">memcpy</span>((<span class="type">void</span> *)UCOW, (<span class="type">void</span> *)ROUNDDOWN(va, BY2PG), BY2PG);</span><br></pre></td></tr></table></figure></p>
<p>现在我们只需要取消 <code>va</code> 到原物理页的映射，将 <code>va</code> 映射到新申请的物理页即可。因此首先，使用系统调用 <code>syscall_mem_map</code> 将当前进程的 <code>UCOW</code> 所在的物理页，作为当前进程的 <code>va</code> 地址所映射的物理页，并设定其权限即可。<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Step 5: Map the page at &#x27;UCOW&#x27; to &#x27;va&#x27; with the new &#x27;perm&#x27;.</span></span><br><span class="line"><span class="comment">/* Exercise 4.13: Your code here. (5/6) */</span></span><br><span class="line">syscall_mem_map(<span class="number">0</span>, (<span class="type">void</span> *)UCOW, <span class="number">0</span>, (<span class="type">void</span> *)va, perm);</span><br></pre></td></tr></table></figure></p>
<p>该系统调用同样是一个较为简单的函数。首先判断虚拟地址是否位于用户空间<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sys_mem_map</span><span class="params">(u_int srcid, u_int srcva, u_int dstid, u_int dstva, u_int perm)</span> &#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Env</span> *<span class="title">srcenv</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Env</span> *<span class="title">dstenv</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Page</span> *<span class="title">pp</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Step 1: Check if &#x27;srcva&#x27; and &#x27;dstva&#x27; are legal user virtual addresses using</span></span><br><span class="line"><span class="comment">	 * &#x27;is_illegal_va&#x27;. */</span></span><br><span class="line">	<span class="comment">/* Exercise 4.5: Your code here. (1/4) */</span></span><br><span class="line">	<span class="keyword">if</span> (is_illegal_va(srcva) || is_illegal_va(dstva)) &#123;</span><br><span class="line">		<span class="keyword">return</span> -E_INVAL;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure></p>
<p>之后取得 <code>srcid</code>，<code>dstid</code> 进程标识符所对应的进程控制块<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Step 2: Convert the &#x27;srcid&#x27; to its corresponding &#x27;struct Env *&#x27; using &#x27;envid2env&#x27;. */</span></span><br><span class="line"><span class="comment">/* Exercise 4.5: Your code here. (2/4) */</span></span><br><span class="line">try(envid2env(srcid, &amp;srcenv, <span class="number">1</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Step 3: Convert the &#x27;dstid&#x27; to its corresponding &#x27;struct Env *&#x27; using &#x27;envid2env&#x27;. */</span></span><br><span class="line"><span class="comment">/* Exercise 4.5: Your code here. (3/4) */</span></span><br><span class="line">try(envid2env(dstid, &amp;dstenv, <span class="number">1</span>));</span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<p>从源进程的页表系统中查找 <code>srcva</code> 对应的物理页<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Step 4: Find the physical page mapped at &#x27;srcva&#x27; in the address space of &#x27;srcid&#x27;. */</span></span><br><span class="line"><span class="comment">/* Return -E_INVAL if &#x27;srcva&#x27; is not mapped. */</span></span><br><span class="line"><span class="comment">/* Exercise 4.5: Your code here. (4/4) */</span></span><br><span class="line"><span class="keyword">if</span> ((pp = page_lookup(srcenv-&gt;env_pgdir, srcva, <span class="literal">NULL</span>)) == <span class="literal">NULL</span>) &#123;</span><br><span class="line">	<span class="keyword">return</span> -E_INVAL;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<p>在目标进程的页表系统中创建 <code>dstva</code> 到该物理页的映射，同时设置权限<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">	<span class="comment">/* Step 5: Map the physical page at &#x27;dstva&#x27; in the address space of &#x27;dstid&#x27;. */</span></span><br><span class="line">	<span class="keyword">return</span> page_insert(dstenv-&gt;env_pgdir, dstenv-&gt;env_asid, pp, dstva, perm);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<p>这里因为 <code>page_insert</code> 会在要创建映射的虚拟地址已存在映射的情况下取消先前的映射，所以我们调用 <code>syscall_mem_map</code> 就同时完成了 “取消 <code>va</code> 到原物理页的映射” 和 “将 <code>va</code> 映射到新申请的物理页” 这两个操作。</p>
<p><code>UCOW</code> 处还存在到新申请物理页的映射，我们需要取消该映射。调用 <code>syscall_mem_unmap</code> 实现 “取消该进程中 UCOW 与物理页的映射” 操作。<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Step 6: Unmap the page at &#x27;UCOW&#x27;.</span></span><br><span class="line"><span class="comment">/* Exercise 4.13: Your code here. (6/6) */</span></span><br><span class="line">syscall_mem_unmap(<span class="number">0</span>, (<span class="type">void</span> *)UCOW);</span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<p><code>syscall_mem_unmap</code> 只是调用 <code>page_remove</code> 取消了映射而已。<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sys_mem_unmap</span><span class="params">(u_int envid, u_int va)</span> &#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Env</span> *<span class="title">e</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Step 1: Check if &#x27;va&#x27; is a legal user virtual address using &#x27;is_illegal_va&#x27;. */</span></span><br><span class="line">	<span class="comment">/* Exercise 4.6: Your code here. (1/2) */</span></span><br><span class="line">	<span class="keyword">if</span> (is_illegal_va(va)) &#123;</span><br><span class="line">		<span class="keyword">return</span> -E_INVAL;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Step 2: Convert the envid to its corresponding &#x27;struct Env *&#x27; using &#x27;envid2env&#x27;. */</span></span><br><span class="line">	<span class="comment">/* Exercise 4.6: Your code here. (2/2) */</span></span><br><span class="line">	try(envid2env(envid, &amp;e, <span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Step 3: Unmap the physical page at &#x27;va&#x27; in the address space of &#x27;envid&#x27;. */</span></span><br><span class="line">	page_remove(e-&gt;env_pgdir, e-&gt;env_asid, va);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<p>最后，我们需要在异常处理完成后恢复现场，可现在位于用户态，去哪里恢复现场呢？我们需要使用系统调用 <code>syscall_set_trapframe</code>。也因此 <code>cow_entry</code> 成为了一个不返回的函数 （<code>__attribute__((noreturn))</code>）。<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">	<span class="comment">// Step 7: Return to the faulting routine.</span></span><br><span class="line">	<span class="type">int</span> r = syscall_set_trapframe(<span class="number">0</span>, tf);</span><br><span class="line">	user_panic(<span class="string">&quot;syscall_set_trapframe returned %d&quot;</span>, r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>sys_set_trapframe</code> 将 trap frame 修改为传入的参数 <code>struct Trapframe *tf</code> 对应的 trap frame。这样当<strong>从该系统调用返回</strong>时，将返回设置的栈帧中 <code>epc</code> 的位置。对于 <code>cow_entry</code> 来说，意味着恢复到产生 TLB Mod 时的现场。<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sys_set_trapframe</span><span class="params">(u_int envid, <span class="keyword">struct</span> Trapframe *tf)</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> (is_illegal_va_range((u_long)tf, <span class="keyword">sizeof</span> *tf)) &#123;</span><br><span class="line">		<span class="keyword">return</span> -E_INVAL;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Env</span> *<span class="title">env</span>;</span></span><br><span class="line">	try(envid2env(envid, &amp;env, <span class="number">1</span>));</span><br><span class="line">	<span class="keyword">if</span> (env == curenv) &#123;</span><br><span class="line">		*((<span class="keyword">struct</span> Trapframe *)KSTACKTOP - <span class="number">1</span>) = *tf;</span><br><span class="line">		<span class="comment">// return `tf-&gt;regs[2]` instead of 0, because return value overrides regs[2] on</span></span><br><span class="line">		<span class="comment">// current trapframe.</span></span><br><span class="line">		<span class="keyword">return</span> tf-&gt;regs[<span class="number">2</span>];</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		env-&gt;env_tf = *tf;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这样，写时复制的主要流程就结束了。</p>
<h3 id="（3）一次调用、两次返回"><a href="#（3）一次调用、两次返回" class="headerlink" title="（3）一次调用、两次返回"></a>（3）一次调用、两次返回</h3><p>我们继续看 <code>fork</code> 函数。接下来的步骤是 <code>fork</code> 的关键。我们使用 <code>syscall_exofork</code> 系统调用。该系统调用的作用是复制父进程的信息，创建一个子进程。该系统调用实现了一次调用、两次返回，也是 <code>fork</code> 拥有此能力的原因。<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Step 2: Create a child env that&#x27;s not ready to be scheduled. */</span></span><br><span class="line"><span class="comment">// Hint: &#x27;env&#x27; should always point to the current env itself, so we should fix it to the</span></span><br><span class="line"><span class="comment">// correct value.</span></span><br><span class="line">child = syscall_exofork();</span><br></pre></td></tr></table></figure></p>
<p>在此调用之后的一条语句，我们就通过不同返回值实现了父子进程的不同流程，对于子进程来说，我们直接返回 0。这里我们还设置了 <code>env</code> 的值为当前进程（因为复制后，<code>env</code> 原本还指向父进程）。为了取得当前进程的 envid，我们又使用了系统调用 <code>syscall_getenvid</code>。再次强调，<code>env</code> 和 <code>envs</code> 是位于用户空间的。<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (child == <span class="number">0</span>) &#123;</span><br><span class="line">	env = envs + ENVX(syscall_getenvid());</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>接下来我们就分析一下 <code>syscall_exofork</code>。首先，为了创建新的进程，我们需要申请一个进程控制块。需要注意，这里 <code>env_alloc</code> 的 parent 参数为当前进程的 envid。<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sys_exofork</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Env</span> *<span class="title">e</span>;</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">/* Step 1: Allocate a new env using &#x27;env_alloc&#x27;. */</span></span><br><span class="line">	<span class="comment">/* Exercise 4.9: Your code here. (1/4) */</span></span><br><span class="line">	try(env_alloc(&amp;e, curenv-&gt;env_id));</span><br></pre></td></tr></table></figure></p>
<p>接着我们复制父进程调用系统操作时的现场。<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Step 2: Copy the current Trapframe below &#x27;KSTACKTOP&#x27; to the new env&#x27;s &#x27;env_tf&#x27;. */</span></span><br><span class="line"><span class="comment">/* Exercise 4.9: Your code here. (2/4) */</span></span><br><span class="line">e-&gt;env_tf = *((<span class="keyword">struct</span> Trapframe *)KSTACKTOP - <span class="number">1</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<p>需要注意这里不能使用 <code>curenv-&gt;env_tf</code>。因为 <code>curenv-&gt;env_tf</code> 存储的是进程调度，切换为其他进程之前的 trap frame。而父进程调用 <code>syscall_exofork</code> 时保存的现场，并不一定等同于<code>curenv-&gt;tf</code> 中的信息。如果你还记得 Lab3，应该明白只有一处进行了 <code>env_tf</code> 的赋值。就是在 <code>env_run</code> 函数中。<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (curenv) &#123;</span><br><span class="line">	curenv-&gt;env_tf = *((<span class="keyword">struct</span> Trapframe *)KSTACKTOP - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>最后 <code>syscall_exofork</code> 将子进程的返回值设置为 0，同时设置进程的状态和优先级，最后返回新创建进程的 envid。<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">	<span class="comment">/* Step 3: Set the new env&#x27;s &#x27;env_tf.regs[2]&#x27; to 0 to indicate the return value in child. */</span></span><br><span class="line">	<span class="comment">/* Exercise 4.9: Your code here. (3/4) */</span></span><br><span class="line">	e-&gt;env_tf.regs[<span class="number">2</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Step 4: Set up the new env&#x27;s &#x27;env_status&#x27; and &#x27;env_pri&#x27;.  */</span></span><br><span class="line">	<span class="comment">/* Exercise 4.9: Your code here. (4/4) */</span></span><br><span class="line">	e-&gt;env_status = ENV_NOT_RUNNABLE;</span><br><span class="line">	e-&gt;env_pri = curenv-&gt;env_pri;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> e-&gt;env_id;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>到这里你应该能理解何为 “一次调用、两次返回” 了。一次调用指的是只有父进程调用了 <code>syscall_exofork</code>，两次返回分别是父进程调用 <code>syscall_exofork</code> 得到的返回值和被创建的子进程中设定了 <code>v0</code> 寄存器的值为 0 作为返回值。这样当子进程开始运行时，就会拥有一个和父进程不同的返回值。</p>
<h3 id="（4）子进程运行前的设置"><a href="#（4）子进程运行前的设置" class="headerlink" title="（4）子进程运行前的设置"></a>（4）子进程运行前的设置</h3><p>我们已经创建了子进程，但是子进程现在还没有加入调度队列，同时父子进程虽然共享了页表，但页表项还没有设置 <code>PTE_COW</code> 位。这些我们都要进行处理。</p>
<p>设置 <code>PTE_COW</code> 位需要通过 <code>duppage</code> 函数。如果当前页表项具有 <code>PTE_D</code> 权限（且不是共享页面 <code>PTE_LIBRARY</code>），则需要重新设置页表项的权限。<code>duppage</code> 会对每一个页表项进行操作，因此我们需要在 <code>fork</code> 中遍历所有的页表项。相比于在内核态中，在用户态中遍历页表项更为方便。</p>
<p>这里我们只遍历 <code>USTACKTOP</code> 之下的地址空间，因为其上的空间总是会被共享。在调用 <code>duppage</code> 之前，我们判断页目录项和页表项是否有效。如果不判断则会在 <code>duppage</code> 函数中发生异常（最终是由 <code>page_lookup</code> 产生的）。需要注意取页目录项的方法，<code>vpd</code> 是页目录项数组，<code>i</code> 相当于地址的高 20 位，我们需要取得地址的高 10 位作为页目录的索引，因此有 <code>vpd[i &gt;&gt; 10]</code><br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Step 3: Map all mapped pages below &#x27;USTACKTOP&#x27; into the child&#x27;s address space. */</span></span><br><span class="line"><span class="comment">// Hint: You should use &#x27;duppage&#x27;.</span></span><br><span class="line"><span class="comment">/* Exercise 4.15: Your code here. (1/2) */</span></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; VPN(USTACKTOP); i++) &#123;</span><br><span class="line">	<span class="keyword">if</span> ((vpd[i &gt;&gt; <span class="number">10</span>] &amp; PTE_V) &amp;&amp; (vpt[i] &amp; PTE_V)) &#123;</span><br><span class="line">		duppage(child, i);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>接下来让我们看一下 <code>duppage</code> 函数。首先取得页表项对应的虚拟地址和权限。<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">duppage</span><span class="params">(u_int envid, u_int vpn)</span> &#123;</span><br><span class="line">	<span class="type">int</span> r;</span><br><span class="line">	u_int addr;</span><br><span class="line">	u_int perm;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Step 1: Get the permission of the page. */</span></span><br><span class="line">	<span class="comment">/* Hint: Use &#x27;vpt&#x27; to find the page table entry. */</span></span><br><span class="line">	<span class="comment">/* Exercise 4.10: Your code here. (1/2) */</span></span><br><span class="line">	addr = vpn &lt;&lt; PGSHIFT;</span><br><span class="line">	perm = vpt[vpn] &amp; <span class="number">0xfff</span>;</span><br></pre></td></tr></table></figure></p>
<p>接着，对所有有效的页，我们都需要通过系统调用 <code>syscall_mem_map</code> 实现父进程与子进程页面的共享。特别的，对于可写的，且不是共享的页，我们还需要更新页表项的权限。在用户态，我们不能直接修改页表项，因此需要通过系统调用来实现修改。我们同样使用的是 <code>syscall_mem_map</code>。虽然之前我们使用此系统调用来进行页的共享和复制，但由于该系统调用具有新的映射会覆盖旧的映射的特点，因此可以对本来就有的关系采取重新映射，只改变权限位的设置，就可以实现权限位的修改。<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">	<span class="comment">/* Step 2: If the page is writable, and not shared with children, and not marked as COW yet,</span></span><br><span class="line"><span class="comment">	 * then map it as copy-on-write, both in the parent (0) and the child (envid). */</span></span><br><span class="line">	<span class="comment">/* Hint: The page should be first mapped to the child before remapped in the parent. (Why?)</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="comment">/* Exercise 4.10: Your code here. (2/2) */</span></span><br><span class="line">	<span class="type">int</span> flag = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span> ((perm &amp; PTE_D) &amp;&amp; !(perm &amp; PTE_LIBRARY)) &#123;</span><br><span class="line">		perm = (perm &amp; ~ PTE_D) | PTE_COW;</span><br><span class="line">		flag = <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	syscall_mem_map(<span class="number">0</span>, addr, envid, addr, perm);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span> (flag) &#123;</span><br><span class="line">		syscall_mem_map(<span class="number">0</span>, addr, <span class="number">0</span>, addr, perm);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里需要注意，父进程将页映射到子进程应该先于对自己权限的修改。如果先修改自己的权限位，则该页表就不再可写，这样的话就会发生 TLB Mod 异常，而不能实现父进程将页映射到子进程。</p>
<p>之后在 <code>fork</code> 中，我们同样设置子进程的 TLB Mod 异常处理函数为 <code>cow_entry</code>。<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Step 4: Set up the child&#x27;s tlb mod handler and set child&#x27;s &#x27;env_status&#x27; to</span></span><br><span class="line"><span class="comment"> * &#x27;ENV_RUNNABLE&#x27;. */</span></span><br><span class="line"><span class="comment">/* Hint:</span></span><br><span class="line"><span class="comment"> *   You may use &#x27;syscall_set_tlb_mod_entry&#x27; and &#x27;syscall_set_env_status&#x27;</span></span><br><span class="line"><span class="comment"> *   Child&#x27;s TLB Mod user exception entry should handle COW, so set it to &#x27;cow_entry&#x27;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/* Exercise 4.15: Your code here. (2/2) */</span></span><br><span class="line">try(syscall_set_tlb_mod_entry(child, cow_entry));</span><br></pre></td></tr></table></figure></p>
<p>最后，我们调用 <code>syscall_set_env_status</code> 将子进程状态设定为 <code>RUNNABLE</code> 并将其加入调度队列中。返回子进程的 envid。作为父进程 <code>fork</code> 的返回值。<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">	try(syscall_set_env_status(child, ENV_RUNNABLE));</span><br><span class="line">	<span class="keyword">return</span> child;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>syscall_set_env_status</code> 较为简单，只是根据设定的状态将进程加入或移除调度队列而已。<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sys_set_env_status</span><span class="params">(u_int envid, u_int status)</span> &#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Env</span> *<span class="title">env</span>;</span></span><br><span class="line">	<span class="comment">/* Step 1: Check if &#x27;status&#x27; is valid. */</span></span><br><span class="line">	<span class="comment">/* Exercise 4.14: Your code here. (1/3) */</span></span><br><span class="line">	<span class="keyword">if</span> (status != ENV_RUNNABLE &amp;&amp; status != ENV_NOT_RUNNABLE) &#123;</span><br><span class="line">		<span class="keyword">return</span> -E_INVAL;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Step 2: Convert the envid to its corresponding &#x27;struct Env *&#x27; using &#x27;envid2env&#x27;. */</span></span><br><span class="line">	<span class="comment">/* Exercise 4.14: Your code here. (2/3) */</span></span><br><span class="line">	try(envid2env(envid, &amp;env, <span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Step 4: Update &#x27;env_sched_list&#x27; if the &#x27;env_status&#x27; of &#x27;env&#x27; is being changed. */</span></span><br><span class="line">	<span class="comment">/* Exercise 4.14: Your code here. (3/3) */</span></span><br><span class="line">	<span class="keyword">if</span> (env-&gt;env_status != ENV_NOT_RUNNABLE &amp;&amp; status == ENV_NOT_RUNNABLE) &#123;</span><br><span class="line">		TAILQ_REMOVE(&amp;env_sched_list, env, env_sched_link);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (env-&gt;env_status != ENV_RUNNABLE &amp;&amp; status == ENV_RUNNABLE) &#123;</span><br><span class="line">		TAILQ_INSERT_TAIL(&amp;env_sched_list, env, env_sched_link);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Step 5: Set the &#x27;env_status&#x27; of &#x27;env&#x27;. */</span></span><br><span class="line">	env-&gt;env_status = status;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这样，我们就通过 <code>fork</code> 完成了子进程的创建。</p>
<h2 id="三、进程间通信"><a href="#三、进程间通信" class="headerlink" title="三、进程间通信"></a>三、进程间通信</h2><h3 id="（1）信息接收"><a href="#（1）信息接收" class="headerlink" title="（1）信息接收"></a>（1）信息接收</h3><p>在 Lab4 中，我们还需要实现进程间通信。这需要实现两个系统调用 <code>syscall_ipc_try_send</code> 和 <code>syscall_ipc_recv</code>。</p>
<p>调用 <code>syscall_ipc_recv</code> 后会阻塞当前进程，直到收到信息。</p>
<p>该调用的参数为要接收信息的虚拟地址。首先我们要检查虚拟地址是否处于用户空间。另外当 <code>dstva</code> 为 0 时表示不需要传输额外信息。<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sys_ipc_recv</span><span class="params">(u_int dstva)</span> &#123;</span><br><span class="line">	<span class="comment">/* Step 1: Check if &#x27;dstva&#x27; is either zero or a legal address. */</span></span><br><span class="line">	<span class="keyword">if</span> (dstva != <span class="number">0</span> &amp;&amp; is_illegal_va(dstva)) &#123;</span><br><span class="line">		<span class="keyword">return</span> -E_INVAL;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure></p>
<p>接着我们设置进程控制块的字段，<code>env_ipc_recving</code> 表示进程是否正在接收信息；<code>env_ipc_dstva</code> 存储要接收信息的地址。<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Step 2: Set &#x27;curenv-&gt;env_ipc_recving&#x27; to 1. */</span></span><br><span class="line"><span class="comment">/* Exercise 4.8: Your code here. (1/8) */</span></span><br><span class="line">curenv-&gt;env_ipc_recving = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Step 3: Set the value of &#x27;curenv-&gt;env_ipc_dstva&#x27;. */</span></span><br><span class="line"><span class="comment">/* Exercise 4.8: Your code here. (2/8) */</span></span><br><span class="line">curenv-&gt;env_ipc_dstva = dstva;</span><br></pre></td></tr></table></figure></p>
<p>接着我们要阻塞当前进程，将该进程从调度队列中移出<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Step 4: Set the status of &#x27;curenv&#x27; to &#x27;ENV_NOT_RUNNABLE&#x27; and remove it from</span></span><br><span class="line"><span class="comment"> * &#x27;env_sched_list&#x27;. */</span></span><br><span class="line"><span class="comment">/* Exercise 4.8: Your code here. (3/8) */</span></span><br><span class="line">curenv-&gt;env_status = ENV_NOT_RUNNABLE;</span><br><span class="line">TAILQ_REMOVE(&amp;env_sched_list, curenv, env_sched_link);</span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<p>最后我们将返回值设置为 0，调用 <code>schedule</code> 函数进行进程切换。<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">	<span class="comment">/* Step 5: Give up the CPU and block until a message is received. */</span></span><br><span class="line">	((<span class="keyword">struct</span> Trapframe *)KSTACKTOP - <span class="number">1</span>)-&gt;regs[<span class="number">2</span>] = <span class="number">0</span>;</span><br><span class="line">	schedule(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>你可能会想，<code>schedule</code> 函数不是没有返回的吗？那这里设置的返回值保存在哪里？另外如果没有返回，该系统调用又要如何返回到用户程序中？关键在于 <code>env_run</code> 函数中。在进程切换之前，会将 trap frame 存储到 <code>env-&gt;env_tf</code> 中。当重新轮到该进程运行的时候，就会从 <code>env_tf</code> 存储的位置恢复现场。这里也重新强调了 <code>sys_exofork</code> 中为什么不能使用 <code>env_tf</code>。</p>
<h3 id="（2）信息发送"><a href="#（2）信息发送" class="headerlink" title="（2）信息发送"></a>（2）信息发送</h3><p>在 <code>sys_ipc_try_send</code> 中我们同样判断地址是否正确。并通过 envid 获取进程控制块。需要注意这里 <code>envid2env</code> 的 <code>checkperm</code> 参数为 0，而此前所有的参数值均为 1。这是因为进程通信不一定只在父子进程之间。<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sys_ipc_try_send</span><span class="params">(u_int envid, u_int value, u_int srcva, u_int perm)</span> &#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Env</span> *<span class="title">e</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Page</span> *<span class="title">p</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Step 1: Check if &#x27;srcva&#x27; is either zero or a legal address. */</span></span><br><span class="line">	<span class="comment">/* Exercise 4.8: Your code here. (4/8) */</span></span><br><span class="line">	<span class="keyword">if</span> (srcva != <span class="number">0</span> &amp;&amp; is_illegal_va(srcva)) &#123;</span><br><span class="line">		<span class="keyword">return</span> -E_INVAL;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Step 2: Convert &#x27;envid&#x27; to &#x27;struct Env *e&#x27;. */</span></span><br><span class="line">	<span class="comment">/* This is the only syscall where the &#x27;envid2env&#x27; should be used with &#x27;checkperm&#x27; UNSET,</span></span><br><span class="line"><span class="comment">	 * because the target env is not restricted to &#x27;curenv&#x27;&#x27;s children. */</span></span><br><span class="line">	<span class="comment">/* Exercise 4.8: Your code here. (5/8) */</span></span><br><span class="line">	try(envid2env(envid, &amp;e, <span class="number">0</span>));</span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<p>然后我们检查 <code>env_ipc_recving</code>，这一字段在信息接收时设置。<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Step 3: Check if the target is waiting for a message. */</span></span><br><span class="line"><span class="comment">/* Exercise 4.8: Your code here. (6/8) */</span></span><br><span class="line"><span class="keyword">if</span> (!e-&gt;env_ipc_recving) &#123;</span><br><span class="line">	<span class="keyword">return</span> -E_IPC_NOT_RECV;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<p>接下来我们传输一些信息，并将 <code>env_ipc_recving</code> 重新置 0，表示接收进程已经接收到信息。<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Step 4: Set the target&#x27;s ipc fields. */</span></span><br><span class="line">e-&gt;env_ipc_value = value;</span><br><span class="line">e-&gt;env_ipc_from = curenv-&gt;env_id;</span><br><span class="line">e-&gt;env_ipc_perm = PTE_V | perm;</span><br><span class="line">e-&gt;env_ipc_recving = <span class="number">0</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<p>既然接收到了信息，那么我们就要取消接收进程的阻塞状态。<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Step 5: Set the target&#x27;s status to &#x27;ENV_RUNNABLE&#x27; again and insert it to the tail of</span></span><br><span class="line"><span class="comment"> * &#x27;env_sched_list&#x27;. */</span></span><br><span class="line"><span class="comment">/* Exercise 4.8: Your code here. (7/8) */</span></span><br><span class="line">e-&gt;env_status = ENV_RUNNABLE;</span><br><span class="line">TAILQ_INSERT_TAIL(&amp;env_sched_list, e, env_sched_link);</span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<p>最后，我们还需要将当前进程的一个页面共享到接收进程。只有这样，接收进程才能通过该页面获得发送进程发送的一些信息。<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">	<span class="comment">/* Step 6: If &#x27;srcva&#x27; is not zero, map the page at &#x27;srcva&#x27; in &#x27;curenv&#x27; to &#x27;e-&gt;env_ipc_dstva&#x27;</span></span><br><span class="line"><span class="comment">	 * in &#x27;e&#x27;. */</span></span><br><span class="line">	<span class="comment">/* Return -E_INVAL if &#x27;srcva&#x27; is not zero and not mapped in &#x27;curenv&#x27;. */</span></span><br><span class="line">	<span class="keyword">if</span> (srcva != <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="comment">/* Exercise 4.8: Your code here. (8/8) */</span></span><br><span class="line">		p = page_lookup(curenv-&gt;env_pgdir, srcva, <span class="literal">NULL</span>);</span><br><span class="line">		<span class="keyword">if</span> (p == <span class="literal">NULL</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> -E_INVAL;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		try(page_insert(e-&gt;env_pgdir, e-&gt;env_asid, p, e-&gt;env_ipc_dstva, perm));</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>MOS</tag>
        <tag>os</tag>
        <tag>BUAA</tag>
      </tags>
  </entry>
  <entry>
    <title>BUAA-OS实验笔记之Lab5</title>
    <url>/posts/b72a5f5f/</url>
    <content><![CDATA[<h2 id="一、Lab5-前言"><a href="#一、Lab5-前言" class="headerlink" title="一、Lab5 前言"></a>一、Lab5 前言</h2><p>这是最长的一篇文章，可就算这么长，文中出现的代码也不过本次 Lab 中新增加的代码的一小部分。幸好完成本次实验不需要熟悉所有代码，一部分练习甚至不需要熟悉要填写的代码的前后文，只需要根据注释就可以填出很多。可是我感觉本篇文章还是有帮助的，毕竟谁也不知道 Exam 会出什么题。</p>
<p>Lab5 主要分为四部分，分别是镜像制作工具、关于设备的系统调用、文件系统服务进程、文件操作库函数。本文对这四个方面都有所涉及，第二章主要讲镜像制作工具，第三章主要讲文件系统服务进程和文件操作库函数，最后一章讲关于设备的系统调用。</p>
<span id="more"></span>
<h2 id="二、磁盘镜像"><a href="#二、磁盘镜像" class="headerlink" title="二、磁盘镜像"></a>二、磁盘镜像</h2><h3 id="（1）镜像制作工具"><a href="#（1）镜像制作工具" class="headerlink" title="（1）镜像制作工具"></a>（1）镜像制作工具</h3><p>在本次实验中我们要实现一个文件系统。广义来说，一切字节序列都可以称为文件，但本次实验中我们还是主要关注在磁盘中存储的数据，将这些数据按一定的结构组织起来，就是本次实验的主要目标。</p>
<p>本文依旧不按照指导书中的顺序。我们先查看位于 tools 文件夹下的磁盘镜像制作工具 fsformat 的源代码，以便我们理解磁盘以及文件系统的组织结构。</p>
<h3 id="（2）磁盘数据初始化"><a href="#（2）磁盘数据初始化" class="headerlink" title="（2）磁盘数据初始化"></a>（2）磁盘数据初始化</h3><p>我们查看 tools/fsformat.c 文件。找到其中的 <code>main</code> 函数。<code>main</code> 函数首先调用了 <code>init_disk</code> 用于初始化磁盘。<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span> &#123;</span><br><span class="line">	<span class="keyword">static_assert</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> File) == BY2FILE);</span><br><span class="line">	init_disk();</span><br></pre></td></tr></table></figure></p>
<p>该函数中我们要用到一个数据结构 <code>disk</code>。因此我们先考察 <code>disk</code>。<code>disk</code> 是一个数组，大小为 <code>NBLOCK</code>，每个元素是一个结构体，其中有字段 <code>data</code>，是一个 <code>BY2BLK</code> 字节大小的空间，用于存储一个磁盘块的数据。很容易得知，<code>NBLOCK</code> * <code>BY2BLK</code> = 磁盘空间大小。这样就可以理解 <code>disk</code> 起到的作用了，也就是在构筑磁盘镜像时暂时存储磁盘数据，等到构筑完成后再将 <code>disk</code> 中 <code>data</code> 的内容拼接并输出为二进制镜像文件。<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Block</span> &#123;</span></span><br><span class="line">	<span class="type">uint8_t</span> data[BY2BLK];</span><br><span class="line">	<span class="type">uint32_t</span> type;</span><br><span class="line">&#125; disk[NBLOCK];</span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>磁盘块是对磁盘空间的逻辑划分；扇区是对磁盘空间的物理划分</p>
</blockquote>
<p>另外 <code>Block</code> 结构体还有一个字段 <code>type</code>，该字段的值为如下枚举的值<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> &#123;</span></span><br><span class="line">	BLOCK_FREE = <span class="number">0</span>,</span><br><span class="line">	BLOCK_BOOT = <span class="number">1</span>,</span><br><span class="line">	BLOCK_BMAP = <span class="number">2</span>,</span><br><span class="line">	BLOCK_SUPER = <span class="number">3</span>,</span><br><span class="line">	BLOCK_DATA = <span class="number">4</span>,</span><br><span class="line">	BLOCK_FILE = <span class="number">5</span>,</span><br><span class="line">	BLOCK_INDEX = <span class="number">6</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>让我们回到 <code>init_disk</code>。该函数中首先将第一个磁盘块类型设为 <code>BLOCK_BOOT</code>，表示主引导扇区。之后我们要从第三个磁盘块开始（为什么不是第二个？因为第二个磁盘块为 “超级块”，将在后面介绍），设置磁盘块的位图分配机制。在函数中我们计算了在磁盘中存储位图需要的磁盘块数量。<code>NBLOCK</code> 是磁盘块的总数，那么我们同样需要 <code>NBLOCK</code> bit 大小的位图，又因为一个磁盘块有 <code>BIT2BLK</code> bit，那么总共需要 <code>NBLOCK / BIT2BLK</code> 个磁盘块。向上取整，总共需要 <code>(NBLOCK + BIT2BLK - 1) / BIT2BLK</code> 个磁盘块来存储位图。现在我们已经将 0 到 nbitblock-1 的位图分配了用途，那么下一个空闲的磁盘块就是 <code>nextbno = 2 + nbitblock</code> 了。<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Step 2: Initialize boundary.</span></span><br><span class="line">nbitblock = (NBLOCK + BIT2BLK - <span class="number">1</span>) / BIT2BLK;</span><br><span class="line">nextbno = <span class="number">2</span> + nbitblock;</span><br></pre></td></tr></table></figure></p>
<p>对于存储位图的磁盘块，我们要将其初始化。首先我们将这些磁盘块标记为 <code>BLOCK_BMAP</code>，表示他们用作存储位图<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Step 2: Initialize bitmap blocks.</span></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; nbitblock; ++i) &#123;</span><br><span class="line">	disk[<span class="number">2</span> + i].type = BLOCK_BMAP;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>对于位图，我们设定 1 表示空闲，0 表示使用。因此我们先将所有的磁盘块数据都设定为 1。<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; nbitblock; ++i) &#123;</span><br><span class="line">	<span class="built_in">memset</span>(disk[<span class="number">2</span> + i].data, <span class="number">0xff</span>, BY2BLK);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>最后如果位图不足以占用全部空间，那么我们还需要将最后一个磁盘块末位不作为位图使用的部分置 0。<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (NBLOCK != nbitblock * BIT2BLK) &#123;</span><br><span class="line">	diff = NBLOCK % BIT2BLK / <span class="number">8</span>;</span><br><span class="line">	<span class="built_in">memset</span>(disk[<span class="number">2</span> + (nbitblock - <span class="number">1</span>)].data + diff, <span class="number">0x00</span>, BY2BLK - diff);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>我们不要忘记了第二个磁盘块，这个磁盘块会用作 “超级块”，所谓超级块，就是文件系统的起点，该磁盘块中存储了根目录文件的信息（当然还包括其他一些内容）。超级块定义在 user/include/fs.h 中。包含了用于验证文件系统的幻数 <code>s_magic</code>，磁盘的磁盘块总数 <code>s_nblocks</code> 和根目录文件节点 <code>s_root</code>。<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Super</span> &#123;</span></span><br><span class="line">	<span class="type">uint32_t</span> s_magic;   <span class="comment">// Magic number: FS_MAGIC</span></span><br><span class="line">	<span class="type">uint32_t</span> s_nblocks; <span class="comment">// Total number of blocks on disk</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">File</span> <span class="title">s_root</span>;</span> <span class="comment">// Root directory node</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>在本文件系统中，文件信息通过 <code>struct File</code> 结构体存储。该结构体同样定义在 user/include/fs.h 中，在本文的后面我们将其称为文件控制块。<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">File</span> &#123;</span></span><br><span class="line">	<span class="type">char</span> f_name[MAXNAMELEN]; <span class="comment">// filename</span></span><br><span class="line">	<span class="type">uint32_t</span> f_size;	 <span class="comment">// file size in bytes</span></span><br><span class="line">	<span class="type">uint32_t</span> f_type;	 <span class="comment">// file type</span></span><br><span class="line">	<span class="type">uint32_t</span> f_direct[NDIRECT];</span><br><span class="line">	<span class="type">uint32_t</span> f_indirect;</span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">File</span> *<span class="title">f_dir</span>;</span> <span class="comment">// the pointer to the dir where this file is in, valid only in memory.</span></span><br><span class="line">	<span class="type">char</span> f_pad[BY2FILE - MAXNAMELEN - (<span class="number">3</span> + NDIRECT) * <span class="number">4</span> - <span class="keyword">sizeof</span>(<span class="type">void</span> *)];</span><br><span class="line">&#125; __attribute__((aligned(<span class="number">4</span>), packed));</span><br></pre></td></tr></table></figure></p>
<p>该结构体中包含了文件名 <code>f_name</code>，文件大小 <code>f_size</code>，文件类型 <code>f_type</code>，和用于存储指向存储文件内容的磁盘块的编号的数组 <code>f_direct</code>，以及指向存储 “存储指向存储文件内容的磁盘块的编号的数组” 的磁盘块的编号 <code>f_indirect</code>，还有自己所在的目录 <code>f_dir</code>。最后 <code>f_pad</code> 将文件控制块的大小填充到 <code>BY2FILE</code>，保证多个文件控制块能够填满整个磁盘。</p>
<blockquote>
<p><code>f_direct</code> 和 <code>f_indirect</code> 用一句话来表示似乎有些困难，这里再重新说明一下。文件的内容需要在磁盘中存储，这些内容分布于不同的磁盘块中，因此还需要对这些内容进行管理，也就是要再分配一个磁盘块用于存储文件控制块，该结构体中要存储哪些存储文件内容的磁盘块的地址。<code>f_direct</code> 中就存储了前 <code>NDIRECT</code> 个磁盘块的编号方便快速访问。但如果文件较大，超出了 <code>NDIRECT</code> 个磁盘块的大小的话要怎么办？这就要再分配一个磁盘块，用这个磁盘块的全部空间作为存储磁盘块编号的数组，保存那些存储了文件内容的磁盘块的编号。再使用 <code>f_indirect</code> 保存这个新分配的，作为数组的磁盘块的编号。</p>
<p>为了方便，<code>f_indirect</code> 指向的磁盘块的前 <code>NDIRECT</code> 个元素不保存编号。现在我们就可以计算在这个文件系统中，文件的最大大小了：我们可以有 <code>BY2BLK / 4</code> 个磁盘块用于存储，每个磁盘块又有 <code>BY2BLK</code> 的空间，那么总共就有 <code>BY2BLK**2 / 4</code> 的空间可以用于单一文件的存储。</p>
</blockquote>
<p>在 <code>dist_init</code> 的最后，就设置了超级块的信息，<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">    disk[<span class="number">1</span>].type = BLOCK_SUPER;</span><br><span class="line">	super.s_magic = FS_MAGIC;</span><br><span class="line">	super.s_nblocks = NBLOCK;</span><br><span class="line">	super.s_root.f_type = FTYPE_DIR;</span><br><span class="line">	<span class="built_in">strcpy</span>(super.s_root.f_name, <span class="string">&quot;/&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>其中设置了根目录文件类型 <code>s_root.f_type</code> 为 <code>FTYPE_DIR</code>，表示该文件为目录。此宏定义在 user/include/fs.h 中。类似还有 <code>FTYPE_REG</code>。<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// File types</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FTYPE_REG 0 <span class="comment">// Regular file</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FTYPE_DIR 1 <span class="comment">// Directory</span></span></span><br></pre></td></tr></table></figure></p>
<p>最后我们设置根目录的名字为 <code>/</code>，这说明该文件系统的路径是 Linux 的格式。</p>
<h3 id="（3）文件写入"><a href="#（3）文件写入" class="headerlink" title="（3）文件写入"></a>（3）文件写入</h3><p>在 <code>main</code> 函数的后面部分，我们不断读取命令行参数，通过 <code>stat</code> 函数（这是库函数）判断文件类型，分别调用 <code>write_directory</code> 和 <code>write_file</code> 将文件内容写入磁盘镜像中。需要注意这里传入了 <code>&amp;super.s_root</code>，也就是根目录文件作为参数。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">   <span class="keyword">if</span> (argc &lt; <span class="number">3</span>) &#123;</span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Usage: fsformat &lt;img-file&gt; [files or directories]...\n&quot;</span>);</span><br><span class="line">	<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt; argc; i++) &#123;</span><br><span class="line">	<span class="type">char</span> *name = argv[i];</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">stat</span> <span class="title">stat_buf</span>;</span></span><br><span class="line">	<span class="type">int</span> r = stat(name, &amp;stat_buf);</span><br><span class="line">	assert(r == <span class="number">0</span>);</span><br><span class="line">	<span class="keyword">if</span> (S_ISDIR(stat_buf.st_mode)) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;writing directory &#x27;%s&#x27; recursively into disk\n&quot;</span>, name);</span><br><span class="line">		write_directory(&amp;super.s_root, name);</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (S_ISREG(stat_buf.st_mode)) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;writing regular file &#x27;%s&#x27; into disk\n&quot;</span>, name);</span><br><span class="line">		write_file(&amp;super.s_root, name);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;&#x27;%s&#x27; has illegal file mode %o\n&quot;</span>, name, stat_buf.st_mode);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">2</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来我们查看 <code>write_directory</code> 和 <code>write_file</code>。<code>write_directory</code> 用于递归地将目录下所有文件写入磁盘，而 <code>write_file</code> 则只将单一文件写入。我们首先查看 <code>write_directory</code>。</p>
<p>一开始只是调用库函数 <code>opendir</code> 打开了目录，不需关注。第一个关注点是调用了 <code>create_file</code> 在 <code>dirf</code> 文件下创建了新文件。<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">write_directory</span><span class="params">(<span class="keyword">struct</span> File *dirf, <span class="type">char</span> *path)</span> &#123;</span><br><span class="line">	DIR *dir = opendir(path);</span><br><span class="line">	<span class="keyword">if</span> (dir == <span class="literal">NULL</span>) &#123;</span><br><span class="line">		perror(<span class="string">&quot;opendir&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">File</span> *<span class="title">pdir</span> =</span> create_file(dirf);</span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<p>在 <code>create_file</code> 函数中，遍历了 <code>dirf</code> 文件下用于保存内容（对于目录来说，内容就是文件控制块）的所有磁盘块。这里我们使用 <code>f_direct</code> 和 <code>f_indirect</code> 获取了对应磁盘块的编号。<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> File *<span class="title function_">create_file</span><span class="params">(<span class="keyword">struct</span> File *dirf)</span> &#123;</span><br><span class="line">	<span class="type">int</span> nblk = dirf-&gt;f_size / BY2BLK;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Step 1: Iterate through all existing blocks in the directory.</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nblk; ++i) &#123;</span><br><span class="line">		<span class="type">int</span> bno; <span class="comment">// the block number</span></span><br><span class="line">		<span class="comment">// If the block number is in the range of direct pointers (NDIRECT), get the &#x27;bno&#x27;</span></span><br><span class="line">		<span class="comment">// directly from &#x27;f_direct&#x27;. Otherwise, access the indirect block on &#x27;disk&#x27; and get</span></span><br><span class="line">		<span class="comment">// the &#x27;bno&#x27; at the index.</span></span><br><span class="line">		<span class="comment">/* Exercise 5.5: Your code here. (1/3) */</span></span><br><span class="line">		<span class="keyword">if</span> (i &lt; NDIRECT) &#123;</span><br><span class="line">			bno = dirf-&gt;f_direct[i];</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			bno = ((<span class="type">uint32_t</span> *)(disk[dirf-&gt;f_indirect].data))[i];</span><br><span class="line">		&#125;</span><br></pre></td></tr></table></figure></p>
<p>该磁盘块的空间全部用于存储文件控制块。我们再在一个磁盘块中遍历所有文件控制块，看是否有未使用的文件控制块，用该处空间表示我们新创建的文件。这样遍历的原因是可能出现中间磁盘块中文件被删除，或者最后一个磁盘块还未用满的情况。<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">	<span class="comment">// Get the directory block using the block number.</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">File</span> *<span class="title">blk</span> =</span> (<span class="keyword">struct</span> File *)(disk[bno].data);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Iterate through all &#x27;File&#x27;s in the directory block.</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">struct</span> File *f = blk; f &lt; blk + FILE2BLK; ++f) &#123;</span><br><span class="line">		<span class="comment">// If the first byte of the file name is null, the &#x27;File&#x27; is unused.</span></span><br><span class="line">		<span class="comment">// Return a pointer to the unused &#x27;File&#x27;.</span></span><br><span class="line">		<span class="comment">/* Exercise 5.5: Your code here. (2/3) */</span></span><br><span class="line">		<span class="keyword">if</span> (f-&gt;f_name[<span class="number">0</span>] == <span class="literal">NULL</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> f;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>最后如果没有找到未使用的文件控制块，就说明所有的已分配给当前目录文件，用于存储文件控制块的磁盘块都被占满了。这时就需要调用 <code>make_link_block</code> 新申请一个磁盘块。该磁盘块中第一个文件控制块的位置就代表了新创建的文件。<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">   <span class="comment">// Step 2: If no unused file is found, allocate a new block using &#x27;make_link_block&#x27; function</span></span><br><span class="line"><span class="comment">// and return a pointer to the new block on &#x27;disk&#x27;.</span></span><br><span class="line"><span class="comment">/* Exercise 5.5: Your code here. (3/3) */</span></span><br><span class="line"><span class="keyword">return</span> (<span class="keyword">struct</span> File *)(disk[make_link_block(dirf, nblk)].data);</span><br></pre></td></tr></table></figure></p>
<p><code>make_link_block</code> 很简单，就是获取下一个空闲的磁盘块，调用 <code>save_block_link</code> 为 <code>dirf</code> 目录文件添加该磁盘块。<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">next_block</span><span class="params">(<span class="type">int</span> type)</span> &#123;</span><br><span class="line">	disk[nextbno].type = type;</span><br><span class="line">	<span class="keyword">return</span> nextbno++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">make_link_block</span><span class="params">(<span class="keyword">struct</span> File *dirf, <span class="type">int</span> nblk)</span> &#123;</span><br><span class="line">	<span class="type">int</span> bno = next_block(BLOCK_FILE);</span><br><span class="line">	save_block_link(dirf, nblk, bno);</span><br><span class="line">	dirf-&gt;f_size += BY2BLK;</span><br><span class="line">	<span class="keyword">return</span> bno;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>save_block_link</code> 函数就是将新申请的磁盘块设置到 <code>f_direct</code> 中或 <code>f_indirect</code> 对应的磁盘块中的相应位置。<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">save_block_link</span><span class="params">(<span class="keyword">struct</span> File *f, <span class="type">int</span> nblk, <span class="type">int</span> bno)</span> &#123;</span><br><span class="line">	assert(nblk &lt; NINDIRECT); <span class="comment">// if not, file is too large !</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (nblk &lt; NDIRECT) &#123;</span><br><span class="line">		f-&gt;f_direct[nblk] = bno;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> (f-&gt;f_indirect == <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="comment">// create new indirect block.</span></span><br><span class="line">			f-&gt;f_indirect = next_block(BLOCK_INDEX);</span><br><span class="line">		&#125;</span><br><span class="line">		((<span class="type">uint32_t</span> *)(disk[f-&gt;f_indirect].data))[nblk] = bno;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<p>这样 <code>create_file</code> 就完成了，让我们回到 <code>write_directory</code>。接下来为新创建的目录文件设置名字和文件类型。途中还判断了文件名是否过长。<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">File</span> *<span class="title">pdir</span> =</span> create_file(dirf);</span><br><span class="line"><span class="built_in">strncpy</span>(pdir-&gt;f_name, basename(path), MAXNAMELEN - <span class="number">1</span>);</span><br><span class="line"><span class="keyword">if</span> (pdir-&gt;f_name[MAXNAMELEN - <span class="number">1</span>] != <span class="number">0</span>) &#123;</span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;file name is too long: %s\n&quot;</span>, path);</span><br><span class="line">	<span class="comment">// File already created, no way back from here.</span></span><br><span class="line">	<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">pdir-&gt;f_type = FTYPE_DIR;</span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<p>接下来的步骤很明显，需要遍历宿主机上该路径下的所有文件，如果是目录，则递归执行 <code>write_directory</code>，如果是普通文件，则执行 <code>write_file</code>，这样直到目录下所有文件都被写入镜像中。<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span> (<span class="keyword">struct</span> dirent *e; (e = readdir(dir)) != <span class="literal">NULL</span>;) &#123;</span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">strcmp</span>(e-&gt;d_name, <span class="string">&quot;.&quot;</span>) != <span class="number">0</span> &amp;&amp; <span class="built_in">strcmp</span>(e-&gt;d_name, <span class="string">&quot;..&quot;</span>) != <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="type">char</span> *buf = <span class="built_in">malloc</span>(<span class="built_in">strlen</span>(path) + <span class="built_in">strlen</span>(e-&gt;d_name) + <span class="number">2</span>);</span><br><span class="line">			<span class="built_in">sprintf</span>(buf, <span class="string">&quot;%s/%s&quot;</span>, path, e-&gt;d_name);</span><br><span class="line">			<span class="keyword">if</span> (e-&gt;d_type == DT_DIR) &#123;</span><br><span class="line">				write_directory(pdir, buf);</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				write_file(pdir, buf);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="built_in">free</span>(buf);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	closedir(dir);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>接下来转过头查看一下 <code>write_file</code>。首先我们同样调用 <code>create_file</code> 在 <code>dirf</code> 目录文件下创建新文件。<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">write_file</span><span class="params">(<span class="keyword">struct</span> File *dirf, <span class="type">const</span> <span class="type">char</span> *path)</span> &#123;</span><br><span class="line">	<span class="type">int</span> iblk = <span class="number">0</span>, r = <span class="number">0</span>, n = <span class="keyword">sizeof</span>(disk[<span class="number">0</span>].data);</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">File</span> *<span class="title">target</span> =</span> create_file(dirf);</span><br></pre></td></tr></table></figure></p>
<p>接下来函数还对 <code>create_file</code> 的结果进行了判断。这似乎只是修改代码后的一个遗留问题而已。<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* in case `create_file` is&#x27;t filled */</span></span><br><span class="line"><span class="keyword">if</span> (target == <span class="literal">NULL</span>) &#123;</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>我们打开宿主机上的文件，便于后面复制文件内容到镜像中<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> fd = open(path, O_RDONLY);</span><br></pre></td></tr></table></figure></p>
<p>接着我们复制文件名。这里使用 <code>strrchr</code> 从后往前查找了 <code>&#39;/&#39;</code> 字符的位置，只拷贝该字符之后的内容。但是不知这里为何不与 <code>write_directory</code> 一样使用 <code>basename</code>。<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Get file name with no path prefix.</span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span> *fname = <span class="built_in">strrchr</span>(path, <span class="string">&#x27;/&#x27;</span>);</span><br><span class="line"><span class="keyword">if</span> (fname) &#123;</span><br><span class="line">	fname++;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	fname = path;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">strcpy</span>(target-&gt;f_name, fname);</span><br></pre></td></tr></table></figure></p>
<p>接着使用 <code>lseek</code> 获取并设置文件大小，以及文件类型为普通文件<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">target-&gt;f_size = lseek(fd, <span class="number">0</span>, SEEK_END);</span><br><span class="line">target-&gt;f_type = FTYPE_REG;</span><br></pre></td></tr></table></figure></p>
<p>最后读取文件内容，写入镜像文件中。这里我们以 <code>n = sizeof(disk[0].data)</code> 的大小读取，但不知道为何不使用 <code>BY2BLK</code>。值得注意的是，这里我们是先向 <code>disk[nextbno]</code> 中写入了数据，之后才调用 <code>next_block</code> 申请的该磁盘块。<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">	<span class="comment">// Start reading file.</span></span><br><span class="line">	lseek(fd, <span class="number">0</span>, SEEK_SET);</span><br><span class="line">	<span class="keyword">while</span> ((r = read(fd, disk[nextbno].data, n)) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">		save_block_link(target, iblk++, next_block(BLOCK_DATA));</span><br><span class="line">	&#125;</span><br><span class="line">	close(fd); <span class="comment">// Close file descriptor.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="（4）收尾工作"><a href="#（4）收尾工作" class="headerlink" title="（4）收尾工作"></a>（4）收尾工作</h3><p>完成文件的写入后，<code>main</code> 函数中还有一些收尾工作。首先是根据磁盘块的使用情况设置位图<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">flush_bitmap();</span><br></pre></td></tr></table></figure></p>
<p>置 0 语句看似复杂，实际只是按顺序一位一位置 0 而已。<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">flush_bitmap</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line">	<span class="comment">// update bitmap, mark all bit where corresponding block is used.</span></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; nextbno; ++i) &#123;</span><br><span class="line">		((<span class="type">uint32_t</span> *)disk[<span class="number">2</span> + i / BIT2BLK].data)[(i % BIT2BLK) / <span class="number">32</span>] &amp;= ~(<span class="number">1</span> &lt;&lt; (i % <span class="number">32</span>));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>最后还要根据 <code>disk</code> 生成磁盘镜像文件。使用 <code>finish_fs</code> 函数完成<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">	finish_fs(argv[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>一直以来，超级块都没有写入 <code>disk</code>，现在我们将超级块信息写入<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">finish_fs</span><span class="params">(<span class="type">char</span> *name)</span> &#123;</span><br><span class="line">	<span class="type">int</span> fd, i;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Prepare super block.</span></span><br><span class="line">	<span class="built_in">memcpy</span>(disk[<span class="number">1</span>].data, &amp;super, <span class="keyword">sizeof</span>(super));</span><br></pre></td></tr></table></figure></p>
<p>最后我们将 <code>disk</code> 中所有的 <code>data</code> 写入一个新创建的文件中，作为磁盘镜像。<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">	<span class="comment">// Dump data in `disk` to target image file.</span></span><br><span class="line">	fd = open(name, O_RDWR | O_CREAT, <span class="number">0666</span>);</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">1024</span>; ++i) &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_REVERSE_ENDIAN</span></span><br><span class="line">		reverse_block(disk + i);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">		<span class="type">ssize_t</span> n = write(fd, disk[i].data, BY2BLK);</span><br><span class="line">		assert(n == BY2BLK);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Finish.</span></span><br><span class="line">	close(fd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p><code>reverse_block</code> 用于宿主机和操作系统大小端不一致的情况，这里我们不需要考虑，就不看了。</p>
</blockquote>
<p>这样我们就实现了磁盘镜像的创建。在阅读 fsformat 工具的代码的同时，我们也了解了磁盘中数据的组织形式以及文件系统的基本概念，这对我们之后了解理解文件系统的代码有很大的帮助。</p>
<h2 id="三、文件系统"><a href="#三、文件系统" class="headerlink" title="三、文件系统"></a>三、文件系统</h2><h3 id="（1）文件操作库函数"><a href="#（1）文件操作库函数" class="headerlink" title="（1）文件操作库函数"></a>（1）文件操作库函数</h3><p>操作系统需要为用户程序提供一系列库函数来完成文件的相关操作。这些函数我们都知道，有 <code>open</code>、<code>read</code>、<code>write</code>、<code>close</code> 等。我们先以 <code>open</code> 为例查看一下文件系统操作的基本流程。</p>
<p><code>open</code> 函数和其他提供给用户的库函数一样，位于 user/lib，定义在 file.c 文件中。首先，该函数调用 <code>fd_alloc</code> 申请了一个文件描述符<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">open</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *path, <span class="type">int</span> mode)</span> &#123;</span><br><span class="line">	<span class="type">int</span> r;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Step 1: Alloc a new &#x27;Fd&#x27; using &#x27;fd_alloc&#x27; in fd.c.</span></span><br><span class="line">	<span class="comment">// Hint: return the error code if failed.</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Fd</span> *<span class="title">fd</span>;</span></span><br><span class="line">	<span class="comment">/* Exercise 5.9: Your code here. (1/5) */</span></span><br><span class="line">	try(fd_alloc(&amp;fd));</span><br></pre></td></tr></table></figure></p>
<p>文件描述符 <code>struct Fd</code> 定义在 user/include/fd.h 中，保存了文件对应的设备 <code>fd_dev_id</code>，文件读写的偏移量 <code>fd_offset</code> 和文件读写的模式 <code>fd_omode</code>。该结构体不表现文件的物理结构，是在用户侧对文件的抽象。<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// file descriptor</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Fd</span> &#123;</span></span><br><span class="line">	u_int fd_dev_id;</span><br><span class="line">	u_int fd_offset;</span><br><span class="line">	u_int fd_omode;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p><code>fd_alloc</code> 函数的功能就是遍历所有文件描述符编号（共有 <code>MAXFD</code> 个），找到其中还没有被使用过的最小的一个，返回该文件描述符对应的地址。注意通过文件描述符编号到地址我们使用了宏 <code>INDEX2FD</code>。该宏定义在 user/include/fd.h 中。通过观察相关宏的定义，我们可以得知每个文件描述符占用空间大小为 <code>BY2PG</code>，所有文件描述符位于 <code>[FILEBASE - PDMAP, FILEBASE)</code> 的地址空间中。<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> FILEBASE 0x60000000</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FDTABLE (FILEBASE - PDMAP)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INDEX2FD(i) (FDTABLE + (i)*BY2PG)</span></span><br></pre></td></tr></table></figure></p>
<p>这里我们并没有采用任何数据结构用于表示文件描述符的分配，而是通过查看页目录项和页表项是否有效来得知文件描述符是否被使用。这是因为文件描述符并不是在用户进程中被创建的，而是在<strong>文件系统服务进程</strong>中创建，被共享到用户进程的地址区域中的。因此我们只需要找出一处空闲空间，将文件系统服务进程中的对应文件描述符共享到该位置即可。<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">fd_alloc</span><span class="params">(<span class="keyword">struct</span> Fd **fd)</span> &#123;</span><br><span class="line">	u_int va;</span><br><span class="line">	u_int fdno;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (fdno = <span class="number">0</span>; fdno &lt; MAXFD - <span class="number">1</span>; fdno++) &#123;</span><br><span class="line">		va = INDEX2FD(fdno);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> ((vpd[va / PDMAP] &amp; PTE_V) == <span class="number">0</span>) &#123;</span><br><span class="line">			*fd = (<span class="keyword">struct</span> Fd *)va;</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> ((vpt[va / BY2PG] &amp; PTE_V) == <span class="number">0</span>) &#123; <span class="comment">// the fd is not used</span></span><br><span class="line">			*fd = (<span class="keyword">struct</span> Fd *)va;</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> -E_MAX_OPEN;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>MOS 采取了微内核设计，因此文件系统的大部分操作并不在内核态中完成，而是交由一个<strong>文件系统服务进程</strong>处理。之后我们会了解这一进程的相关内容。</p>
<p><code>fd_alloc</code> 中我们先查看页目录项，如果页目录项无效，那么整个页目录项对应的地址空间就都没有进行映射，那么只需要返回 <code>va</code> 即可，因为 <code>va</code> 就是该目录项的第一个页表中的第一个页表项对应的地址，即第一个没有被使用的文件描述符的地址。</p>
</blockquote>
<p>需要注意，我们这里只是返回了可以作为文件描述符的地址，还没有实际的文件描述符数据。之后我们就要获取文件描述符。在 <code>open</code> 中调用 <code>fsipc_open</code>。该函数会将 <code>path</code> 对应的文件以 <code>mode</code> 的方式打开，将该文件的文件描述符共享到 <code>fd</code> 指针对应的地址处。</p>
<p>该函数定义在 user/lib/fsipc.c 中。所做的工作很简单，就是通过进程间通信向文件系统服务进程发送一条消息，表示自己希望进行的操作，服务进程再返回一条消息，表示操作的结果。这样一来一回，虽然不是函数调用，却产生了函数调用的效果，很是像系统调用。</p>
<p><code>fsipc_open</code> 中，我们将一块缓冲区 <code>fsipcbuf</code> 视为 <code>struct Fsreq_open</code>，向其中写入了请求打开的文件路径 <code>req_path</code> 和打开方式 <code>req_omode</code>。并调用 <code>fsipc</code> 进行发送。<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">fsipc_open</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *path, u_int omode, <span class="keyword">struct</span> Fd *fd)</span> &#123;</span><br><span class="line">	u_int perm;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Fsreq_open</span> *<span class="title">req</span>;</span></span><br><span class="line"></span><br><span class="line">	req = (<span class="keyword">struct</span> Fsreq_open *)fsipcbuf;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// The path is too long.</span></span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">strlen</span>(path) &gt;= MAXPATHLEN) &#123;</span><br><span class="line">		<span class="keyword">return</span> -E_BAD_PATH;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">strcpy</span>((<span class="type">char</span> *)req-&gt;req_path, path);</span><br><span class="line">	req-&gt;req_omode = omode;</span><br><span class="line">	<span class="keyword">return</span> fsipc(FSREQ_OPEN, req, fd, &amp;perm);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<p>缓冲区 <code>fsipcbuf</code> 是一个页面。因为其大小为 <code>BY2PG</code> 字节，又以 <code>BY2PG</code> 为基准对齐。<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">u_char fsipcbuf[BY2PG] __attribute__((aligned(BY2PG)));</span><br></pre></td></tr></table></figure></p>
<p><code>Fsreq_open</code> 定义在 user/include/fsreq.h 中，类似的还有 <code>Fsreq_close</code>、<code>Fsreq_map</code> 等等。<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Fsreq_open</span> &#123;</span></span><br><span class="line">	<span class="type">char</span> req_path[MAXPATHLEN];</span><br><span class="line">	u_int req_omode;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>在调用 <code>fsipc</code> 时我们的第一个参数表示请求的类型。这些类型也都定义在 user/include/fsreq.h 中。<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> FSREQ_OPEN 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FSREQ_MAP 2</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FSREQ_SET_SIZE 3</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FSREQ_CLOSE 4</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FSREQ_DIRTY 5</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FSREQ_REMOVE 6</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FSREQ_SYNC 7</span></span><br></pre></td></tr></table></figure></p>
<p><code>fsipc</code> 函数就是简单的向服务进程发送消息，并接收服务进程返回的消息。注意这里我们通过 <code>envs[1].env_id</code> 获取服务进程的 envid，这说明服务进程必须为第二个进程。<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">fsipc</span><span class="params">(u_int type, <span class="type">void</span> *fsreq, <span class="type">void</span> *dstva, u_int *perm)</span> &#123;</span><br><span class="line">	u_int whom;</span><br><span class="line">	<span class="comment">// Our file system server must be the 2nd env.</span></span><br><span class="line">	ipc_send(envs[<span class="number">1</span>].env_id, type, fsreq, PTE_D);</span><br><span class="line">	<span class="keyword">return</span> ipc_recv(&amp;whom, dstva, perm);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="（2）文件系统服务进程的初始化"><a href="#（2）文件系统服务进程的初始化" class="headerlink" title="（2）文件系统服务进程的初始化"></a>（2）文件系统服务进程的初始化</h3><p>文件系统服务进程是一个完整的进程，有自己的 main 函数。该进程的代码都位于 fs 文件夹下。<code>main</code> 函数位于 fs/serv.c 中。我们从这里入手。</p>
<p>首先调用 <code>serve_init</code> 对程序进行初始化。<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">	user_assert(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> File) == BY2FILE);</span><br><span class="line"></span><br><span class="line">	debugf(<span class="string">&quot;FS is running\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">	serve_init();</span><br></pre></td></tr></table></figure></p>
<p>在 <code>serve_init</code> 函数中，实际进行初始化的只有 <code>opentab</code>。这是一个 <code>struct Open</code> 类型的数组，用于记录整个操作系统中所有处于打开状态的文件。<code>MAXOPEN</code> 就表示了文件打开的最大数量。<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Max number of open files in the file system at once</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXOPEN 1024</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// initialize to force into data section</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Open</span> <span class="title">opentab</span>[<span class="title">MAXOPEN</span>] =</span> &#123;&#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>&#125;&#125;;</span><br></pre></td></tr></table></figure></p>
<p><code>struct Open</code> 定义在同一个文件中。其中保存了打开的文件 <code>o_file</code>、文件的 id <code>o_fileid</code>、文件打开的方式 <code>o_mode</code> 和文件对应的文件描述符 <code>o_ff</code>。<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Open</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">File</span> *<span class="title">o_file</span>;</span> <span class="comment">// mapped descriptor for open file</span></span><br><span class="line">	u_int o_fileid;	     <span class="comment">// file id</span></span><br><span class="line">	<span class="type">int</span> o_mode;	     <span class="comment">// open mode</span></span><br><span class="line">	Filefd *o_ff; <span class="comment">// va of filefd page</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p><code>Filefd</code> 是如下所示的结构体。我们在将文件描述符共享到用户进程时，实际上共享的是 <code>Filefd</code>。<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// file descriptor + file</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Filefd</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Fd</span> <span class="title">f_fd</span>;</span></span><br><span class="line">	u_int f_fileid;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">File</span> <span class="title">f_file</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>在 <code>serve_init</code> 中，我们就是对 <code>opentab</code> 进行初始化。为其中每个元素设定 <code>o_fileid</code> 和 <code>o_ff</code>。<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">serve_init</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line">	u_int va;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Set virtual address to map.</span></span><br><span class="line">	va = FILEVA;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Initial array opentab.</span></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; MAXOPEN; i++) &#123;</span><br><span class="line">		opentab[i].o_fileid = i;</span><br><span class="line">		opentab[i].o_ff = (<span class="keyword">struct</span> Filefd *)va;</span><br><span class="line">		va += BY2PG;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>地址的分配是从 <code>va = FILEVA</code> 开始的，其中 <code>#define FILEVA 0x60000000</code>。每个 <code>Filefd</code> 分配一页 <code>BY2PG</code> 的大小。因此所有的 <code>Filefd</code> 存储在 <code>[FILEVA, FILEVA + PDMAP)</code> 的地址空间中。</p>
<p>在 <code>main</code> 函数中，之后我们又调用 <code>fs_init</code> 完成文件系统的初始化。<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">fs_init();</span><br></pre></td></tr></table></figure></p>
<p>该函数定义在 fs/fs.c 中。其中又调用了三个函数 <code>read_super</code>、<code>check_write_block</code> 和 <code>read_bitmap</code><br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">fs_init</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">	read_super();</span><br><span class="line">	check_write_block();</span><br><span class="line">	read_bitmap();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>read_super</code> 中大部分都是检查，只有如下部分值得关注。该部分读取了第一个磁盘块的内容，赋值给全局变量 <code>super</code>。<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Step 1: read super block.</span></span><br><span class="line"><span class="keyword">if</span> ((r = read_block(<span class="number">1</span>, &amp;blk, <span class="number">0</span>)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">	user_panic(<span class="string">&quot;cannot read superblock: %e&quot;</span>, r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">super = blk;</span><br></pre></td></tr></table></figure></p>
<p>其中 <code>read_block</code> 用于读取对应磁盘块编号的磁盘块数据到内存中。我们不看前面的检查。首先使用 <code>diskaddr</code> 获取磁盘块编号应该存储到的地址。<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">read_block</span><span class="params">(u_int blockno, <span class="type">void</span> **blk, u_int *isnew)</span> &#123;</span><br><span class="line">    <span class="comment">// omit...</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// Step 3: transform block number to corresponding virtual address.</span></span><br><span class="line">	<span class="type">void</span> *va = diskaddr(blockno);</span><br></pre></td></tr></table></figure></p>
<p><code>diskaddr</code> 函数很简单。这里只是人为规定的地址，我们将 <code>[DISKMAP, DISKMAP+DISKMAX)</code> 的地址空间用作缓冲区，当磁盘读入内存时，用来映射相关的页。因为该缓冲区与内存空间是一一映射的，所以我们也可以得知实验中支持的最大磁盘大小为 <code>DISKMAX</code> = 1GB。<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> *<span class="title function_">diskaddr</span><span class="params">(u_int blockno)</span> &#123;</span><br><span class="line">	<span class="comment">/* Exercise 5.6: Your code here. */</span></span><br><span class="line">	<span class="keyword">return</span> DISKMAP + blockno * BY2BLK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>回到 <code>read_block</code>，接下来通过 <code>block_is_mapped</code> 判断编号对应的磁盘块是否已经被映射，如果没有，则我们需要为其分配内存，并将硬盘中的数据读入该内存空间中。最后我们设置 <code>*blk</code> 以返回读取的磁盘块数据对应的内存地址。<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">	<span class="keyword">if</span> (block_is_mapped(blockno)) &#123; <span class="comment">// the block is in memory</span></span><br><span class="line">		<span class="keyword">if</span> (isnew) &#123;</span><br><span class="line">			*isnew = <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123; <span class="comment">// the block is not in memory</span></span><br><span class="line">		<span class="keyword">if</span> (isnew) &#123;</span><br><span class="line">			*isnew = <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		syscall_mem_alloc(<span class="number">0</span>, va, PTE_D);</span><br><span class="line">		ide_read(<span class="number">0</span>, blockno * SECT2BLK, va, SECT2BLK);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Step 5: if blk != NULL, assign &#x27;va&#x27; to &#x27;*blk&#x27;.</span></span><br><span class="line">	<span class="keyword">if</span> (blk) &#123;</span><br><span class="line">		*blk = va;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这一部分使用的 <code>block_is_mapped</code> 函数比较简单。和我们在 <code>fd_alloc</code> 中遇到的通过页表来判断是否被使用相同。<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Overview:</span></span><br><span class="line"><span class="comment">//  Check if this virtual address is mapped to a block. (check PTE_V bit)</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">va_is_mapped</span><span class="params">(<span class="type">void</span> *va)</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> (vpd[PDX(va)] &amp; PTE_V) &amp;&amp; (vpt[VPN(va)] &amp; PTE_V);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Overview:</span></span><br><span class="line"><span class="comment">//  Check if this disk block is mapped in cache.</span></span><br><span class="line"><span class="comment">//  Returns the virtual address of the cache page if mapped, 0 otherwise.</span></span><br><span class="line"><span class="type">void</span> *<span class="title function_">block_is_mapped</span><span class="params">(u_int blockno)</span> &#123;</span><br><span class="line">	<span class="type">void</span> *va = diskaddr(blockno);</span><br><span class="line">	<span class="keyword">if</span> (va_is_mapped(va)) &#123;</span><br><span class="line">		<span class="keyword">return</span> va;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>如果没有映射，则我们调用 <code>syscall_mem_alloc</code> 为该地址分配一页空间，之后调用 <code>ide_read</code> 函数从磁盘中读取数据。这一部分内容属于磁盘驱动，我们会在下一章讲解。</p>
<p>现在让我们回到 <code>fs_init</code>。<code>check_write_block</code> 函数只是一个插入到基本流程中的测试代码，不需要考虑。我们考虑 <code>read_bitmap</code>。该函数会将管理磁盘块分配的位图读取到内存中。</p>
<p>这里很奇怪的使用了 <code>super-&gt;s_nblocks / BIT2BLK + 1</code> 来计算作为位图的磁盘块数量。但是对于 <code>super-&gt;s_nblocks</code> 是 <code>BIT2BLK</code> 整倍数的情况，不是会多计算一个磁盘块吗？不懂。（不过 nbitmap 多了 1 似乎也不会产生什么大的影响，因为各个磁盘块数据在内存中的空间并不重合。）之后就是调用 <code>read_block</code> 将磁盘上的数据读取到内存缓冲区中，最后设定全局变量 <code>bitmap</code> 的值为位图的首地址。<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">read_bitmap</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">	u_int i;</span><br><span class="line">	<span class="type">void</span> *blk = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Step 1: Calculate the number of the bitmap blocks, and read them into memory.</span></span><br><span class="line">	u_int nbitmap = super-&gt;s_nblocks / BIT2BLK + <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; nbitmap; i++) &#123;</span><br><span class="line">		read_block(i + <span class="number">2</span>, blk, <span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	bitmap = diskaddr(<span class="number">2</span>);</span><br></pre></td></tr></table></figure></p>
<p><code>read_bitmap</code> 中之后的内容都是一些检查，这里就不详细说明了。</p>
<h3 id="（3）文件系统服务进程的服务"><a href="#（3）文件系统服务进程的服务" class="headerlink" title="（3）文件系统服务进程的服务"></a>（3）文件系统服务进程的服务</h3><p>初始化终于完成了，接下来我们调用 <code>serve</code> 以开启服务<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">serve();</span><br></pre></td></tr></table></figure></p>
<p>很容易理解，这样的服务进程就是一个死循环。不断地调用 <code>ipc_recv</code> 以接收其他进程发来的请求，根据请求类型的不同分发给不同的处理函数进行处理，并进行回复。<code>serve</code> 函数中只需要注意一点，那就是在完成处理后需要进行系统调用 <code>syscall_mem_unmap</code> 以取消接收消息时的页面共享，为下一次接收请求做准备。<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">serve</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">	u_int req, whom, perm;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (;;) &#123;</span><br><span class="line">		perm = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">		req = ipc_recv(&amp;whom, (<span class="type">void</span> *)REQVA, &amp;perm);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// All requests must contain an argument page</span></span><br><span class="line">		<span class="keyword">if</span> (!(perm &amp; PTE_V)) &#123;</span><br><span class="line">			debugf(<span class="string">&quot;Invalid request from %08x: no argument page\n&quot;</span>, whom);</span><br><span class="line">			<span class="keyword">continue</span>; <span class="comment">// just leave it hanging, waiting for the next request.</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">switch</span> (req) &#123;</span><br><span class="line">		<span class="keyword">case</span> FSREQ_OPEN:</span><br><span class="line">			serve_open(whom, (<span class="keyword">struct</span> Fsreq_open *)REQVA);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// omit...</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		syscall_mem_unmap(<span class="number">0</span>, (<span class="type">void</span> *)REQVA);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里我们只考虑 <code>FSREQ_OPEN</code> 请求的处理函数 <code>serve_open</code>。在该函数中，我们首先调用 <code>alloc_open</code> 申请一个存储文件打开信息的 <code>struct Open</code> 控制块。需要注意这里的 <code>ipc_send</code> 类似于发生错误时的返回。只不过不知为何此处不和下面调用 <code>file_open</code> 时一样有 <code>return</code> 语句。这或许是一个<strong>错误</strong>，不过既然此处并没有让人写代码，那还是不要擅自改动好了<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">serve_open</span><span class="params">(u_int envid, <span class="keyword">struct</span> Fsreq_open *rq)</span> &#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">File</span> *<span class="title">f</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Filefd</span> *<span class="title">ff</span>;</span></span><br><span class="line">	<span class="type">int</span> r;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Open</span> *<span class="title">o</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// Find a file id.</span></span><br><span class="line">	<span class="keyword">if</span> ((r = open_alloc(&amp;o)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		ipc_send(envid, r, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>open_alloc</code> 函数用于申请一个未使用的 <code>struct Open</code> 元素。这里由于 <code>opentab</code> 和 存储在 <code>[FILEVA, FILEVA + PDMAP)</code> 中的 <code>Filefd</code> 是一一对应的关系，所以通过查看 <code>Filefd</code> 地址的页表项是否有效（第三次！！！）就可以得知 <code>struct Open</code> 元素是否被使用了。（注意这里不能查看 <code>opentab</code> 中各元素的页表项，因为 <code>opentab</code> 作为数组，占用的空间已经被分配了。）<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">open_alloc</span><span class="params">(<span class="keyword">struct</span> Open **o)</span> &#123;</span><br><span class="line">	<span class="type">int</span> i, r;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Find an available open-file table entry</span></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; MAXOPEN; i++) &#123;</span><br><span class="line">		<span class="keyword">switch</span> (pageref(opentab[i].o_ff)) &#123;</span><br><span class="line">		<span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">			<span class="keyword">if</span> ((r = syscall_mem_alloc(<span class="number">0</span>, opentab[i].o_ff, PTE_D | PTE_LIBRARY)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">				<span class="keyword">return</span> r;</span><br><span class="line">			&#125;</span><br><span class="line">		<span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">			opentab[i].o_fileid += MAXOPEN;</span><br><span class="line">			*o = &amp;opentab[i];</span><br><span class="line">			<span class="built_in">memset</span>((<span class="type">void</span> *)opentab[i].o_ff, <span class="number">0</span>, BY2PG);</span><br><span class="line">			<span class="keyword">return</span> (*o)-&gt;o_fileid;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> -E_MAX_OPEN;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>通过 <code>pageref</code> 我们可以得知某一页的引用数量。该函数定义在 user/lib/pageref.c 中，不需要多言。<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">pageref</span><span class="params">(<span class="type">void</span> *v)</span> &#123;</span><br><span class="line">	u_int pte;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!(vpd[PDX(v)] &amp; PTE_V)) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	pte = vpt[VPN(v)];</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!(pte &amp; PTE_V)) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> pages[PPN(pte)].pp_ref;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>我必须解释一下 <code>open_alloc</code> 中 <code>switch</code> 的使用。首先要再次明确 <code>pageref</code> 返回的是某一页的引用数量。那么除了 0、1 以外，还可能有 2、3 等等，即物理页在不同进程间共享的情况。在我们的文件系统中，是会出现将 <code>Filefd</code> 共享到用户进程的情况，这时因为 <code>switch</code> 的 <code>case</code> 中只有 1、2，因此便会跳过这次循环。这样我们就将正在使用的文件排除在外了。</p>
<p>我们知道在最开始，所有的 <code>Filefd</code> 都没有被访问过，他们的引用数量为 0。只有当使用过之后，引用数量才大于 0。那么 <code>case 1</code> 表示的情况就很明显了，那就是曾经被使用过，但现在不被任何用户进程使用的文件，只有服务进程还保存着引用。这种情况的 <code>struct Open</code> 就没有被使用，因此可以被申请。但是之前使用时的 <code>o_fileid</code> 这次就不能使用了，需要更新 <code>opentab[i].o_fileid += MAXOPEN</code>，同时将对应的文件描述符 <code>o_ff</code> 的内容清零。</p>
<p>最后是还没有被访问过的情况，这种情况下我们先要使用系统调用 <code>syscall_mem_alloc</code> 申请一个物理页。注意申请时我们使用的权限位 <code>PTE_D | PTE_LIBRARY</code>。<code>PTE_LIBRARY</code> 表示该页面可以被共享。之后呢？我们还需要和引用数量为 1 的情况一样，将 <code>o_ff</code> 对应的空间清零，返回 <code>o_fileid</code> 和 <code>opentab[i]</code>。这里采用了一个巧妙的方法，在 <code>case 0</code> 和 <code>case 1</code> 之间没有使用 <code>break</code> 分隔，直接让 <code>case 0</code> 的执行穿透到了 <code>case 1</code> 中。</p>
<p>现在让我们回到 <code>serve_open</code>。接下来调用 <code>file_open</code> 来打开文件。<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Open the file.</span></span><br><span class="line"><span class="keyword">if</span> ((r = file_open(rq-&gt;req_path, &amp;f)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">	ipc_send(envid, r, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>file_open</code> 定义在 fs/fs.c 中，只是调用了 <code>walk_path</code> 而已。<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">file_open</span><span class="params">(<span class="type">char</span> *path, <span class="keyword">struct</span> File **file)</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> walk_path(path, <span class="number">0</span>, file, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>walk_path</code> 函数位于同一个文件中，主要内容就是解析路径，根据路径不断找到目录下的文件，找到最后得到的就是表示路径对应的文件的文件控制块。<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">walk_path</span><span class="params">(<span class="type">char</span> *path, <span class="keyword">struct</span> File **pdir, <span class="keyword">struct</span> File **pfile, <span class="type">char</span> *lastelem)</span> &#123;</span><br><span class="line">	<span class="type">char</span> *p;</span><br><span class="line">	<span class="type">char</span> name[MAXNAMELEN];</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">File</span> *<span class="title">dir</span>, *<span class="title">file</span>;</span></span><br><span class="line">	<span class="type">int</span> r;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// start at the root.</span></span><br><span class="line">	path = skip_slash(path);</span><br><span class="line">	file = &amp;super-&gt;s_root;</span><br><span class="line">	dir = <span class="number">0</span>;</span><br><span class="line">	name[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (pdir) &#123;</span><br><span class="line">		*pdir = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	*pfile = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// find the target file by name recursively.</span></span><br><span class="line">	<span class="keyword">while</span> (*path != <span class="string">&#x27;\0&#x27;</span>) &#123;</span><br><span class="line">		dir = file;</span><br><span class="line">		p = path;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">while</span> (*path != <span class="string">&#x27;/&#x27;</span> &amp;&amp; *path != <span class="string">&#x27;\0&#x27;</span>) &#123;</span><br><span class="line">			path++;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (path - p &gt;= MAXNAMELEN) &#123;</span><br><span class="line">			<span class="keyword">return</span> -E_BAD_PATH;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="built_in">memcpy</span>(name, p, path - p);</span><br><span class="line">		name[path - p] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">		path = skip_slash(path);</span><br><span class="line">		<span class="keyword">if</span> (dir-&gt;f_type != FTYPE_DIR) &#123;</span><br><span class="line">			<span class="keyword">return</span> -E_NOT_FOUND;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> ((r = dir_lookup(dir, name, &amp;file)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span> (r == -E_NOT_FOUND &amp;&amp; *path == <span class="string">&#x27;\0&#x27;</span>) &#123;</span><br><span class="line">				<span class="keyword">if</span> (pdir) &#123;</span><br><span class="line">					*pdir = dir;</span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">				<span class="keyword">if</span> (lastelem) &#123;</span><br><span class="line">					<span class="built_in">strcpy</span>(lastelem, name);</span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">				*pfile = <span class="number">0</span>;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">return</span> r;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (pdir) &#123;</span><br><span class="line">		*pdir = dir;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	*pfile = file;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>该函数大部分工作都用于完成路径解析和异常处理，不用解释相信各位也能理解。唯一需要注意的是 <code>dir_lookup</code> 函数。该函数用于找到指定目录下的指定名字的文件。该函数也位于同一个文件中，也是我们需要填写代码的函数。</p>
<p>该函数本身很简单，与 tools/fsformat.c 中的 <code>create_file</code> 类似。都是获取文件的所有磁盘块，遍历其中所有的文件控制块。只不过这里需要返回指定名字的文件对应的文件控制块。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">dir_lookup</span><span class="params">(<span class="keyword">struct</span> File *dir, <span class="type">char</span> *name, <span class="keyword">struct</span> File **file)</span> &#123;</span><br><span class="line">	<span class="type">int</span> r;</span><br><span class="line">	<span class="comment">// Step 1: Calculate the number of blocks in &#x27;dir&#x27; via its size.</span></span><br><span class="line">	u_int nblock;</span><br><span class="line">	<span class="comment">/* Exercise 5.8: Your code here. (1/3) */</span></span><br><span class="line">	nblock = dir-&gt;f_size / BY2BLK;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Step 2: Iterate through all blocks in the directory.</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nblock; i++) &#123;</span><br><span class="line">		<span class="comment">// Read the i&#x27;th block of &#x27;dir&#x27; and get its address in &#x27;blk&#x27; using &#x27;file_get_block&#x27;.</span></span><br><span class="line">		<span class="type">void</span> *blk;</span><br><span class="line">		<span class="comment">/* Exercise 5.8: Your code here. (2/3) */</span></span><br><span class="line">		try(file_get_block(dir, i, &amp;blk));</span><br><span class="line"></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">File</span> *<span class="title">files</span> =</span> (<span class="keyword">struct</span> File *)blk;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Find the target among all &#x27;File&#x27;s in this block.</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">struct</span> File *f = files; f &lt; files + FILE2BLK; ++f) &#123;</span><br><span class="line">			<span class="comment">/* Exercise 5.8: Your code here. (3/3) */</span></span><br><span class="line">			<span class="keyword">if</span> (<span class="built_in">strcmp</span>(name, f-&gt;f_name) == <span class="number">0</span>) &#123;</span><br><span class="line">				*file = f;</span><br><span class="line">				f-&gt;f_dir = dir;</span><br><span class="line">				<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> -E_NOT_FOUND;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>唯一需要注意的是 <code>file_get_block</code> 函数。该函数用于获取文件中第几个磁盘块。其中首先调用 <code>file_map_block</code> 获取了文件中使用的第几个磁盘块对应的磁盘块编号（请注意这两者的区别，一个是相对于文件中其他部分的编号，另一个是相对于磁盘来说的编号）。<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">file_get_block</span><span class="params">(<span class="keyword">struct</span> File *f, u_int filebno, <span class="type">void</span> **blk)</span> &#123;</span><br><span class="line">	<span class="type">int</span> r;</span><br><span class="line">	u_int diskbno;</span><br><span class="line">	u_int isnew;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Step 1: find the disk block number is `f` using `file_map_block`.</span></span><br><span class="line">	<span class="keyword">if</span> ((r = file_map_block(f, filebno, &amp;diskbno, <span class="number">1</span>)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> r;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure></p>
<p>在 <code>file_map_block</code> 中首先调用 <code>file_block_walk</code> 获取对应的磁盘块编号<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">file_map_block</span><span class="params">(<span class="keyword">struct</span> File *f, u_int filebno, u_int *diskbno, u_int alloc)</span> &#123;</span><br><span class="line">	<span class="type">int</span> r;</span><br><span class="line">	<span class="type">uint32_t</span> *ptr;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Step 1: find the pointer for the target block.</span></span><br><span class="line">	<span class="keyword">if</span> ((r = file_block_walk(f, filebno, &amp;ptr, alloc)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> r;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>file_block_walk</code> 中用到了之前着重解释的 <code>f_direct</code> 和 <code>f_indirect</code>。容易发现此函数的与 fsformat 中的 <code>save_block_link</code> 函数结构类似。此函数我们已经在之前说明过了。需要注意的是这里当 <code>f_indirect</code> 还未申请时，我们使用了 <code>alloc_block</code> 来申请一个新的磁盘块，并使用 <code>read_block</code> 将该磁盘块数据读入内存中。<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">file_block_walk</span><span class="params">(<span class="keyword">struct</span> File *f, u_int filebno, <span class="type">uint32_t</span> **ppdiskbno, u_int alloc)</span> &#123;</span><br><span class="line">	<span class="type">int</span> r;</span><br><span class="line">	<span class="type">uint32_t</span> *ptr;</span><br><span class="line">	<span class="type">uint32_t</span> *blk;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (filebno &lt; NDIRECT) &#123;</span><br><span class="line">		<span class="comment">// Step 1: if the target block is corresponded to a direct pointer, just return the</span></span><br><span class="line">		<span class="comment">// disk block number.</span></span><br><span class="line">		ptr = &amp;f-&gt;f_direct[filebno];</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (filebno &lt; NINDIRECT) &#123;</span><br><span class="line">		<span class="comment">// Step 2: if the target block is corresponded to the indirect block, but there&#x27;s no</span></span><br><span class="line">		<span class="comment">//  indirect block and `alloc` is set, create the indirect block.</span></span><br><span class="line">		<span class="keyword">if</span> (f-&gt;f_indirect == <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span> (alloc == <span class="number">0</span>) &#123;</span><br><span class="line">				<span class="keyword">return</span> -E_NOT_FOUND;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> ((r = alloc_block()) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">				<span class="keyword">return</span> r;</span><br><span class="line">			&#125;</span><br><span class="line">			f-&gt;f_indirect = r;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Step 3: read the new indirect block to memory.</span></span><br><span class="line">		<span class="keyword">if</span> ((r = read_block(f-&gt;f_indirect, (<span class="type">void</span> **)&amp;blk, <span class="number">0</span>)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> r;</span><br><span class="line">		&#125;</span><br><span class="line">		ptr = blk + filebno;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> -E_INVAL;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Step 4: store the result into *ppdiskbno, and return 0.</span></span><br><span class="line">	*ppdiskbno = ptr;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>read_block</code> 我们之前已经提及了，现在我们就考察一下 <code>alloc_block</code>。该函数首先调用 <code>alloc_block_num</code> 在磁盘块管理位图上找到空闲的磁盘块，更新位图并将位图写入内存<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">alloc_block_num</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">	<span class="type">int</span> blockno;</span><br><span class="line">	<span class="comment">// walk through this bitmap, find a free one and mark it as used, then sync</span></span><br><span class="line">	<span class="comment">// this block to IDE disk (using `write_block`) from memory.</span></span><br><span class="line">	<span class="keyword">for</span> (blockno = <span class="number">3</span>; blockno &lt; super-&gt;s_nblocks; blockno++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (bitmap[blockno / <span class="number">32</span>] &amp; (<span class="number">1</span> &lt;&lt; (blockno % <span class="number">32</span>))) &#123; <span class="comment">// the block is free</span></span><br><span class="line">			bitmap[blockno / <span class="number">32</span>] &amp;= ~(<span class="number">1</span> &lt;&lt; (blockno % <span class="number">32</span>));</span><br><span class="line">			write_block(blockno / BIT2BLK + <span class="number">2</span>); <span class="comment">// write to disk.</span></span><br><span class="line">			<span class="keyword">return</span> blockno;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// no free blocks.</span></span><br><span class="line">	<span class="keyword">return</span> -E_NO_DISK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">alloc_block</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">	<span class="type">int</span> r, bno;</span><br><span class="line">	<span class="comment">// Step 1: find a free block.</span></span><br><span class="line">	<span class="keyword">if</span> ((r = alloc_block_num()) &lt; <span class="number">0</span>) &#123; <span class="comment">// failed.</span></span><br><span class="line">		<span class="keyword">return</span> r;</span><br><span class="line">	&#125;</span><br><span class="line">	bno = r;</span><br></pre></td></tr></table></figure></p>
<p>之后 <code>alloc_block</code> 函数调用 <code>map_block</code> 将获取的编号所对应的空闲磁盘块从磁盘中读入内存。<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">	<span class="comment">// Step 2: map this block into memory.</span></span><br><span class="line">	<span class="keyword">if</span> ((r = map_block(bno)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		free_block(bno);</span><br><span class="line">		<span class="keyword">return</span> r;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Step 3: return block number.</span></span><br><span class="line">	<span class="keyword">return</span> bno;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>map_block</code> 函数申请一个页面用于存储磁盘块内容，类似的含有 <code>unmap_block</code> 函数。这两个函数较为简单，唯一需要注意的是 <code>unmap_block</code> 会将内存中对磁盘块的修改写回磁盘。<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">map_block</span><span class="params">(u_int blockno)</span> &#123;</span><br><span class="line">	<span class="comment">// Step 1: If the block is already mapped in cache, return 0.</span></span><br><span class="line">	<span class="comment">// Hint: Use &#x27;block_is_mapped&#x27;.</span></span><br><span class="line">	<span class="comment">/* Exercise 5.7: Your code here. (1/5) */</span></span><br><span class="line">	<span class="keyword">if</span> (block_is_mapped(blockno)) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Step 2: Alloc a page in permission &#x27;PTE_D&#x27; via syscall.</span></span><br><span class="line">	<span class="comment">// Hint: Use &#x27;diskaddr&#x27; for the virtual address.</span></span><br><span class="line">	<span class="comment">/* Exercise 5.7: Your code here. (2/5) */</span></span><br><span class="line">	try(syscall_mem_alloc(env-&gt;env_id, diskaddr(blockno), PTE_D));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">unmap_block</span><span class="params">(u_int blockno)</span> &#123;</span><br><span class="line">	<span class="comment">// Step 1: Get the mapped address of the cache page of this block using &#x27;block_is_mapped&#x27;.</span></span><br><span class="line">	<span class="type">void</span> *va;</span><br><span class="line">	<span class="comment">/* Exercise 5.7: Your code here. (3/5) */</span></span><br><span class="line">	va = block_is_mapped(blockno);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Step 2: If this block is used (not free) and dirty in cache, write it back to the disk</span></span><br><span class="line">	<span class="comment">// first.</span></span><br><span class="line">	<span class="comment">/* Exercise 5.7: Your code here. (4/5) */</span></span><br><span class="line">	<span class="keyword">if</span> (!block_is_free(blockno) &amp;&amp; block_is_dirty(blockno)) &#123;</span><br><span class="line">		write_block(blockno);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Step 3: Unmap the virtual address via syscall.</span></span><br><span class="line">	<span class="comment">/* Exercise 5.7: Your code here. (5/5) */</span></span><br><span class="line">	syscall_mem_unmap(env-&gt;env_id, diskaddr(blockno));</span><br><span class="line"></span><br><span class="line">	user_assert(!block_is_mapped(blockno));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>最后 <code>free_block</code> 则是重新将位图对应位置置 1，表示空闲。<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">free_block</span><span class="params">(u_int blockno)</span> &#123;</span><br><span class="line">	<span class="comment">// You can refer to the function &#x27;block_is_free&#x27; above.</span></span><br><span class="line">	<span class="comment">// Step 1: If &#x27;blockno&#x27; is invalid (0 or &gt;= the number of blocks in &#x27;super&#x27;), return.</span></span><br><span class="line">	<span class="comment">/* Exercise 5.4: Your code here. (1/2) */</span></span><br><span class="line">	<span class="keyword">if</span> (super == <span class="number">0</span> || blockno &gt;= super-&gt;s_nblocks) &#123;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Step 2: Set the flag bit of &#x27;blockno&#x27; in &#x27;bitmap&#x27;.</span></span><br><span class="line">	<span class="comment">// Hint: Use bit operations to update the bitmap, such as b[n / W] |= 1 &lt;&lt; (n % W).</span></span><br><span class="line">	<span class="comment">/* Exercise 5.4: Your code here. (2/2) */</span></span><br><span class="line">	bitmap[blockno / <span class="number">32</span>] |= <span class="number">1</span> &lt;&lt; (blockno % <span class="number">32</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>我在看这一部分的时候有点想要吐槽一下，为什么 <code>map_block</code> 函数和 <code>read_block</code> 函数如此相似？<code>map_block</code> 分明完全是 <code>read_block</code> 的弱化版。后来回看 <code>file_block_walk</code> 的时候就明白原因了。在 <code>file_block_walk</code> 中我们同时使用了 <code>alloc_block</code>（其中用到 <code>read_block</code>） 和 <code>read_block</code>。其中 <code>alloc_block</code> 只是申请了一个磁盘块，但因为是新申请，所以对应地址空间中的数据没有用处，并不从磁盘中读取数据，只需要申请对应地址的物理页即可。而 <code>read_block</code> 则进行了数据的读取。如在 <code>file_block_walk</code> 中需要读取间接磁盘块中的数据来确定。</p>
<p>经过了这么艰辛的历程，我们重新回到 <code>file_map_block</code>。文件的第几个磁盘块对应的磁盘块编号现在已经被存储在了 <code>*ptr</code>。这里还考虑了未找到时再调用 <code>alloc_block</code> 申请一个磁盘块的情况。<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Step 2: if the block not exists, and create is set, alloc one.</span></span><br><span class="line"><span class="keyword">if</span> (*ptr == <span class="number">0</span>) &#123;</span><br><span class="line">	<span class="keyword">if</span> (alloc == <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> -E_NOT_FOUND;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> ((r = alloc_block()) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> r;</span><br><span class="line">	&#125;</span><br><span class="line">	*ptr = r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>最后将文件的第几个磁盘块对应的磁盘块编号传给 <code>*diskbno</code>，这样就找到了对应的磁盘块编号。<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">	<span class="comment">// Step 3: set the pointer to the block in *diskbno and return 0.</span></span><br><span class="line">	*diskbno = *ptr;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>还记得我们是从哪里调用的吗？我们返回到 <code>file_get_block</code>，现在我们已经找到了文件中第几个磁盘块对应的磁盘块编号，最后只需要调用 <code>read_block</code> 将该磁盘块的内容从磁盘中读取到内存即可。<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">	<span class="comment">// Step 2: read the data in this disk to blk.</span></span><br><span class="line">	<span class="keyword">if</span> ((r = read_block(diskbno, blk, &amp;isnew)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> r;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>之后，我们的 <code>dir_lookup</code> 函数就可以遍历目录文件下所有的文件，找到和目标文件名相同的文件了。而 <code>dir_lookup</code> 作为 <code>walk_path</code> 的重要组成部分，使 <code>walk_path</code> 完成了根据路径获取对应文件的功能。<code>file_open</code> 函数调用 <code>walk_path</code> 之后返回。我们终于又回到了 <code>serve_open</code> 函数。</p>
<p><code>serve_open</code> 接下来的内容就比较简单了，只是将 <code>file_open</code> 返回的文件控制块结构体设置到 <code>struct Open</code> 结构体，表示新打开的文件为该文件，接着设置一系列字段的值。最后调用 <code>ipc_send</code> 返回，将文件描述符 <code>o-&gt;o_ff</code> 与用户进程共享。<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">	<span class="comment">// Save the file pointer.</span></span><br><span class="line">	o-&gt;o_file = f;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Fill out the Filefd structure</span></span><br><span class="line">	ff = (<span class="keyword">struct</span> Filefd *)o-&gt;o_ff;</span><br><span class="line">	ff-&gt;f_file = *f;</span><br><span class="line">	ff-&gt;f_fileid = o-&gt;o_fileid;</span><br><span class="line">	o-&gt;o_mode = rq-&gt;req_omode;</span><br><span class="line">	ff-&gt;f_fd.fd_omode = o-&gt;o_mode;</span><br><span class="line">	ff-&gt;f_fd.fd_dev_id = devfile.dev_id;</span><br><span class="line"></span><br><span class="line">	ipc_send(envid, <span class="number">0</span>, o-&gt;o_ff, PTE_D | PTE_LIBRARY);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>只需要注意 <code>ff-&gt;f_fd.fd_dev_id = devfile.dev_id;</code> 这一句，我们设置文件描述符对应的设备为 <code>devfile</code>。该变量定义在 user/lib/file.c 中<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Dev</span> <span class="title">devfile</span> =</span> &#123;</span><br><span class="line">    .dev_id = <span class="string">&#x27;f&#x27;</span>,</span><br><span class="line">    .dev_name = <span class="string">&quot;file&quot;</span>,</span><br><span class="line">    .dev_read = file_read,</span><br><span class="line">    .dev_write = file_write,</span><br><span class="line">    .dev_close = file_close,</span><br><span class="line">    .dev_stat = file_stat,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>其中 <code>struct Dev</code> 定义在 user/include/fd.h 中<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Dev</span> &#123;</span></span><br><span class="line">	<span class="type">int</span> dev_id;</span><br><span class="line">	<span class="type">char</span> *dev_name;</span><br><span class="line">	<span class="type">int</span> (*dev_read)(<span class="keyword">struct</span> Fd *, <span class="type">void</span> *, u_int, u_int);</span><br><span class="line">	<span class="type">int</span> (*dev_write)(<span class="keyword">struct</span> Fd *, <span class="type">const</span> <span class="type">void</span> *, u_int, u_int);</span><br><span class="line">	<span class="type">int</span> (*dev_close)(<span class="keyword">struct</span> Fd *);</span><br><span class="line">	<span class="type">int</span> (*dev_stat)(<span class="keyword">struct</span> Fd *, <span class="keyword">struct</span> Stat *);</span><br><span class="line">	<span class="type">int</span> (*dev_seek)(<span class="keyword">struct</span> Fd *, u_int);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>这样看就很容易理解了。这实际上通过结构体实现了类似抽象类的功能。</p>
<h3 id="（4）open-的后续"><a href="#（4）open-的后续" class="headerlink" title="（4）open 的后续"></a>（4）open 的后续</h3><p>不要忘了，我们的 <code>open</code> 函数还没有结束呢。接着上一节，获取到的文件描述符与用户进程共享，那么共享到哪里了呢？如果你还记得 <code>fd_alloc</code> 函数，那么应该知道共享到了 <code>struct Fd *fd</code> 所指向的地址处。虽然我们获得了服务进程共享给用户进程的文件描述符，可文件的内容还没有被一同共享过来。我们还需要使用 <code>fsipc_map</code> 进行映射。</p>
<p>在此之前我们先做准备工作。我们通过 <code>fd2data</code> 获取文件内容应该映射到的地址<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Step 3: Set &#x27;va&#x27; to the address of the page where the &#x27;fd&#x27;&#x27;s data is cached, using</span></span><br><span class="line"><span class="comment">// &#x27;fd2data&#x27;. Set &#x27;size&#x27; and &#x27;fileid&#x27; correctly with the value in &#x27;fd&#x27; as a &#x27;Filefd&#x27;.</span></span><br><span class="line"><span class="type">char</span> *va;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Filefd</span> *<span class="title">ffd</span>;</span></span><br><span class="line">u_int size, fileid;</span><br><span class="line"><span class="comment">/* Exercise 5.9: Your code here. (3/5) */</span></span><br><span class="line">va = fd2data(fd);</span><br></pre></td></tr></table></figure></p>
<p>由定义可知，该函数为不同的文件描述符提供不同的地址用于映射。整体的映射区间为 <code>[FILEBASE, FILEBASE+1024*PDMAP)</code>。这正好在存储文件描述符的空间 <code>[FILEBASE - PDMAP, FILEBASE)</code> 的上面。<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// user/lib/fd.c</span></span><br><span class="line"><span class="type">void</span> *<span class="title function_">fd2data</span><span class="params">(<span class="keyword">struct</span> Fd *fd)</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> (<span class="type">void</span> *)INDEX2DATA(fd2num(fd));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">fd2num</span><span class="params">(<span class="keyword">struct</span> Fd *fd)</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> ((u_int)fd - FDTABLE) / BY2PG;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// user/include/fd.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FILEBASE 0x60000000</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INDEX2DATA(i) (FILEBASE + (i)*PDMAP)</span></span><br></pre></td></tr></table></figure></p>
<p>接着我们将文件所有的内容都从磁盘中映射到内存。使用的函数为 <code>fsipc_map</code>。映射的过程和得到文件描述符的过程类似，就不详述了。<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">ffd = (<span class="keyword">struct</span> Filefd *)fd;</span><br><span class="line">size = ffd-&gt;f_file.f_size;</span><br><span class="line">fileid = ffd-&gt;f_fileid;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Step 4: Alloc pages and map the file content using &#x27;fsipc_map&#x27;.</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; size; i += BY2PG) &#123;</span><br><span class="line">	<span class="comment">/* Exercise 5.9: Your code here. (4/5) */</span></span><br><span class="line">	try(fsipc_map(fileid, i, va + i));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>注意这里要映射到的地址为 <code>va + i</code> 而非 <code>va</code>，使用后者在 Lab6 中加载更大文件时会出现 bug，但却可以通过 Lab5 的评测……</p>
</blockquote>
<p>在最后，使用 <code>fd2num</code> 方法获取文件描述符在文件描述符 “数组” 中的索引<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">	<span class="comment">// Step 5: Return the number of file descriptor using &#x27;fd2num&#x27;.</span></span><br><span class="line">	<span class="comment">/* Exercise 5.9: Your code here. (5/5) */</span></span><br><span class="line">	<span class="keyword">return</span> fd2num(fd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这样，<code>open</code> 函数就终于完成了。</p>
<h3 id="（5）read-的实现"><a href="#（5）read-的实现" class="headerlink" title="（5）read 的实现"></a>（5）read 的实现</h3><p>文件系统的最后一部分，让我们再举 <code>read</code> 做一个例子。该函数位于 user/lib/fd.c 中。</p>
<p><code>read</code> 函数给了文件描述符序号作为参数，我们首先要根据该序号找到文件描述符，并根据文件描述符中的设备序号 <code>fd_dev_id</code> 找到对应的设备。这两个操作分别通过 <code>fd_lookup</code> 和 <code>dev_lookup</code> 实现。<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">read</span><span class="params">(<span class="type">int</span> fdnum, <span class="type">void</span> *buf, u_int n)</span> &#123;</span><br><span class="line">	<span class="type">int</span> r;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Similar to the &#x27;write&#x27; function below.</span></span><br><span class="line">	<span class="comment">// Step 1: Get &#x27;fd&#x27; and &#x27;dev&#x27; using &#x27;fd_lookup&#x27; and &#x27;dev_lookup&#x27;.</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Dev</span> *<span class="title">dev</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Fd</span> *<span class="title">fd</span>;</span></span><br><span class="line">	<span class="comment">/* Exercise 5.10: Your code here. (1/4) */</span></span><br><span class="line">	<span class="keyword">if</span> ((r = fd_lookup(fdnum, &amp;fd)) &lt; <span class="number">0</span> || (r = dev_lookup(fd-&gt;fd_dev_id, &amp;dev)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> r;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure></p>
<p>因为文件描述符存储在内存中的连续空间中，所以 <code>fd_lookup</code> 函数只是根据序号找到对应的文件描述符，并且判断文件描述符是否被使用而已，这一点函数中又一次使用页表判断。<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">fd_lookup</span><span class="params">(<span class="type">int</span> fdnum, <span class="keyword">struct</span> Fd **fd)</span> &#123;</span><br><span class="line">	u_int va;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (fdnum &gt;= MAXFD) &#123;</span><br><span class="line">		<span class="keyword">return</span> -E_INVAL;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	va = INDEX2FD(fdnum);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> ((vpt[va / BY2PG] &amp; PTE_V) != <span class="number">0</span>) &#123; <span class="comment">// the fd is used</span></span><br><span class="line">		*fd = (<span class="keyword">struct</span> Fd *)va;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> -E_INVAL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>对于 <code>dev_lookup</code>，首先我们应该了解到所有的设备都被存储到了全局变量 <code>devtab</code> 中。（这里出现了我们之前见到过的 <code>devfile</code>。<code>devcons</code> 类似。）<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">Dev</span> *<span class="title">devtab</span>[] =</span> &#123;&amp;devfile, &amp;devcons,</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> !defined(LAB) || LAB &gt;= 6</span></span><br><span class="line">			       &amp;devpipe,</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">			       <span class="number">0</span>&#125;;</span><br></pre></td></tr></table></figure></p>
<p>那么在 <code>dev_lookup</code> 中，我们就只是遍历该数组，找到和传入的参数 <code>dev_id</code> 相同的设备而已。<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">dev_lookup</span><span class="params">(<span class="type">int</span> dev_id, <span class="keyword">struct</span> Dev **dev)</span> &#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; devtab[i]; i++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (devtab[i]-&gt;dev_id == dev_id) &#123;</span><br><span class="line">			*dev = devtab[i];</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	debugf(<span class="string">&quot;[%08x] unknown device type %d\n&quot;</span>, env-&gt;env_id, dev_id);</span><br><span class="line">	<span class="keyword">return</span> -E_INVAL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>回到 <code>read</code>，接下来我们判断文件的打开方式是否是只写，如果是那么我们就不能够进行读取，应该返回异常。<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Step 2: Check the open mode in &#x27;fd&#x27;.</span></span><br><span class="line"><span class="comment">// Return -E_INVAL if the file is opened for writing only (O_WRONLY).</span></span><br><span class="line"><span class="comment">/* Exercise 5.10: Your code here. (2/4) */</span></span><br><span class="line"><span class="keyword">if</span> ((fd-&gt;fd_omode &amp; O_ACCMODE) == O_WRONLY) &#123;</span><br><span class="line">	<span class="keyword">return</span> -E_INVAL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>接着我们调用设备对应的 <code>dev_read</code> 函数，完成数据的读取。<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Step 3: Read from &#x27;dev&#x27; into &#x27;buf&#x27; at the seek position (offset in &#x27;fd&#x27;).</span></span><br><span class="line"><span class="comment">/* Exercise 5.10: Your code here. (3/4) */</span></span><br><span class="line">r = dev-&gt;dev_read(fd, buf, n, fd-&gt;fd_offset);</span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<p>根据之前我们展示的 <code>devfile</code> 的定义，普通文件的读取函数为 <code>file_read</code>。该函数位于 user/lib/file.c 中，只是简单地读取被映射到内存中的文件内容而已。（还记得 <code>fsipc_map</code> 吗？）<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">file_read</span><span class="params">(<span class="keyword">struct</span> Fd *fd, <span class="type">void</span> *buf, u_int n, u_int offset)</span> &#123;</span><br><span class="line">	u_int size;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Filefd</span> *<span class="title">f</span>;</span></span><br><span class="line">	f = (<span class="keyword">struct</span> Filefd *)fd;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Avoid reading past the end of file.</span></span><br><span class="line">	size = f-&gt;f_file.f_size;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (offset &gt; size) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (offset + n &gt; size) &#123;</span><br><span class="line">		n = size - offset;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">memcpy</span>(buf, (<span class="type">char</span> *)fd2data(fd) + offset, n);</span><br><span class="line">	<span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>再次回到 <code>read</code>，我们读取完了内容，现在我们要更新文件的指针 <code>fd_offset</code>。在调用读取函数的时候，我们使用 <code>fd_offset</code> 确定了读取的位置（ <code>dev_read(fd, buf, n, fd-&gt;fd_offset)</code>）。那么下一次读取时，就应该从还未被读取的地方读取了。更新完成后，我们返回读到的数据的字节数。这样 <code>read</code> 函数也完成了。<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">	<span class="comment">// Step 4: Update the offset in &#x27;fd&#x27; if the read is successful.</span></span><br><span class="line">	<span class="comment">/* Hint: DO NOT add a null terminator to the end of the buffer!</span></span><br><span class="line"><span class="comment">	 *  A character buffer is not a C string. Only the memory within [buf, buf+n) is safe to</span></span><br><span class="line"><span class="comment">	 *  use. */</span></span><br><span class="line">	<span class="comment">/* Exercise 5.10: Your code here. (4/4) */</span></span><br><span class="line">	<span class="keyword">if</span> (r &gt; <span class="number">0</span>) &#123;</span><br><span class="line">		fd-&gt;fd_offset += r;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="四、磁盘驱动"><a href="#四、磁盘驱动" class="headerlink" title="四、磁盘驱动"></a>四、磁盘驱动</h2><h3 id="（1）设备读写系统调用"><a href="#（1）设备读写系统调用" class="headerlink" title="（1）设备读写系统调用"></a>（1）设备读写系统调用</h3><p>我们在前面的许多 Lab 中都见到了与外部设备进行交互的代码。我们只需要在对应的物理地址位置写入或读取某些数值，就可以完成与设备的信息传递。现在我们要规范化这一过程，让用户程序也能够实现与设备的直接交互。也就是说，要实现设备读写的系统调用。</p>
<p>这一部分十分简单。根据指导书和注释我们可以得知，只需要完成对三个设备的读写即可。这三个设备是终端、磁盘和时钟。<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *  All valid device and their physical address ranges:</span></span><br><span class="line"><span class="comment"> *	* ---------------------------------*</span></span><br><span class="line"><span class="comment"> *	|   device   | start addr | length |</span></span><br><span class="line"><span class="comment"> *	* -----------+------------+--------*</span></span><br><span class="line"><span class="comment"> *	|  console   | 0x10000000 | 0x20   | (dev_cons.h)</span></span><br><span class="line"><span class="comment"> *	|  IDE disk  | 0x13000000 | 0x4200 | (dev_disk.h)</span></span><br><span class="line"><span class="comment"> *	|    rtc     | 0x15000000 | 0x200  | (dev_rtc.h)</span></span><br><span class="line"><span class="comment"> *	* ---------------------------------*</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure></p>
<p>在内核中，我们要完成系统调用的实现。这里我们要判断内存的虚拟地址是否处于用户空间以及设备的物理地址是否处于那三个设备的范围内。如果所有检查都合法，则调用 <code>memcpy</code> 从内存向设备写入或从设备向内存读取即可，系统调用函数依旧在 kern/syscall_all.c 中实现。<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sys_write_dev</span><span class="params">(u_int va, u_int pa, u_int len)</span> &#123;</span><br><span class="line">	<span class="comment">/* Exercise 5.1: Your code here. (1/2) */</span></span><br><span class="line">	<span class="keyword">if</span> (is_illegal_va_range(va, len)) &#123;</span><br><span class="line">		<span class="keyword">return</span> -E_INVAL;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> ((<span class="number">0x10000000</span> &lt;= pa &amp;&amp; pa + len &lt;= <span class="number">0x10000020</span>) ||</span><br><span class="line">	    (<span class="number">0x13000000</span> &lt;= pa &amp;&amp; pa + len &lt;= <span class="number">0x13004200</span>) ||</span><br><span class="line">	    (<span class="number">0x15000000</span> &lt;= pa &amp;&amp; pa + len &lt;= <span class="number">0x15000200</span>)) &#123;</span><br><span class="line">		<span class="built_in">memcpy</span>((<span class="type">void</span> *)(KSEG1 | pa), (<span class="type">void</span> *)va, len);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> -E_INVAL;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">sys_read_dev</span><span class="params">(u_int va, u_int pa, u_int len)</span> &#123;</span><br><span class="line">	<span class="comment">/* Exercise 5.1: Your code here. (2/2) */</span></span><br><span class="line">	<span class="keyword">if</span> (is_illegal_va_range(va, len)) &#123;</span><br><span class="line">		<span class="keyword">return</span> -E_INVAL;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> ((<span class="number">0x10000000</span> &lt;= pa &amp;&amp; pa + len &lt;= <span class="number">0x10000020</span>) ||</span><br><span class="line">	    (<span class="number">0x13000000</span> &lt;= pa &amp;&amp; pa + len &lt;= <span class="number">0x13004200</span>) ||</span><br><span class="line">	    (<span class="number">0x15000000</span> &lt;= pa &amp;&amp; pa + len &lt;= <span class="number">0x15000200</span>)) &#123;</span><br><span class="line">		<span class="built_in">memcpy</span>((<span class="type">void</span> *)va, (<span class="type">void</span> *)(KSEG1 | pa), len);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> -E_INVAL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>另外不要忘记在用户库函数中实现接口，用户的系统调用接口同样还在 user/lib/syscall_lib.c<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">syscall_write_dev</span><span class="params">(<span class="type">void</span> *va, u_int dev, u_int len)</span> &#123;</span><br><span class="line">	<span class="comment">/* Exercise 5.2: Your code here. (1/2) */</span></span><br><span class="line">	<span class="keyword">return</span> msyscall(SYS_write_dev, va, dev, len);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">syscall_read_dev</span><span class="params">(<span class="type">void</span> *va, u_int dev, u_int len)</span> &#123;</span><br><span class="line">	<span class="comment">/* Exercise 5.2: Your code here. (2/2) */</span></span><br><span class="line">	<span class="keyword">return</span> msyscall(SYS_read_dev, va, dev, len);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="（2）IDE-磁盘读写"><a href="#（2）IDE-磁盘读写" class="headerlink" title="（2）IDE 磁盘读写"></a>（2）IDE 磁盘读写</h3><p>最后我们需要实现磁盘的读写操作。在上一章中我们就遇到了 <code>ide_read</code> 函数。该函数通过调用系统操作，实现了从磁盘中读取数据到内存中。类似的还有 <code>ide_write</code> 函数。这两个函数都是磁盘驱动。</p>
<p>在指导书中给出了操作 IDE 磁盘可能用到的地址偏移。我们只需要读写这些地址即可。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">偏移</th>
<th>效果</th>
<th style="text-align:center">数据位宽</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">0x0000</td>
<td>写：设置下一次读写操作时的磁盘镜像偏移的字节数</td>
<td style="text-align:center">4 字节</td>
</tr>
<tr>
<td style="text-align:center">0x0008</td>
<td>写：设置高 32 位的偏移的字节数</td>
<td style="text-align:center">4 字节</td>
</tr>
<tr>
<td style="text-align:center">0x0010</td>
<td>写：设置下一次读写操作的磁盘编号</td>
<td style="text-align:center">4 字节</td>
</tr>
<tr>
<td style="text-align:center">0x0020</td>
<td>写：开始一次读写操作（写 0 表示读操作，1 表示写操作）</td>
<td style="text-align:center">4 字节</td>
</tr>
<tr>
<td style="text-align:center">0x0030</td>
<td>读：获取上一次操作的状态返回值（读 0 表示失败，非 0 则表示成功）</td>
<td style="text-align:center">4 字节</td>
</tr>
<tr>
<td style="text-align:center">0x4000-0x41ff</td>
<td>读/写：512 字节的读写缓存</td>
<td style="text-align:center">/</td>
</tr>
</tbody>
</table>
</div>
<p><code>ide_read</code> 和 <code>ide_write</code> 定义在 fs/ide.c 中。这两个函数都需要我们自己实现<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">ide_read</span><span class="params">(u_int diskno, u_int secno, <span class="type">void</span> *dst, u_int nsecs)</span> &#123;</span><br><span class="line">	u_int begin = secno * BY2SECT;</span><br><span class="line">	u_int end = begin + nsecs * BY2SECT;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (u_int off = <span class="number">0</span>; begin + off &lt; end; off += BY2SECT) &#123;</span><br><span class="line">		<span class="type">uint32_t</span> temp = diskno;</span><br><span class="line">		<span class="comment">/* Exercise 5.3: Your code here. (1/2) */</span></span><br><span class="line">		syscall_write_dev(&amp;temp, DEV_DISK_ADDRESS | DEV_DISK_ID, <span class="number">4</span>);</span><br><span class="line">		temp = begin + off;</span><br><span class="line">		syscall_write_dev(&amp;temp, DEV_DISK_ADDRESS | DEV_DISK_OFFSET, <span class="number">4</span>);</span><br><span class="line">		temp = DEV_DISK_OPERATION_READ;</span><br><span class="line">		syscall_write_dev(&amp;temp, DEV_DISK_ADDRESS | DEV_DISK_START_OPERATION, <span class="number">4</span>);</span><br><span class="line">		syscall_read_dev(&amp;temp, DEV_DISK_ADDRESS | DEV_DISK_STATUS, <span class="number">4</span>);</span><br><span class="line">		<span class="keyword">if</span> (temp == <span class="number">0</span>) &#123;</span><br><span class="line">			panic_on(<span class="string">&quot;fail to read from disk&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		syscall_read_dev(dst + off, DEV_DISK_ADDRESS | DEV_DISK_BUFFER, BY2SECT);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">ide_write</span><span class="params">(u_int diskno, u_int secno, <span class="type">void</span> *src, u_int nsecs)</span> &#123;</span><br><span class="line">	u_int begin = secno * BY2SECT;</span><br><span class="line">	u_int end = begin + nsecs * BY2SECT;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (u_int off = <span class="number">0</span>; begin + off &lt; end; off += BY2SECT) &#123;</span><br><span class="line">		<span class="type">uint32_t</span> temp = diskno;</span><br><span class="line">		<span class="comment">/* Exercise 5.3: Your code here. (2/2) */</span></span><br><span class="line">		syscall_write_dev(&amp;temp, DEV_DISK_ADDRESS | DEV_DISK_ID, <span class="number">4</span>);</span><br><span class="line">		temp = begin + off;</span><br><span class="line">		syscall_write_dev(&amp;temp, DEV_DISK_ADDRESS | DEV_DISK_OFFSET, <span class="number">4</span>);</span><br><span class="line">		syscall_write_dev(src + off, DEV_DISK_ADDRESS | DEV_DISK_BUFFER, BY2SECT);</span><br><span class="line">		temp = DEV_DISK_OPERATION_WRITE;</span><br><span class="line">		syscall_write_dev(&amp;temp, DEV_DISK_ADDRESS | DEV_DISK_START_OPERATION, <span class="number">4</span>);</span><br><span class="line">		syscall_read_dev(&amp;temp, DEV_DISK_ADDRESS| DEV_DISK_STATUS, <span class="number">4</span>);</span><br><span class="line">		<span class="keyword">if</span> (temp == <span class="number">0</span>) &#123;</span><br><span class="line">			panic_on(<span class="string">&quot;fail to write disk&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里的代码看上去复杂，实际上只实现了简单的步骤，比如对于 <code>ide_read</code>，只不过实现了 1. 设定要读的磁盘编号；2. 设定要读取的地址；3. 开始读取；4. 获取读取后状态（返回值），如果读取失败则 panic；5. 将缓冲区中的内容读到内存中。</p>
<p>这样 Lab5 就完成了。</p>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>MOS</tag>
        <tag>os</tag>
        <tag>BUAA</tag>
      </tags>
  </entry>
  <entry>
    <title>Django创建表结构</title>
    <url>/posts/c837c423/</url>
    <content><![CDATA[<h2 id="一、对象关系映射（ORM）"><a href="#一、对象关系映射（ORM）" class="headerlink" title="一、对象关系映射（ORM）"></a>一、对象关系映射（ORM）</h2><p>面向对象与关系型数据库中的数据存储方式并不匹配，因此为了在编程中实现对数据库的操作，需要 ORM 技术将数据库中数据映射到对象之中。通过对对象的操作，做到对数据库的操作，从而实现增删改查等功能。</p>
<blockquote>
<p>面向对象编程中，“关系”体现在类与其属性之间以及同一类的不同属性之间；而在关系型数据库中，“关系”体现在同一表中的不同列字段中。</p>
</blockquote>
<h2 id="二、django-的-ORM-实现"><a href="#二、django-的-ORM-实现" class="headerlink" title="二、django 的 ORM 实现"></a>二、django 的 ORM 实现</h2><p>django 通过 <code>models.Model</code> 类来对应数据库中的表结构，如<br><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">User</span>(models.Model):</span><br></pre></td></tr></table></figure><br>即表示了 <code>User</code> 类，也对应了数据库中的 user 表。django 会根据类的声明自动在数据库中建表。</p>
<p>django 用类中的属性来表示表的列字段。如<br><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">User</span>(models.Model):</span><br><span class="line">    <span class="built_in">id</span> = models.IntegerField(primary_key=<span class="literal">True</span>)</span><br><span class="line">    name = models.CharField(max_length=<span class="number">50</span>)</span><br><span class="line">    password = models.CharField(max_length=<span class="number">50</span>)</span><br></pre></td></tr></table></figure><br>定义了 user 表的主键、名字、密码信息。</p>
<p>表间关系通过类与其属性表示，如<br><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">User</span>(models.Model):</span><br><span class="line">    <span class="built_in">id</span> = models.IntegerField(primary_key=<span class="literal">True</span>)</span><br><span class="line">    name = models.CharField(max_length=<span class="number">50</span>)</span><br><span class="line">    password = models.CharField(max_length=<span class="number">50</span>)</span><br><span class="line">    courses = models.ManyToManyField(to=<span class="string">&quot;Course&quot;</span>)</span><br></pre></td></tr></table></figure><br><code>courses</code> 属性表示用户具有的课程，反映了用户与课程之间的关系。</p>
<h2 id="三、类属性与数据库字段的对应"><a href="#三、类属性与数据库字段的对应" class="headerlink" title="三、类属性与数据库字段的对应"></a>三、类属性与数据库字段的对应</h2><p>如上一节所述，django 建立了类属性与数据库字段之间的对应关系。常见的如<br><figure class="highlight py"><table><tr><td class="code"><pre><span class="line">models.CharField</span><br><span class="line">models.TextField</span><br><span class="line">models.IntegerField</span><br><span class="line">models.FloatField</span><br></pre></td></tr></table></figure><br>就对应了数据库中的 char(n)，text，int，float 类型。不一一详述。</p>
<h2 id="四、主键与外键"><a href="#四、主键与外键" class="headerlink" title="四、主键与外键"></a>四、主键与外键</h2><p>在表中要定义主键，作为该表一条记录的唯一标识。相应的，在 django 中定义主键需要在对应属性上添加 <code>primary_key=True</code> 参数。例如<br><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="built_in">id</span> = models.IntegerField(primary_key=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure><br>未定义主键时，django 也会自动创建一个主键。</p>
<p>通过外键可以设置表间的关系。外键通过属性 <code>models.ForeignKey</code> 定义。如<br><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Task</span>(models.Model):</span><br><span class="line">    <span class="built_in">id</span> = models.IntegerField(primary_key=<span class="literal">True</span>, null=<span class="literal">False</span>)</span><br><span class="line">    name = models.CharField(max_length=<span class="number">50</span>, null=<span class="literal">False</span>)</span><br><span class="line">    course = models.ForeignKey(to=<span class="string">&quot;Course&quot;</span>, on_delete=models.CASCADE)</span><br></pre></td></tr></table></figure><br>就定义了一个外键，对数据库来说，保存的是 course 表中的主键信息。但对 Task 类来说，则是定义了一个 Course 类型的属性。但这两种观点的本质是一样的，都是建立了 task 到 course 的关系。更准确地说，是多到一的关系（不同的 task 可以对应同一个 course）。</p>
<blockquote>
<p>注意建立表间关系的时候，需要设置 on_delete 参数，表示外键所对应的记录被删除时，本记录的行为。在例子中 CASCADE 表示外键对应的删除后，本记录也删除。</p>
</blockquote>
<h2 id="五、表间关系的创建"><a href="#五、表间关系的创建" class="headerlink" title="五、表间关系的创建"></a>五、表间关系的创建</h2><p>外键是创建表间关系的基础。这一节将更深入讨论表间关系。表间关系可以分为三类，分别是一对一、多对一和多对多。可以通过如下例子进行理解：</p>
<ul>
<li>一对一：一个人对应唯一的身份证，一张身份证对应唯一的一个人。</li>
<li>多对一：一个班级有许多学生，而一个学生只属于某个班级。</li>
<li>多对多：一门课有许多的学生，一个学生会上不同的课。</li>
</ul>
<h3 id="一对一的创建"><a href="#一对一的创建" class="headerlink" title="一对一的创建"></a>一对一的创建</h3><p>在数据库中，一对一的关系比较随意，可以在 A 表中包含 B 表的主键，也可以在 B 表中包含 A 表的主键。只需要保证外键的唯一性即可。</p>
<p>django 设置一对一关系，需要定义 <code>models.OneToOneField</code> 的属性。如在 <code>Person</code> 类中有<br><figure class="highlight py"><table><tr><td class="code"><pre><span class="line">id_card = models.OneToOneField(to=<span class="string">&quot;IDCard&quot;</span>, on_delete=models.RESTRICT)</span><br></pre></td></tr></table></figure><br>这样就可以通过访问 <code>Person</code> 类的属性 <code>id_card</code> 来访问对应的表格数据了。</p>
<blockquote>
<p>models.RESTRICT 表示如果存在关系，则删除会产生异常</p>
</blockquote>
<h3 id="多对一的创建"><a href="#多对一的创建" class="headerlink" title="多对一的创建"></a>多对一的创建</h3><p>建立多对一关系，在数据库中需要让多的一方设置外键，包含一的一方的主键。</p>
<p>而在 django 中，则只需要添加一个外键即可实现。如第五节中的例子<br><figure class="highlight py"><table><tr><td class="code"><pre><span class="line">course = models.ForeignKey(to=<span class="string">&quot;Course&quot;</span>, on_delete=models.CASCADE)</span><br></pre></td></tr></table></figure></p>
<h3 id="多对多的创建"><a href="#多对多的创建" class="headerlink" title="多对多的创建"></a>多对多的创建</h3><p>多对多关系不能通过在任何一方或两方中添加外键实现。需要建立第三个表，称中间表或关系表，在该表中同时包含原来两个表的主键。</p>
<p>django 通过添加 <code>models.ManyToManyField</code> 创建多对多关系。如<br><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Course</span>(models.Model):</span><br><span class="line">    <span class="built_in">id</span> = models.CharField(max_length=<span class="number">10</span>, primary_key=<span class="literal">True</span>, null=<span class="literal">False</span>)</span><br><span class="line">    name = models.CharField(max_length=<span class="number">50</span>, null=<span class="literal">False</span>)</span><br><span class="line">    users = models.ManyToManyField(to=User)</span><br></pre></td></tr></table></figure><br>这样将自动创建一个中间表 course_user，包含 course 表和 user 表的主键。</p>
<p>但是这样只能创建由 Course 到 User 的单向联系。通过 Course 可以访问 User，但从 User 却不能访问 Course。可以自行定义中间表来实现双向多对多关系。</p>
<blockquote>
<p>注意，如果在 User 表中添加属性 <code>courses = models.ManyToManyField(to=Courses)</code> 并不能解决问题。这只会创建另一个表 user_course，最终形成两个单向多对多关系。</p>
</blockquote>
<p>正确的方式是通过 <code>through=</code> 参数指定中间表。<br><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Course</span>(models.Model):</span><br><span class="line">    <span class="built_in">id</span> = models.CharField(max_length=<span class="number">10</span>, primary_key=<span class="literal">True</span>, null=<span class="literal">False</span>)</span><br><span class="line">    name = models.CharField(max_length=<span class="number">50</span>, null=<span class="literal">False</span>)</span><br><span class="line">    users = models.ManyToManyField(to=User, through=<span class="string">&quot;Course2User&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Course2User</span>(models.Model):</span><br><span class="line">    <span class="built_in">id</span> = models.IntegerField(primary_key=<span class="literal">True</span>, null=<span class="literal">False</span>)</span><br><span class="line">    course = models.ForeignKey(to=<span class="string">&quot;Course&quot;</span>, on_delete=models.CASCADE)</span><br><span class="line">    user = models.ForeignKey(to=User, on_delete=models.CASCADE)</span><br></pre></td></tr></table></figure></p>
<p>这样就可以通过中间表查询某个 <code>User</code> 对应的 <code>Course</code> 了。</p>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>Django</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>CMake实用语法教程</title>
    <url>/posts/38f6cfcb/</url>
    <content><![CDATA[<h2 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h2><p>最近一段时间在用 c++ 写一个项目，因此学了学 cmake。说实话，cmake 奇怪的语法在一开始实在容易让人望而生畏。但是上手使用的话就会发现平常会用到的不过是其中的一小部分，并且通常有规律可循。掌握这一部分的内容，大概率就可以组织起一个规模较大的项目了。因此本文也就旨在讲述 cmake 的这一部分的内容。</p>
<p>当然，阅读本教程之前需要了解代码编译、链接的相关知识。关于编译相关的命令，可见我的文章<a href="https://wokron.github.io/posts/a5aebc7b/">系统编程之命令行编译</a>。</p>
<p>本文的所有代码保存在仓库 <a href="https://github.com/wokron/practical-cmake">practical-cmake</a> 中，欢迎 star <code>:)</code>。</p>
<span id="more"></span>
<p>cmake 下载方式如下（apt）<br><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">sudo apt-get install build-essential</span><br><span class="line">sudo apt-get install cmake</span><br></pre></td></tr></table></figure></p>
<h2 id="二、第一步"><a href="#二、第一步" class="headerlink" title="二、第一步"></a>二、第一步</h2><p>说到第一个程序，那当然要请出经典的 <code>hello, world</code> 了。<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;hello, world\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在本文中我会首先给出使用 gcc 编译的命令，之后再使用 cmake 做同样的事情。那么对于第一步，我们的 gcc 命令如下<br><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">gcc main.cpp -o main</span><br></pre></td></tr></table></figure></p>
<p>当然很简单，而对于 cmake 也类似。要使用 cmake，我们需要添加一个配置文件 CMakeLists.txt，其中包含要执行的操作。本小节中，CMakeLists.txt 的内容是<br><figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.10</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">project</span>(main)</span><br><span class="line"></span><br><span class="line"><span class="keyword">add_executable</span>(main main.cpp)</span><br></pre></td></tr></table></figure></p>
<p>其中第一条指定了 cmake 版本要求，第二条指定了当前项目名，而第三条 <code>add_executable</code> 则实现了和 gcc 命令相同的操作：指定源文件 <code>main.cpp</code> 和输出文件名 <code>main</code>，生成一个可执行文件。</p>
<p>要进行编译，需要首先使用 <code>cmake</code> 命令生成构建文件，这会在当前目录下生成包含 Makefile 在内的许多配置文件。之后再通过 <code>make</code> 指令即可完成编译。</p>
<p>为了不影响源文件的结构，我们可以选择新建一个文件夹执行 <code>cmake</code> 命令。假设现在位于项目根目录，那么执行如下命令<br><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> build</span><br><span class="line"><span class="built_in">cd</span> build</span><br><span class="line">cmake ..</span><br></pre></td></tr></table></figure><br>即可生成构建文件。</p>
<p>随后执行 <code>make</code> 命令完成编译并运行。<br><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">make</span><br><span class="line">./main</span><br></pre></td></tr></table></figure></p>
<p>仅就这一节看来，cmake 和 gcc 并没有什么差距，反而步骤更加繁琐，但是随着项目结构越发复杂，cmake 的优势就会越发明显。</p>
<h2 id="三、头文件的引入"><a href="#三、头文件的引入" class="headerlink" title="三、头文件的引入"></a>三、头文件的引入</h2><p>大部分实际的项目都不会只有一个文件。如果有多个源文件，编译器可以将其编译成同一个 .o 文件，源文件间的符号通过头文件共享。下面我们举如下的项目为例。<br><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">.</span><br><span class="line">|-- CMakeLists.txt</span><br><span class="line">|-- include</span><br><span class="line">|   `-- add.h</span><br><span class="line">`-- src</span><br><span class="line">    |-- add.cpp</span><br><span class="line">    `-- main.cpp</span><br></pre></td></tr></table></figure></p>
<p>add.h 中声明了函数 <code>int add(int a, int b)</code>，并在 add.cpp 中实现，而 main.cpp 则调用了该函数，因此需要引入头文件 add.h 获得该函数的声明。</p>
<p>如果使用 gcc，可以使用如下命令编译。注意此处需要通过命令行参数 <code>-I</code> 设定头文件所在路径。<br><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">gcc src/add.cpp src/main.cpp -I ./include -o main</span><br></pre></td></tr></table></figure></p>
<p>对于 cmake 来说，配置如下<br><figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.10</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">project</span>(main)</span><br><span class="line"></span><br><span class="line"><span class="keyword">add_executable</span>(main src/main.cpp src/add.cpp)</span><br><span class="line"><span class="keyword">target_include_directories</span>(main PRIVATE <span class="keyword">include</span>)</span><br></pre></td></tr></table></figure><br>可以看出 <code>add_executable</code> 指令之外，我们新增加了一条指令 <code>target_include_directories</code>，这条命令将路径 ./include 添加到生成目标文件 main 所需的头文件路径中。</p>
<blockquote>
<p>注意 <code>target_include_directories</code> 中除了目标和 include 路径外，还有一个符号 <code>PRIVATE</code>，该符号指定了头文件的作用范围，<code>PRIVATE</code> 表示头文件只用于当前的目标，而不用于链接当前目标的文件，类似还有 <code>PUBLIC</code>，将头文件向外暴露，和 <code>INTERFACE</code>，目标不使用，但向外暴露。当然现在不理解没有关系，在之后我们还会遇到。</p>
</blockquote>
<h2 id="四、库的编译和链接"><a href="#四、库的编译和链接" class="headerlink" title="四、库的编译和链接"></a>四、库的编译和链接</h2><p>有时候可能需要将一个模块编译成一个库，以便用于不同的程序。我们还以前一小节所用的代码为例，但这次我们重新组织代码结构。因为 main 模块调用了 add 模块提供的函数，所以我们可以直接把 add 模块编译成一个库，再将该库与 main 链接。</p>
<p>因为要将 add 作为一个库，所以这里将 add 移到了一个文件夹中。<br><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">.</span><br><span class="line">|-- add</span><br><span class="line">|   |-- include</span><br><span class="line">|   |   `-- add</span><br><span class="line">|   |       `-- add.h</span><br><span class="line">|   `-- src</span><br><span class="line">|       `-- add.cpp</span><br><span class="line">|-- CMakeLists.txt</span><br><span class="line">`-- main.cpp</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>这里有一个技巧，include 的路径下并不直接放头文件，而是在其中增加一层以库名为名的文件夹，这样引入的时候就需要使用 <code>#include &lt;add/add.h&gt;</code> 而不是 <code>#include &lt;add.h&gt;</code>，可以避免命名冲突。</p>
</blockquote>
<p>gcc 可以选择编译为静态库或动态链接库，对于静态库，使用如下的命令创建 add 模块的静态库<br><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">gcc -c add/src/add.cpp -I add/include <span class="comment"># just compile add</span></span><br><span class="line">ar cr libadd.a add.o <span class="comment"># create a static lib add (this name is libadd.a)</span></span><br></pre></td></tr></table></figure></p>
<p>之后还需要将库文件与程序链接起来<br><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">gcc main.cpp -I add/include -L . -l add -o main</span><br></pre></td></tr></table></figure></p>
<p>同理，对于动态库，有<br><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">gcc -c -fPIC add/src/add.cpp -I add/include -o add.o</span><br><span class="line">gcc -shared -fPIC add.o -o libadd.so</span><br></pre></td></tr></table></figure></p>
<p>之后进行链接<br><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">gcc main.cpp libadd.so -I add/include -o main</span><br></pre></td></tr></table></figure></p>
<p>执行时还需要设定动态库位置<br><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">LD_LIBRARY_PATH=.</span><br><span class="line">./main</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>可以看出，随着项目越来越复杂，我们为了完成编译需要进行的操作越来越繁琐了。一般的情况下，多个命令可以写成 shell 脚本；如果依赖关系更加复杂，则需要 makefile 管理编译环节；但如果项目更加庞大，使用 makefile 也需要编写大量代码的话，cmake 之类更加高级的工具就是必然的选择了。</p>
</blockquote>
<p>对于 cmake 来说，库的编译和链接同样简单。我们需要引入两条新的指令。<br><figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.10</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">project</span>(main)</span><br><span class="line"></span><br><span class="line"><span class="keyword">add_library</span>(add add/src/add.cpp)</span><br><span class="line"><span class="keyword">target_include_directories</span>(add PUBLIC add/<span class="keyword">include</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">add_executable</span>(main main.cpp)</span><br><span class="line"><span class="keyword">target_link_libraries</span>(main PRIVATE add)</span><br></pre></td></tr></table></figure><br>注意这里对于 add.cpp，我们不再使用 <code>add_executable</code> 而是 <code>add_library</code>。默认这将创建一个动态库（对于静态库，添加 <code>STATIC</code> 符号即可 <code>add_library(add STATIC add/src/add.cpp)</code>）。之后我们需要将该库与 main 模块链接，这需要使用 <code>target_link_libraries</code>，和引入头文件时类似，只不过这次参数不是路径而是库名。不论是静态库还是动态库，cmake 都使用统一的方法进行处理，实际上简化了流程。</p>
<blockquote>
<p>其实还有另一种“库”，就是只包含头文件的库，使用如下方式定义<br><figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">add_library</span>(headerlib INTERFACE)</span><br><span class="line"><span class="keyword">target_include_directories</span>(headerlib INTERFACE headerlib/<span class="keyword">include</span>)</span><br></pre></td></tr></table></figure></p>
<p>注意这里出现了 <code>PUBLIC</code> 和 <code>PRIVATE</code>。这次 add.h 被 main.cpp 引用，因此需要使用 <code>PUBLIC</code>。试想一下，将 add.cpp 中的 <code>#include &lt;add/add.h&gt;</code> 去掉（因为 add.cpp 中定义了 add 函数，所以可以去掉），那么这里就可以使用 <code>INTERFACE</code> 或 <code>PUBLIC</code>。</p>
</blockquote>
<h2 id="五、项目组织——子目录"><a href="#五、项目组织——子目录" class="headerlink" title="五、项目组织——子目录"></a>五、项目组织——子目录</h2><p>有时候如果你有一个规模较大的项目，将所有源文件堆在一起就不是一个很好的决定了。你可能需要拆分代码，将实现同一功能的源文件放在同一个文件夹中，并将其编译成一个库以便项目其他部分调用。但是一个项目拥有很多模块，如果所有模块的编译操作都在一个 CMakeLists.txt 文件中编写，则这个文件必然变得臃肿杂乱。合适的方法是在子目录中添加 CMakeLists.txt 文件，让该文件管理其目录下的编译操作，再将所有子目录合并到一起。</p>
<p>在 cmake 中只需要一条语句就可以完成子目录的添加，那就是 <code>add_subdirectory</code>。为了便于理解，我们以如下的项目作为例子。<br><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">.</span><br><span class="line">|-- add</span><br><span class="line">|   |-- CMakeLists.txt</span><br><span class="line">|   |-- include</span><br><span class="line">|   |   `-- add</span><br><span class="line">|   |       `-- add.h</span><br><span class="line">|   `-- src</span><br><span class="line">|       `-- add.cpp</span><br><span class="line">|-- CMakeLists.txt</span><br><span class="line">|-- fibo</span><br><span class="line">|   |-- CMakeLists.txt</span><br><span class="line">|   |-- include</span><br><span class="line">|   |   `-- fibo</span><br><span class="line">|   |       `-- fibo.h</span><br><span class="line">|   `-- src</span><br><span class="line">|       `-- fibo.cpp</span><br><span class="line">`-- main.cpp</span><br></pre></td></tr></table></figure></p>
<p>在这个项目中，我们添加了一个 fibo 模块，用于计算斐波那契数，该模块使用 <code>add</code> 函数来完成加法运算。而 main.cpp 现在则添加了一个循环用来计算 1-10 的斐波那契数并输出。因此模块间有如下的引用关系：<br><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">fibo -&gt; add</span><br><span class="line">main -&gt; add</span><br><span class="line">main -&gt; fibo</span><br></pre></td></tr></table></figure></p>
<p>我们在 add 和 fibo 文件夹中都添加了 CMakeLists.txt 用于模块内的编译操作。<br><figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="comment"># add/CMakeLists.txt</span></span><br><span class="line"><span class="keyword">add_library</span>(add src/add.cpp)</span><br><span class="line"><span class="keyword">target_include_directories</span>(add PUBLIC <span class="keyword">include</span>)</span><br></pre></td></tr></table></figure></p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="comment"># fibo/CMakeLists.txt</span></span><br><span class="line"><span class="keyword">add_library</span>(fibo src/fibo.cpp)</span><br><span class="line"><span class="keyword">target_include_directories</span>(fibo INTERFACE <span class="keyword">include</span>)</span><br><span class="line"><span class="keyword">target_link_libraries</span>(fibo PRIVATE add)</span><br></pre></td></tr></table></figure>
<p>而在项目路径下的 CMakeLists.txt 中使用 <code>add_subdirectory</code> 将 add 和 fibo 路径设定为子路径。这样 cmake 便会执行 add 和 fibo 的 CMakeLists.txt 中的指令。<br><figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.10</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">project</span>(main)</span><br><span class="line"></span><br><span class="line"><span class="keyword">add_subdirectory</span>(add)</span><br><span class="line"><span class="keyword">add_subdirectory</span>(fibo)</span><br><span class="line"></span><br><span class="line"><span class="keyword">add_executable</span>(main main.cpp)</span><br><span class="line"><span class="keyword">target_link_libraries</span>(main PRIVATE add fibo)</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>再一次，注意 <code>PUBLIC</code>、<code>INTERFACE</code> 和 <code>PRIVATE</code> 的使用，fibo 的源代码中没有引用 fibo.h 头文件，因此使用 <code>INTERFACE</code>；fibo 模块引用了 add 模块，但又不想向外提供 add 模块的接口，因此使用 <code>PRIVATE</code>（这时如果从 <code>target_link_libraries(main PRIVATE add fibo)</code> 中删除 add 则会报错）。</p>
</blockquote>
<p>使用 <code>add_subdirectory</code> 之后，项目结构多么清晰！</p>
<h2 id="六、输入输出、变量与流程控制"><a href="#六、输入输出、变量与流程控制" class="headerlink" title="六、输入输出、变量与流程控制"></a>六、输入输出、变量与流程控制</h2><p>有时候你可能想要以多种不同的方式编译项目，比如说选择只编译某些模块或者选择是否编译单元测试。因此你希望在编译的时候输入某些参数选项，而 cmake 也确实提供了这一功能。</p>
<p>cmake 实际上提供了输入、输出、变量和流程控制，像是一门编程语言。当然这一部分并不会深入，因为那样的话这篇文章就不能称为“实用”了。</p>
<blockquote>
<p>cmake 中的输入输出、变量与流程控制发生在调用 <code>cmake</code> 命令时。</p>
</blockquote>
<h3 id="输入输出"><a href="#输入输出" class="headerlink" title="输入输出"></a>输入输出</h3><p>cmake 中使用 <code>option</code> 设置布尔参数作为输入（当然也可以使用 set cache string 设置字符串参数，但不在本文范围内），使用 <code>message</code> 输出字符串，其中也可以包含参数。如下的例子中展示了具体的用法。<br><figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.10</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">project</span>(io)</span><br><span class="line"></span><br><span class="line"><span class="keyword">option</span>(OPTION_VAR <span class="string">&quot;this is help text&quot;</span> <span class="keyword">OFF</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">message</span>(<span class="string">&quot;the value of OPTION_VAR is $&#123;OPTION_VAR&#125;&quot;</span>)</span><br></pre></td></tr></table></figure></p>
<h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><p>用户也可以使用 <code>set</code> 设置变量。语法为 <code>set(name &quot;value&quot;)</code>。另外 cmake 也内置了一些变量，如项目名 <code>PROJECT_NAME</code>、项目根路径 <code>CMAKE_SOURCE_DIR</code>、当前路径 <code>CMAKE_CURRENT_DIR</code> 等等。比如如下的例子<br><figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.10</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">project</span>(variable)</span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span>(USER_VAR <span class="string">&quot;default&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">message</span>(<span class="string">&quot;the value of USER_VAR is $&#123;USER_VAR&#125;&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">message</span>(<span class="string">&quot;the name of project is $&#123;PROJECT_NAME&#125;&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">message</span>(<span class="string">&quot;the whole project&#x27;s dir is $&#123;CMAKE_SOURCE_DIR&#125;&quot;</span>)</span><br></pre></td></tr></table></figure></p>
<p>运行后应该能看到类似下面的输出<br><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">the value of USER_VAR is default</span><br><span class="line">the name of project is variable</span><br><span class="line">the whole project&#x27;s dir is /home/wokron/Code/Projects/practical-cmake/variable</span><br></pre></td></tr></table></figure></p>
<p>因为有了这些内置变量，我们也可以将之前的 CMakeLists.txt 继续化简，如用 <code>$&#123;PROJECT_NAME&#125;</code> 替换特定的目标名。</p>
<h3 id="流程控制"><a href="#流程控制" class="headerlink" title="流程控制"></a>流程控制</h3><p>有了变量当然要有对变量的比较，cmake 提供了分支控制的方法。这里就只介绍一下分支控制。通过例子就可以理解分支控制的语法了。<br><figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.10</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">project</span>(controlflow)</span><br><span class="line"></span><br><span class="line"><span class="keyword">option</span>(OPTION_VAR <span class="string">&quot;this is option&quot;</span> <span class="keyword">ON</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(OPTION_VAR)</span><br><span class="line">    <span class="keyword">message</span>(<span class="string">&quot;OPTION_VAR is on&quot;</span>)</span><br><span class="line"><span class="keyword">else</span>()</span><br><span class="line">    <span class="keyword">message</span>(<span class="string">&quot;OPTION_VAR is off&quot;</span>)</span><br><span class="line"><span class="keyword">endif</span>()</span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span>(STR_VAR <span class="string">&quot;123&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(STR_VAR <span class="keyword">MATCHES</span> <span class="string">&quot;123&quot;</span>)</span><br><span class="line">    <span class="keyword">message</span>(<span class="string">&quot;is 123!&quot;</span>)</span><br><span class="line"><span class="keyword">elseif</span>(STR_VAR <span class="keyword">MATCHES</span> <span class="string">&quot;456&quot;</span>)</span><br><span class="line">    <span class="keyword">message</span>(<span class="string">&quot;is 456&quot;</span>)</span><br><span class="line"><span class="keyword">else</span>()</span><br><span class="line">    <span class="keyword">message</span>(<span class="string">&quot;is other :(&quot;</span>)</span><br><span class="line"><span class="keyword">endif</span>()</span><br></pre></td></tr></table></figure></p>
<p>通过参数和分支，就可以使我们项目的编译更加灵活，适应更复杂的情况。</p>
<h3 id="增加子目录的情况"><a href="#增加子目录的情况" class="headerlink" title="增加子目录的情况"></a>增加子目录的情况</h3><p>在使用 <code>add_subdirectory</code> 时，cmake 究竟发生了什么？其实很简单，cmake 只是去执行子目录中的指令，等执行完成后再跳转回原本的位置而已。这一点实在类似于函数，因为子目录中的 CMakeLists.txt 中可能包含 <code>option</code>，而父目录中的 CMakeLists.txt 也可以通过使用 <code>option</code> 设置同名参数值来指定子目录的编译选项。这一点在引入第三方库的时候十分有用。如下的两个 CMakeLists.txt 实例可以很好的模拟这种情况。<br><figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="comment"># ./CMakeLists.txt</span></span><br><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.10</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">project</span>(subdirectory)</span><br><span class="line"></span><br><span class="line"><span class="keyword">message</span>(<span class="string">&quot;this is $&#123;PROJECT_NAME&#125;&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">option</span>(EXTERN_OPTION <span class="string">&quot;&quot;</span> <span class="keyword">ON</span>)</span><br><span class="line"><span class="keyword">add_subdirectory</span>(extern)</span><br></pre></td></tr></table></figure></p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="comment"># ./extern/CMakeLists.txt</span></span><br><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.8</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">project</span>(extern_module)</span><br><span class="line"></span><br><span class="line"><span class="keyword">option</span>(EXTERN_OPTION <span class="string">&quot;this is option in extern&quot;</span> <span class="keyword">OFF</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">message</span>(<span class="string">&quot;this is $&#123;PROJECT_NAME&#125;&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(EXTERN_OPTION)</span><br><span class="line">    <span class="keyword">message</span>(<span class="string">&quot;will do something&quot;</span>)</span><br><span class="line"><span class="keyword">else</span>()</span><br><span class="line">    <span class="keyword">message</span>(<span class="string">&quot;will do other things&quot;</span>)</span><br><span class="line"><span class="keyword">endif</span>()</span><br></pre></td></tr></table></figure>
<h2 id="七、测试"><a href="#七、测试" class="headerlink" title="七、测试"></a>七、测试</h2><p>cmake 提供了一个简单的测试功能。想要使用首先需要开启测试，这需要在根 CMakeLists.txt 中加入 <code>enable_testing</code><br><figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.10</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">project</span>(main)</span><br><span class="line"></span><br><span class="line"><span class="keyword">enable_testing</span>() <span class="comment"># here!!!</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">add_subdirectory</span>(add)</span><br><span class="line"><span class="keyword">add_subdirectory</span>(fibo)</span><br><span class="line"><span class="keyword">add_subdirectory</span>(<span class="keyword">test</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">add_executable</span>(main main.cpp)</span><br><span class="line"><span class="keyword">target_link_libraries</span>(main PRIVATE add fibo)</span><br></pre></td></tr></table></figure></p>
<p>之后我们需要创建用于测试的可执行文件，并使用 <code>add_test</code> 指令将其加入到测试中。这里我们选择使用一个新的子目录存储测试文件，当然也可以在其他位置，如每个模块目录内。test 目录下的 CMakeLists.txt 文件内容如下<br><figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">add_executable</span>(test_add test_add.cpp)</span><br><span class="line"><span class="keyword">target_link_libraries</span>(test_add add)</span><br><span class="line"></span><br><span class="line"><span class="keyword">add_executable</span>(test_fibo test_fibo.cpp)</span><br><span class="line"><span class="keyword">target_link_libraries</span>(test_fibo fibo)</span><br><span class="line"></span><br><span class="line"><span class="keyword">add_test</span>(NAME test_add <span class="keyword">COMMAND</span> test_add)</span><br><span class="line"><span class="keyword">add_test</span>(NAME test_fibo <span class="keyword">COMMAND</span> test_fibo)</span><br></pre></td></tr></table></figure></p>
<p>以及测试文件的内容，这里就只是简单编写一下<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// test_add.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;add/add.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">assert</span>(<span class="built_in">add</span>(<span class="number">1</span>, <span class="number">2</span>) == <span class="number">3</span>);</span><br><span class="line">    <span class="built_in">assert</span>(<span class="built_in">add</span>(<span class="number">1</span>, <span class="number">-1</span>) == <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">assert</span>(<span class="built_in">add</span>(<span class="number">1</span>, <span class="number">-2</span>) == <span class="number">-1</span>);</span><br><span class="line">    <span class="built_in">assert</span>(<span class="built_in">add</span>(<span class="number">100</span>, <span class="number">100</span>) == <span class="number">200</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// test_fibo.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;fibo/fibo.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">assert</span>(<span class="built_in">fibonacci</span>(<span class="number">1</span>) == <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">assert</span>(<span class="built_in">fibonacci</span>(<span class="number">2</span>) == <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">assert</span>(<span class="built_in">fibonacci</span>(<span class="number">3</span>) == <span class="number">2</span>);</span><br><span class="line">    <span class="built_in">assert</span>(<span class="built_in">fibonacci</span>(<span class="number">4</span>) == <span class="number">3</span>);</span><br><span class="line">    <span class="built_in">assert</span>(<span class="built_in">fibonacci</span>(<span class="number">5</span>) == <span class="number">5</span>);</span><br><span class="line">    <span class="built_in">assert</span>(<span class="built_in">fibonacci</span>(<span class="number">6</span>) == <span class="number">8</span>);</span><br><span class="line">    <span class="built_in">assert</span>(<span class="built_in">fibonacci</span>(<span class="number">7</span>) == <span class="number">13</span>);</span><br><span class="line">    <span class="built_in">assert</span>(<span class="built_in">fibonacci</span>(<span class="number">8</span>) == <span class="number">21</span>);</span><br><span class="line">    <span class="built_in">assert</span>(<span class="built_in">fibonacci</span>(<span class="number">9</span>) == <span class="number">34</span>);</span><br><span class="line">    <span class="built_in">assert</span>(<span class="built_in">fibonacci</span>(<span class="number">10</span>) == <span class="number">55</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>之后在 build 目录下执行如下命令<br><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">cmake ..</span><br><span class="line">make</span><br><span class="line">make <span class="built_in">test</span></span><br></pre></td></tr></table></figure></p>
<p>输出结果如下，测试成功！！！<br><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">Test project /home/wokron/Code/Projects/practical-cmake/build/test</span><br><span class="line">    Start 1: test_add</span><br><span class="line">1/2 Test #1: test_add .........................   Passed    0.00 sec</span><br><span class="line">    Start 2: test_fibo</span><br><span class="line">2/2 Test #2: test_fibo ........................   Passed    0.00 sec</span><br><span class="line"></span><br><span class="line">100% tests passed, 0 tests failed out of 2</span><br><span class="line"></span><br><span class="line">Total Test time (real) =   0.00 sec</span><br></pre></td></tr></table></figure></p>
<p>最终，我们的项目结构如下<br><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">.</span><br><span class="line">|-- add</span><br><span class="line">|   |-- CMakeLists.txt</span><br><span class="line">|   |-- include</span><br><span class="line">|   |   `-- add</span><br><span class="line">|   |       `-- add.h</span><br><span class="line">|   `-- src</span><br><span class="line">|       `-- add.cpp</span><br><span class="line">|-- CMakeLists.txt</span><br><span class="line">|-- fibo</span><br><span class="line">|   |-- CMakeLists.txt</span><br><span class="line">|   |-- include</span><br><span class="line">|   |   `-- fibo</span><br><span class="line">|   |       `-- fibo.h</span><br><span class="line">|   `-- src</span><br><span class="line">|       `-- fibo.cpp</span><br><span class="line">|-- main.cpp</span><br><span class="line">`-- test</span><br><span class="line">    |-- CMakeLists.txt</span><br><span class="line">    |-- test_add.cpp</span><br><span class="line">    `-- test_fibo.cpp</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>教程</category>
      </categories>
      <tags>
        <tag>cmake</tag>
      </tags>
  </entry>
  <entry>
    <title>ESIM网络的搭建和训练</title>
    <url>/posts/3c5d5cf3/</url>
    <content><![CDATA[<h2 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h2><p>最近半年多的时间里学了许多人工智能，尤其是深度学习的知识，但是一直没有搭建过一个较为复杂的神经网络，最多也只是一个简单的 rnn。这主要是因为自己的笔记本没有训练较大模型的能力。</p>
<p>因为对nlp比较感兴趣，因此最近开始尝试跟着复旦大学邱锡鹏老师的<a href="https://github.com/FudanNLP/nlp-beginner">NLP入门练习</a>搭建网络。但到任务三时自己的笔记本就无法继续训练了，于是这次我下定决心找到训练一个比较好的训练模型的方法。最终找到了 Colab。</p>
<p>因为使用了Colab，本次模型的构建和训练比较成功，因而做此记录。</p>
<h2 id="二、任务"><a href="#二、任务" class="headerlink" title="二、任务"></a>二、任务</h2><p>本次任务是输入两个句子，判断它们之间的关系。具体来说，我们需要实现<a href="https://arxiv.org/pdf/1609.06038v3.pdf">论文</a>中提出的 ESIM 网络，并通过 <a href="https://nlp.stanford.edu/projects/snli/">SNLI数据集</a> 进行训练，以学习预测两个句子间的关系。</p>
<h2 id="三、数据集"><a href="#三、数据集" class="headerlink" title="三、数据集"></a>三、数据集</h2><p>SNLI数据集包含57万行英文句子对，并被标注了句子间的关系，包括蕴含（Entailment），矛盾（Contradiction），中立/不冲突（Neutral），未知（-）。</p>
<p>例如</p>
<blockquote>
<p>输入文本： A man inspects the uniform of a figure in some East Asian  country.<br>输入假设： The man is sleeping.<br>输出： 矛盾（C）</p>
<p>输入文本： A smiling costumed woman is holding an umbrella.<br>输入假设：A happy woman in a fairy costume holds an umbrella.<br>输出： 中立（N）</p>
<p>输入文本： A soccer game with multiple males playing.<br>输入假设： Some men are playing a sport.<br>输出： 蕴含（E）</p>
</blockquote>
<p>原始的数据集提供了 json 格式和制表符分割 txt 格式。在读取数据时，我们使用了制表符格式。</p>
<p>对于每一个文件，第一行为表头，其他行为数据。我们只需要获取 sentence1 和 sentence2 列对应的句子和 gold_label 所对应的标注。</p>
<p>我们创建获取SNLI数据集的 Dataset 类<br><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SNLIDataset</span>(<span class="title class_ inherited__">Dataset</span>):</span><br></pre></td></tr></table></figure><br>首先指定 sentence1、sentence2 和 gold_label 对应的列数<br><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, file_path, vocab=<span class="literal">None</span></span>):</span><br><span class="line">    s1 = <span class="number">5</span></span><br><span class="line">    s2 = <span class="number">6</span></span><br><span class="line">    l = <span class="number">0</span></span><br></pre></td></tr></table></figure></p>
<p>训练时使用自建词汇表。我们在加载训练集时构建词汇表，在验证级和测试集中使用词汇表<br><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> vocab <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">    self.build_vocab = <span class="literal">True</span></span><br><span class="line">    self.vocab = &#123;<span class="string">&quot;&lt;pad&gt;&quot;</span>: <span class="number">0</span>&#125;</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    self.build_vocab = <span class="literal">False</span></span><br><span class="line">    self.vocab = vocab</span><br></pre></td></tr></table></figure></p>
<p>我们打开文件，遍历其中每一行，注意这里我们使用了 tqdm 来显示进度条。同时使用了 enumerate 获取 index。当遇到第一行时 continue。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">self.s1 = []</span><br><span class="line">self.s2 = []</span><br><span class="line">self.labels = []</span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(file_path, encoding=<span class="string">&quot;UTF-8&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    <span class="keyword">with</span> tqdm(f) <span class="keyword">as</span> tqdm_file:</span><br><span class="line">        tqdm_file.set_description(<span class="string">&quot;Load Data&quot;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> index, line <span class="keyword">in</span> <span class="built_in">enumerate</span>(tqdm_file):</span><br><span class="line">            <span class="keyword">if</span> index == <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">continue</span></span><br></pre></td></tr></table></figure>
<p>按制表符分割一行，取出其中的 sentence1、sentence2 和 gold_label。分别将字符串转化为 tensor 存入对应的数组中。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">splited_line = line.split(<span class="string">&quot;\t&quot;</span>)</span><br><span class="line"></span><br><span class="line">sentence1 = splited_line[s1]</span><br><span class="line">sentence2 = splited_line[s2]</span><br><span class="line">label = splited_line[l]</span><br><span class="line"></span><br><span class="line">self.s1.append(self.__sentence2tensor(sentence1))</span><br><span class="line">self.s2.append(self.__sentence2tensor(sentence2))</span><br><span class="line">self.labels.append(torch.as_tensor(labels[label]))</span><br></pre></td></tr></table></figure>
<p>其中 <code>__sentence2tensor</code> 方法如下。该方法通过正则表达式匹配单词，构建词汇表。<code>get_word_index</code> 将 char 字符转化为数字 token，如果字符不在词汇表中则返回值为 0。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">__sentence2tensor</span>(<span class="params">self, s</span>):</span><br><span class="line">    rt = []</span><br><span class="line">    <span class="keyword">for</span> char <span class="keyword">in</span> re.findall(<span class="string">&quot;[a-zA-Z-]+&quot;</span>, s):</span><br><span class="line">        <span class="keyword">if</span> self.build_vocab <span class="keyword">and</span> char <span class="keyword">not</span> <span class="keyword">in</span> self.vocab:</span><br><span class="line">            self.vocab[char] = <span class="built_in">len</span>(self.vocab)</span><br><span class="line">        rt.append(get_word_index(self.vocab, char))</span><br><span class="line">    <span class="keyword">return</span> torch.as_tensor(rt)</span><br></pre></td></tr></table></figure>
<p>接着我们实现 <code>__getitem__</code> 和 <code>__len__</code> 方法。<br><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">__getitem__</span>(<span class="params">self, item</span>):</span><br><span class="line">    <span class="keyword">return</span> self.s1[item], self.s2[item], self.labels[item]</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">__len__</span>(<span class="params">self</span>):</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">len</span>(self.s1)</span><br></pre></td></tr></table></figure></p>
<h2 id="四、神经网络"><a href="#四、神经网络" class="headerlink" title="四、神经网络"></a>四、神经网络</h2><p>在实现的过程中，我简化了一部分流程</p>
<p>首先，我们定义输入的两个句子为 $a = (a<em>1, …, a</em>{seq<em>a})$ 和 $b = (b_1, …, b</em>{seq_b})$。其中 $a_i, b_j$ 为 $l$ 维的词向量。</p>
<p>依照双向注意力的机制，我们首先定义 $f(x)$。即</p>
<script type="math/tex; mode=display">
    \bar{a}_i = BiLSTM(a, i)</script><script type="math/tex; mode=display">
    \bar{b}_j = BiLSTM(b, j)</script><p>接着，我们定义注意力权重 $e_{ij} = f(a_i)^T f(b_j)$，即</p>
<script type="math/tex; mode=display">
    e_{ij} = \bar{a}_i^T \bar{b}_j</script><p>我们计算对某一句中的每一个词，被注意到的另一个句子中词汇的含义。</p>
<script type="math/tex; mode=display">
    \tilde{a}_i = \sum_{j} \frac{\exp(e_{ij})}{\sum_k \exp(e_{ik})} \bar{b}_j</script><script type="math/tex; mode=display">
    \tilde{b}_j = \sum_{i} \frac{\exp(e_{ij})}{\sum_k \exp(e_{kj})} \bar{a}_i</script><p>为了获取更多的信息，ESIM 将结果组合成如下的形式</p>
<script type="math/tex; mode=display">
    m_a = [\bar{a}; \tilde{a}; \bar{a}-\tilde{a}; \bar{a} \odot \tilde{a}]</script><script type="math/tex; mode=display">
    m_b = [\bar{b}; \tilde{b}; \bar{b}-\tilde{b}; \bar{b} \odot \tilde{b}]</script><p>接着，我们再使用 BiLSTM 对 $m_a, m_b$ 进行处理</p>
<script type="math/tex; mode=display">
    \bar{v}_{a, i} = BiLSTM(a, i)</script><script type="math/tex; mode=display">
    \bar{v}_{b, j} = BiLSTM(b, j)</script><p>最后进行池化操作，并将结果再次连接在一起，通过多层感知机得到结果</p>
<script type="math/tex; mode=display">
    \bar{v}_{a, ave} = \sum_i \frac{\bar{v}_{a, i}}{l_a}, \bar{v}_{a, max} = \max_i \bar{v}_{a, i}</script><script type="math/tex; mode=display">
    \bar{v}_{b, ave} = \sum_j \frac{\bar{v}_{b, j}}{l_b}, \bar{v}_{b, max} = \max_j \bar{v}_{b, j}</script><script type="math/tex; mode=display">
    v = [\bar{v}_{a, ave}; \bar{v}_{a, max}; \bar{v}_{b, ave}; \bar{v}_{b, max}]</script><p>我们开始构建模型：<br><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ESIM</span>(nn.Module):</span><br></pre></td></tr></table></figure></p>
<p>首先将单词编码转化为词向量</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, s1, s2</span>):</span><br><span class="line">    a = self.embed(s1)  <span class="comment"># (batch_size,seq_size1,embed_size)</span></span><br><span class="line">    b = self.embed(s2)  <span class="comment"># (batch_size,seq_size2,embed_size)</span></span><br></pre></td></tr></table></figure>
<p>通过 BiLSTM 层计算得出 $\bar{a}, \bar{b}$<br><figure class="highlight py"><table><tr><td class="code"><pre><span class="line">a_, _ = self.lstm1(a)  <span class="comment"># (batch_size,seq_size1,2*hidden_size)</span></span><br><span class="line">b_, _ = self.lstm1(b)  <span class="comment"># (batch_size,seq_size2,2*hidden_size)</span></span><br></pre></td></tr></table></figure></p>
<p>接着计算出 $e$，注意这里直接使用了矩阵乘法。<br><figure class="highlight py"><table><tr><td class="code"><pre><span class="line">e = torch.bmm(a_, b_.permute(<span class="number">0</span>, <span class="number">2</span>, <span class="number">1</span>))  <span class="comment"># (batch_size,seq_size1,seq_size2)</span></span><br></pre></td></tr></table></figure></p>
<p>计算 $\tilde{a}, \tilde{b}$。使用 softmax 时，设置 <code>dim=-1</code> 表示对最高维求 softmax。<br><figure class="highlight py"><table><tr><td class="code"><pre><span class="line">a_sim = torch.bmm(F.softmax(e, dim=-<span class="number">1</span>), b_)</span><br><span class="line"><span class="comment"># (batch_size,seq_size1,2*hidden_size)</span></span><br><span class="line">b_sim = torch.bmm(F.softmax(e.permute(<span class="number">0</span>, <span class="number">2</span>, <span class="number">1</span>), dim=-<span class="number">1</span>), a_)</span><br><span class="line"><span class="comment"># (batch_size,seq_size2,2*hidden_size)</span></span><br></pre></td></tr></table></figure></p>
<p>得到 $m_a, m_b$<br><figure class="highlight py"><table><tr><td class="code"><pre><span class="line">ma = torch.cat([a_, a_sim, a_ - a_sim, a_ * a_sim], dim=<span class="number">2</span>)</span><br><span class="line"><span class="comment"># (batch_size,seq_size1,8*hidden_size)</span></span><br><span class="line">mb = torch.cat([b_, b_sim, b_ - b_sim, b_ * b_sim], dim=<span class="number">2</span>)</span><br><span class="line"><span class="comment"># (batch_size,seq_size2,8*hidden_size)</span></span><br></pre></td></tr></table></figure></p>
<p>通过 BiLSTM 层计算得出 $v_a, v_b$<br><figure class="highlight py"><table><tr><td class="code"><pre><span class="line">va, _ = self.lstm2(ma)  <span class="comment"># (batch_size,seq_size1,2*hidden_size2)</span></span><br><span class="line">vb, _ = self.lstm2(mb)  <span class="comment"># (batch_size,seq_size2,2*hidden_size2)</span></span><br></pre></td></tr></table></figure></p>
<p>池化并连接<br><figure class="highlight py"><table><tr><td class="code"><pre><span class="line">va_ave = torch.mean(va, dim=<span class="number">1</span>)  <span class="comment"># (batch_size,2*hidden_size2)</span></span><br><span class="line">va_max, _ = torch.<span class="built_in">max</span>(va, dim=<span class="number">1</span>)  <span class="comment"># (batch_size,2*hidden_size2)</span></span><br><span class="line"></span><br><span class="line">vb_ave = torch.mean(vb, dim=<span class="number">1</span>)  <span class="comment"># (batch_size,2*hidden_size2)</span></span><br><span class="line">vb_max, _ = torch.<span class="built_in">max</span>(vb, dim=<span class="number">1</span>)  <span class="comment"># (batch_size,2*hidden_size2)</span></span><br><span class="line"></span><br><span class="line">v = torch.cat([va_ave, va_max, vb_ave, vb_max], dim=<span class="number">1</span>)</span><br><span class="line"><span class="comment"># (batch_size,8*hidden_size2)</span></span><br></pre></td></tr></table></figure></p>
<p>经过双层线性感知机得到结果<br><figure class="highlight py"><table><tr><td class="code"><pre><span class="line">predict = self.multi(v)  <span class="comment"># (batch_size,class_num)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> predict</span><br></pre></td></tr></table></figure></p>
<h2 id="五、训练"><a href="#五、训练" class="headerlink" title="五、训练"></a>五、训练</h2><h3 id="部分代码"><a href="#部分代码" class="headerlink" title="部分代码"></a>部分代码</h3><p>定义训练函数，声明全局训练步数和全局轮次<br><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">train</span>(<span class="params">dataloader, net, criterion, optimizer</span>):</span><br><span class="line">    <span class="keyword">global</span> global_train_step</span><br><span class="line">    <span class="keyword">global</span> global_epoch</span><br></pre></td></tr></table></figure></p>
<p>设置进度条<br><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">with</span> tqdm(dataloader) <span class="keyword">as</span> tqdm_loader:</span><br><span class="line">    tqdm_loader.set_description(<span class="string">f&quot;Epoch <span class="subst">&#123;global_epoch&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure></p>
<p>开始训练<br><figure class="highlight py"><table><tr><td class="code"><pre><span class="line">net.train()</span><br><span class="line"><span class="keyword">for</span> s1, s2, target <span class="keyword">in</span> tqdm_loader:</span><br><span class="line">    global_train_step += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    s1 = s1.to(args.device)</span><br><span class="line">    s2 = s2.to(args.device)</span><br><span class="line">    target = target.to(args.device)</span><br><span class="line"></span><br><span class="line">    predict = net(s1, s2)</span><br><span class="line"></span><br><span class="line">    loss = criterion(predict, target)</span><br><span class="line"></span><br><span class="line">    accuracy = get_accuracy(predict, target)</span><br><span class="line"></span><br><span class="line">    optimizer.zero_grad()</span><br><span class="line">    loss.backward()</span><br><span class="line">    optimizer.step()</span><br></pre></td></tr></table></figure></p>
<p>为进度条和 tensorboard 更新信息<br><figure class="highlight py"><table><tr><td class="code"><pre><span class="line">tqdm_loader.set_postfix(loss=loss.item(), accuracy=accuracy)</span><br><span class="line"></span><br><span class="line">writer.add_scalar(<span class="string">&quot;train loss&quot;</span>, loss.item(), global_train_step)</span><br><span class="line">writer.add_scalar(<span class="string">&quot;train accuracy&quot;</span>, accuracy, global_train_step)</span><br></pre></td></tr></table></figure></p>
<p>定义评价函数，参数 tag 表示验证或者测试<br><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">evaluate</span>(<span class="params">tag, dataloader, net, criterion</span>):</span><br><span class="line">    <span class="keyword">global</span> global_epoch</span><br></pre></td></tr></table></figure></p>
<p>开始评价<br><figure class="highlight py"><table><tr><td class="code"><pre><span class="line">total_loss = <span class="number">0</span></span><br><span class="line">accuracy = <span class="number">0</span></span><br><span class="line">total_step = <span class="number">0</span></span><br><span class="line">net.<span class="built_in">eval</span>()</span><br><span class="line"><span class="keyword">with</span> torch.no_grad():</span><br><span class="line">    <span class="keyword">for</span> s1, s2, target <span class="keyword">in</span> dataloader:</span><br><span class="line">        s1 = s1.to(args.device)</span><br><span class="line">        s2 = s2.to(args.device)</span><br><span class="line">        target = target.to(args.device)</span><br><span class="line"></span><br><span class="line">        predict = net(s1, s2)</span><br><span class="line"></span><br><span class="line">        loss = criterion(predict, target)</span><br><span class="line"></span><br><span class="line">        total_loss += loss</span><br><span class="line"></span><br><span class="line">        accuracy += get_accuracy(predict, target)</span><br><span class="line"></span><br><span class="line">        total_step += <span class="number">1</span></span><br></pre></td></tr></table></figure></p>
<p>更新 tensorboard 信息<br><figure class="highlight py"><table><tr><td class="code"><pre><span class="line">accuracy /= total_step</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;tag&#125;</span>: total loss=<span class="subst">&#123;total_loss&#125;</span>, accuracy=<span class="subst">&#123;accuracy&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">writer.add_scalar(tag + <span class="string">&quot; loss&quot;</span>, total_loss, global_epoch)</span><br><span class="line">writer.add_scalar(tag + <span class="string">&quot; accuracy&quot;</span>, accuracy, global_epoch)</span><br></pre></td></tr></table></figure></p>
<p>设定参数<br><figure class="highlight py"><table><tr><td class="code"><pre><span class="line">args = Namespace(</span><br><span class="line">    batch_size=<span class="number">512</span>,</span><br><span class="line">    device=torch.device(<span class="string">&quot;cuda&quot;</span> <span class="keyword">if</span> torch.cuda.is_available() <span class="keyword">else</span> <span class="string">&quot;cpu&quot;</span>),</span><br><span class="line">    embed_size=<span class="number">100</span>,</span><br><span class="line">    hidden_size1=<span class="number">200</span>,</span><br><span class="line">    hidden_size2=<span class="number">200</span>,</span><br><span class="line">    num_layers=<span class="number">2</span>,</span><br><span class="line">    epoch_size=<span class="number">15</span>,</span><br><span class="line">    learning_rate=<span class="number">0.01</span>,</span><br><span class="line"></span><br><span class="line">    train_path=<span class="string">&quot;./data/snli_1.0_train.txt&quot;</span>,</span><br><span class="line">    test_path=<span class="string">&quot;./data/snli_1.0_test.txt&quot;</span>,</span><br><span class="line">    dev_path=<span class="string">&quot;./data/snli_1.0_dev.txt&quot;</span>,</span><br><span class="line">    log_path=<span class="string">&quot;./logs&quot;</span>,</span><br><span class="line">    checkpoint_path=<span class="string">&quot;./checkpoints&quot;</span>,</span><br><span class="line">)</span><br></pre></td></tr></table></figure></p>
<p>设定损失函数和优化器<br><figure class="highlight py"><table><tr><td class="code"><pre><span class="line">loss_fn = nn.CrossEntropyLoss().to(args.device)</span><br><span class="line"></span><br><span class="line">optim = torch.optim.SGD(net.parameters(), lr=args.learning_rate)</span><br></pre></td></tr></table></figure></p>
<p>主循环<br><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(args.epoch_size):</span><br><span class="line">    global_epoch += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    train(train_loader, net, loss_fn, optim)</span><br><span class="line"></span><br><span class="line">    save_checkpoint(net, optim, global_epoch, global_train_step)</span><br><span class="line"></span><br><span class="line">    evaluate(<span class="string">&quot;dev&quot;</span>, dev_loader, net, loss_fn)</span><br><span class="line"></span><br><span class="line">    evaluate(<span class="string">&quot;test&quot;</span>, test_loader, net, loss_fn)</span><br></pre></td></tr></table></figure></p>
<h3 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h3><img src="/posts/3c5d5cf3/train_loss.png" class="" title="train_loss">
<img src="/posts/3c5d5cf3/train_acc.png" class="" title="train_acc">
<img src="/posts/3c5d5cf3/test_loss.png" class="" title="test_loss">
<img src="/posts/3c5d5cf3/test_acc.png" class="" title="test_acc">
<p>模型在训练集和测试集上均取得了 72% 的准确率，和 ESTM 论文中的还有一定差距，可能的原因是</p>
<ul>
<li>词向量使用了随机初始化而非GloVe初始化</li>
<li>优化器使用了 SGD 而非 Adam，导致训练过慢</li>
<li>模型的参数设置不合理</li>
</ul>
<p>另外</p>
<ul>
<li>模型中没有使用 dropout，可能导致过拟合（虽然本模型并没有出现）</li>
</ul>
<h2 id="七、参考资料"><a href="#七、参考资料" class="headerlink" title="七、参考资料"></a>七、参考资料</h2><p><a href="https://blog.csdn.net/qq_42365109/article/details/115704688">NLP-Beginner 任务三：基于注意力机制的文本匹配+pytorch</a></p>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>AI</tag>
        <tag>机器学习</tag>
        <tag>pytorch</tag>
        <tag>Colab</tag>
      </tags>
  </entry>
  <entry>
    <title>BUAA-OS实验笔记之Lab6</title>
    <url>/posts/2e230ee5/</url>
    <content><![CDATA[<h2 id="一、Lab6-前言"><a href="#一、Lab6-前言" class="headerlink" title="一、Lab6 前言"></a>一、Lab6 前言</h2><p>操作系统实验的最后一篇笔记，不说什么了。本文主要讲了 Shell 的实现机制，管道通信略有说明。<br><span id="more"></span></p>
<h2 id="二、Shell-程序的启动"><a href="#二、Shell-程序的启动" class="headerlink" title="二、Shell 程序的启动"></a>二、Shell 程序的启动</h2><p>这次我们还要回到 Init/init.c 文件。我们的 MOS 的所有实验都结束之后，<code>mips_init</code> 函数应该是这样的<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">mips_init</span><span class="params">()</span> &#123;</span><br><span class="line">	printk(<span class="string">&quot;init.c:\tmips_init() is called\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// lab2:</span></span><br><span class="line">	mips_detect_memory();</span><br><span class="line">	mips_vm_init();</span><br><span class="line">	page_init();</span><br><span class="line"></span><br><span class="line">	<span class="comment">// lab3:</span></span><br><span class="line">	env_init();</span><br><span class="line"></span><br><span class="line">	<span class="comment">// lab6:</span></span><br><span class="line">	ENV_CREATE(user_icode);  <span class="comment">// This must be the first env!</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// lab5:</span></span><br><span class="line">	ENV_CREATE(fs_serv);  <span class="comment">// This must be the second env!</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// lab3:</span></span><br><span class="line">	kclock_init();</span><br><span class="line">	enable_irq();</span><br><span class="line">	<span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>其中我们使用 <code>ENV_CREATE</code> 创建了两个用户进程。这两个进程的代码在编译时便写入了内核 ELF 文件中。其中第二个进程 <code>fs_serv</code> 就是 Lab5 中用到的文件系统服务进程；而第一个进程 <code>user_icode</code> 则是整个操作系统中除文件系统服务进程外所有进程的共同祖先进程，该进程便用于启动 Shell 进程。<code>user_icode</code> 或为 “user init code” 之意。</p>
<p>对应的文件位于 user/icode.c 中。首先读取 motd 文件并输出其内容。motd 即 “message of today” 的缩写。其实这一步只是为了打印欢迎信息罢了。<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="type">int</span> fd, n, r;</span><br><span class="line">	<span class="type">char</span> buf[<span class="number">512</span> + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">	debugf(<span class="string">&quot;icode: open /motd\n&quot;</span>);</span><br><span class="line">	<span class="keyword">if</span> ((fd = open(<span class="string">&quot;/motd&quot;</span>, O_RDONLY)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		user_panic(<span class="string">&quot;icode: open /motd: %d&quot;</span>, fd);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	debugf(<span class="string">&quot;icode: read /motd\n&quot;</span>);</span><br><span class="line">	<span class="keyword">while</span> ((n = read(fd, buf, <span class="keyword">sizeof</span> buf - <span class="number">1</span>)) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">		buf[n] = <span class="number">0</span>;</span><br><span class="line">		debugf(<span class="string">&quot;%s\n&quot;</span>, buf);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	debugf(<span class="string">&quot;icode: close /motd\n&quot;</span>);</span><br><span class="line">	close(fd);</span><br></pre></td></tr></table></figure></p>
<p>之后调用 <code>spawnl</code> 函数执行文件 <code>init.b</code>。<code>spawnl</code> 实际调用了 <code>spawn</code> 函数，该函数用于将磁盘中的文件加载到内存，并以此创建一个新进程。<code>spawn</code> 函数的内容让我们搁到后面，现在先来继续看 Shell 启动的过程。</p>
<p>执行的 <code>init.b</code> 文件的源代码在 user/init.c 中。其中前面一大部分都是测试 ELF 文件加载正确性的代码，就略过不讲了。重要的部分从这里开始。<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span> &#123;</span><br><span class="line">	<span class="type">int</span> i, r, x, want;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// omit...</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// stdin should be 0, because no file descriptors are open yet</span></span><br><span class="line">	<span class="keyword">if</span> ((r = opencons()) != <span class="number">0</span>) &#123;</span><br><span class="line">		user_panic(<span class="string">&quot;opencons: %d&quot;</span>, r);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure></p>
<p>首先调用了 <code>opencons</code> 打开一个终端文件。该函数位于 user/lib/console.c 中。内容很简单，只是申请了一个文件描述符，并设置 <code>fd-&gt;fd_dev_id = devcons.dev_id</code> 表示该文件属于终端文件，执行读写等等操作时使用终端提供的函数。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">opencons</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">	<span class="type">int</span> r;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Fd</span> *<span class="title">fd</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> ((r = fd_alloc(&amp;fd)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> r;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> ((r = syscall_mem_alloc(<span class="number">0</span>, fd, PTE_D | PTE_LIBRARY)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> r;</span><br><span class="line">	&#125;</span><br><span class="line">	fd-&gt;fd_dev_id = devcons.dev_id;</span><br><span class="line">	fd-&gt;fd_omode = O_RDWR;</span><br><span class="line">	<span class="keyword">return</span> fd2num(fd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于终端的读写操作，我们也可以看一下。以写为例，对应的函数为 <code>cons_write</code>，实际可以看出只是通过系统调用实现读写而已。<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Dev</span> <span class="title">devcons</span> =</span> &#123;</span><br><span class="line">    .dev_id = <span class="string">&#x27;c&#x27;</span>,</span><br><span class="line">    .dev_name = <span class="string">&quot;cons&quot;</span>,</span><br><span class="line">    .dev_read = cons_read,</span><br><span class="line">    .dev_write = cons_write,</span><br><span class="line">    .dev_close = cons_close,</span><br><span class="line">    .dev_stat = cons_stat,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">cons_write</span><span class="params">(<span class="keyword">struct</span> Fd *fd, <span class="type">const</span> <span class="type">void</span> *buf, u_int n, u_int offset)</span> &#123;</span><br><span class="line">	<span class="type">int</span> r = syscall_print_cons(buf, n);</span><br><span class="line">	<span class="keyword">if</span> (r &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> r;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>让我们回到 user/init.c。因为调用 <code>opencons</code> 时系统内必定没有其他文件被打卡，所以该函数申请得到的文件描述符必定为 0。之后代码中又调用 <code>dup</code> 函数申请了一个新的文件描述符 1。该文件描述符是 0 的复制。也就是说，对这两个文件描述符进行读写等文件操作，都是对同一个文件（这里是终端文件）的操作。<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// stdout</span></span><br><span class="line"><span class="keyword">if</span> ((r = dup(<span class="number">0</span>, <span class="number">1</span>)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">	user_panic(<span class="string">&quot;dup: %d&quot;</span>, r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>dup</code> 函数位于 user/lib/fd.c 中，本属于文件系统的内容，但 Lab5 中碍于篇幅没有讲解，这里我们讲解一下。<code>dup</code> 函数在最开始做了一系列准备工作，首先是根据已有的文件描述符 <code>oldfdnum</code> 找到对应的文件描述结构体。<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">dup</span><span class="params">(<span class="type">int</span> oldfdnum, <span class="type">int</span> newfdnum)</span> &#123;</span><br><span class="line">	<span class="type">int</span> i, r;</span><br><span class="line">	<span class="type">void</span> *ova, *nva;</span><br><span class="line">	u_int pte;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Fd</span> *<span class="title">oldfd</span>, *<span class="title">newfd</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> ((r = fd_lookup(oldfdnum, &amp;oldfd)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> r;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure></p>
<p>之后需要注意我们调用了 <code>close</code> 函数关闭了要复制的文件描述符 <code>newfdnum</code> 原本对应的文件（如果有的话）。只有这样我们才能将 <code>oldfdnum</code> 对应的文件复制给 <code>newfdnum</code>。最后我们通过 <code>fd2data</code> 函数根据描述符得到文件内容所在的地址位置。<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">close(newfdnum);</span><br><span class="line">newfd = (<span class="keyword">struct</span> Fd *)INDEX2FD(newfdnum);</span><br><span class="line">ova = fd2data(oldfd);</span><br><span class="line">nva = fd2data(newfd);</span><br></pre></td></tr></table></figure></p>
<p>之后我们要做的就是共享文件描述符和文件内容，这通过系统调用 <code>syscall_mem_map</code> 实现。</p>
<p>这一部分将 <code>oldfd</code> 所在的页映射到 <code>newfd</code> 所在的地址。需要注意这里的 <code>vpt[VPN(oldfd)] &amp; (PTE_D | PTE_LIBRARY)</code> 表示为 <code>newfd</code> 设置与 <code>oldfd</code> 相同的可写可共享权限。<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> ((r = syscall_mem_map(<span class="number">0</span>, oldfd, <span class="number">0</span>, newfd, vpt[VPN(oldfd)] &amp; (PTE_D | PTE_LIBRARY))) &lt;</span><br><span class="line">    <span class="number">1</span>) &#123;</span><br><span class="line">	<span class="keyword">goto</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>对于文件内容也一样，对于有效的页（<code>pte &amp; PTE_V</code>），我们同样需要进行映射。全部都映射完成后，返回新的文件描述符。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (vpd[PDX(ova)]) &#123;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; PDMAP; i += BY2PG) &#123;</span><br><span class="line">		pte = vpt[VPN(ova + i)];</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (pte &amp; PTE_V) &#123;</span><br><span class="line">			<span class="comment">// should be no error here -- pd is already allocated</span></span><br><span class="line">			<span class="keyword">if</span> ((r = syscall_mem_map(<span class="number">0</span>, (<span class="type">void</span> *)(ova + i), <span class="number">0</span>, (<span class="type">void</span> *)(nva + i),</span><br><span class="line">						 pte &amp; (PTE_D | PTE_LIBRARY))) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">				<span class="keyword">goto</span> err;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> newfdnum;</span><br></pre></td></tr></table></figure>
<p>很有趣的一点是这里 <code>dup</code> 函数中使用到了 <code>goto</code> 进行异常处理。当出错后，会跳转到 <code>err</code> 标签的位置，解除已经建立的映射关系。在之后我们还会多次遇到这种处理方法。这种方法的主要目的是在出错时释放已经分配的资源，优点是对多次申请不同资源的情况，可以很简洁地进行处理。这一点在 <code>dup</code> 函数中似乎不太明显，但等到了 <code>spawn</code> 函数中就可以看出来了。<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">err:</span><br><span class="line">	syscall_mem_unmap(<span class="number">0</span>, newfd);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; PDMAP; i += BY2PG) &#123;</span><br><span class="line">		syscall_mem_unmap(<span class="number">0</span>, (<span class="type">void</span> *)(nva + i));</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>让我们再回到 user/init.c。现在我们有了 0、1 两个文件描述符，分别表示了标准输入和标准输出。此后进程都会通过 <code>spawn</code> 或 <code>fork</code> 创建进程，这些新创建的进程也会继承两个标准输入输出，除非进程自己关闭。</p>
<p>最后是一个死循环，这个循环用于创建 Shell 进程。在调用 <code>spawnl</code> 创建 Shell 进程成功后，会调用 <code>wait</code> 等待 Shell 进程退出。因为处于循环中，所以当 Shell 进程退出后，又会创建一个新的 Shell 进程。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">	<span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">		debugf(<span class="string">&quot;init: starting sh\n&quot;</span>);</span><br><span class="line">		r = spawnl(<span class="string">&quot;sh.b&quot;</span>, <span class="string">&quot;sh&quot;</span>, <span class="literal">NULL</span>);</span><br><span class="line">		<span class="keyword">if</span> (r &lt; <span class="number">0</span>) &#123;</span><br><span class="line">			debugf(<span class="string">&quot;init: spawn sh: %d\n&quot;</span>, r);</span><br><span class="line">			<span class="keyword">return</span> r;</span><br><span class="line">		&#125;</span><br><span class="line">		wait(r);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中 <code>wait</code> 定义在 user/lib/wait.c 中。只是实现了一个简单的忙等，使得调用 <code>wait</code> 的函数被阻塞，直到 <code>envid</code> 对应的进程退出才继续执行。<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">wait</span><span class="params">(u_int envid)</span> &#123;</span><br><span class="line">	<span class="keyword">volatile</span> <span class="class"><span class="keyword">struct</span> <span class="title">Env</span> *<span class="title">e</span>;</span></span><br><span class="line"></span><br><span class="line">	e = &amp;envs[ENVX(envid)];</span><br><span class="line">	<span class="keyword">while</span> (e-&gt;env_id == envid &amp;&amp; e-&gt;env_status != ENV_FREE) &#123;</span><br><span class="line">		syscall_yield();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这样 Shell 进程就启动了</p>
<h2 id="三、Shell-原理"><a href="#三、Shell-原理" class="headerlink" title="三、Shell 原理"></a>三、Shell 原理</h2><p>Shell 程序需要做的事就是这样：不断读取用户的命令输入，根据命令创建对应的进程，并实现进程间的通信。我们的 Shell 进程位于 user/sh.c。</p>
<p>首先打印了欢迎信息，这点就略过了。紧随其后是两个比较复杂的宏 <code>ARGBEGIN</code> 和 <code>ARGEND</code>。这两个宏和其中间的部分解析了命令中的选项。对于本函数来说，就是 <code>-i</code> 和 <code>-x</code>。<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span> &#123;</span><br><span class="line">	<span class="type">int</span> r;</span><br><span class="line">	<span class="type">int</span> interactive = iscons(<span class="number">0</span>);</span><br><span class="line">	<span class="type">int</span> echocmds = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// omit...</span></span><br><span class="line"></span><br><span class="line">	ARGBEGIN &#123;</span><br><span class="line">	<span class="keyword">case</span> <span class="string">&#x27;i&#x27;</span>:</span><br><span class="line">		interactive = <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> <span class="string">&#x27;x&#x27;</span>:</span><br><span class="line">		echocmds = <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		usage();</span><br><span class="line">	&#125;</span><br><span class="line">	ARGEND</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p><code>ARGBEGIN</code> 和 <code>ARGEND</code> 的具体内容在 include/args.h 中，但是既然注释里已经说了 <code>you are not expected to understand this</code>，那我们还是跳过吧。但是我还想插一句嘴，注释里说道，这个参数解析宏是 <code>simple command line parser from Plan 9</code>。plan 9 是贝尔实验室 40 多年前开发的超前的实验性操作系统，没想到能看到这么老的代码……这可比 Lab2 中 30 年前的 <a href="https://github.com/torvalds/linux/blob/master/drivers/scsi/aic7xxx/queue.h">queue.h</a> 还要离谱。</p>
</blockquote>
<p>接下来的这一部分考虑了执行 Shell 脚本的情况。如果需要执行脚本，则关闭标准输入，改为文件作为输入。<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (argc &gt; <span class="number">1</span>) &#123;</span><br><span class="line">	usage();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (argc == <span class="number">1</span>) &#123;</span><br><span class="line">	close(<span class="number">0</span>);</span><br><span class="line">	<span class="keyword">if</span> ((r = open(argv[<span class="number">1</span>], O_RDONLY)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		user_panic(<span class="string">&quot;open %s: %d&quot;</span>, argv[<span class="number">1</span>], r);</span><br><span class="line">	&#125;</span><br><span class="line">	user_assert(r == <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>最后在循环中不断读入命令行并进行处理。对于交互界面，会首先输出提示符 <code>$</code>。随后读入一行命令。<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (;;) &#123;</span><br><span class="line">	<span class="keyword">if</span> (interactive) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;\n$ &quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	readline(buf, <span class="keyword">sizeof</span> buf);</span><br></pre></td></tr></table></figure></p>
<p>其中 <code>readline</code> 函数会逐字符读取。需要注意当标准输入未被重定向时（即从终端进行读取时），这一过程是和用户的输入同步的。当用户输入一个字符，<code>read</code> 才会读取一个字符，否则会被阻塞。<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">readline</span><span class="params">(<span class="type">char</span> *buf, u_int n)</span> &#123;</span><br><span class="line">	<span class="type">int</span> r;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">		<span class="keyword">if</span> ((r = read(<span class="number">0</span>, buf + i, <span class="number">1</span>)) != <span class="number">1</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span> (r &lt; <span class="number">0</span>) &#123;</span><br><span class="line">				debugf(<span class="string">&quot;read error: %d\n&quot;</span>, r);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="built_in">exit</span>();</span><br><span class="line">		&#125;</span><br></pre></td></tr></table></figure></p>
<p>阻塞的实现也不过是一个忙等而已<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">cons_read</span><span class="params">(<span class="keyword">struct</span> Fd *fd, <span class="type">void</span> *vbuf, u_int n, u_int offset)</span> &#123;</span><br><span class="line">	<span class="type">int</span> c;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> ((c = syscall_cgetc()) == <span class="number">0</span>) &#123;</span><br><span class="line">		syscall_yield();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// omit...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>之后，<code>readline</code> 中值得注意的是这里进行了退格的处理。所谓退格键就是 backspace 键，当按下该键后，就会在串口中产生一个退格符 <code>\b</code>。接下来我们的操作就很清楚了，只需要将之前读入的一个字符清除即可。另外对于终端显示，我们也要产生删除上一个字符的效果，这一效果可以通过向串口输出一个退格符实现 <code>printf(&quot;\b&quot;)</code>。<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (buf[i] == <span class="string">&#x27;\b&#x27;</span> || buf[i] == <span class="number">0x7f</span>) &#123;</span><br><span class="line">	<span class="keyword">if</span> (i &gt; <span class="number">0</span>) &#123;</span><br><span class="line">		i -= <span class="number">2</span>;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		i = <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (buf[i] != <span class="string">&#x27;\b&#x27;</span>) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;\b&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>哪里来的 <code>printf</code>？我们都知道之前用户进程只使用 <code>debugf</code> 进行输出，其实 <code>printf</code> 的实现也一样，该函数位于 user/lib/fprintf.c 中，是在 Lab5 时添加的，当时我怎么没注意到。</p>
</blockquote>
<p>再之后，<code>readline</code> 判断是否读到换行符，是的话则退出，完成一行命令的读入。<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">	<span class="keyword">if</span> (buf[i] == <span class="string">&#x27;\r&#x27;</span> || buf[i] == <span class="string">&#x27;\n&#x27;</span>) &#123;</span><br><span class="line">		buf[i] = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在循环之外还对过长的命令进行了处理。在这一部分会不断读入剩下的命令，并返回空字符串。<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">	debugf(<span class="string">&quot;line too long\n&quot;</span>);</span><br><span class="line">	<span class="keyword">while</span> ((r = read(<span class="number">0</span>, buf, <span class="number">1</span>)) == <span class="number">1</span> &amp;&amp; buf[<span class="number">0</span>] != <span class="string">&#x27;\r&#x27;</span> &amp;&amp; buf[<span class="number">0</span>] != <span class="string">&#x27;\n&#x27;</span>) &#123;</span><br><span class="line">		;</span><br><span class="line">	&#125;</span><br><span class="line">	buf[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>回到 Shell 进程的 <code>main</code> 函数。接着我们会对读入的命令进行处理，首先忽略以 <code>#</code> 开头的注释，接着在 <code>echocmds</code> 模式下输出读入的命令。这些没有什么好说的，再之后的部分才是 Shell 的重点。<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (buf[<span class="number">0</span>] == <span class="string">&#x27;#&#x27;</span>) &#123;</span><br><span class="line">	<span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (echocmds) &#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;# %s\n&quot;</span>, buf);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> ((r = fork()) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">	user_panic(<span class="string">&quot;fork: %d&quot;</span>, r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里我们调用 <code>fork</code> 复制了一个 Shell 进程，执行 <code>runcmd</code> 函数来运行命令，而原本的 Shell 进程则等待该新复制的进程结束。<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">		<span class="keyword">if</span> ((r = fork()) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">			user_panic(<span class="string">&quot;fork: %d&quot;</span>, r);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (r == <span class="number">0</span>) &#123;</span><br><span class="line">			runcmd(buf);</span><br><span class="line">			<span class="built_in">exit</span>();</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			wait(r);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>对于新复制的 Shell 进程，我们查看一下 <code>runcmd</code> 函数，这个函数以及 <code>parsecmd</code> 函数是 Shell 的核心。首先调用一次 <code>gettoken</code>，这将把 <code>s</code> 设定为要解析的字符串。<code>gettoken</code> 函数似乎较为复杂，涉及到字符串的解析，就不深入了。<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">runcmd</span><span class="params">(<span class="type">char</span> *s)</span> &#123;</span><br><span class="line">	gettoken(s, <span class="number">0</span>);</span><br></pre></td></tr></table></figure></p>
<p>接着我们需要调用 <code>parsecmd</code> 将完整的字符串解析。解析的参数返回到 <code>argv</code>，参数的数量返回为 <code>argc</code>。<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> *argv[MAXARGS];</span><br><span class="line"><span class="type">int</span> rightpipe = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> argc = parsecmd(argv, &amp;rightpipe);</span><br></pre></td></tr></table></figure></p>
<p>另外 <code>parsecmd</code> 还会返回 <code>rightpipe</code>。对于该值的理解需要从头到尾梳理一下 Shell 解析并执行命令的流程。首先为了方便讲述，我要定义三个名词。第一个是<strong>主 Shell 进程</strong>，即执行了 <code>main</code> 部分代码的 Shell 进程；第二个是<strong>执行命令的 Shell 进程</strong>，即调用 <code>spawn</code> 创建执行命令的进程；第三个是<strong>命令进程</strong>，即被 <code>spawn</code> 创建的进程。</p>
<p>那么我们就来分析一下解析和执行命令的过程。首先读到命令后，主 Shell 进程会调用 <code>fork</code> 创建一个执行命令的 Shell 进程。该进程会执行命令，创建命令进程。但问题是命令中可能出现管道 <code>|</code>，这就需要创建两个或多个命令进程。这时我们并不通过循环之类的方法多次调用 <code>spawn</code>，而是 <code>fork</code> 出一个新的执行命令的进程，由这个新的进程调用 <code>spawn</code> 根据管道右侧的命令创建命令进程；而原来的进程则根据管道左侧的命令创建。</p>
<p><code>parsecmd</code> 函数完成了上述流程中 “<code>fork</code> 出新的执行命令的进程” 的任务。<code>rightpipe</code> 表示的就是 <code>fork</code> 创建的执行命令的 Shell 进程的进程 id。</p>
<p>当然除此之外该函数还完成了其他一些工作。比如将完整的命令字符串解析为参数数组；完成标准输入输出重定向到文件；为命令中管道符号 <code>|</code> 两侧的命令创建管道并将管道重定向到标准输入输出。</p>
<p>根据上面的内容，我们查看一下 <code>parsecmd</code> 函数的内容。该函数会不断解析命令，直到解析到命令字符串的末尾（<code>gettoken</code> 返回值为 0）则退出。<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">parsecmd</span><span class="params">(<span class="type">char</span> **argv, <span class="type">int</span> *rightpipe)</span> &#123;</span><br><span class="line">	<span class="type">int</span> argc = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">		<span class="type">char</span> *t;</span><br><span class="line">		<span class="type">int</span> fd, r;</span><br><span class="line">		<span class="type">int</span> c = gettoken(<span class="number">0</span>, &amp;t);</span><br><span class="line">		<span class="keyword">switch</span> (c) &#123;</span><br><span class="line">		<span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">			<span class="keyword">return</span> argc;</span><br></pre></td></tr></table></figure></p>
<p>对于解析得到的是一般单词的情况，我们为参数数组 <code>argv</code> 添加一个参数。<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="string">&#x27;w&#x27;</span>:</span><br><span class="line">	<span class="keyword">if</span> (argc &gt;= MAXARGS) &#123;</span><br><span class="line">		debugf(<span class="string">&quot;too many arguments\n&quot;</span>);</span><br><span class="line">		<span class="built_in">exit</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	argv[argc++] = t;</span><br><span class="line">	<span class="keyword">break</span>;</span><br></pre></td></tr></table></figure></p>
<p>对于输入或输出重定向的情况，我们获取下一个 token，打开对应的文件，调用 <code>dup</code> 设定 0 或 1 为该文件的文件描述符（原本的标准输入输出被 “挤掉”），并关闭原来打开的文件描述符。<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="string">&#x27;&lt;&#x27;</span>:</span><br><span class="line">	<span class="keyword">if</span> (gettoken(<span class="number">0</span>, &amp;t) != <span class="string">&#x27;w&#x27;</span>) &#123;</span><br><span class="line">		debugf(<span class="string">&quot;syntax error: &lt; not followed by word\n&quot;</span>);</span><br><span class="line">		<span class="built_in">exit</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// Open &#x27;t&#x27; for reading, dup it onto fd 0, and then close the original fd.</span></span><br><span class="line">	<span class="comment">/* Exercise 6.5: Your code here. (1/3) */</span></span><br><span class="line">	fd = open(t, O_RDONLY);</span><br><span class="line">	dup(fd, <span class="number">0</span>);</span><br><span class="line">	close(fd);</span><br><span class="line">	<span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="string">&#x27;&gt;&#x27;</span>:</span><br><span class="line">	<span class="keyword">if</span> (gettoken(<span class="number">0</span>, &amp;t) != <span class="string">&#x27;w&#x27;</span>) &#123;</span><br><span class="line">		debugf(<span class="string">&quot;syntax error: &gt; not followed by word\n&quot;</span>);</span><br><span class="line">		<span class="built_in">exit</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// Open &#x27;t&#x27; for writing, dup it onto fd 1, and then close the original fd.</span></span><br><span class="line">	<span class="comment">/* Exercise 6.5: Your code here. (2/3) */</span></span><br><span class="line">	fd = open(t, O_WRONLY);</span><br><span class="line">	dup(fd, <span class="number">1</span>);</span><br><span class="line">	close(fd);</span><br><span class="line">	<span class="keyword">break</span>;</span><br></pre></td></tr></table></figure></p>
<p>最后是重点部分，当读到的 token 为 <code>|</code> 时，我们就需要创建一个管道，并调用 <code>fork</code> 分出一个执行命令的 Shell 进程。并将 <code>fork</code> 的返回值传给 <code>*rightpipe</code>。此后位于管道左侧的进程完成命令的解析直接返回，这样位于管道左侧的进程获得的就一定是位于管道右侧的进程的进程 id。而位于管道右侧的进程则从继续解析剩下的命令，这里通过递归调用 <code>parsecmd</code> 实现。</p>
<p>对于创建的管道文件，我们同样要将其重定向到标准输入输出。对于管道左侧的进程，需要重定向其标准输出；而对于管道右侧的进程，则需要重定向其标准输入。<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">		<span class="keyword">case</span> <span class="string">&#x27;|&#x27;</span>:;</span><br><span class="line">			<span class="type">int</span> p[<span class="number">2</span>];</span><br><span class="line">			<span class="comment">/* Exercise 6.5: Your code here. (3/3) */</span></span><br><span class="line">			pipe(p);</span><br><span class="line">			*rightpipe = fork();</span><br><span class="line">			<span class="keyword">if</span> (*rightpipe == <span class="number">0</span>) &#123;</span><br><span class="line">				dup(p[<span class="number">0</span>], <span class="number">0</span>);</span><br><span class="line">				close(p[<span class="number">0</span>]);</span><br><span class="line">				close(p[<span class="number">1</span>]);</span><br><span class="line">				<span class="keyword">return</span> parsecmd(argv, rightpipe);</span><br><span class="line">			&#125;  <span class="keyword">else</span> <span class="keyword">if</span> (*rightpipe &gt; <span class="number">0</span>) &#123;</span><br><span class="line">				dup(p[<span class="number">1</span>], <span class="number">1</span>);</span><br><span class="line">				close(p[<span class="number">1</span>]);</span><br><span class="line">				close(p[<span class="number">0</span>]);</span><br><span class="line">				<span class="keyword">return</span> argc;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> argc;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>现在回到 <code>runcmd</code> 函数。首先注意此时 <code>runcmd</code> 中可能会有多个 Shell 进程并发地执行，他们都具有不同的参数数组，同时各自的 <code>rightpipe</code> 变量中都保存了位于其右侧的进程的进程 id。</p>
<p>首先当参数数量为 0 时，说明根本没有命令，直接返回即可。否则需要调用 spawn 函数创建对应进程，并为其传入参数。注意这里我们没有向 <code>spawn</code> 中传入 <code>argc</code> 参数，而是通过设置 <code>argv[argc] = 0</code> 来简介表示 <code>argv</code> 的大小。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (argc == <span class="number">0</span>) &#123;</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">argv[argc] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> child = spawn(argv[<span class="number">0</span>], argv);</span><br></pre></td></tr></table></figure>
<p>之后，因为我们在执行命令的 Shell 进程中打开的文件都只是为了继承给 <code>spawn</code> 创建的进程，所以此时就要关闭当前进程的所有文件<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">close_all();</span><br></pre></td></tr></table></figure></p>
<p>调用 <code>spawn</code> 后我们处理其返回值 <code>child</code>，对于父进程，需要等待子进程，即命令进程结束后继续执行<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (child &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">	wait(child);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	debugf(<span class="string">&quot;spawn %s: %d\n&quot;</span>, argv[<span class="number">0</span>], child);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>最后对于存在管道通信的情况，还需要等待管道右侧的进程先结束。因为假设不等待，则在管道左侧的进程退出之后，管道右侧的进程就不能再通过管道读取信息了。<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">	<span class="keyword">if</span> (rightpipe) &#123;</span><br><span class="line">		wait(rightpipe);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">exit</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这样 Shell 的机制就讲完了。关于进程运行的部分我们还需要考察一下 <code>spawn</code> 函数的实现。</p>
<h2 id="四、spawn-函数的实现"><a href="#四、spawn-函数的实现" class="headerlink" title="四、spawn 函数的实现"></a>四、spawn 函数的实现</h2><p><code>spawn</code> 函数位于 user/lib/spawn.c 中。还有一个可变参数的版本 <code>spawnl</code>，只是简单地调用了 <code>spawn</code> 函数。<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">spawnl</span><span class="params">(<span class="type">char</span> *prog, <span class="type">char</span> *args, ...)</span> &#123;</span><br><span class="line">	<span class="comment">// Thanks to MIPS calling convention, the layout of arguments on the stack</span></span><br><span class="line">	<span class="comment">// are straightforward.</span></span><br><span class="line">	<span class="keyword">return</span> spawn(prog, &amp;args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>接下来我们考察一下 <code>spawn</code> 函数。首先要明确 <code>spawn</code> 函数的功能是根据磁盘文件创建一个进程。那么首先要做的就是将文件内容加载到内存中。</p>
<p>于是我们根据传入的文件路径参数 <code>prog</code> 打开文件，并首先通过 <code>readn</code> 函数读取其文件头的信息。<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">spawn</span><span class="params">(<span class="type">char</span> *prog, <span class="type">char</span> **argv)</span> &#123;</span><br><span class="line">	<span class="comment">// Step 1: Open the file &#x27;prog&#x27; (the path of the program).</span></span><br><span class="line">	<span class="comment">// Return the error if &#x27;open&#x27; fails.</span></span><br><span class="line">	<span class="type">int</span> fd;</span><br><span class="line">	<span class="keyword">if</span> ((fd = open(prog, O_RDONLY)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> fd;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Step 2: Read the ELF header (of type &#x27;Elf32_Ehdr&#x27;) from the file into &#x27;elfbuf&#x27; using</span></span><br><span class="line">	<span class="comment">// &#x27;readn()&#x27;.</span></span><br><span class="line">	<span class="comment">// If that fails (where &#x27;readn&#x27; returns a different size than expected),</span></span><br><span class="line">	<span class="comment">// set &#x27;r&#x27; and &#x27;goto err&#x27; to close the file and return the error.</span></span><br><span class="line">	<span class="type">int</span> r;</span><br><span class="line">	u_char elfbuf[<span class="number">512</span>];</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/* Exercise 6.4: Your code here. (1/6) */</span></span><br><span class="line">	<span class="keyword">if</span> ((r = readn(fd, elfbuf, <span class="keyword">sizeof</span>(Elf32_Ehdr))) &lt; <span class="number">0</span> || r != <span class="keyword">sizeof</span>(Elf32_Ehdr)) &#123;</span><br><span class="line">		<span class="keyword">goto</span> err;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure></p>
<p>接着我们要将文件头转换为 <code>Elf32_Ehdr</code> 结构体的格式。我们通过 <code>elf_from</code> 完成这一步骤，该函数也在 Lab3 中使用过，在转换之前检查了文件头格式的有效性。（实际上 <code>spawn</code> 函数的实现也与 Lab3 中的 <code>load_icode</code> 类似，后者各位如果还记得的话，应该知道是用于加载编译器写进操作系统的程序的。）<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> Elf32_Ehdr *ehdr = elf_from(elfbuf, <span class="keyword">sizeof</span>(Elf32_Ehdr));</span><br><span class="line"><span class="keyword">if</span> (!ehdr) &#123;</span><br><span class="line">	r = -E_NOT_EXEC;</span><br><span class="line">	<span class="keyword">goto</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>我们从 ELF 文件头中读取了程序入口信息。（虽然不知道有什么意义，似乎又是遗留没有修改的代码。）<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">u_long entrypoint = ehdr-&gt;e_entry;</span><br></pre></td></tr></table></figure></p>
<p>接着使用系统调用 <code>syscall_exofork</code> 创建一个新的进程。注意这里不需要像 <code>fork</code> 一样创建后判断 <code>child</code> 的值来区分父子进程。因为在 <code>spawn</code> 之后的内容中我们会替换子进程的代码和数据，不会再从此处继续执行。<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Step 3: Create a child using &#x27;syscall_exofork()&#x27; and store its envid in &#x27;child&#x27;.</span></span><br><span class="line"><span class="comment">// If the syscall fails, set &#x27;r&#x27; and &#x27;goto err&#x27;.</span></span><br><span class="line">u_int child;</span><br><span class="line"><span class="comment">/* Exercise 6.4: Your code here. (2/6) */</span></span><br><span class="line">child = syscall_exofork();</span><br><span class="line"><span class="keyword">if</span> (child &lt; <span class="number">0</span>) &#123;</span><br><span class="line">	r = child;</span><br><span class="line">	<span class="keyword">goto</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>随后在父进程中，调用 <code>init_stack</code> 完成子进程栈的初始化。<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Step 4: Use &#x27;init_stack(child, argv, &amp;sp)&#x27; to initialize the stack of the child.</span></span><br><span class="line"><span class="comment">// &#x27;goto err1&#x27; if that fails.</span></span><br><span class="line">u_int sp;</span><br><span class="line"><span class="comment">/* Exercise 6.4: Your code here. (3/6) */</span></span><br><span class="line"><span class="keyword">if</span> ((r = init_stack(child, argv, &amp;sp)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">	<span class="keyword">goto</span> err1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在 <code>init_stack</code> 函数中，我们要将 <code>argc</code>、<code>argv</code> 的数据写入要初始化的进程的栈中，完成进程栈的初始化。具体来说，我们首先要按一定格式将 <code>argc</code>、<code>argv</code> 写入 <code>UTEMP</code> 页（这个地址就在 <code>UCOW</code> 的下面，用途也和 <code>UCOW</code> 那一页类似，详见 Lab4）中，再将 <code>UTEMP</code> 映射到的物理页转而映射到要初始化进程的栈的位置。</p>
<p>首先统计一下所有参数字符串的长度。<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">init_stack</span><span class="params">(u_int child, <span class="type">char</span> **argv, u_int *init_sp)</span> &#123;</span><br><span class="line">	<span class="type">int</span> argc, i, r, tot;</span><br><span class="line">	<span class="type">char</span> *strings;</span><br><span class="line">	u_int *args;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Count the number of arguments (argc)</span></span><br><span class="line">	<span class="comment">// and the total amount of space needed for strings (tot)</span></span><br><span class="line">	tot = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (argc = <span class="number">0</span>; argv[argc]; argc++) &#123;</span><br><span class="line">		tot += <span class="built_in">strlen</span>(argv[argc]) + <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure></p>
<p>计算参数所需内存是否超过了一页的大小，如果超过直接返回异常。由这部分也可以大致看出栈的结构（<code>argc(4)+**argv(4)+*argv[i](4*(argc+1))+sum(len(argv[i])+1)</code>，其中argc+1 中的 1 为表示最后一个参数的 <code>argv[argc] = 0</code>，详见 <code>runcmd</code> 函数。）<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Make sure everything will fit in the initial stack page</span></span><br><span class="line"><span class="keyword">if</span> (ROUND(tot, <span class="number">4</span>) + <span class="number">4</span> * (argc + <span class="number">3</span>) &gt; BY2PG) &#123;</span><br><span class="line">	<span class="keyword">return</span> -E_NO_MEM;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这一部分确定了字符串和指针数组的地址，并使用系统调用申请了 UTEMP 所在的页。<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Determine where to place the strings and the args array</span></span><br><span class="line">strings = (<span class="type">char</span> *)(UTEMP + BY2PG) - tot;</span><br><span class="line">args = (u_int *)(UTEMP + BY2PG - ROUND(tot, <span class="number">4</span>) - <span class="number">4</span> * (argc + <span class="number">1</span>));</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ((r = syscall_mem_alloc(<span class="number">0</span>, (<span class="type">void</span> *)UTEMP, PTE_D)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">	<span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这一部分复制了所有参数字符串<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Copy the argument strings into the stack page at &#x27;strings&#x27;</span></span><br><span class="line"><span class="type">char</span> *ctemp, *argv_temp;</span><br><span class="line">u_int j;</span><br><span class="line">ctemp = strings;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; argc; i++) &#123;</span><br><span class="line">	argv_temp = argv[i];</span><br><span class="line">	<span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; <span class="built_in">strlen</span>(argv[i]); j++) &#123;</span><br><span class="line">		*ctemp = *argv_temp;</span><br><span class="line">		ctemp++;</span><br><span class="line">		argv_temp++;</span><br><span class="line">	&#125;</span><br><span class="line">	*ctemp = <span class="number">0</span>;</span><br><span class="line">	ctemp++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这一部分设置了指针数组的内容<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Initialize args[0..argc-1] to be pointers to these strings</span></span><br><span class="line"><span class="comment">// that will be valid addresses for the child environment</span></span><br><span class="line"><span class="comment">// (for whom this page will be at USTACKTOP-BY2PG!).</span></span><br><span class="line">ctemp = (<span class="type">char</span> *)(USTACKTOP - UTEMP - BY2PG + (u_int)strings);</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; argc; i++) &#123;</span><br><span class="line">	args[i] = (u_int)ctemp;</span><br><span class="line">	ctemp += <span class="built_in">strlen</span>(argv[i]) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里代码和注释的内容似乎不符，不知为何。<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Set args[argc] to 0 to null-terminate the args array.</span></span><br><span class="line">ctemp--;</span><br><span class="line">args[argc] = (u_int)ctemp;</span><br></pre></td></tr></table></figure></p>
<p>最后设置 <code>argc</code> 的值和 <code>argv</code> 数组指针的内容<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Push two more words onto the child&#x27;s stack below &#x27;args&#x27;,</span></span><br><span class="line"><span class="comment">// containing the argc and argv parameters to be passed</span></span><br><span class="line"><span class="comment">// to the child&#x27;s main() function.</span></span><br><span class="line">u_int *pargv_ptr;</span><br><span class="line">pargv_ptr = args - <span class="number">1</span>;</span><br><span class="line">*pargv_ptr = USTACKTOP - UTEMP - BY2PG + (u_int)args;</span><br><span class="line">pargv_ptr--;</span><br><span class="line">*pargv_ptr = argc;</span><br></pre></td></tr></table></figure></p>
<p>返回栈帧的初始地址<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Set *init_sp to the initial stack pointer for the child</span></span><br><span class="line">*init_sp = USTACKTOP - UTEMP - BY2PG + (u_int)pargv_ptr;</span><br></pre></td></tr></table></figure></p>
<p>将 <code>UTEMP</code> 页映射到用户栈真正应该处于的地址，如果操作失败通过 <code>goto</code> 进行异常处理。<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">	<span class="keyword">if</span> ((r = syscall_mem_map(<span class="number">0</span>, (<span class="type">void</span> *)UTEMP, child, (<span class="type">void</span> *)(USTACKTOP - BY2PG), PTE_D)) &lt;</span><br><span class="line">	    <span class="number">1</span>) &#123;</span><br><span class="line">		<span class="keyword">goto</span> error;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> ((r = syscall_mem_unmap(<span class="number">0</span>, (<span class="type">void</span> *)UTEMP)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="keyword">goto</span> error;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">error:</span><br><span class="line">	syscall_mem_unmap(<span class="number">0</span>, (<span class="type">void</span> *)UTEMP);</span><br><span class="line">	<span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这样就完成了程序栈的初始化。让我们回到 <code>spawn</code>。接下来我们遍历整个 ELF 头的程序段，将程序段的内容读到内存中。<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Step 5: Load the ELF segments in the file into the child&#x27;s memory.</span></span><br><span class="line"><span class="comment">// This is similar to &#x27;load_icode()&#x27; in the kernel.</span></span><br><span class="line"><span class="type">size_t</span> ph_off;</span><br><span class="line">ELF_FOREACH_PHDR_OFF (ph_off, ehdr) &#123;</span><br><span class="line">	<span class="comment">// Read the program header in the file with offset &#x27;ph_off&#x27; and length</span></span><br><span class="line">	<span class="comment">// &#x27;ehdr-&gt;e_phentsize&#x27; into &#x27;elfbuf&#x27;.</span></span><br><span class="line">	<span class="comment">// &#x27;goto err1&#x27; on failure.</span></span><br><span class="line">	<span class="comment">// You may want to use &#x27;seek&#x27; and &#x27;readn&#x27;.</span></span><br><span class="line">	<span class="comment">/* Exercise 6.4: Your code here. (4/6) */</span></span><br><span class="line">	<span class="keyword">if</span> ((r = seek(fd, ph_off)) &lt; <span class="number">0</span> || (r = readn(fd, elfbuf, ehdr-&gt;e_phentsize)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="keyword">goto</span> err1;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure></p>
<p>如果是需要加载的程序段，则首先根据程序段相对于文件的偏移得到其在内存中映射到的地址，接着就和 Lab3 的 <code>load_icode</code> 函数一样，调用 <code>elf_load_seg</code> 将程序段加载到适当的位置。<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">	Elf32_Phdr *ph = (Elf32_Phdr *)elfbuf;</span><br><span class="line">	<span class="keyword">if</span> (ph-&gt;p_type == PT_LOAD) &#123;</span><br><span class="line">		<span class="type">void</span> *bin;</span><br><span class="line">		<span class="comment">// Read and map the ELF data in the file at &#x27;ph-&gt;p_offset&#x27; into our memory</span></span><br><span class="line">		<span class="comment">// using &#x27;read_map()&#x27;.</span></span><br><span class="line">		<span class="comment">// &#x27;goto err1&#x27; if that fails.</span></span><br><span class="line">		<span class="comment">/* Exercise 6.4: Your code here. (5/6) */</span></span><br><span class="line">		<span class="keyword">if</span> ((r = read_map(fd, ph-&gt;p_offset, &amp;bin)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="keyword">goto</span> err1;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Load the segment &#x27;ph&#x27; into the child&#x27;s memory using &#x27;elf_load_seg()&#x27;.</span></span><br><span class="line">		<span class="comment">// Use &#x27;spawn_mapper&#x27; as the callback, and &#x27;&amp;child&#x27; as its data.</span></span><br><span class="line">		<span class="comment">// &#x27;goto err1&#x27; if that fails.</span></span><br><span class="line">		<span class="comment">/* Exercise 6.4: Your code here. (6/6) */</span></span><br><span class="line">		<span class="keyword">if</span> ((r = elf_load_seg(ph, bin, spawn_mapper, &amp;child)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="keyword">goto</span> err1;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">close(fd);</span><br></pre></td></tr></table></figure></p>
<p>但还是要注意和 <code>load_icode</code> 的区别。此处我们设定的回调函数为 <code>spawn_mapper</code> 而非 <code>load_icode_mapper</code>。通过下面的对比可以看出，因为 <code>spawn_mapper</code> 处于用户态，所以使用了很多系统调用，同时我传入的是子进程的进程 id 而非进程控制块。<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// user/lib/spawn.c</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">spawn_mapper</span><span class="params">(<span class="type">void</span> *data, u_long va, <span class="type">size_t</span> offset, u_int perm, <span class="type">const</span> <span class="type">void</span> *src,</span></span><br><span class="line"><span class="params">			<span class="type">size_t</span> len)</span> &#123;</span><br><span class="line">	u_int child_id = *(u_int *)data;</span><br><span class="line">	try(syscall_mem_alloc(child_id, (<span class="type">void</span> *)va, perm));</span><br><span class="line">	<span class="keyword">if</span> (src != <span class="literal">NULL</span>) &#123;</span><br><span class="line">		<span class="type">int</span> r = syscall_mem_map(child_id, (<span class="type">void</span> *)va, <span class="number">0</span>, (<span class="type">void</span> *)UTEMP, perm | PTE_D);</span><br><span class="line">		<span class="keyword">if</span> (r) &#123;</span><br><span class="line">			syscall_mem_unmap(child_id, (<span class="type">void</span> *)va);</span><br><span class="line">			<span class="keyword">return</span> r;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">memcpy</span>((<span class="type">void</span> *)(UTEMP + offset), src, len);</span><br><span class="line">		<span class="keyword">return</span> syscall_mem_unmap(<span class="number">0</span>, (<span class="type">void</span> *)UTEMP);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// kern/env.c</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">load_icode_mapper</span><span class="params">(<span class="type">void</span> *data, u_long va, <span class="type">size_t</span> offset, u_int perm, <span class="type">const</span> <span class="type">void</span> *src,</span></span><br><span class="line"><span class="params">			     <span class="type">size_t</span> len)</span> &#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Env</span> *<span class="title">env</span> =</span> (<span class="keyword">struct</span> Env *)data;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Page</span> *<span class="title">p</span>;</span></span><br><span class="line">	<span class="type">int</span> r;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Step 1: Allocate a page with &#x27;page_alloc&#x27;. */</span></span><br><span class="line">	<span class="comment">/* Exercise 3.5: Your code here. (1/2) */</span></span><br><span class="line">	<span class="keyword">if</span> ((r = page_alloc(&amp;p)) != <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> r;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Step 2: If &#x27;src&#x27; is not NULL, copy the &#x27;len&#x27; bytes started at &#x27;src&#x27; into &#x27;offset&#x27; at this</span></span><br><span class="line"><span class="comment">	 * page. */</span></span><br><span class="line">	<span class="comment">// Hint: You may want to use &#x27;memcpy&#x27;.</span></span><br><span class="line">	<span class="keyword">if</span> (src != <span class="literal">NULL</span>) &#123;</span><br><span class="line">		<span class="comment">/* Exercise 3.5: Your code here. (2/2) */</span></span><br><span class="line">		<span class="built_in">memcpy</span>((<span class="type">void</span> *)(page2kva(p) + offset), src, len);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Step 3: Insert &#x27;p&#x27; into &#x27;env-&gt;env_pgdir&#x27; at &#x27;va&#x27; with &#x27;perm&#x27;. */</span></span><br><span class="line">	<span class="keyword">return</span> page_insert(env-&gt;env_pgdir, env-&gt;env_asid, p, va, perm);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这样就将程序加载到了新创建的进程的适当位置了。之后设定栈帧，父子进程共享 <code>USTACKTOP</code> 地址之下的数据，这一部分和 <code>duppage</code> 的操作很相似，只不过这里不共享程序部分。<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Trapframe</span> <span class="title">tf</span> =</span> envs[ENVX(child)].env_tf;</span><br><span class="line">tf.cp0_epc = entrypoint;</span><br><span class="line">tf.regs[<span class="number">29</span>] = sp;</span><br><span class="line"><span class="keyword">if</span> ((r = syscall_set_trapframe(child, &amp;tf)) != <span class="number">0</span>) &#123;</span><br><span class="line">	<span class="keyword">goto</span> err2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Pages with &#x27;PTE_LIBRARY&#x27; set are shared between the parent and the child.</span></span><br><span class="line"><span class="keyword">for</span> (u_int pdeno = <span class="number">0</span>; pdeno &lt;= PDX(USTACKTOP); pdeno++) &#123;</span><br><span class="line">	<span class="keyword">if</span> (!(vpd[pdeno] &amp; PTE_V)) &#123;</span><br><span class="line">		<span class="keyword">continue</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (u_int pteno = <span class="number">0</span>; pteno &lt;= PTX(~<span class="number">0</span>); pteno++) &#123;</span><br><span class="line">		u_int pn = (pdeno &lt;&lt; <span class="number">10</span>) + pteno;</span><br><span class="line">		u_int perm = vpt[pn] &amp; ((<span class="number">1</span> &lt;&lt; PGSHIFT) - <span class="number">1</span>);</span><br><span class="line">		<span class="keyword">if</span> ((perm &amp; PTE_V) &amp;&amp; (perm &amp; PTE_LIBRARY)) &#123;</span><br><span class="line">			<span class="type">void</span> *va = (<span class="type">void</span> *)(pn &lt;&lt; PGSHIFT);</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> ((r = syscall_mem_map(<span class="number">0</span>, va, child, va, perm)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">				debugf(<span class="string">&quot;spawn: syscall_mem_map %x %x: %d\n&quot;</span>, va, child, r);</span><br><span class="line">				<span class="keyword">goto</span> err2;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>最后设定子进程为运行状态以将其加入进程调度队列，实现子进程的创建。<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> ((r = syscall_set_env_status(child, ENV_RUNNABLE)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">	debugf(<span class="string">&quot;spawn: syscall_set_env_status %x: %d\n&quot;</span>, child, r);</span><br><span class="line">	<span class="keyword">goto</span> err2;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> child;</span><br></pre></td></tr></table></figure></p>
<p>在最后则是异常处理部分，可以看出在 <code>spawn</code> 函数中因为分配的资源数量较多，异常处理部分也变复杂了。这里就可以看出使用 <code>goto</code> 进行异常处理的优点了。只需要按反向的顺序写出资源的释放函数，在异常时只需要跳转到对应位置就可以穿透标签，不断释放所有的资源。这和 Lab5 中我们解释过的 <code>switch</code> 的穿透类似。<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">err2:</span><br><span class="line">	syscall_env_destroy(child);</span><br><span class="line">	<span class="keyword">return</span> r;</span><br><span class="line">err1:</span><br><span class="line">	syscall_env_destroy(child);</span><br><span class="line">err:</span><br><span class="line">	close(fd);</span><br><span class="line">	<span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这样，<code>spawn</code> 函数也终于讲解完了。</p>
<h2 id="五、管道通信的实现"><a href="#五、管道通信的实现" class="headerlink" title="五、管道通信的实现"></a>五、管道通信的实现</h2><p>最后还要讲一下管道。各位应该都清楚，管道是一种特殊的文件，它没有在磁盘中占用空间，所有的数据都存储在内存中。对于 MOS 来说，就是不需要与文件系统服务进程进行通讯，直接在内存中处理读写等等操作。</p>
<p>管道的相关操作位于 user/lib/pipe.c 中。创建管道的函数为 <code>pipe</code>。管道创建时总会返回两个文件描述符，用于对同一块内存的读写操作。</p>
<p>首先就是简单地申请文件描述符，同时申请用于表示文件内容的内存空间。另外对第二个文件描述符 <code>fd1</code> 还需要将该文件对应的内存空间映射到 <code>fd0</code> 对应的空间。这样两个文件描述符才能共享同一块物理内存。<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">pipe</span><span class="params">(<span class="type">int</span> pfd[<span class="number">2</span>])</span> &#123;</span><br><span class="line">	<span class="type">int</span> r;</span><br><span class="line">	<span class="type">void</span> *va;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Fd</span> *<span class="title">fd0</span>, *<span class="title">fd1</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Step 1: Allocate the file descriptors. */</span></span><br><span class="line">	<span class="keyword">if</span> ((r = fd_alloc(&amp;fd0)) &lt; <span class="number">0</span> || (r = syscall_mem_alloc(<span class="number">0</span>, fd0, PTE_D | PTE_LIBRARY)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="keyword">goto</span> err;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> ((r = fd_alloc(&amp;fd1)) &lt; <span class="number">0</span> || (r = syscall_mem_alloc(<span class="number">0</span>, fd1, PTE_D | PTE_LIBRARY)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="keyword">goto</span> err1;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Step 2: Allocate and map the page for the &#x27;Pipe&#x27; structure. */</span></span><br><span class="line">	va = fd2data(fd0);</span><br><span class="line">	<span class="keyword">if</span> ((r = syscall_mem_alloc(<span class="number">0</span>, (<span class="type">void</span> *)va, PTE_D | PTE_LIBRARY)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="keyword">goto</span> err2;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> ((r = syscall_mem_map(<span class="number">0</span>, (<span class="type">void</span> *)va, <span class="number">0</span>, (<span class="type">void</span> *)fd2data(fd1), PTE_D | PTE_LIBRARY)) &lt;</span><br><span class="line">	    <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="keyword">goto</span> err3;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<p>设定文件描述符的相关属性，最后返回。还有异常处理部分，都不再详述。<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">	<span class="comment">/* Step 3: Set up &#x27;Fd&#x27; structures. */</span></span><br><span class="line">	fd0-&gt;fd_dev_id = devpipe.dev_id;</span><br><span class="line">	fd0-&gt;fd_omode = O_RDONLY;</span><br><span class="line"></span><br><span class="line">	fd1-&gt;fd_dev_id = devpipe.dev_id;</span><br><span class="line">	fd1-&gt;fd_omode = O_WRONLY;</span><br><span class="line"></span><br><span class="line">	debugf(<span class="string">&quot;[%08x] pipecreate \n&quot;</span>, env-&gt;env_id, vpt[VPN(va)]);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Step 4: Save the result. */</span></span><br><span class="line">	pfd[<span class="number">0</span>] = fd2num(fd0);</span><br><span class="line">	pfd[<span class="number">1</span>] = fd2num(fd1);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">err3:</span><br><span class="line">	syscall_mem_unmap(<span class="number">0</span>, (<span class="type">void</span> *)va);</span><br><span class="line">err2:</span><br><span class="line">	syscall_mem_unmap(<span class="number">0</span>, fd1);</span><br><span class="line">err1:</span><br><span class="line">	syscall_mem_unmap(<span class="number">0</span>, fd0);</span><br><span class="line">err:</span><br><span class="line">	<span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>管道的数据结构实际上是一个环形队列，是通过共享内存的方式实现进程间的通信。关键的内容就在于管道的读写操作。实际上对于并发的临界区资源读写，有很多需要考虑的细节，但碍于篇幅，还是不详述了。指导书上的说明已经很详尽了，内容就到此为止吧。<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> _pipe_is_closed(<span class="keyword">struct</span> Fd *fd, <span class="keyword">struct</span> Pipe *p) &#123;</span><br><span class="line">	<span class="comment">// The &#x27;pageref(p)&#x27; is the total number of readers and writers.</span></span><br><span class="line">	<span class="comment">// The &#x27;pageref(fd)&#x27; is the number of envs with &#x27;fd&#x27; open</span></span><br><span class="line">	<span class="comment">// (readers if fd is a reader, writers if fd is a writer).</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">// Check if the pipe is closed using &#x27;pageref(fd)&#x27; and &#x27;pageref(p)&#x27;.</span></span><br><span class="line">	<span class="comment">// If they&#x27;re the same, the pipe is closed.</span></span><br><span class="line">	<span class="comment">// Otherwise, the pipe isn&#x27;t closed.</span></span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> fd_ref, pipe_ref, runs;</span><br><span class="line">	<span class="comment">// Use &#x27;pageref&#x27; to get the reference counts for &#x27;fd&#x27; and &#x27;p&#x27;, then</span></span><br><span class="line">	<span class="comment">// save them to &#x27;fd_ref&#x27; and &#x27;pipe_ref&#x27;.</span></span><br><span class="line">	<span class="comment">// Keep retrying until &#x27;env-&gt;env_runs&#x27; is unchanged before and after</span></span><br><span class="line">	<span class="comment">// reading the reference counts.</span></span><br><span class="line">	<span class="comment">/* Exercise 6.1: Your code here. (1/3) */</span></span><br><span class="line">	<span class="keyword">do</span> &#123;</span><br><span class="line">		runs = env-&gt;env_runs;</span><br><span class="line"></span><br><span class="line">		fd_ref = pageref(fd);</span><br><span class="line">		pipe_ref = pageref(p);</span><br><span class="line"></span><br><span class="line">	&#125; <span class="keyword">while</span> (runs != env-&gt;env_runs);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> fd_ref == pipe_ref;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">pipe_read</span><span class="params">(<span class="keyword">struct</span> Fd *fd, <span class="type">void</span> *vbuf, u_int n, u_int offset)</span> &#123;</span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Pipe</span> *<span class="title">p</span>;</span></span><br><span class="line">	<span class="type">char</span> *rbuf;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Use &#x27;fd2data&#x27; to get the &#x27;Pipe&#x27; referred by &#x27;fd&#x27;.</span></span><br><span class="line">	<span class="comment">// Write a loop that transfers one byte in each iteration.</span></span><br><span class="line">	<span class="comment">// Check if the pipe is closed by &#x27;_pipe_is_closed&#x27;.</span></span><br><span class="line">	<span class="comment">// When the pipe buffer is empty:</span></span><br><span class="line">	<span class="comment">//  - If at least 1 byte is read, or the pipe is closed, just return the number</span></span><br><span class="line">	<span class="comment">//    of bytes read so far.</span></span><br><span class="line">	<span class="comment">//  - Otherwise, keep yielding until the buffer isn&#x27;t empty or the pipe is closed.</span></span><br><span class="line">	<span class="comment">/* Exercise 6.1: Your code here. (2/3) */</span></span><br><span class="line">	p = fd2data(fd);</span><br><span class="line">	rbuf = (<span class="type">char</span> *)vbuf;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">		<span class="keyword">while</span> (p-&gt;p_rpos &gt;= p-&gt;p_wpos) &#123;</span><br><span class="line">			<span class="keyword">if</span> (i &gt; <span class="number">0</span> || _pipe_is_closed(fd, p)) &#123;</span><br><span class="line">				<span class="keyword">return</span> i;</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				syscall_yield();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		rbuf[i] = p-&gt;p_buf[p-&gt;p_rpos % BY2PIPE];</span><br><span class="line">		p-&gt;p_rpos++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">pipe_write</span><span class="params">(<span class="keyword">struct</span> Fd *fd, <span class="type">const</span> <span class="type">void</span> *vbuf, u_int n, u_int offset)</span> &#123;</span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Pipe</span> *<span class="title">p</span>;</span></span><br><span class="line">	<span class="type">char</span> *wbuf;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Use &#x27;fd2data&#x27; to get the &#x27;Pipe&#x27; referred by &#x27;fd&#x27;.</span></span><br><span class="line">	<span class="comment">// Write a loop that transfers one byte in each iteration.</span></span><br><span class="line">	<span class="comment">// If the bytes of the pipe used equals to &#x27;BY2PIPE&#x27;, the pipe is regarded as full.</span></span><br><span class="line">	<span class="comment">// Check if the pipe is closed by &#x27;_pipe_is_closed&#x27;.</span></span><br><span class="line">	<span class="comment">// When the pipe buffer is full:</span></span><br><span class="line">	<span class="comment">//  - If the pipe is closed, just return the number of bytes written so far.</span></span><br><span class="line">	<span class="comment">//  - If the pipe isn&#x27;t closed, keep yielding until the buffer isn&#x27;t full or the</span></span><br><span class="line">	<span class="comment">//    pipe is closed.</span></span><br><span class="line">	<span class="comment">/* Exercise 6.1: Your code here. (3/3) */</span></span><br><span class="line">	p = fd2data(fd);</span><br><span class="line">	wbuf = (<span class="type">char</span> *)vbuf;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">		<span class="keyword">while</span> (p-&gt;p_wpos - p-&gt;p_rpos &gt;= BY2PIPE) &#123;</span><br><span class="line">			<span class="keyword">if</span> (_pipe_is_closed(fd, p)) &#123;</span><br><span class="line">				<span class="keyword">return</span> i;</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				syscall_yield();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		p-&gt;p_buf[p-&gt;p_wpos % BY2PIPE] = wbuf[i];</span><br><span class="line">		p-&gt;p_wpos++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">pipe_is_closed</span><span class="params">(<span class="type">int</span> fdnum)</span> &#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Fd</span> *<span class="title">fd</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Pipe</span> *<span class="title">p</span>;</span></span><br><span class="line">	<span class="type">int</span> r;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Step 1: Get the &#x27;fd&#x27; referred by &#x27;fdnum&#x27;.</span></span><br><span class="line">	<span class="keyword">if</span> ((r = fd_lookup(fdnum, &amp;fd)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> r;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// Step 2: Get the &#x27;Pipe&#x27; referred by &#x27;fd&#x27;.</span></span><br><span class="line">	p = (<span class="keyword">struct</span> Pipe *)fd2data(fd);</span><br><span class="line">	<span class="comment">// Step 3: Use &#x27;_pipe_is_closed&#x27; to judge if the pipe is closed.</span></span><br><span class="line">	<span class="keyword">return</span> _pipe_is_closed(fd, p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>（完）</strong></p>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>MOS</tag>
        <tag>os</tag>
        <tag>BUAA</tag>
      </tags>
  </entry>
  <entry>
    <title>FunctionSketch设计文档</title>
    <url>/posts/9a443429/</url>
    <content><![CDATA[<h2 id="一、程序简述"><a href="#一、程序简述" class="headerlink" title="一、程序简述"></a>一、程序简述</h2><p>本软件是一个轻量级的图像绘制软件。在实现较为丰富的函数绘制功能的同时，避免了庞大的体量。与Matlab、Mathematica等专业软件的二维图像绘制功能相比，更方便上手，便于使用。可用于满足学习和简单研究的二维绘图需要。</p>
<h2 id="二、实现思路"><a href="#二、实现思路" class="headerlink" title="二、实现思路"></a>二、实现思路</h2><h3 id="1、表达式字符串解析"><a href="#1、表达式字符串解析" class="headerlink" title="1、表达式字符串解析"></a>1、表达式字符串解析</h3><h4 id="（1）解析目标"><a href="#（1）解析目标" class="headerlink" title="（1）解析目标"></a>（1）解析目标</h4><p>本程序的主要输入内容为表达式字符串，用以表示单变量函数、参数方程或是隐函数。为了进行计算，我们需要将其转化为可使用计算机计算的函数。我们可以将三种方程分别看成单参数、单返回值的函数；单参数、双返回值的函数；双参数，单返回值的函数（即<code>f(x,y)=0</code>）。这可以利用<code>C#</code>的<code>delegate</code>实现。<code>C#</code>中预先定义了<code>Func&lt;&gt;</code>委托。利用泛型可分别存储三种类型的方法。</p>
<p>因此现在的问题便是，如何依据不同的字符串，构造出对应的可反映该表达式计算过程的方法。这里采取表达式树的结构。</p>
<h4 id="（2）FunctionParser类——字符串转表达式树"><a href="#（2）FunctionParser类——字符串转表达式树" class="headerlink" title="（2）FunctionParser类——字符串转表达式树"></a>（2）FunctionParser类——字符串转表达式树</h4><p>字符串转表达式树的基本算法已经在大一的数据结构课上讲过了。这里不赘述。</p>
<p>不同的地方在于面向对象可以方便的利用多态代替判断。因此对于表达式树，不再需要节点内储存数据表示不同的节点类型。只需要所有的节点继承共同的抽象父类<code>ExpressionElement</code>，同时<code>ExpressionElement</code>具有函数<code>Calculate</code>,子类，包括<code>Value</code>、<code>ArgumentX</code>、<code>ArgumentY</code>、<code>Operator</code>等等，各自实现不同的<code>Calculate</code>操作。<br><img src="/posts/9a443429/%E7%B1%BB%E5%9B%BE.png" class="" title="类图"></p>
<p>最后，将<code>Calculate</code>方法赋给<code>Func&lt;&gt;</code>类型的变量，就可以实现表达式的存储了。</p>
<h4 id="（3）FunctionFactory类——字符串转函数封装信息"><a href="#（3）FunctionFactory类——字符串转函数封装信息" class="headerlink" title="（3）FunctionFactory类——字符串转函数封装信息"></a>（3）FunctionFactory类——字符串转函数封装信息</h4><p>但是，不同类型的函数有着不同的信息，比如单变量函数可以方便地求导、积分；参数方程需要指定参数的范围。因此在绘制图像之前，还需要对函数的信息做一次封装。</p>
<p><code>FunctionFactory</code>读入字符串，判断其类型，将其封装为不同的类（<code>SingleVarFuncStorage</code> 、<code>DoubleVarFuncStorage</code>和<code>ParamVarFuncStorage</code>。其中各自具有对应函数的属性和方法），并以<code>FunctionStorage[]</code>父类数组的形式返回。</p>
<h3 id="2、FunctionDrawing类——图像绘制"><a href="#2、FunctionDrawing类——图像绘制" class="headerlink" title="2、FunctionDrawing类——图像绘制"></a>2、FunctionDrawing类——图像绘制</h3><h4 id="（1）基础算法"><a href="#（1）基础算法" class="headerlink" title="（1）基础算法"></a>（1）基础算法</h4><p><code>FunctionStorage</code>类的成员将传入<code>FunctionDrawing</code>类中，成员被存储在一个<code>List&lt;FunctionStorage&gt;</code>内。每次调用<code>Refresh</code>函数重绘，都将对列表内的每一个元素调用绘制。</p>
<p>不同的函数类型将采取不同的绘制策略。绘制时先用里氏转换将函数转换会真正的子类。随后调用多态方法<code>DrawFunction</code>。</p>
<p>虽然绘制算法并不相同，但本质上都采取了取点描线的方式。绘制利用了<code>WPF</code>的绘图API，主要是运用了<code>DrawingGroup</code>、<code>DrawingContext</code>类。并将绘制结果以<code>DrawingImage</code>的形式作为位于主界面左侧窗口的<code>Image</code>的<code>Source</code>。</p>
<h4 id="（2）平滑算法"><a href="#（2）平滑算法" class="headerlink" title="（2）平滑算法"></a>（2）平滑算法</h4><p>单变量函数和参数方程的基本绘制，就是简单的以某一小间隔<code>dx</code>为单位，从自变量初值递增到终值，对每一个自变量，计算对应的坐标。最后将所有在绘制范围内的坐标点连接起来。</p>
<p>而平滑算法是用于改善一些极端情况，如<code>y=sin(1/x)</code>，的绘制效果的算法。用于平滑过于“尖锐”的图像。这是一个递归算法，具体操作如下</p>
<ol>
<li>输入参数为三个点，构成两条线段</li>
<li>如果这两条线段较为“平滑”（本程序采用斜率之差的绝对值小于某一值），则退出</li>
<li>否则，分别对于两条线段，各自取端点参数的中值，算出坐标，将原线段的端点和中值的坐标作为参数，重复1。</li>
</ol>
<h4 id="（3）Marching-Square算法"><a href="#（3）Marching-Square算法" class="headerlink" title="（3）Marching Square算法"></a>（3）Marching Square算法</h4><p>对于图像一般形式<code>f(x,y)=0</code>，就算遍历全部绘制范围也较难恰好取到等于0的情况。另外如果以某一确定的<code>eps</code>作为误差范围，也会因为不同的梯度导致绘制的曲线误差较大。因此需要采用新的算法。</p>
<p>Marching Square算法一定程度上解决了这一问题。该算法通过将绘制区域划分成等大的方块，并取样方块顶点上的函数值，根据函数值的正负估计曲线的走向。最后利用线性插值估计<code>f(x,y)=0</code>在方块边上的位置，连线得出图像。<br><img src="/posts/9a443429/MarchingSquare.png" class="" title="MarchingSquare"></p>
<h3 id="3、UI设计"><a href="#3、UI设计" class="headerlink" title="3、UI设计"></a>3、UI设计</h3><h4 id="（1）图像尺寸自适应"><a href="#（1）图像尺寸自适应" class="headerlink" title="（1）图像尺寸自适应"></a>（1）图像尺寸自适应</h4><p>软件需要能实现尺寸的自由变化，而如果只绘制某一特定尺寸的图像，那么就无法实现较好的变化效果。</p>
<p>采取的解决方式是在<code>FunctionDrawing</code>类内添加属性<code>AspectRatio</code>用于表示长宽比。同时监听窗口的尺寸变化事件。在尺寸变化后，获取新的长宽比，更新<code>AspectRatio</code>并调用<code>Refresh</code>方法重绘界面。</p>
<h4 id="（2）UserControl自定义控件"><a href="#（2）UserControl自定义控件" class="headerlink" title="（2）UserControl自定义控件"></a>（2）UserControl自定义控件</h4><p>在添加函数后，主界面右侧函数列表会出现记录该函数的信息卡片。并具有删除和设置函数的按钮。该卡片集成了该函数所能做的所有操作，是<code>FunctionStorage</code>在UI的反映。</p>
<p>如果每创建一个新的函数，都要执行一大段生成包括<code>Button</code>、<code>Label</code>、<code>TextBlock</code> <code>PopUp</code>等控件的代码，很显然是不明智的。因此采用用户控件<code>UserControl</code>在新的窗口设计信息卡片需要的功能。主页面则只需要在添加函数时创建关于该函数的卡片实例即可。类似的，表达式输入框等内容也是如此。<br><img src="/posts/9a443429/%E7%94%A8%E6%88%B7%E6%8E%A7%E4%BB%B6.png" class="" title="用户控件"></p>
<h4 id="（3）Frame——Page实现单窗口多页面"><a href="#（3）Frame——Page实现单窗口多页面" class="headerlink" title="（3）Frame——Page实现单窗口多页面"></a>（3）Frame——Page实现单窗口多页面</h4><p>点击菜单栏的设置选项，会出现一个用于设置的新窗口。选择左侧边栏的不同设置选项，右侧会显示不同的页面。这个单窗口多页面的功能，由<code>Frame</code>加<code>Page</code>控件实现。</p>
<p>主设置页添加一个<code>Frame</code>控件，在打开该窗口时，<code>Frame</code>加载显示不同设置的<code>Page</code>。在点击左侧边栏按钮的时候，调用<code>Frame</code>的<code>Navigate</code>方法导航到对应的设置页。<br><img src="/posts/9a443429/%E9%A1%B5.png" class="" title="页"></p>
<h2 id="三、运行环境"><a href="#三、运行环境" class="headerlink" title="三、运行环境"></a>三、运行环境</h2><p>编写时使用<code>Visual Studio</code>版本为<code>VS2019 16.11.17</code><br><code>.NET</code>版本为<code>netcoreapp3.1</code><br><code>c#</code>版本为<code>C#8.0</code></p>
<h2 id="四、收获"><a href="#四、收获" class="headerlink" title="四、收获"></a>四、收获</h2><ol>
<li>学习了面向对象编程的思想，实践了简单的代码重构。</li>
<li>获得了开发近4000行代码的项目的经验。</li>
<li>学习了一些图形学算法。</li>
<li>对<code>C#</code>的理解更加深入，并获得了简单的<code>WPF</code>经验。</li>
</ol>
]]></content>
      <categories>
        <category>软件开发</category>
      </categories>
      <tags>
        <tag>C#</tag>
        <tag>函数画板</tag>
      </tags>
  </entry>
  <entry>
    <title>FunctionSketch说明文档</title>
    <url>/posts/fe7db33d/</url>
    <content><![CDATA[<h2 id="一、简述"><a href="#一、简述" class="headerlink" title="一、简述"></a>一、简述</h2><p>本文档将介绍程序<strong>函数画板</strong>的主要功能和基本操作。<strong>函数画板</strong>是一款轻量的函数绘制软件。支持单变量函数、参数方程、隐函数的绘制。可以采用直角坐标和极坐标绘制简单图像，并带有求导、积分、二维线性变换等功能。</p>
<h2 id="二、函数绘制"><a href="#二、函数绘制" class="headerlink" title="二、函数绘制"></a>二、函数绘制</h2><h3 id="1、添加函数"><a href="#1、添加函数" class="headerlink" title="1、添加函数"></a>1、添加函数</h3><p>运行exe文件后，将进入程序的主界面。如下图所示。<br><img src="/posts/fe7db33d/%E5%87%BD%E6%95%B0%E4%B8%BB%E7%95%8C%E9%9D%A2.png" class="" title="函数主界面"></p>
<p>点击右侧“函数列表”栏内的加号按钮，将出现表达式的输入框。<br><img src="/posts/fe7db33d/%E8%BE%93%E5%85%A5%E5%87%BD%E6%95%B0.png" class="" title="输入函数"></p>
<p>输入函数表达式后按回车键（或采取使输入框不再被选中的操作），若表达式<strong>正确</strong>，则会将该表达式所对应的函数绘制到主界面左侧的窗口上。</p>
<p>其中<strong>正确的表达式</strong>包括如下几种情况：</p>
<ol>
<li>表示单变量函数<br>此时表达式请以x为自变量，不忽略运算符（特别注意，对数如logm(n)请写作mlogn）。表达式前可忽略“y=”。例如“y=x+x^2”或“x*(elogx)”</li>
<li>表示参数方程<br>此时请同时输入两个单变量函数表达式，以x或t为自变量，两表达式间以逗号间隔。注意请不要在两个表达式前添加“x=”或“y=”。例如“t^2,t”或“sinx,cosx”</li>
<li>表示隐函数（或一般的方程）<br>此时请以x，y表示横纵两坐标轴对应的变量。表达式中必须包含等号。例如“x^2+y^2=1”。当等式左侧为“y=”时自动转换为单变量函数计算。</li>
</ol>
<p>另外，一次输入可以绘制多个图像。若要输入多个表达式，请将各表达式以分号间隔。</p>
<h3 id="2、函数属性设置"><a href="#2、函数属性设置" class="headerlink" title="2、函数属性设置"></a>2、函数属性设置</h3><p>添加函数后，函数图像将在左侧窗口内显示，同时右侧函数列表栏内也会出现记录该函数信息的卡片（超出范围的卡片可以滑动滚轮以查看）。<br><img src="/posts/fe7db33d/%E7%BB%98%E5%88%B6%E5%9B%BE%E5%83%8F.png" class="" title="绘制图像"></p>
<p>每一个函数信息卡右侧有两个按钮。上面标有“x”字的按钮点击后可关闭该函数卡并删除左侧窗口内对应的函数图像。下面显示“···”符号的按钮，点击后可以设置该函数相关的属性。主要包括如下内容。<br><img src="/posts/fe7db33d/%E5%87%BD%E6%95%B0%E8%AE%BE%E7%BD%AE.png" class="" title="绘制图像"></p>
<ol>
<li>坐标形式<br>单变量函数和参数方程共有。设置图像以直角坐标或极坐标形式呈现。</li>
<li>线性变换<br>单变量函数和参数方程共有。表示一个2*2矩阵。在绘制过程中，图像的每一个坐标点会与该矩阵相乘。</li>
<li>位移<br>单变量函数和参数方程共有。表示一个二维矢量。在绘制过程中，图像的每一个坐标点会与该矢量相加。</li>
<li>积分<br>单变量函数特有。表示一个积分区间。默认不计算积分（积分范围NaN-&gt;NaN）。若输入正确的积分范围，则会在左侧窗口内将求积分的面积涂色。并在信息卡上显示积分结果。</li>
<li>求导<br>单变量函数特有。点击求导按钮后会求一阶导数，并将得到的新函数添加到函数列表栏的末尾。图像也会在左侧窗口内显示。</li>
<li>参数范围<br>参数方程特有。用以表示参数的范围。左侧窗口内只会绘制参数范围内的图像。</li>
</ol>
<h2 id="三、保存文件"><a href="#三、保存文件" class="headerlink" title="三、保存文件"></a>三、保存文件</h2><h3 id="1、保存当前函数图像"><a href="#1、保存当前函数图像" class="headerlink" title="1、保存当前函数图像"></a>1、保存当前函数图像</h3><p>点击主窗口上侧菜单栏“文件”选项。其中第一项“保存”可以将当前绘制的图像保存为图片格式（当前暂时只支持jpg格式）。</p>
<h3 id="2、查看默认保存位置"><a href="#2、查看默认保存位置" class="headerlink" title="2、查看默认保存位置"></a>2、查看默认保存位置</h3><p>第二项“打开默认保存路径”会打开exe所在路径之下的SaveImage文件夹。可用于作为保存文件的位置。</p>
<h2 id="四、设置"><a href="#四、设置" class="headerlink" title="四、设置"></a>四、设置</h2><h3 id="1、绘制设置"><a href="#1、绘制设置" class="headerlink" title="1、绘制设置"></a>1、绘制设置</h3><p>点击菜单栏“设置”选项，会打开一个设置窗口。<br><img src="/posts/fe7db33d/%E8%AE%BE%E7%BD%AE%E7%AA%97%E5%8F%A3.png" class="" title="设置窗口"><br>其中前三项用于绘制设置。</p>
<ol>
<li>显示范围<br>相对位置用于设置当前显示位置与默认位置的偏移量。可以理解该值为一个表示当前窗口显示的位置相对于原点的坐标。<br>显示宽度用于设置当前窗口宽度下，横坐标数值的变化范围。<br>（该项设置也可以在主界面显示窗口用鼠标拖动和滚轮实现。）</li>
<li>线条颜色<br>设置图像曲线、坐标轴、积分区域的颜色。</li>
<li>线条宽度<br>设置图像曲线、坐标轴线条的粗细。注意该粗细不会随着窗口的缩放而发生变化。</li>
</ol>
<h3 id="2、算法设置"><a href="#2、算法设置" class="headerlink" title="2、算法设置"></a>2、算法设置</h3><p>设置窗口第四项用于设置算法相关参数。算法原理详见设计文档。<br><img src="/posts/fe7db33d/%E7%AE%97%E6%B3%95%E8%AE%BE%E7%BD%AE.png" class="" title="算法设置"></p>
<ol>
<li>基本<br>最小绘制间隔即生成基本绘制点时自变量的间隔。</li>
<li>平滑算法<br>平滑算法用于处理曲率较大的情况。平滑率表示连点绘制的曲线的“尖锐度”的阈值，过于“尖锐”的部分将被试图平滑。最大递归层数用于避免过深的递归，减少绘制时间。</li>
<li>Marching Square算法<br>Marching Square算法用于处理一般方程，能较有效地绘制隐函数图像。但计算量较大，以dx为单位长度绘制速度较慢。因此以dx乘以某一常数得到的长度作为新的单位长度，该常数即方块比例。</li>
</ol>
<h2 id="五、帮助"><a href="#五、帮助" class="headerlink" title="五、帮助"></a>五、帮助</h2><h3 id="1、查看源代码"><a href="#1、查看源代码" class="headerlink" title="1、查看源代码"></a>1、查看源代码</h3><p>点击菜单栏“帮助”选项，第一项“源代码”点击后会转到保存该程序源代码的github仓库。</p>
<h3 id="2、操作说明"><a href="#2、操作说明" class="headerlink" title="2、操作说明"></a>2、操作说明</h3><p>第二项“操作说明”可以打开一个新的帮助窗口，其中记录了一些较为常见的操作的提示。可在使用时随时查看。</p>
]]></content>
      <categories>
        <category>软件开发</category>
      </categories>
      <tags>
        <tag>C#</tag>
        <tag>函数画板</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo个人博客搭建及主题配置教程</title>
    <url>/posts/6cacc70/</url>
    <content><![CDATA[<h2 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h2><p>本文是作者对于Hexo搭建的阶段总结。汇总了一些搭建过程中找到的资料。希望能够较为全面的记录博客搭建的全过程。给自己备忘，为他人提供帮助。</p>
<h2 id="二、搭建阶段"><a href="#二、搭建阶段" class="headerlink" title="二、搭建阶段"></a>二、搭建阶段</h2><h3 id="（1）Hexo简介"><a href="#（1）Hexo简介" class="headerlink" title="（1）Hexo简介"></a>（1）Hexo简介</h3><p>Hexo是一款基于Node.js的静态博客框架，依赖少易于安装使用，可以方便的生成静态网页托管在GitHub和Coding上，是搭建博客的首选框架。大家可以进入hexo官网进行详细查看，因为Hexo的创建者是台湾人，对中文的支持很友好，可以选择中文进行查看。</p>
<h3 id="（2）前期安装"><a href="#（2）前期安装" class="headerlink" title="（2）前期安装"></a>（2）前期安装</h3><h4 id="安装Git"><a href="#安装Git" class="headerlink" title="安装Git"></a>安装Git</h4><p>Git是目前世界上最先进的分布式版本控制系统，可以有效、高速的处理从很小到非常大的项目版本管理。也就是用来管理你的hexo博客文章，上传到GitHub的工具。</p>
<p>windows：到git官网上下载,Download git,下载后会有一个Git Bash的命令行工具，以后就用这个工具来使用git。windows在git安装完后，就可以直接使用git bash来敲命令行了。</p>
<p>linux：对linux来说实在是太简单了，因为最早的git就是在linux上编写的，只需要一行代码<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt-get install git</span><br></pre></td></tr></table></figure><br>安装好后，用<code>git --version</code>来查看一下版本。</p>
<h4 id="安装nodejs"><a href="#安装nodejs" class="headerlink" title="安装nodejs"></a>安装nodejs</h4><p>Hexo是基于nodeJS编写的，所以需要安装一下nodeJs和里面的npm工具。</p>
<p>windows：nodejs选择LTS版本就行了。</p>
<p>linux：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt-get install nodejs</span><br><span class="line">sudo apt-get install npm</span><br></pre></td></tr></table></figure><br>安装完后，打开命令行<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">node -v</span><br><span class="line">npm -v</span><br></pre></td></tr></table></figure><br>检查一下有没有安装成功</p>
<h4 id="安装Hexo"><a href="#安装Hexo" class="headerlink" title="安装Hexo"></a>安装Hexo</h4><p>前面git和nodejs安装好后，就可以安装hexo了，可以先创建一个文件夹blog，然后cd到这个文件夹下（或者在这个文件夹下直接右键git bash打开）。</p>
<p>输入命令<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install -g hexo-cli</span><br></pre></td></tr></table></figure><br>用<code>hexo -v</code>查看一下版本，至此就全部安装完了。</p>
<p>接下来初始化一下hexo<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo init myblog</span><br></pre></td></tr></table></figure><br>这个myblog可以自己取什么名字都行，然后<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> myblog //进入这个myblog文件夹</span><br><span class="line">npm install</span><br></pre></td></tr></table></figure><br>新建完成后，指定文件夹目录下有：</p>
<ul>
<li>node_modules: 依赖包</li>
<li>public：存放生成的页面</li>
<li>scaffolds：生成文章的一些模板</li>
<li>source：用来存放你的文章</li>
<li>themes：主题</li>
<li>_config.yml: 博客的配置文件**</li>
</ul>
<p>打开hexo的服务<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo g</span><br><span class="line">hexo server</span><br></pre></td></tr></table></figure><br>在浏览器输入localhost:4000就可以看到你生成的博客了。</p>
<h3 id="（3）Github部署"><a href="#（3）Github部署" class="headerlink" title="（3）Github部署"></a>（3）Github部署</h3><h4 id="GitHub创建个人仓库"><a href="#GitHub创建个人仓库" class="headerlink" title="GitHub创建个人仓库"></a>GitHub创建个人仓库</h4><p>首先，注册Github账号。</p>
<p>注册完登录后，在网站中点击New repository，新建仓库</p>
<p>创建一个和用户名相同的仓库，后面加.github.io，只有这样，将来要部署到GitHub page的时候，才会被识别，也就是xxxx.github.io，其中xxx就是你注册GitHub的用户名。</p>
<p>点击create repository，创建仓库。</p>
<h4 id="生成SSH添加到GitHub"><a href="#生成SSH添加到GitHub" class="headerlink" title="生成SSH添加到GitHub"></a>生成SSH添加到GitHub</h4><p>回到git bash中，输入<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git config --global user.name <span class="string">&quot;yourname&quot;</span></span><br><span class="line">git config --global user.email <span class="string">&quot;youremail&quot;</span></span><br></pre></td></tr></table></figure><br>yourname输入GitHub用户名，youremail输入GitHub的邮箱。</p>
<p>可以用以下两条，检查一下你有没有输对<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git config user.name</span><br><span class="line">git config user.email</span><br></pre></td></tr></table></figure><br>然后创建SSH，输入<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ssh-keygen -t rsa -C <span class="string">&quot;youremail&quot;</span></span><br></pre></td></tr></table></figure><br>接着一路回车。<br>会显示已经生成了.ssh的文件夹。在你的电脑中找到这个文件夹。</p>
<p>在GitHub的setting中，找到SSH keys的设置选项，点击New SSH key<br>把id_rsa.pub里面的信息复制进去。</p>
<p>在gitbash中，查看是否成功<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ssh -T git@github.com</span><br></pre></td></tr></table></figure></p>
<h4 id="将hexo部署到GitHub"><a href="#将hexo部署到GitHub" class="headerlink" title="将hexo部署到GitHub"></a>将hexo部署到GitHub</h4><p>这一步，我们就可以将hexo和GitHub关联起来，也就是将hexo生成的文章部署到GitHub上，打开站点配置文件 _config.yml，翻到最后，修改为<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  <span class="built_in">type</span>: git</span><br><span class="line">  repo: https://github.com/YourgithubName/YourgithubName.github.io.git</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure><br>YourgithubName就是你的GitHub账户</p>
<p>这个时候需要先安装deploy-git ，也就是部署的命令,这样你才能用命令部署到GitHub。<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure><br>然后<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo clean</span><br><span class="line">hexo generate</span><br><span class="line">hexo deploy</span><br></pre></td></tr></table></figure></p>
<p>其中 hexo clean清除了你之前生成的东西，也可以不加。<br>hexo generate 顾名思义，生成静态文章，可以用 hexo g缩写<br>hexo deploy 部署文章，可以用hexo d缩写</p>
<p>注意deploy时可能要你输入username和password。</p>
<p>得到下图就说明部署成功了，过一会儿就可以在<a href="http://yourname.github.io">http://yourname.github.io</a> 这个网站看到你的博客了！！</p>
<h3 id="（4）Hexo基本配置"><a href="#（4）Hexo基本配置" class="headerlink" title="（4）Hexo基本配置"></a>（4）Hexo基本配置</h3><h4 id="Hexo框架配置"><a href="#Hexo框架配置" class="headerlink" title="Hexo框架配置"></a>Hexo框架配置</h4><p>文件根目录下的_config.yml，就是整个hexo框架的配置文件了。可以在里面修改大部分的配置。</p>
<p>这里列出几个比较主要的配置参数：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>参数</th>
<th>描述</th>
<th>例子</th>
</tr>
</thead>
<tbody>
<tr>
<td>title</td>
<td>网站标题</td>
<td>xxx的博客</td>
</tr>
<tr>
<td>subtitle</td>
<td>网站副标题</td>
<td>技术记录</td>
</tr>
<tr>
<td>description</td>
<td>网站描述</td>
<td>一个技术宅的博客</td>
</tr>
<tr>
<td>author</td>
<td>您的名字</td>
<td>author</td>
</tr>
<tr>
<td>language</td>
<td>网站使用的语言</td>
<td>zh-CN</td>
</tr>
<tr>
<td>timezone</td>
<td>网站时区,默认使用电脑时区</td>
<td>Asia/Shanghai</td>
</tr>
</tbody>
</table>
</div>
<h4 id="文件配置"><a href="#文件配置" class="headerlink" title="文件配置"></a>文件配置</h4><p>输入命令<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo new newpaper</span><br></pre></td></tr></table></figure><br>可以创建一篇新的文章。newpaper为文章的名字，格式为markdown文件。</p>
<p>在文件最上方以 —- 分隔的区域，可用于指定个别文件的变量，举例来说：<br><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: Hexo个人博客搭建及主题配置教程</span><br><span class="line">date: 2022-09-11 18:28:06</span><br><span class="line">tags: Hexo</span><br><span class="line"><span class="section">categories: 教程</span></span><br><span class="line"><span class="section">---</span></span><br></pre></td></tr></table></figure><br>以下是预先定义的参数，可在模板中使用这些参数值并加以利用。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>参数</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>layout</td>
<td>布局</td>
</tr>
<tr>
<td>title</td>
<td>标题</td>
</tr>
<tr>
<td>date</td>
<td>建立日期</td>
</tr>
<tr>
<td>updated</td>
<td>更新日期</td>
</tr>
<tr>
<td>comments</td>
<td>开启文章的评论功能</td>
</tr>
<tr>
<td>tags</td>
<td>标签（不适用于分页）</td>
</tr>
<tr>
<td>categories</td>
<td>分类（不适用于分页）</td>
</tr>
<tr>
<td>permalink</td>
<td>覆盖文章网址</td>
</tr>
</tbody>
</table>
</div>
<p>其中，分类和标签需要区别一下，分类具有顺序性和层次性，也就是说 Foo, Bar 不等于 Bar, Foo；而标签没有顺序和层次。</p>
<h2 id="三、更换主题"><a href="#三、更换主题" class="headerlink" title="三、更换主题"></a>三、更换主题</h2><p>本文将以NexT主题为例</p>
<h3 id="（1）安装并启用-NexT-主题"><a href="#（1）安装并启用-NexT-主题" class="headerlink" title="（1）安装并启用 NexT 主题"></a>（1）安装并启用 NexT 主题</h3><h4 id="安装主题"><a href="#安装主题" class="headerlink" title="安装主题"></a>安装主题</h4><p>打开博客根目录文件夹，右键Git Bash，输入如下代码将next主题下载到目录<code>./themes</code>：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/theme-next/hexo-theme-next themes/next</span><br></pre></td></tr></table></figure><br>打开主题文件夹下的package.json文件可以查看NexT主题版本。本文使用的版本为<br><figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="attr">&quot;version&quot;</span><span class="punctuation">:</span> <span class="string">&quot;7.8.0&quot;</span><span class="punctuation">,</span></span><br></pre></td></tr></table></figure></p>
<h4 id="启用主题"><a href="#启用主题" class="headerlink" title="启用主题"></a>启用主题</h4><p>打开根目录下的_config.yml(称为站点配置文件)，修改主题（注意冒号后都要有空格）。搜索theme参数，修改为next<br><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">theme:</span> <span class="string">next</span></span><br></pre></td></tr></table></figure><br>另外next主题有四种样式，分别为Muse、Mist、Pisces、Gemini，这里设置为Gemini，在<code>./themes/next/</code>下的_config.yml（称为主题配置文件）中搜索参数Schemes，将要选的主题取消注释：<br><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment">#scheme: Muse</span></span><br><span class="line"><span class="comment">#scheme: Mist</span></span><br><span class="line"><span class="comment">#scheme: Pisces</span></span><br><span class="line"><span class="attr">scheme:</span> <span class="string">Gemini</span> <span class="comment"># 选择该主题</span></span><br></pre></td></tr></table></figure><br>回到根目录打开Git Bash，输入如下三条命令：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo clean</span><br><span class="line">hexo g</span><br><span class="line">hexo d</span><br></pre></td></tr></table></figure><br>将主题修改应用到网站上。</p>
<h3 id="（2）功能设置"><a href="#（2）功能设置" class="headerlink" title="（2）功能设置"></a>（2）功能设置</h3><h4 id="开启tags-categories"><a href="#开启tags-categories" class="headerlink" title="开启tags/categories"></a>开启tags/categories</h4><p>开启该功能，博客会将写过的文章按照tags或categories进行归类。</p>
<p>进入博客根目录下，输入命令<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo new page tags</span><br><span class="line">hexo new page categories</span><br></pre></td></tr></table></figure><br>会在<code>./source</code>下出现tags和categories文件夹。博客中将出现关于tags和categories的新页面。</p>
<p>打开文件夹中的文件，可以修改相关信息，类似于修改文章配置<br><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: 标签</span><br><span class="line">date: 2022-09-10 10:33:40</span><br><span class="line"><span class="section">type: &quot;tags&quot;</span></span><br><span class="line"><span class="section">---</span></span><br></pre></td></tr></table></figure></p>
<h4 id="修改侧边栏信息"><a href="#修改侧边栏信息" class="headerlink" title="修改侧边栏信息"></a>修改侧边栏信息</h4><p>在主题配置文件<code>./theme/next/_config.yml</code>中搜索avatar<br><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Sidebar Avatar</span></span><br><span class="line"><span class="attr">avatar:</span></span><br><span class="line">  <span class="comment"># Replace the default image and set the url here.</span></span><br><span class="line">  <span class="attr">url:</span> <span class="string">/images/avatar.jpg</span></span><br><span class="line">  <span class="comment"># If true, the avatar will be dispalyed in circle.</span></span><br><span class="line">  <span class="attr">rounded:</span> <span class="literal">true</span></span><br><span class="line">  <span class="comment"># If true, the avatar will be rotated with the cursor.</span></span><br><span class="line">  <span class="attr">rotated:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><br>在这里可以设置侧边栏的头像。包括头像图片，头像是否原型，鼠标放置是否会转动。</p>
<p>同样的文件搜索social<br><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">social:</span></span><br><span class="line">  <span class="attr">GitHub:</span> <span class="string">https://github.com/wokron</span> <span class="string">||</span> <span class="string">fab</span> <span class="string">fa-github</span></span><br><span class="line">  <span class="attr">E-Mail:</span> <span class="string">stringcatwok@gmail.com</span> <span class="string">||</span> <span class="string">fa</span> <span class="string">fa-envelope</span></span><br><span class="line">  <span class="comment">#Weibo: https://weibo.com/yourname || fab fa-weibo</span></span><br><span class="line">  <span class="comment">#Google: https://plus.google.com/yourname || fab fa-google</span></span><br><span class="line">  <span class="comment">#Twitter: https://twitter.com/yourname || fab fa-twitter</span></span><br><span class="line">  <span class="comment">#FB Page: https://www.facebook.com/yourname || fab fa-facebook</span></span><br><span class="line">  <span class="comment">#StackOverflow: https://stackoverflow.com/yourname || fab fa-stack-overflow</span></span><br><span class="line">  <span class="comment">#YouTube: https://youtube.com/yourname || fab fa-youtube</span></span><br><span class="line">  <span class="comment">#Instagram: https://instagram.com/yourname || fab fa-instagram</span></span><br><span class="line">  <span class="comment">#Skype: skype:yourname?call|chat || fab fa-skype</span></span><br></pre></td></tr></table></figure><br>可以设置相关的网络账户信息。</p>
<h4 id="修改代码框"><a href="#修改代码框" class="headerlink" title="修改代码框"></a>修改代码框</h4><p>搜索codeblock<br><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">codeblock:</span></span><br><span class="line">  <span class="comment"># Code Highlight theme</span></span><br><span class="line">  <span class="comment"># Available values: normal | night | night eighties | night blue | night bright | solarized | solarized dark | galactic</span></span><br><span class="line">  <span class="comment"># See: https://github.com/chriskempson/tomorrow-theme</span></span><br><span class="line">  <span class="attr">highlight_theme:</span> <span class="string">night</span></span><br><span class="line">  <span class="comment"># Add copy button on codeblock</span></span><br><span class="line">  <span class="attr">copy_button:</span></span><br><span class="line">    <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">    <span class="comment"># Show text copy result.</span></span><br><span class="line">    <span class="attr">show_result:</span> <span class="string">default</span></span><br><span class="line">    <span class="comment"># Available values: default | flat | mac</span></span><br><span class="line">    <span class="attr">style:</span> <span class="string">mac</span></span><br></pre></td></tr></table></figure><br>可以设置代码框相关的参数。包括代码主题、复制键是否开启、是否显示复制效果、代码框的样式（<code>style: mac</code>就可以设置成很美观的mac panel样式，不需要网上那些复杂的步骤）。</p>
<h3 id="（3）增加扩展"><a href="#（3）增加扩展" class="headerlink" title="（3）增加扩展"></a>（3）增加扩展</h3><h4 id="添加Live2D"><a href="#添加Live2D" class="headerlink" title="添加Live2D"></a>添加Live2D</h4><p>首先在博客目录下执行：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install -save hexo-helper-live2d</span><br></pre></td></tr></table></figure><br>然后在站点配置文件中加入：<br><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">live2d:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">scriptFrom:</span> <span class="string">local</span></span><br><span class="line">  <span class="attr">pluginRootPath:</span> <span class="string">live2dw/</span></span><br><span class="line">  <span class="attr">pluginJsPath:</span> <span class="string">lib/</span></span><br><span class="line">  <span class="attr">pluginModelPath:</span> <span class="string">assets/</span></span><br><span class="line">  <span class="attr">tagMode:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">log:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">model:</span></span><br><span class="line">    <span class="attr">use:</span> <span class="string">live2d-widget-model-hijiki</span> <span class="comment">#选择哪种模型</span></span><br><span class="line">  <span class="attr">display:</span></span><br><span class="line">    <span class="attr">position:</span> <span class="string">right</span></span><br><span class="line">    <span class="attr">width:</span> <span class="number">150</span></span><br><span class="line">    <span class="attr">height:</span> <span class="number">300</span></span><br><span class="line">  <span class="attr">mobile:</span></span><br><span class="line">    <span class="attr">show:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><br>接着下载对应模型<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install live2d-widget-model-hijiki</span><br></pre></td></tr></table></figure></p>
<h4 id="文章图片支持"><a href="#文章图片支持" class="headerlink" title="文章图片支持"></a>文章图片支持</h4><p>这里使用相对引用插入图片</p>
<p>安装插件<code>hexo-renderer-marked</code>：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install hexo-renderer-marked</span><br></pre></td></tr></table></figure><br>修改站点配置文件<br><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">post_asset_folder:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><br>同时在其中添加：<br><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">marked:</span></span><br><span class="line">  <span class="attr">prependRoot:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">postAsset:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><br>就可以进行图片的引用了。</p>
<h4 id="公式支持"><a href="#公式支持" class="headerlink" title="公式支持"></a>公式支持</h4><p>需要更换 Hexo 的 markdown 渲染引擎，hexo-renderer-kramed 引擎是在默认的渲染引擎 hexo-renderer-marked 的基础上修改了一些 bug ，两者比较接近，也比较轻量级。<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm uninstall hexo-renderer-marked --save</span><br><span class="line">npm install hexo-renderer-kramed --save</span><br></pre></td></tr></table></figure><br>执行上面的命令，先卸载原来的渲染引擎，再安装新的。</p>
<p>接下来到博客根目录下，找到<code>node_modules\kramed\lib\rules\inline.js</code>，修改 escape以及em变量的值：<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//escape: /^\\([\\`*&#123;&#125;\[\]()#$+\-.!_&gt;])/,</span></span><br><span class="line"><span class="attr">escape</span>: <span class="regexp">/^\\([`*\[\]()#$+\-.!_&gt;])/</span>,</span><br><span class="line"></span><br><span class="line"><span class="comment">//em: /^\b_((?:__|[\s\S])+?)_\b|^\*((?:\*\*|[\s\S])+?)\*(?!\*)/,</span></span><br><span class="line"><span class="attr">em</span>: <span class="regexp">/^\*((?:\*\*|[\s\S])+?)\*(?!\*)/</span>,</span><br></pre></td></tr></table></figure></p>
<p>然后在主题中开启MathJax。打开主题配置文件，搜索mathjax，改为<br><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># hexo-renderer-pandoc (or hexo-renderer-kramed) required for full MathJax support.</span></span><br><span class="line">  <span class="attr">mathjax:</span></span><br><span class="line">    <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">    <span class="comment"># See: https://mhchem.github.io/MathJax-mhchem/</span></span><br><span class="line">    <span class="attr">mhchem:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure></p>
<p>最后在写文章时，在开头开启mathjax<br><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: 雇佣K名工人的最低成本</span><br><span class="line">date: 2022-09-11 09:02:32</span><br><span class="line">tags: [LeetCode,优先队列,贪心,c++]</span><br><span class="line">categories: 算法</span><br><span class="line"><span class="section">mathjax: true </span></span><br><span class="line"><span class="section">---</span></span><br></pre></td></tr></table></figure><br>即可在文章中使用公式。</p>
<h3 id="（4）主题美化"><a href="#（4）主题美化" class="headerlink" title="（4）主题美化"></a>（4）主题美化</h3><h4 id="添加背景"><a href="#添加背景" class="headerlink" title="添加背景"></a>添加背景</h4><p>把想设置的背景放入./themes/next/source/images中，命名为background.jpg。在根目录的source文件夹下新建文件夹_data与style文件source/_data/styles.styl，输入以下代码<br><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">    <span class="attribute">background</span>:<span class="built_in">url</span>(<span class="string">/images/background.jpg</span>);</span><br><span class="line">    <span class="attribute">background-repeat</span>: no-repeat;</span><br><span class="line">    <span class="attribute">background-attachment</span>:fixed;</span><br><span class="line">    <span class="attribute">background-position</span>:<span class="number">100%</span> <span class="number">100%</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>再在主题_config.yml文件中找到对应的custom_file_path，去掉注释即可。<br><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">custom_file_path:</span></span><br><span class="line">  <span class="comment">#head: source/_data/head.swig</span></span><br><span class="line">  <span class="comment">#header: source/_data/header.swig</span></span><br><span class="line">  <span class="comment">#sidebar: source/_data/sidebar.swig</span></span><br><span class="line">  <span class="comment">#postMeta: source/_data/post-meta.swig</span></span><br><span class="line">  <span class="comment">#postBodyEnd: source/_data/post-body-end.swig</span></span><br><span class="line">  <span class="comment">#footer: source/_data/footer.swig</span></span><br><span class="line">  <span class="comment">#bodyEnd: source/_data/body-end.swig</span></span><br><span class="line">  <span class="comment">#variable: source/_data/variables.styl</span></span><br><span class="line">  <span class="comment">#mixin: source/_data/mixins.styl</span></span><br><span class="line">  <span class="attr">style:</span> <span class="string">source/_data/styles.styl</span></span><br></pre></td></tr></table></figure></p>
<h4 id="博客内容透明化"><a href="#博客内容透明化" class="headerlink" title="博客内容透明化"></a>博客内容透明化</h4><p>在上文新建的styles.styl文件中添加如下内容即可：<br><figure class="highlight css"><table><tr><td class="code"><pre><span class="line">//博客内容透明化</span><br><span class="line">//文章内容的透明度设置</span><br><span class="line"><span class="selector-class">.content-wrap</span> &#123;</span><br><span class="line">  <span class="attribute">opacity</span>: <span class="number">0.9</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//侧边框的透明度设置</span><br><span class="line"><span class="selector-class">.sidebar</span> &#123;</span><br><span class="line">  <span class="attribute">opacity</span>: <span class="number">0.9</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//菜单栏的透明度设置</span><br><span class="line"><span class="selector-class">.header-inner</span> &#123;</span><br><span class="line">  <span class="attribute">background</span>: <span class="built_in">rgba</span>(<span class="number">255</span>,<span class="number">255</span>,<span class="number">255</span>,<span class="number">0.9</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//搜索框（local-search）的透明度设置</span><br><span class="line"><span class="selector-class">.popup</span> &#123;</span><br><span class="line">  <span class="attribute">opacity</span>: <span class="number">0.9</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="四、结语"><a href="#四、结语" class="headerlink" title="四、结语"></a>四、结语</h2><p>搭建和美化博客的工作内容颇多，本人也花了许久功夫去查阅资料、不断尝试，才最终得到了一个比较好的效果。在这一过程中，给过我帮助的文章已经难以一一回忆起来，因此在最后不能给出一份引用资料，实在抱歉。<br>这里就列出一些我还能找得到的参考文章：</p>
<ul>
<li><a href="https://blog.csdn.net/sinat_37781304/article/details/82729029">https://blog.csdn.net/sinat_37781304/article/details/82729029</a></li>
<li><a href="https://blog.csdn.net/qq_34003239/article/details/100883213">https://blog.csdn.net/qq_34003239/article/details/100883213</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/265077468">https://zhuanlan.zhihu.com/p/265077468</a></li>
<li><a href="https://blog.csdn.net/yexiaohhjk/article/details/82526604">https://blog.csdn.net/yexiaohhjk/article/details/82526604</a></li>
<li><a href="https://www.snowmoon.top/2021/02/21/next%E4%B8%BB%E9%A2%98%E7%BE%8E%E5%8C%96/">https://www.snowmoon.top/2021/02/21/next%E4%B8%BB%E9%A2%98%E7%BE%8E%E5%8C%96/</a></li>
</ul>
]]></content>
      <categories>
        <category>教程</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo博客迁移教程</title>
    <url>/posts/33f55625/</url>
    <content><![CDATA[<h2 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h2><p>因为用了新的笔记本，为了继续更新自己的博客，我决定把原来那台笔记本上的博客资源迁移过来。不过呢，当然不能用u盘拷贝这种比较low的方法，最好还是把资源放到 github 上，这样不仅方便现在的迁移，更能防止数据丢失。</p>
<span id="more"></span>
<h2 id="二、将博客资源推送到仓库"><a href="#二、将博客资源推送到仓库" class="headerlink" title="二、将博客资源推送到仓库"></a>二、将博客资源推送到仓库</h2><p>如果你使用 hexo 搭建了自己的博客，并且把博客放到了 github 上，那么很容易注意到使用 hexo 部署时并不是将本地的所有内容推送到了 github，实际推送的只是 ./public 路径下的文件。而现在我们要做的就是将博客的所有资源推送到仓库，不仅是用于网页的部分。</p>
<p>我们选择就在博客网站所在的仓库存储博客资源，为了做到这一点，首先要在本地克隆一个仓库<br><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/&lt;username&gt;/&lt;username&gt;.github.io.git</span><br></pre></td></tr></table></figure></p>
<p>随后我们新建一个分支用于存储博客资源。该分支与博客网站所使用的 master 分支无关，因此最好创建成一个“孤儿”分支。<br><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git checkout --orphan &lt;branch_name&gt;</span><br></pre></td></tr></table></figure></p>
<p>切换到该分支后，原本随着克隆拉取到本地的文件现在依旧存在，需要将这些文件删除<br><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">rm</span> -rf .</span><br></pre></td></tr></table></figure></p>
<p>接着将位于本地的博客资源复制到该文件夹下。<br><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cp</span> -r &lt;old_blog_dir&gt;/* .</span><br></pre></td></tr></table></figure></p>
<p>这里需要注意，如果你使用了 next 等主题，并且是通过克隆仓库的方式下载的，那么此时应该把主题对应的项目路径下的 .git 文件夹删除。<br><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># take next theme as example</span></span><br><span class="line"><span class="built_in">rm</span> -r ./themes/next/.git</span><br></pre></td></tr></table></figure></p>
<p>以上的工作都完成后，将这些复制到仓库中的博客资源文件添加并提交<br><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git add .</span><br><span class="line">git commit -m <span class="string">&quot;commit info&quot;</span></span><br></pre></td></tr></table></figure></p>
<p>最后将本地分支推送到远程仓库的新分支中<br><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git push --set-upstream origin &lt;remote_branch_name&gt;</span><br></pre></td></tr></table></figure></p>
<h2 id="三、迁移博客"><a href="#三、迁移博客" class="headerlink" title="三、迁移博客"></a>三、迁移博客</h2><p>接下来要将博客迁移到另一台设备上。首先当然要下载 git 并配置用户名和邮箱<br><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">sudo apt install git</span><br><span class="line">git config --global user.name &lt;username&gt;</span><br><span class="line">git config --global user.email &lt;email&gt;</span><br></pre></td></tr></table></figure></p>
<p>之后克隆仓库并切换到博客资源所在的分支<br><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/&lt;username&gt;/&lt;username&gt;.github.io.git</span><br><span class="line"><span class="built_in">cd</span> &lt;username&gt;.github.io</span><br><span class="line">git checkout -b &lt;branch_name&gt; origin/&lt;remote_branch_name&gt;</span><br></pre></td></tr></table></figure></p>
<p>接着下载 nodejs、npm 和 hexo<br><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">sudo apt install nodejs</span><br><span class="line">sudo apt install npm</span><br><span class="line">sudo npm install -g hexo-cli</span><br></pre></td></tr></table></figure></p>
<p>最后下载项目中使用的其他包<br><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">npm install</span><br></pre></td></tr></table></figure></p>
<h2 id="四、在新设备上生成网页以及部署"><a href="#四、在新设备上生成网页以及部署" class="headerlink" title="四、在新设备上生成网页以及部署"></a>四、在新设备上生成网页以及部署</h2><p>hexo 的命令不用多说，可以用 <code>hexo g</code> 生成网页，并使用 <code>hexo s</code> 命令在本地运行。</p>
<p>最后使用 <code>hexo d</code> 将网页部署到 github 上。但是这时可能会出现如下的信息：<br><figure class="highlight text"><table><tr><td class="code"><pre><span class="line"># omit...</span><br><span class="line">Username for &#x27;https://github.com&#x27;: &lt;username&gt;</span><br><span class="line">Password for &#x27;https://wokron@github.com&#x27;: &lt;password&gt;</span><br><span class="line">remote: Support for password authentication was removed on August 13, 2021.</span><br><span class="line">remote: Please see https://docs.github.com/en/get-started/getting-started-with-git/about-remote-repositories#cloning-with-https-urls for information on currently recommended modes of authentication.</span><br><span class="line"># omit...</span><br></pre></td></tr></table></figure></p>
<p>这时就需要增加授权。可以使用 ssh 生成密钥。输入如下命令后按三次回车。<br><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">ssh-keygen -t rsa -C &lt;email&gt;</span><br></pre></td></tr></table></figure></p>
<p>之后查看 ~/.ssh/id_rsa.pub 中的明文密钥<br><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cat</span> ~/.ssh/id_rsa.pub</span><br></pre></td></tr></table></figure></p>
<p>进入 github，找到 Settings - SSH and GPG keys - SSH keys - New SSH Key，将该密钥粘贴并保存。之后输入如下命令查看密钥是否设置成功。<br><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">ssh git@github.com</span><br></pre></td></tr></table></figure></p>
<p>此时可能会输出如下内容，这时只要输入 yes 并回车即可。<br><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">The authenticity of host &#x27;[ssh.github.com]:443 ([20.205.243.160]:443)&#x27; can&#x27;t be established.</span><br><span class="line">ED25519 key fingerprint is &lt;fingerprint&gt;.</span><br><span class="line">This key is not known by any other names</span><br><span class="line">Are you sure you want to continue connecting (yes/no/[fingerprint])? </span><br></pre></td></tr></table></figure></p>
<p>最终出现如下输出则表示成功<br><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">PTY allocation request failed on channel 0</span><br><span class="line">Hi wokron! You&#x27;ve successfully authenticated, but GitHub does not provide shell access.</span><br><span class="line">Connection to ssh.github.com closed.</span><br></pre></td></tr></table></figure></p>
<p>最后打开博客的配置文件 _config.yml，将其中部署部分改为如下形式，使用 ssh 链接进行部署<br><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">deploy:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">git</span></span><br><span class="line">  <span class="attr">repo:</span> <span class="string">git@github.com:&lt;username&gt;/&lt;username&gt;.github.io.git</span></span><br><span class="line">  <span class="attr">branch:</span> <span class="string">master</span></span><br></pre></td></tr></table></figure></p>
<p>最后再次应用 <code>hexo d</code> 即可部署。</p>
]]></content>
      <categories>
        <category>教程</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo插入图片</title>
    <url>/posts/e01ea1fb/</url>
    <content><![CDATA[<h2 id="插入图片"><a href="#插入图片" class="headerlink" title="插入图片"></a>插入图片</h2><p><img src="blackcat.jpg" alt=""><br>以上图片被保存在路径<code>./Hexo插入图片/</code>中。插入图片使用的代码为：<br><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">![](<span class="link">blackcat.jpg</span>)</span><br></pre></td></tr></table></figure><br>注意这样写在VScode中无法显示图片。Vscode中写法应为：<br><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">![](<span class="link">/Hexo插入图片/blackcat.jpg</span>)</span><br></pre></td></tr></table></figure></p>
<h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>需要使用插件hexo-renderer-marked。利用命令直接安装：<br><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">npm install hexo-renderer-marked</span><br></pre></td></tr></table></figure><br>之后在config.yaml中更改配置如下：<br><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">&lt;!-- 用于在生成文章时生成对应的资源文件夹，请在配置文件中搜索并修改为true --&gt;</span><br><span class="line">post<span class="emphasis">_asset_</span>folder: true</span><br><span class="line"></span><br><span class="line">&lt;!-- 插件配置 --&gt;</span><br><span class="line">marked:</span><br><span class="line">  prependRoot: true</span><br><span class="line">  postAsset: true</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>测试</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>Java和C#中的反射机制</title>
    <url>/posts/afa82b33/</url>
    <content><![CDATA[<h2 id="一、反射简介"><a href="#一、反射简介" class="headerlink" title="一、反射简介"></a>一、反射简介</h2><p>反射是一种程序动态访问修改其状态或行为的机制。具体来说，反射提供了在程序运行时对代码进行操作的手段。</p>
<p>反射提高了程序的灵活性和扩展性，能使程序员通过字符串动态地实现程序的修改。它降低了代码间的耦合度，可以避免硬编码，实现代码的组件化。反射的这些特点在对灵活性和扩展性要求很高的框架上有巨大的作用。</p>
<p>当然，也需要注意到，反射通过字符串进行操作的方式是解释性的，这将导致性能的降低。</p>
<h2 id="二、反射的原理"><a href="#二、反射的原理" class="headerlink" title="二、反射的原理"></a>二、反射的原理</h2><p>对于拥有虚拟机（或者类似的东西，虚拟机只是一个不正规的名词）的语言，都存在加载字节码（同样不正规的名词）到虚拟机的过程。在这个过程中，虚拟机获取了有关类的信息，包括继承关系、包含的字段和方法等等。对于java来说，局部变量放在栈中，类实例放在堆中，程序方法放在方法区中。</p>
<p>对不使用反射的一般情况来说，方法调用更加直接。调用时虚拟机将根据编译时即确定的方法地址进行跳转。而对于反射，则需要根据字符串查找对应的类或方法。这样查找而非硬编码的过程就会影响性能。</p>
<h2 id="二、java中的反射"><a href="#二、java中的反射" class="headerlink" title="二、java中的反射"></a>二、java中的反射</h2><p>通过反射我们能获取java语言中的如下组成部分：包、类（和接口）、方法（一般/构造）、字段、注解。反射不能操作方法中的内容。</p>
<p>类是面向对象的基本单元，我们通过获取类来实现对程序的动态操作。</p>
<h3 id="（1）类和包"><a href="#（1）类和包" class="headerlink" title="（1）类和包"></a>（1）类和包</h3><p>“类” <code>Class&lt;?&gt;</code> 是一个用于表示类的类型。它有三种获取方式<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ClassName.class <span class="comment">// 类型名.class</span></span><br><span class="line">obj.getClass(); <span class="comment">// 对象.getClass</span></span><br><span class="line">Class.forName(String className); <span class="comment">// Class.forName(&quot;包含包路径的类型全称&quot;)</span></span><br></pre></td></tr></table></figure></p>
<p>前两种较好理解，相当于获取一个类型，我们可以用这编写一个类似于 <code>instanceof</code> 的函数。<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">boolean</span> <span class="title function_">typeof</span><span class="params">(Object obj, Class&lt;?&gt; cls)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> obj.getClass() == cls;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>当然这无法将子类也判断为真。值得注意的是这里我们直接使用了 <code>==</code> 而不是 <code>equals</code>。因为对于每一个类，Class&lt;?&gt;只用一个实例。</p>
</blockquote>
<p>但第三种才最为重要，它通过字符串获取了一个类型。这就为程序提供了灵活性。</p>
<p>获取了一个 <code>Class</code> 对象后，我们可以进一步获取其父类和实现的接口<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Class&lt;?&gt; cls = Class.forName(<span class="string">&quot;somepackages.someClass&quot;</span>);</span><br><span class="line">Class&lt;?&gt; superCls = cls.getSuperclass();</span><br><span class="line">Class&lt;?&gt;[] interfaces = cls.getInterfaces();</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>值得注意的是获取接口方法返回的是一个 <code>Class</code> 数组。这说明对于虚拟机来说本没有类和接口之分。</p>
</blockquote>
<p>调用 <code>getPackage</code> 可以获取包<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Package</span> <span class="variable">p</span> <span class="operator">=</span> cls.getPackage();</span><br></pre></td></tr></table></figure></p>
<p><code>Package</code> 类型保存了该包的一些信息，如名称、版本等等，不一一列举。</p>
<h3 id="（2）方法"><a href="#（2）方法" class="headerlink" title="（2）方法"></a>（2）方法</h3><p>通过反射机制可以获取类的方法。既可以获取方法集合也可以获取指定的方法。</p>
<p>获取方法集合的方法为<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Class&lt;?&gt; cls = Class.forName(&quot;somepackages.someClass&quot;);</span></span><br><span class="line">Method[] ms = cls.getMethods(); <span class="comment">// 只获取 public 方法</span></span><br><span class="line">Method[] ms = cls.getDeclaredMethods(); <span class="comment">// 获取所有方法</span></span><br></pre></td></tr></table></figure></p>
<p>获取特定的方法，需要指定方法签名。也就是方法的名称和其参数类型。<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Method</span> <span class="variable">m</span> <span class="operator">=</span> cls.getMethod(<span class="string">&quot;func1&quot;</span>, <span class="type">int</span>.class, <span class="type">double</span>.class);</span><br><span class="line"><span class="type">Method</span> <span class="variable">m</span> <span class="operator">=</span> cls.getDeclaredMethod(<span class="string">&quot;func2&quot;</span>, <span class="type">int</span>.class, cls);</span><br><span class="line"><span class="comment">// 参数类型 (String name, Class&lt;?&gt;... parameterTypes)</span></span><br></pre></td></tr></table></figure></p>
<p><code>Method</code> 类提供了一些方法以访问方法的相关信息，如名称、参数类型、返回值类型等等。通过函数名很容易理解，这里不一一列举。</p>
<p>如果想要调用方法的话，则需要调用 <code>Method</code> 类的 <code>invoke</code> 方法。<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">m.invoke(obj, param1, param2)</span><br><span class="line"><span class="comment">// 参数类型 (Object obj, Object... args) 其中第一个参数为要调用该方法的实例</span></span><br></pre></td></tr></table></figure></p>
<p>对于私有方法，不能直接调用，还需要通过 <code>setAccessible</code> 方法设置其为允许调用。<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">m.setAccessible(<span class="literal">true</span>); <span class="comment">// is accessible</span></span><br></pre></td></tr></table></figure></p>
<p>对于构造函数的获取也有类似的方法<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Constructor&lt;?&gt;[] cs = cls.getConstructors();</span><br><span class="line">Constructor&lt;?&gt;[] cs = cls.getDeclaredConstructors();</span><br><span class="line">Constructor&lt;?&gt; c = cls.getConstructor(<span class="type">int</span>.class);</span><br><span class="line">Constructor&lt;?&gt; c = cls.getDeclaredConstructor(<span class="type">double</span>.class);</span><br></pre></td></tr></table></figure></p>
<p>需要注意的是，调用构造函数所使用的方法不是 <code>invoke</code> 而是 <code>newInstance</code>。同时方法不包含对象参数（这是当然的）。<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">var</span> <span class="variable">ins</span> <span class="operator">=</span> c.newInstance(param1, param2);</span><br></pre></td></tr></table></figure></p>
<h3 id="（3）字段"><a href="#（3）字段" class="headerlink" title="（3）字段"></a>（3）字段</h3><p>同样使用反射机制获取类的字段，这与获取方法类似。对于获取特定字段，只需要指定字段名即可。<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Field[] fs = cls.getFields();</span><br><span class="line">Field[] fs = cls.getDeclaredFields();</span><br><span class="line"><span class="type">Field</span> <span class="variable">f</span> <span class="operator">=</span> cls.getField(<span class="string">&quot;fieldName&quot;</span>);</span><br><span class="line"><span class="type">Field</span> <span class="variable">f</span> <span class="operator">=</span> cls.getDeclaredField(<span class="string">&quot;fieldName&quot;</span>);</span><br></pre></td></tr></table></figure></p>
<p>我们希望实现字段的读写，这需要通过 <code>Field</code> 的 <code>get</code> 和 <code>set</code> 方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Object</span> <span class="variable">val</span> <span class="operator">=</span> f.get(obj);</span><br><span class="line">f.set(obj2, val);</span><br><span class="line"><span class="comment">// obj 和 obj2 为拥有被访问字段的实例</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意进行类型转换。字段的类型是在编译时确定的。</p>
</blockquote>
<h3 id="（4）注解"><a href="#（4）注解" class="headerlink" title="（4）注解"></a>（4）注解</h3><p>注解 <code>Annotation</code> 是一种特殊的类（就像异常也是一种特殊的类）。它能够被写在类（或接口）、方法、字段或包等等位置，用于为这些元素附加一些内容。如java内置的 <code>@Override</code> 注解就表达了 “其所注解的方法重写了父类方法” 的意思。</p>
<p>编译器会在编译期处理一些注解。但在运行阶段注解就只能通过反射访问。如果想要自定义注解，需要继承 <code>Annotation</code> 类。<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyAnnotation</span> <span class="keyword">extends</span> <span class="title class_">Annotation</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>同时还有另一种写法，由此可知注释本质上是接口<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> MyAnnotation2 &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>但关于注释的具体内容这里还是先打住吧，可能会另写一篇文章详细说明。还是看一下通过反射获取注解的方式吧。</p>
</blockquote>
<p>反射中所说明的其他对象都继承了 <code>AnnotatedElement</code> 类。这意味着他们都是 “可以被注解的”。他们都具有获取自己拥有的注解的方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">cls.getAnnotation(MyAnnotation.class);</span><br><span class="line">cls.getAnnotations();</span><br><span class="line">cls.getAnnotationsByType(MyAnnotation2.class);</span><br><span class="line"></span><br><span class="line">cls.getDeclaredAnnotation(MyAnnotation.class);</span><br><span class="line">cls.getDeclaredAnnotations();</span><br><span class="line">cls.getDeclaredAnnotationsByType(MyAnnotation2.class);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意 <code>getAnnotationsByType</code> 获取可重复注解；<code>DeclaredAnnotation</code> 指的是直接属于该对象，而非继承得来的注解</p>
</blockquote>
<p>不同的反射对象也有特殊的关于注解的方法，如 <code>Class</code> 有获取具有注解的方法集合的方法，<code>Method</code> 有获取具有注解的参数的方法。不一一列举。</p>
<h3 id="（5）泛型"><a href="#（5）泛型" class="headerlink" title="（5）泛型"></a>（5）泛型</h3><p>java的假泛型设计使得这个语言关于泛型的部分都十分麻烦，这里也是。</p>
<p>反射库中可以看到一些带有 <code>Generic</code> 字段的方法。如 <code>getGenericReturnType</code>。这些方法返回的类型不是 <code>Class</code> 而是 <code>Type</code>。<code>Type</code> 是 <code>Class</code> 的父类。<code>Type</code> 类还有用以支持泛型、泛型数组等类型的子类，如 <code>ParameterizedType</code>、<code>GenericArrayType</code> 这些子类各有方法用于获取其类型参数。</p>
<blockquote>
<p>也就是说，没有 <code>Generic</code> 字段的方法返回的只是类型擦除后的类型。</p>
</blockquote>
<p><code>ParameterizedType</code> 具有 <code>getActualTypeArguments</code> 方法，可以获取一个泛型类的泛型类型。如 <code>List&lt;Integer&gt;</code> 获取 <code>Integer</code> 类型。</p>
<p><code>GenericArrayType</code> 具有 <code>getGenericComponentType</code> 方法，可以获取一个泛型数组的泛型类型。</p>
<h2 id="三、C-中的反射"><a href="#三、C-中的反射" class="headerlink" title="三、C#中的反射"></a>三、C#中的反射</h2><p>C# 中的反射机制与java中类似，这里进行对比介绍。</p>
<p>C# 的反射机制能获取如下组成部分，类型、方法（构造、一般）、属性、字段、事件。</p>
<h3 id="（1）程序集"><a href="#（1）程序集" class="headerlink" title="（1）程序集"></a>（1）程序集</h3><p>程序集是C#自有的概念，指的是C#代码编译后产生的exe文件或dll文件。类似于java中的jar。可以动态地加载程序集，这一点类似于java中的 <code>ClassLoader</code>，但似乎更加灵活。</p>
<p>可以通过程序集名或程序集路径来加载程序集。<br><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">Assembly assembly = Assembly.Load(<span class="string">&quot;assemblyName&quot;</span>);</span><br><span class="line">Assembly assembly = Assembly.LoadFile(<span class="string">&quot;filePath&quot;</span>);</span><br><span class="line">Assembly assembly = Assembly.LoadFrom(<span class="string">&quot;assemblyFile&quot;</span>);</span><br></pre></td></tr></table></figure></p>
<p>之后使用类型全名获取类型或获取程序集中的所有类型<br><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">Type type = assembly.GetType(<span class="string">&quot;namespace.className&quot;</span>);</span><br><span class="line">Type[] type = assembly.GetTypes(); <span class="comment">// 获取程序集中的所有类型</span></span><br></pre></td></tr></table></figure></p>
<p>通过类型同样可以反过来获取程序集<br><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">Assembly assembly = type.Assembly;</span><br></pre></td></tr></table></figure></p>
<h3 id="（2）类型"><a href="#（2）类型" class="headerlink" title="（2）类型"></a>（2）类型</h3><p>类型 <code>Type</code> 同java <code>Type</code>。但没有假泛型导致的复杂子类。除了通过程序集，还有其他的获取类型的三种方式，类似于java。<br><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">Type t = <span class="keyword">typeof</span>(TypeName) <span class="comment">// typeof(类型名)</span></span><br><span class="line">Type t = obj.getType(); <span class="comment">// 对象.getClass</span></span><br><span class="line">Type t = Type.getType(String className); <span class="comment">// Class.forName(&quot;包含命名空间的类型全称&quot;)</span></span><br></pre></td></tr></table></figure></p>
<p>同样的，第三种方式最为关键。另外C#中也可以获取到父类和接口，这些内容不再重复。</p>
<h3 id="（3）方法"><a href="#（3）方法" class="headerlink" title="（3）方法"></a>（3）方法</h3><p>C#同样可以获取构方法集合和特定方法。<br><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">ConstructorInfo[] cs = t.GetConstructors();</span><br><span class="line">ConstructorInfo? c = t.GetConstructor(<span class="keyword">new</span> Type[]&#123;type1, type2&#125;); <span class="comment">// 参数类型(Type[] types)</span></span><br><span class="line"></span><br><span class="line">MethodInfo[] ms = t.GetMethods();</span><br><span class="line">MethodInfo? m = t.GetMethod(<span class="string">&quot;func1&quot;</span>, <span class="keyword">new</span> Type[]&#123;type1, type2&#125;);</span><br></pre></td></tr></table></figure></p>
<p>值得注意的是，<code>ConstructorInfo</code> 和 <code>MethodInfo</code> 都继承了 <code>MethodBase</code>。这意味着构造函数和一般函数在C#反射中都是函数，可以使用同样的 <code>Invoke</code> 方法调用。<br><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">object</span> newObj = c.Invoke(<span class="keyword">new</span> <span class="built_in">object</span>[]&#123;param1, param2&#125;);</span><br><span class="line">m.Invoke(obj, <span class="keyword">new</span> <span class="built_in">object</span>[]&#123;param1, param2&#125;);</span><br></pre></td></tr></table></figure></p>
<h3 id="（4）属性"><a href="#（4）属性" class="headerlink" title="（4）属性"></a>（4）属性</h3><p>属性相当于C#中的getter、setter函数。也是类的组成部分，也可以通过反射获取。<br><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">PropertyInfo? p = t.GetProperty(<span class="string">&quot;propertyName&quot;</span>);</span><br><span class="line">PropertyInfo[] ps = t.GetProperties();</span><br></pre></td></tr></table></figure></p>
<p>通过 <code>GetValue</code> 和 <code>SetValue</code> 进行属性的修改。<br><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">object</span>? val = p.GetValue(obj);</span><br><span class="line">p.setValue(obj2, val);</span><br></pre></td></tr></table></figure></p>
<h3 id="（5）字段"><a href="#（5）字段" class="headerlink" title="（5）字段"></a>（5）字段</h3><p>字段类似于java的字段<br><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">FieldInfo? f = t.GetField(<span class="string">&quot;fieldName&quot;</span>);</span><br><span class="line">FieldInfo[] fs = t.GetFields();</span><br></pre></td></tr></table></figure></p>
<p>同样通过 <code>GetValue</code> 和 <code>SetValue</code> 进行属性的修改。<br><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">object</span>? val = f.GetValue(obj);</span><br><span class="line">f.setValue(obj2, val);</span><br></pre></td></tr></table></figure></p>
<h3 id="（6）事件"><a href="#（6）事件" class="headerlink" title="（6）事件"></a>（6）事件</h3><p>从C#的角度讲，事件是只属于某一类的委托。因此单独作为反射的一部分。<br><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">EventInfo? e = t.GetEvent(<span class="string">&quot;eventName&quot;</span>);</span><br><span class="line">EventInfo[] es = t.GetEvents();</span><br></pre></td></tr></table></figure></p>
<p>每个事件具有 <code>Add</code> 和 <code>Remove</code> 方法。用于注册或删除方法。我们可以获取某一事件对应的方法<br><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">MethodInfo addHandler = e.GetAddMethod();</span><br><span class="line">MethodInfo removeHandler = e.GetRemoveMethod();</span><br></pre></td></tr></table></figure></p>
<p>之后，创建代理并将其添加到事件或从事件中删除。<br><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">Delegate d = Delegate.CreateDelegate(tDelegate, <span class="keyword">this</span>, miHandler); <span class="comment">// 创建代理</span></span><br><span class="line">Object[] handlerArgs = &#123; d &#125;;</span><br><span class="line">addHandler.Invoke(eventObj, handlerArgs);</span><br><span class="line">removeHandler.Invoke(eventObj, handlerArgs);</span><br></pre></td></tr></table></figure></p>
<h3 id="（7）类型成员"><a href="#（7）类型成员" class="headerlink" title="（7）类型成员"></a>（7）类型成员</h3><p>如上除程序集和类型之外的组成部分都是类型的成员。我们可以直接获取成员<br><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">MemberInfo[] members = t.GetMember(<span class="string">&quot;memberName&quot;</span>); <span class="comment">// 获取该名称的成员</span></span><br><span class="line">MemberInfo[] members = t.GetMembers(); <span class="comment">// 获取类型的所有public成员</span></span><br></pre></td></tr></table></figure></p>
<h3 id="（8）成员筛选"><a href="#（8）成员筛选" class="headerlink" title="（8）成员筛选"></a>（8）成员筛选</h3><p>我们有时希望之查找具有某些特征的成员，如只搜索私有成员或公共成员。这需要在如上获取成员的方法（不管是如第3节获取特定的成员，如方法。或是如上一节获取一般的成员）上设定参数 <code>bindingAttr:</code>。</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> m = type.GetMethod(<span class="string">&quot;func&quot;</span>, <span class="keyword">new</span> Type[]&#123;type1, type2&#125;,</span><br><span class="line">    bindingAttr: BindingFlags.Public);</span><br><span class="line"><span class="keyword">var</span> members = t.GetMembers(</span><br><span class="line">    bindingAttr: BindingFlags.NonPublic);</span><br></pre></td></tr></table></figure>
<p><code>bindingAttr:</code> 参数的类型是一个枚举类 <code>BindingFlags</code>。包含有许多设置参数，如</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>选项</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>IgnoreCase</td>
<td>忽略名称大小写</td>
</tr>
<tr>
<td>Public</td>
<td>查找公共成员</td>
</tr>
<tr>
<td>NonPublic</td>
<td>查找非公共成员</td>
</tr>
<tr>
<td>Static</td>
<td>查找静态成员</td>
</tr>
<tr>
<td>…</td>
<td>…</td>
</tr>
</tbody>
</table>
</div>
<blockquote>
<p>如果想要采取不止一种选项，可以对这些枚举值求按位或。如 <code>bindingAttr: BindingFlags.Public|BindingFlags.NonPublic</code></p>
</blockquote>
<h3 id="（9）特性"><a href="#（9）特性" class="headerlink" title="（9）特性"></a>（9）特性</h3><p>c#的特性（Attribute）与java的注解几乎一模一样。只不过声明方法略有区别，是用方括号括起来的。<br><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">[<span class="meta">MyAttribute(<span class="string">&quot;123&quot;</span>)</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">MyClass</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>C#中获取特性的方法更为优雅。<br><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">Attribute[] attrs = Attribute.GetCustomAttributes(t);</span><br><span class="line">Attribute attr = Attribute.GetCustomAttribute(</span><br><span class="line">    t, attributeType: <span class="keyword">typeof</span>(MyAttribute));</span><br></pre></td></tr></table></figure></p>
<h3 id="（10）泛型"><a href="#（10）泛型" class="headerlink" title="（10）泛型"></a>（10）泛型</h3><p>C#中反射的泛型十分简单。<br><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">Type[] gArgs = t.GetGenericArguments();</span><br></pre></td></tr></table></figure><br>这样就可以获取类型的泛型参数了（如果不是泛型类则数组长度为0）。对于类内的成员同样适用。</p>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>C#</tag>
        <tag>反射</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java注解与C#特性</title>
    <url>/posts/99f60659/</url>
    <content><![CDATA[<h2 id="一、元数据简介"><a href="#一、元数据简介" class="headerlink" title="一、元数据简介"></a>一、元数据简介</h2><p>元数据是指用来描述数据的数据。对编程语言来说，元数据可以为程序中元素添加额外的信息。这一功能可以被用于描述代码间关系，以及代码与其他资源的联系。</p>
<p>元数据可以被用于框架中。通过元数据可以实现在代码上对类的直接配置，避免编写如 xml 的配置文件。</p>
<p>Java 和 C# 都具有为程序中元素，如类、方法等等，添加元数据的方式。Java中称为注解，而C#中称为特性。注解和特性都通过反射获取，关于两者的获取方式，已经在前一篇文章中有所记述。本篇只讨论注解和特性的定义和使用。</p>
<h2 id="二、Java注解"><a href="#二、Java注解" class="headerlink" title="二、Java注解"></a>二、Java注解</h2><h3 id="注解的定义"><a href="#注解的定义" class="headerlink" title="注解的定义"></a>注解的定义</h3><p>如果想要自定义注解，需要继承 <code>Annotation</code> 类。<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyAnnotation</span> <span class="keyword">extends</span> <span class="title class_">Annotation</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>同时还有另一种写法，由此可知注释本质上是接口<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> MyAnnotation2 &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>和接口一样，注解可以添加静态变量</p>
</blockquote>
<p>我们可以为注解添加“参数”，比如 Spring 中的注解 <code>@Profile(value = &quot;dev&quot;)</code>。我们为其设置了 <code>value</code> 属性。</p>
<p>但是注解本是接口，不可能有保存数据的能力，要如何设置注解的属性呢？实际上，注解的属性在编写 <code>Annotation</code> 时是一个方法。即</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> MyProfile &#123;</span><br><span class="line">    String <span class="title function_">value</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>还可以为参数添加默认值<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> MyAnnotation3 &#123;</span><br><span class="line">    String <span class="title function_">value</span><span class="params">()</span>;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">number</span><span class="params">()</span> <span class="keyword">default</span> <span class="number">8</span>; <span class="comment">// set default number</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>注解经常和枚举一起使用。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> MyAnnotation4 &#123;</span><br><span class="line">    <span class="keyword">enum</span> <span class="title class_">SELECT_TYPE</span> &#123;TYPE_A, TYPE_B&#125;</span><br><span class="line">    SELECT_TYPE <span class="title function_">selectType</span><span class="params">()</span> <span class="keyword">default</span> TYPE_A;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="元注解"><a href="#元注解" class="headerlink" title="元注解"></a>元注解</h3><p>元注解是注解的元数据，也就是对注解的注解。元注解为注解设置额外的信息，如设置注解的作用对象等等。</p>
<h4 id="Documented"><a href="#Documented" class="headerlink" title="@Documented"></a>@Documented</h4><p>设置@Documented表明该注解能够出现在javadoc中。默认注解不会出现在javadoc中。</p>
<h4 id="Target"><a href="#Target" class="headerlink" title="@Target"></a>@Target</h4><p>设置注解的作用对象，如注解类、方法、构造方法等等。使用方式如下<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target(&#123;ElementType.METHOD, ElementType.CONSTRUCTOR&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> MyAnnotation5 &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><code>@Target</code> 表明注解 <code>@MyAnnotation5</code> 只能修饰方法和构造函数。</p>
<h4 id="Retention"><a href="#Retention" class="headerlink" title="@Retention"></a>@Retention</h4><p>@Retention 设置注解被保留的时间。分为“仅在源文件”、“在class文件中保留”和“直到运行时依旧存在”。对应枚举 <code>RetentionPolicy.SOURCE</code>、<code>RetentionPolicy.CLASS</code>和<code>RetentionPolicy.RUNTIME</code>。</p>
<h4 id="Inherited"><a href="#Inherited" class="headerlink" title="@Inherited"></a>@Inherited</h4><p>@Inherited 表示该注解所修饰的类，其子类也具有该注解。即注解也可被继承。</p>
<h4 id="Repeatable"><a href="#Repeatable" class="headerlink" title="@Repeatable"></a>@Repeatable</h4><p>@Repeatable 表示该注解可以多次修饰同一个地方。例如</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RepeatableAnnotation(&quot;123&quot;)</span></span><br><span class="line"><span class="meta">@RepeatableAnnotation(&quot;456&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestClass</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="注解的使用"><a href="#注解的使用" class="headerlink" title="注解的使用"></a>注解的使用</h3><p>注解可以看做存储有一定信息的类型。使用注解就是获取其存储的信息（或者特定的注解类型本身便可作为一种信息）。获取注解信息只需要调用注解接口定义的方法即可。</p>
<h2 id="三、C-特性"><a href="#三、C-特性" class="headerlink" title="三、C#特性"></a>三、C#特性</h2><h3 id="特性的定义"><a href="#特性的定义" class="headerlink" title="特性的定义"></a>特性的定义</h3><p>在C#中，特性就是一个类。可以定义类的所有成员种类，如方法、属性、字段等等，获取后也可以像一般类实例一样使用。自定义特性只需要继承 <code>Attribute</code> 类即可。</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> MyTestAttribute : Attribute</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Value &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyTestAttribute</span>()</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyTestAttribute</span>(<span class="params"><span class="built_in">string</span> <span class="keyword">value</span></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Value = <span class="keyword">value</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>约定特性类名称以 Attribute 结尾。要使用特性时，既可以使用特性类名，也可以使用去掉末尾 Attribute 后的名称。<br><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">[<span class="meta">MyTestAttribute(<span class="string">&quot;123&quot;</span>)</span>]</span><br><span class="line"><span class="keyword">public</span> TestClass</span><br><span class="line">&#123; &#125;</span><br><span class="line"></span><br><span class="line">[<span class="meta">MyTest(<span class="string">&quot;456&quot;</span>)</span>]</span><br><span class="line"><span class="keyword">public</span> TestClass2</span><br><span class="line">&#123; &#125;</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>注意特性类作为特性使用构造函数时传入的参数只能是简单类型如 <code>bool, int, double, string, Type, enums</code> 等等。</p>
</blockquote>
<p>同时特性类型中的属性也可以在特性修饰时设置，还举 <code>MyTest</code> 为例。使用方法为 <code>propertyName = constPropertyValue</code>。<br><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">[<span class="meta">MyTest(Value = <span class="string">&quot;789&quot;</span>)</span>]</span><br><span class="line"><span class="keyword">public</span> TestClass3</span><br><span class="line">&#123; &#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="特性设置"><a href="#特性设置" class="headerlink" title="特性设置"></a>特性设置</h3><p>类似于Java注解的元注解，也有对特性进行设置的方式。只需要使用 <code>AttributeUsage</code> 注解。<br><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">[<span class="meta">AttributeUsage(AttributeTargets.Class|AttributeTargets.Method, AllowMultiple = true, Inherited = true)</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">MyTest2Attribute</span> : <span class="title">Attribute</span></span><br><span class="line">&#123; &#125;</span><br></pre></td></tr></table></figure></p>
<p>上面的例子展示了可以对特性进行的所有设置：作用对象、是否可重复、是否可继承。</p>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>C#</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux-Mint双系统的安装及美化</title>
    <url>/posts/10a01cda/</url>
    <content><![CDATA[<h2 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h2><p>我的笔记本现在用起来很慢了。每次听到它嗡嗡的风扇声却又看不到它跑不出来结果的时候，就感觉它好似一头老驴，使劲却又力不从心，腿打着颤却也拉不动身后的货。所以我谋划着新买一台，就让之前的那台好好休息吧。</p>
<span id="more"></span>
<p>一想到买台新的笔记本，我的思绪就沿着这条道一直走下去：“要买什么样的配置呢？买了新的电脑要做些什么项目呢？要玩什么游戏呢？” 诸如此类。装一个 linux 系统也是这时产生的想法。有人可能会想，“这有什么用呢？难道 windows 就不能用吗？如果不得不用 linux，wsl 也是很好地办法，或者用虚拟机，甚至直接用 docker，都可以解决。” 确实，如果就满足当下的使用而言，将 linux 作为一个个人使用的真正的系统，相对于 windows 似乎并没有什么优点。</p>
<p>不过呢，我选择折腾这么一阵也并没有什么经过考量的理由，而仅仅是因为自己在主观上更加喜欢 linux 罢了。在我不算太长的接触并学习 linux 的时间里，我从这个系统中感受到了设计的一致性，这是我在更长时间的对 windows 的接触和学习中所没有体会到的。当然，或许在之后看来，我现在的理解也不过是浅薄的认识罢了。但是现在，我还是决定安装一个 linux 系统。</p>
<p>如果有读者的话，希望不要嫌弃我太过啰嗦（笑）。</p>
<h2 id="二、为什么是薄荷"><a href="#二、为什么是薄荷" class="headerlink" title="二、为什么是薄荷"></a>二、为什么是薄荷</h2><p>众所周知，linux 是内核，许多不同的组织在 linux 内核的基础上增加了其他必要的软件和应用，开发了不同的发行版。发行版的江湖中帮派林立，主要有三大派系，debian 系、redhat 系和 suse 系。各个派系中又有无数相互关联却又相互区分的发行版。如 debian 的 ubuntu、deepin；redhat 的 fedora、suse 的 opensuse。只需要把这些发行版的大名亮出来，就足以让人眼花缭乱了。</p>
<img src="/posts/10a01cda/complex-of-linux.jpg" class="" title="complex-of-linux">
<p>本人也在这些发行版中漂移不定了一段时间，但最终选择了 debian 系的 mint（薄荷）。主要有一下几个原因</p>
<ul>
<li>debian 系有着 apt 的超级牛力加持，.deb 格式的软件包使用作为广泛</li>
<li>mint 基于 ubuntu，ubuntu 是使用最为广泛的 linux 发行版</li>
<li>mint 精简了 ubuntu 下的一些功能，如 snap；并对初学者较为友好</li>
</ul>
<h2 id="三、安装操作系统"><a href="#三、安装操作系统" class="headerlink" title="三、安装操作系统"></a>三、安装操作系统</h2><p>我新买的电脑是联想拯救者 R9000P，配置如下<br>|设备|配置|<br>|—-|—-|<br>|处理器|AMD Ryzen 9 7945HX|<br>|内存| 16G|<br>|硬盘| 1T|<br>|显卡| Nvidia 4060 |</p>
<p>要安装的操作系统配置<br>|名称|版本|<br>|—-|—-|<br>|操作系统|Linux Mint 21.1 Cinnamon|<br>|Cinnamon 版本|5.6.8|<br>|Linux 内核|5.15.0-75-generic|</p>
<p>接下开始安装。</p>
<h3 id="（1）windows-分盘"><a href="#（1）windows-分盘" class="headerlink" title="（1）windows 分盘"></a>（1）windows 分盘</h3><p>如果电脑中只有一个系统，那么当然就是这个系统占用所有的磁盘空间了。但是对于双系统，就需要将不同系统所使用的磁盘空间分离开来。</p>
<img src="/posts/10a01cda/disk1.png" class="" title="disk1">
<p>这里直接使用 windows 自带的磁盘管理工具进行分盘。可以在搜索栏里搜索 “磁盘分区” 并点击 “创建并格式化磁盘分区”。</p>
<img src="/posts/10a01cda/disk2.png" class="" title="disk2">
<p>之后在想要分盘的磁盘空间处点击右键，选择压缩卷。随后修改“输入压缩空间量”部分的数值，将其设定为你想要分配给另一个操作系统的磁盘空间大小。点击压缩。</p>
<img src="/posts/10a01cda/disk3.png" class="" title="disk3">
<p>此时应该会出现一块未分配的磁盘空间。这就是将来我们要将 linux 操作系统挂载到的位置。当然此处我已经为 linux 系统分配了 200g 的空间，并已经成功安装了。</p>
<h3 id="（2）usb-启动盘的制作"><a href="#（2）usb-启动盘的制作" class="headerlink" title="（2）usb 启动盘的制作"></a>（2）usb 启动盘的制作</h3><p>接下来我们要将一个 u 盘做成 linux 系统的启动盘。首先我们要去 <a href="https://linuxmint.com/">linux mint 官网</a>下载 mint 发行版的光盘镜像。</p>
<p>这里本人选择下来 Cinnamon 版。除此之外 mint 还提供了 MATE 和 Xfce 版。Cinnamon、MATE 和 Xfce 是不同的 linux 桌面环境，与 windows 统一的桌面（explorer.exe）不同，linux 中提供了多种多样的桌面环境。对于 mint 来说，Cinnamon 是其自身开发的桌面环境，因此我便选择该桌面了。</p>
<p>Cinnamon 版的<a href="https://linuxmint.com/edition.php?id=302">下载页</a>中提供了不同的镜像源，可以选择清华源进行<a href="https://mirrors.tuna.tsinghua.edu.cn/linuxmint-cd/stable/21.1/linuxmint-21.1-cinnamon-64bit.iso">下载</a>。</p>
<p>为了将该镜像装入 u 盘中，还需要下载 usb 启动盘制作工具。这里使用 Universal USB Installer（2.0.1.5）。可以在此<a href="https://www.pendrivelinux.com/universal-usb-installer-easy-as-1-2-3/">下载页</a>下载，或者直接点击<a href="https://www.pendrivelinux.com/downloads/Universal-USB-Installer/Universal-USB-Installer-2.0.1.5.exe">此处</a>。</p>
<blockquote>
<p>在继续之前需要强调一点，就是制作启动盘时，u 盘会被格式化，其中原有的数据都会被删除，因此请在制作之前做好 u 盘数据的备份。</p>
</blockquote>
<p>下载完 Universal USB Installer 后直接双击打开即可。随后选择发行版、镜像位置以及要制作成启动盘的 u 盘。点击 Create 按钮进行制作。此过程可能需要几分钟。</p>
<img src="/posts/10a01cda/usb.png" class="" title="usb">
<p>完成之后，u 盘就变成了 linux 系统的启动盘。现在将电脑关机，接下来就要开始真正的系统安装。</p>
<h3 id="（3）安装-linux-系统"><a href="#（3）安装-linux-系统" class="headerlink" title="（3）安装 linux 系统"></a>（3）安装 linux 系统</h3><blockquote>
<p>此节的部分图片引用自 <a href="https://www.sysgeek.cn/install-linux-mint-21/">如何安装 Linux Mint 21 桌面版，详细步骤</a></p>
</blockquote>
<p>把 usb 启动盘插到要安装的电脑上，开机，并进入 boot menu。进入的方法可能因为笔记本的型号不同而有所差别，但对于 R9000P 来说，方法是在开机但还未启动的时候按 F12 键（为了避免错过可以不断按 F12 直到成功进入）。在 boot menu 中可以选择启动方式。这里需要选择带有 linpus lite 的启动选项（上下方向键选择、回车键确认）。之后就进入了一个 linux mint 的桌面环境。</p>
<p>但是目前的这个 linux mint 依旧在 u 盘上，需要双击桌面上的 Install Linux Mint 将系统安装到磁盘上。</p>
<img src="/posts/10a01cda/install1.jpg" class="" title="install">
<p>在安装界面，首先选择语言、键盘布局等，这些当然都选择 Chinese 即可。之后也需要安装多媒体编码译码器。</p>
<p>随后选择安装类型。因为要安装双系统，所以不能选 “清除整个磁盘并安装 Linux Mint” 选项，而要选择 “其它选项”。</p>
<img src="/posts/10a01cda/install2.jpg" class="" title="instal2">
<p>接着要选择操作系统要安装到的分区，这个分区我们已经在 windows 中划分出来了。右键点击该分区，选择 Ext4 日志文件系统，挂载点为根目录 <code>/</code>。继续。</p>
<img src="/posts/10a01cda/install3.jpg" class="" title="install">
<p>然后设置位置，当然是自行选择了。该位置会影响时区。</p>
<p>最后创建用户账户，也是自行填写即可。点击继续后就会开始 linux mint 系统的安装。安装完成后重启，并在 crub 系统选择界面选择 linux mint 进入即可。</p>
<h3 id="（4）踩坑和解决"><a href="#（4）踩坑和解决" class="headerlink" title="（4）踩坑和解决"></a>（4）踩坑和解决</h3><p>这一部分记录了我在安装时踩得坑，或许比较幸运，并没有花费太长的时间解决。</p>
<h4 id="成功安装但无法启动"><a href="#成功安装但无法启动" class="headerlink" title="成功安装但无法启动"></a>成功安装但无法启动</h4><p>接着上一节，重启之后你可能会发现新安装的系统无法启动。显示的错误提示类似于如下内容<br><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">error: bad shim signature</span><br><span class="line">error: you need to load the kernel first</span><br></pre></td></tr></table></figure></p>
<p>或是<br><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">错误：无效的 shim 签名。</span><br><span class="line">错误：您需要先加载内核。</span><br></pre></td></tr></table></figure></p>
<p>这是由于 UEFI 开启了 secure boot 导致的。secure boot 要求在其上运行的系统必须具有正确的 shim 签名，否则无法运行。对于预装的 windows 系统来说，当然内置了 shim 签名；但是自行安装的系统，尤其是作为自由软件的 linux，就不太能提供正确的签名了。这一行为虽然确实能在一定程度上保护硬件的安全，但却更是被微软作为保持其 windows 系统垄断地位的手段。secure boot 模式可以在 bios 中选择是否启用。此前似乎也存在一旦关闭 secure boot 则无法再次启用的情况，不过厂商最终还是做出了让步。</p>
<p>要禁用 secure boot，首先需要关机再重新开机，在系统启动之前进入 bios，对于 R9000P 来说就是按 F2 键。不同厂商的 bios 外观不同，因此无法统一说明。但是只要找到 secure boot 相关的选项，并禁用该选项即可。应用修改后重新尝试进入 linux 系统。</p>
<h4 id="休眠后黑屏无法唤醒"><a href="#休眠后黑屏无法唤醒" class="headerlink" title="休眠后黑屏无法唤醒"></a>休眠后黑屏无法唤醒</h4><p>合上笔记本的盖子，或者长时间不使用笔记本，笔记本就会进入休眠状态。此时采取按键等手段在正常情况下应该能唤醒笔记本。但是本人的笔记本在 linux 系统下会保持黑屏，但是电源灯、键盘灯、鼠标灯均表明系统已经被唤醒。</p>
<p>很明显，这是显示的问题。原因其实是 linux mint 系统在安装时默认采用 Nvidia 显卡的开源驱动 Nouveau，该驱动并没有得到 Nvidia 的认可与支持，只是让用户安装完系统即可进入桌面罢了。</p>
<p>所以还需要更换显卡的驱动，linux mint 提供了很方便的更换手段。其实在一开始进入 linux mint 时的欢迎页上，就有更换驱动的选项，可惜我那时并没有更新。不过就算错过了，只要在搜索栏里搜索 driver 并选择驱动管理器选项也可以更换显卡驱动。</p>
<p>只需要将原本开源的驱动改为 linux mint 标识了 “推荐” 的驱动即可，注意需要重启。之后再让笔记本进入休眠状态并唤醒，就不会出现黑屏了。</p>
<h2 id="四、系统的美化"><a href="#四、系统的美化" class="headerlink" title="四、系统的美化"></a>四、系统的美化</h2><p>系统装是装上了，可总感觉有些朴素，长得也和 windows 没有什么区别。其实 linux 桌面的精髓是定制化。美化也是其中很重要的一部分。这一部分当然不是为了让读者做出和我一样的桌面，而只是记录一些可以用于美化的手段，也便于自己日后的使用。</p>
<h3 id="（1）主题配置"><a href="#（1）主题配置" class="headerlink" title="（1）主题配置"></a>（1）主题配置</h3><p>在搜索框中输入 theme 找到 “主题” 功能，可以用来修改桌面的整体外貌。可以在其中的 “添加/删除” 直接下载配置好的主题并应用；或者可以在如下的资源网站中搜索主题并下载。</p>
<ul>
<li><a href="https://www.cinnamon-look.org/">https://www.cinnamon-look.org/</a></li>
<li><a href="https://www.pling.com/">https://www.pling.com/</a></li>
</ul>
<p>下载后，将其中的内容放到用户 home 目录下的隐藏文件夹中即可。比如对于图标，放入 .icons 中；对于主题，放入 .themes 文件夹中。</p>
<h3 id="（2）桌面小程序"><a href="#（2）桌面小程序" class="headerlink" title="（2）桌面小程序"></a>（2）桌面小程序</h3><p>右击面板可以为面板添加不同的小程序。这里可以列出我所使用的一些小程序</p>
<ul>
<li>Cinnamenu</li>
<li>Corner bar</li>
<li>XApp 状态小应用</li>
<li>日历</li>
<li>窗口列表</li>
<li>…</li>
</ul>
<h3 id="（3）桌面布局"><a href="#（3）桌面布局" class="headerlink" title="（3）桌面布局"></a>（3）桌面布局</h3><p>mint 可以修改桌面的布局。比如右击面板，点击移动可以将面板移动到桌面的上面。另外右键面板后也可以启用面板编辑模式，从而按照自己的需要排布分布在面板上的不同小程序的位置。</p>
<h3 id="（4）plank"><a href="#（4）plank" class="headerlink" title="（4）plank"></a>（4）plank</h3><p>plank 提供了一个轻量简洁的面板，可以直接通过 apt 下载<br><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">sudo apt-get install plank</span><br></pre></td></tr></table></figure></p>
<p>下载完成后在搜索栏中搜索 plank 并点击打开，就可以看到桌面底端出现了一个面板。我们可以将该程序添加到开机启动项中。只需要在搜索栏中搜索 setting，点击系统设置；在系统设置中搜索 “开机自启动程序”，并将 plank 添加到其中即可。这样就得到了一个看上去更加美观的面板了。</p>
<h3 id="（5）grub-的美化"><a href="#（5）grub-的美化" class="headerlink" title="（5）grub 的美化"></a>（5）grub 的美化</h3><p>每次开机选择系统时都会进入 gnu grub 界面。可是这个界面实在是显得有些古老了。其实 grub 也是可以美化的。比如我们可以在<a href="https://www.gnome-look.org/browse?cat=109&amp;ord=plinged">这个网站</a>找到 grub 美化的主题。</p>
<p>选择喜欢的主题后下载，解压后直接运行其中的 install.sh 脚本即可。</p>
]]></content>
      <categories>
        <category>踩坑记录</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Mint</tag>
      </tags>
  </entry>
  <entry>
    <title>MySCS云平台（一）——注册与登陆</title>
    <url>/posts/74b7a513/</url>
    <content><![CDATA[<h2 id="一、注册与登陆模块"><a href="#一、注册与登陆模块" class="headerlink" title="一、注册与登陆模块"></a>一、注册与登陆模块</h2><p>该模块执行注册和登陆操作。从本质上说，也就是进行用户信息的添加，以及更改当前登陆的用户信息。因此我们还要定义一个储存用户信息的类</p>
<h2 id="（1）用户信息（UserInfo）"><a href="#（1）用户信息（UserInfo）" class="headerlink" title="（1）用户信息（UserInfo）"></a>（1）用户信息（UserInfo）</h2><p>为什么是UserInfo而不是User呢？因为用户的操作是读入的命令行，所以并不需要一个User类来执行操作。在注册登录模块只需要显示用户的信息而已。（或许多用户的时候User类会出现？）</p>
<h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><p>重写toString方法</p>
<h3 id="字段"><a href="#字段" class="headerlink" title="字段"></a>字段</h3><ol>
<li>学工号</li>
<li>姓、名</li>
<li>邮箱</li>
<li>密码</li>
</ol>
<h3 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h3><p>暂无。注意构造函数只能有包括全部信息的。</p>
<h2 id="（2）注册与登陆控制器（LoginController）"><a href="#（2）注册与登陆控制器（LoginController）" class="headerlink" title="（2）注册与登陆控制器（LoginController）"></a>（2）注册与登陆控制器（LoginController）</h2><p>用来控制注册与登陆，在执行不正确的操作时会抛出异常。</p>
<h3 id="方法-1"><a href="#方法-1" class="headerlink" title="方法"></a>方法</h3><p>注册：无返回值，参数为用户的各项信息，用来创建一个新的用户。当用户信息不合法、已存在、密码不一致等情况发生时抛出异常<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">register</span><span class="params">(String ID, String firstName, String lastName, String email, String password, String passwordConfirm)</span>;</span><br></pre></td></tr></table></figure></p>
<p>登陆：无返回值，参数为一个学工号和一个密码，用来登陆一个用户。当用户不存在、密码不正确或已经登录的时候抛出异常<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">login</span><span class="params">(String ID, String password)</span>;</span><br></pre></td></tr></table></figure></p>
<p>打印信息：无返回值，无参数或有一个学工号作为参数，打印当前登陆的信息或学号对应的人的信息。当未登录、输入的学号不合法、不存在等等情况发生时抛出异常<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">printInfo</span><span class="params">()</span>;</span><br><span class="line"><span class="keyword">void</span> <span class="title function_">printInfo</span><span class="params">(String ID)</span>;</span><br></pre></td></tr></table></figure></p>
<p>退出登陆：无返回值、无参数。退出当前登陆，如果当前没有登陆则抛出异常。<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">logout</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure></p>
<h3 id="字段-1"><a href="#字段-1" class="headerlink" title="字段"></a>字段</h3><ol>
<li>储存用户信息的列表（<code>List&lt;UserInfo&gt;</code>）</li>
<li>当前登陆的用户<code>(UserInfo</code>)</li>
<li>当前程序所处的状态（<code>LoginStatus</code>枚举）</li>
</ol>
<h3 id="算法-1"><a href="#算法-1" class="headerlink" title="算法"></a>算法</h3><p>一个有限状态机，包含这样几种状态：未登录、学生登陆、教师登录。利用函数进行状态转换。不合理的转换会抛出异常。</p>
]]></content>
      <categories>
        <category>软件开发</category>
      </categories>
      <tags>
        <tag>MySCS云平台</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL的中文插入问题</title>
    <url>/posts/4754b2bd/</url>
    <content><![CDATA[<h2 id="一、问题描述"><a href="#一、问题描述" class="headerlink" title="一、问题描述"></a>一、问题描述</h2><p>在执行一个sql脚本的时候出现了这样的问题：<br><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">ERROR 1366 (HY000): Incorrect string value: &#x27;\xA3\x8E\xE6\x9C\x89\xE5...&#x27; for column &#x27;name_zh&#x27; at row 1</span><br></pre></td></tr></table></figure></p>
<p>问题很明显是由于中文引起的。查看报错的语句：<br><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `admin_menu` <span class="keyword">VALUES</span> (<span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;/admin&#x27;</span>, <span class="string">&#x27;AdminIndex&#x27;</span>, <span class="string">&#x27;首页&#x27;</span>, <span class="string">&#x27;el-icon-s-home&#x27;</span>, <span class="string">&#x27;AdminIndex&#x27;</span>, <span class="string">&#x27;0&#x27;</span>);</span><br></pre></td></tr></table></figure><br>是 “首页” 无法被识别。考虑是字符集的问题。</p>
<h2 id="二、问题处理"><a href="#二、问题处理" class="headerlink" title="二、问题处理"></a>二、问题处理</h2><h3 id="情况一：数据库字符集与脚本所用字符集不一致"><a href="#情况一：数据库字符集与脚本所用字符集不一致" class="headerlink" title="情况一：数据库字符集与脚本所用字符集不一致"></a>情况一：数据库字符集与脚本所用字符集不一致</h3><p>第一种可能是数据库所用的字符集和脚本字符集不一致，比如说建表时使用的字符集为 <code>latin1</code>，而脚本使用的却是 <code>utf-8</code>，这样就会导致错误。</p>
<p>输入命令，查看建库语句<br><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> <span class="keyword">CREATE</span> DATABASE wj;</span><br></pre></td></tr></table></figure><br><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">+--------------+----------------------------------------------------------------------------------------------------------------------------------------+</span><br><span class="line">| Database     | Create Database                                                                                                                        |</span><br><span class="line">+--------------+----------------------------------------------------------------------------------------------------------------------------------------+</span><br><span class="line">| white_jotter | CREATE DATABASE `wj` /*!40100 DEFAULT CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci */ /*!80016 DEFAULT ENCRYPTION=&#x27;N&#x27; */ |</span><br><span class="line">+--------------+----------------------------------------------------------------------------------------------------------------------------------------+</span><br></pre></td></tr></table></figure><br>显示所用字符集为 <code>utf8mb4</code>，说明数据库字符集与脚本所用字符集一致。</p>
<blockquote>
<p>若不一致，应该使用如下指令来修改<br><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> DATABASE 数据库名 <span class="type">CHARACTER</span> <span class="keyword">SET</span> utf8mb4;</span><br></pre></td></tr></table></figure></p>
<p>注意平常所说的 utf8 指 sql 中的 utf8mb4，而不是 sql 中的 utf8 或 utf8md3。sql 将 utf8md3 视为 utf8 似乎有历史的原因。utf8mb4 兼容 utf8md3，并可以表示更多的符号，一些表情符号也包含在 utf8mb4 中。</p>
</blockquote>
<h3 id="情况二：表字符集或列字符集与脚本所用字符集不一致"><a href="#情况二：表字符集或列字符集与脚本所用字符集不一致" class="headerlink" title="情况二：表字符集或列字符集与脚本所用字符集不一致"></a>情况二：表字符集或列字符集与脚本所用字符集不一致</h3><p>同样输入命令，查看建表语句<br><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> <span class="keyword">CREATE</span> <span class="keyword">TABLE</span> admin_menu;</span><br></pre></td></tr></table></figure><br><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">+------------+------------------------------------------------------------------------+</span><br><span class="line">| admin_menu | CREATE TABLE `admin_menu` (</span><br><span class="line">  `id` int NOT NULL AUTO_INCREMENT,</span><br><span class="line">  `path` varchar(64) DEFAULT NULL,</span><br><span class="line">  `name` varchar(64) DEFAULT NULL,</span><br><span class="line">  `name_zh` varchar(64) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci DEFAULT NULL,</span><br><span class="line">  `icon_cls` varchar(64) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci DEFAULT NULL,</span><br><span class="line">  `component` varchar(64) DEFAULT NULL,</span><br><span class="line">  `parent_id` int DEFAULT NULL,</span><br><span class="line">  PRIMARY KEY (`id`)</span><br><span class="line">) ENGINE=InnoDB AUTO_INCREMENT=17 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci |</span><br><span class="line">+------------+------------------------------------------------------------------------+</span><br></pre></td></tr></table></figure></p>
<p>显示表字符集和列字符集所用字符集依旧为 <code>utf8mb4</code>。</p>
<blockquote>
<p>类似的，如果不一致，应该使用如下指令来修改<br><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> 表名 <span class="type">CHARACTER</span> <span class="keyword">SET</span> utf8mb4;</span><br></pre></td></tr></table></figure></p>
</blockquote>
<h3 id="情况三：客户端字符集与脚本所用字符集不一致"><a href="#情况三：客户端字符集与脚本所用字符集不一致" class="headerlink" title="情况三：客户端字符集与脚本所用字符集不一致"></a>情况三：客户端字符集与脚本所用字符集不一致</h3><p>所谓的客户端字符集指的是用户输入的命令所用的字符集。</p>
<p>通过如下指令查看：<br><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> variables <span class="keyword">LIKE</span> <span class="string">&#x27;%char%&#x27;</span>;</span><br></pre></td></tr></table></figure><br><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">+--------------------------+-------------------------------------------+</span><br><span class="line">| Variable_name            | Value                                     |</span><br><span class="line">+--------------------------+-------------------------------------------+</span><br><span class="line">| character_set_client     | gbk                                       |</span><br><span class="line">| character_set_connection | gbk                                       |</span><br><span class="line">| character_set_database   | utf8mb4                                   |</span><br><span class="line">| character_set_filesystem | binary                                    |</span><br><span class="line">| character_set_results    | gbk                                       |</span><br><span class="line">| character_set_server     | utf8mb4                                   |</span><br><span class="line">| character_set_system     | utf8mb3                                   |</span><br><span class="line">| character_sets_dir       | D:\MySQL\MySQL Server 8.0\share\charsets\ |</span><br><span class="line">+--------------------------+-------------------------------------------+</span><br></pre></td></tr></table></figure><br>第一行 <code>character_set_client</code> 便是用户字符集，为 <code>gbk</code> 而非 <code>utf8mb4</code>。这就是 sql 指令中出现中文会产生错误的原因。</p>
<p>使用指令<br><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">set</span> character_set_client<span class="operator">=</span>utf8mb4;</span><br></pre></td></tr></table></figure><br>可以修改 <code>character_set_client</code> 为 <code>utf8mb4</code>。</p>
<p>类似的命令也可以修改 <code>character_set_connection</code> 和 <code>character_set_results</code>。这两个字符集分别是连接数据库的字符集和数据库向客户端返回时的字符集。另外这三个字符集也可以通过一条命令同时修改：<br><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SET</span> NAMES utf8mb4;</span><br></pre></td></tr></table></figure></p>
<p>注意这样的设置在重启后将会还原，永久设置字符集可以通过修改配置文件 <code>my.ini</code> 实现（<a href="https://stackoverflow.com/questions/20570246/change-database-variable-character-set-client-in-mysql">永久修改字符集</a>）。</p>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring依赖注入</title>
    <url>/posts/94547693/</url>
    <content><![CDATA[<h2 id="一、依赖注入"><a href="#一、依赖注入" class="headerlink" title="一、依赖注入"></a>一、依赖注入</h2><p>考虑这样一个例子，<code>CustomerDAO</code> 类使用了 <code>DBUtil</code> 类中的方法连接到 MySQL 数据库<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CustomerDAO</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">DBUtil</span> <span class="variable">databaseUtil</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DBUtil</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Customer <span class="title function_">findCustomerByName</span><span class="params">(String name)</span></span><br><span class="line">    &#123;</span><br><span class="line">        databaseUtil.doSomething()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>假设现在想要改为使用 Oracle 数据库，需要怎么做？可以使用 <code>OracleDBUtil</code> 继承 <code>DBUtil</code>，并重写其相关方法。但是由于 <code>CustomerDAO</code> 中将 DBUtil 实例添加到其初始化过程中。因此想要修改的话还是需要对 <code>CustomerDAO</code> 本身进行修改。这违反了开-闭原则。<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CustomerDAO</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">DBUtil</span> <span class="variable">databaseUtil</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OracleDBUtil</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Customer <span class="title function_">findCustomerByName</span><span class="params">(String name)</span></span><br><span class="line">    &#123;</span><br><span class="line">        databaseUtil.doSomething()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>为了使对 <code>dbUtil</code> 的修改不影响 <code>CustomerDAO</code> 本身，我们可以将实例的创建移到 <code>CustomerDAO</code> 之外。<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CustomerDAO</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> DBUtil databaseUtil;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">CustomerDAO</span><span class="params">(DBUtil databaseUtil)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">this</span>.databaseUtil = databaseUtil;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Customer <span class="title function_">findCustomerByName</span><span class="params">(String name)</span></span><br><span class="line">    &#123;</span><br><span class="line">        databaseUtil.doSomething()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>这样，我们就可以自主选择 DBUtil 的具体实现，同时不会造成对 CustomerDAO 的修改。保证了开闭原则，降低了代码的耦合程度，有助于更有效的代码复用。<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">DBUtil</span> <span class="variable">databaseUtil</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OracleDBUtil</span>();</span><br><span class="line"><span class="type">var</span> <span class="variable">customerDAO</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CustomerDAO</span>(databaseUtil) </span><br></pre></td></tr></table></figure></p>
<p>这样的方法称为依赖注入。也就是，一个类对其他类的依赖，并不存在于这个类中，而是通过构造函数或其他方法传入这个类中。这样就使得编程时只需要关注抽象的依赖，而不需要考虑具体的实现。</p>
<h2 id="二、spring的依赖注入"><a href="#二、spring的依赖注入" class="headerlink" title="二、spring的依赖注入"></a>二、spring的依赖注入</h2><p>依赖注入是 spring 的核心之一。spring 提供了通过 java 注释或 xml 进行依赖注入配置的方法。这里只介绍通过 java 注释实现的手动装配和自动装配。</p>
<p>接下来本文会举一个经典例子来比较手动装配和自动装配的不同。考虑我们需要一个 CDPlayer，其中包含 CD。CD 具有 <code>play()</code> 方法，需要 CDPlayer 调用才能播放。</p>
<h2 id="三、自动化装配"><a href="#三、自动化装配" class="headerlink" title="三、自动化装配"></a>三、自动化装配</h2><p>不管自动或手动装配，都需要创建配置类，并为其添加注释 <code>@Configuration</code>。这一配置类将提供可供 spring 维护的用于装配的类。这些类称为 Bean（爪哇咖啡豆！！）。<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CDPlayerConfig</span></span><br></pre></td></tr></table></figure></p>
<p>自动化装配方式中，用于指示类与类的依赖关系的标志分散在各个类中。给类添加注释 <code>@Component</code> 表示该类为一个 Bean。或者可以认为这表示配置类中会自动生成一个创建该类型 Bean 的方法。<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SgtPeppers</span> <span class="keyword">implements</span> <span class="title class_">CompactDisc</span></span><br></pre></td></tr></table></figure></p>
<p>同时在需要被注入的位置，需要添加 <code>@Autowired</code> 方法。表示该属性是自动装配的。<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> CompactDisc cd;</span><br></pre></td></tr></table></figure></p>
<p>最后，在配置类中再添加一条注释 <code>@ComponentScan</code>，表示该配置类会扫描对应路径下所有带 <code>@Component</code> 注释的类，为这些类创建生成 Bean 的方法。<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CDPlayerConfig</span></span><br></pre></td></tr></table></figure></p>
<blockquote>
<p><code>@ComponentScan</code> 默认扫描与配置类在同一包或在子包下的所有 Component，可以通过 <code>@ComponentScan(&quot;包名&quot;)</code> 或 <code>@ComponentScan(&#123;&quot;包名1&quot;, &quot;包名2&quot;&#125;)</code> 来设置扫描路径。</p>
</blockquote>
<p>最终各文件代码如下（去除导入语句，各文件在同一包目录下）：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// CompactDisc.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">CompactDisc</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">play</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// CDPlayerConfig.java</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CDPlayerConfig</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// SgtPeppers.java</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SgtPeppers</span> <span class="keyword">implements</span> <span class="title class_">CompactDisc</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">String</span> <span class="variable">title</span> <span class="operator">=</span> <span class="string">&quot;Sgt. Pepper&#x27;s Lonely Hearts Club Band&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">String</span> <span class="variable">artist</span> <span class="operator">=</span> <span class="string">&quot;The Beatles&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">play</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Playing &quot;</span> + title + <span class="string">&quot; by &quot;</span> + artist);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// CDPlayer.java</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CDPlayer</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> CompactDisc cd;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">playCD</span><span class="params">()</span> &#123;</span><br><span class="line">        cd.play();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>注意此时若直接通过 <code>new</code> 创建 <code>CDPlayer</code> 实例，<code>cd</code> 属性不会被装配。正确的使用方法是让 spring 托管对象的创建。这将在第五节介绍。</p>
<h2 id="四、注释手动装配"><a href="#四、注释手动装配" class="headerlink" title="四、注释手动装配"></a>四、注释手动装配</h2><p>手动装配 Bean 需要自行编写配置类。但是不需要在其他类中添加注释。</p>
<p>配置类只需要添加注释 <code>@Configuration</code>，而不需要 <code>@ComponentScan</code>。<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CDPlayerConfig</span></span><br></pre></td></tr></table></figure></p>
<p>接着在配置类中编写方法，返回值为要创建 Bean 的类型。在例子中，也就是要 <code>SgtPeppers</code> 和 <code>CDPlayer</code>。同时要对方法添加 <code>@Bean</code> 注释。<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> CompactDisc <span class="title function_">compactDisc</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">SgtPeppers</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> CDPlayer <span class="title function_">cdPlayer</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">CDPlayer</span>(sgtPeppers());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>注意在 <code>cdPlayer()</code> 方法中使用了 <code>CDPlayer</code> 的一个参数的构造函数。为了通过java 代码实现配置，实现对希望注入依赖的属性的访问（如构造函数，或 <code>setter</code>）是必要的。<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">CDPlayer</span><span class="params">(CompactDisc cd)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.cd = cd;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>通过 <code>new CDPlayer(sgtPeppers())</code>，我们就建立了 CDPlayer 和 SgtPeppers 的依赖关系。另外一种写法更加简洁，也更能体现组件之间的依赖关系。<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> CompactDisc <span class="title function_">compactDisc</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">SgtPeppers</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> CDPlayer <span class="title function_">cdPlayer</span><span class="params">(CompactDisc cd)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">CDPlayer</span>(cd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
</blockquote>
<p>最终各文件代码如下：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// CompactDisc.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">CompactDisc</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">play</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// CDPlayerConfig.java</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CDPlayerConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> CompactDisc <span class="title function_">sgtPeppers</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">SgtPeppers</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> CDPlayer <span class="title function_">cdPlayer</span><span class="params">(CompactDisc cd)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">CDPlayer</span>(cd);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// SgtPeppers.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SgtPeppers</span> <span class="keyword">implements</span> <span class="title class_">CompactDisc</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">String</span> <span class="variable">title</span> <span class="operator">=</span> <span class="string">&quot;Sgt. Pepper&#x27;s Lonely Hearts Club Band&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">String</span> <span class="variable">artist</span> <span class="operator">=</span> <span class="string">&quot;The Beatles&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">play</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Playing &quot;</span> + title + <span class="string">&quot; by &quot;</span> + artist);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// CDPlayer.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CDPlayer</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> CompactDisc cd;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">CDPlayer</span><span class="params">(CompactDisc cd)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.cd = cd;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">playCD</span><span class="params">()</span> &#123;</span><br><span class="line">        cd.play();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="五、Bean-的使用"><a href="#五、Bean-的使用" class="headerlink" title="五、Bean 的使用"></a>五、Bean 的使用</h2><p>终于到了 Bean 的使用部分。被 <code>@Bean</code> 或 <code>@Component</code> 注释，作为 Bean 的类，并不能直接通过 <code>new</code> 来创建实例，而只能通过被 Spring 托管的方式创建，这似乎类似于 jvm。</p>
<p>具体来说，要使用 Bean，需要创建一个 Spring 应用上下文（Application Context）的实例，并设定需要用到的 Bean 所在的配置类或 xml。通过这个实例获取各 Bean 对象实例，才能进行操作。</p>
<p>以 java 配置类为例，我们需要使用 CDPlayer 类，不能直接通过 <code>new</code> 创建实例。而是先创建上下文，并将配置类传入。<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">ApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AnnotationConfigApplicationContext</span>(CDPlayerConfig.class);</span><br></pre></td></tr></table></figure></p>
<p>接着才能获取 CDPlayer 实例，并调用其方法。<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">CDPlayer</span> <span class="variable">cdPlayer</span> <span class="operator">=</span> context.getBean(CDPlayer.class);</span><br><span class="line">cdPlayer.playCD();</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>Spring</tag>
        <tag>依赖注入</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring面向切面</title>
    <url>/posts/b452423a/</url>
    <content><![CDATA[<h2 id="一、面向切面（AOP）"><a href="#一、面向切面（AOP）" class="headerlink" title="一、面向切面（AOP）"></a>一、面向切面（AOP）</h2><p>有时，在按数据的处理流程编写程序时，我们不得不关心流程之外的情况，比如异常处理安全或日志。这些部分与主要事务交织在一起，使得代码功能不清，造成了强耦合。</p>
<p>面向切片（Aspect-Oriented Programming）就是为解决这样的问题产生的技术。该技术把那些横向影响了应用多处的功能从被其影响的主要事物流程中分离开来，作为切面。使流程只需要关注其本身，而切片则通过其他方式织入程序。</p>
<h2 id="二、面向切面的术语"><a href="#二、面向切面的术语" class="headerlink" title="二、面向切面的术语"></a>二、面向切面的术语</h2><p>正如面向对象有其术语一样，面向切面也有用于描述其技术的相关概念，在介绍 Spring 的面向切面前需要加以解释。</p>
<h3 id="通知（Advice）"><a href="#通知（Advice）" class="headerlink" title="通知（Advice）"></a>通知（Advice）</h3><p>通知是切面所具有的行为，也就是不采用面向切面编程时，那些与主要事务无关，应该被抽离出来的代码段。</p>
<h3 id="连接点（Join-Point）"><a href="#连接点（Join-Point）" class="headerlink" title="连接点（Join Point）"></a>连接点（Join Point）</h3><p>连接点是可以应用通知的地方，也就是能够执行切面所具有的行为的地方。</p>
<h3 id="切点（Poincut）"><a href="#切点（Poincut）" class="headerlink" title="切点（Poincut）"></a>切点（Poincut）</h3><p>切点是真正应用通知的地方，切点一定是连接点。</p>
<h3 id="切面（Aspect）"><a href="#切面（Aspect）" class="headerlink" title="切面（Aspect）"></a>切面（Aspect）</h3><p>切面是通知和切点的总和。当程序执行到切点所在的位置时，就会执行对应的通知。</p>
<h3 id="引入（Introduction）"><a href="#引入（Introduction）" class="headerlink" title="引入（Introduction）"></a>引入（Introduction）</h3><p>引入是作为切面的类作用到处理主要事务的类的过程。这一过程为处理主要事物的类引入了新的方法和属性，但却没有对这个类本身进行修改。</p>
<h3 id="织入（Weaving）"><a href="#织入（Weaving）" class="headerlink" title="织入（Weaving）"></a>织入（Weaving）</h3><p>织入是为了实现切面的引入而采取的操作。织入将切面引入目标对象，创建了融合切面和目标的代理对象。这一操作可以发生在编译期、类加载期和运行期，需要看具体的实现。Spring 会在运行期完成切面的织入。</p>
<h2 id="三、Spring的AOP：利用切点表达式选择切点"><a href="#三、Spring的AOP：利用切点表达式选择切点" class="headerlink" title="三、Spring的AOP：利用切点表达式选择切点"></a>三、Spring的AOP：利用切点表达式选择切点</h2><p>通知和切点共同组成了切面，在这一部分将讲述如何确定切点的位置。我们使用的是称为切点表达式的语法规范，用这一表达式确定我们所指定的切点，以便之后通知的编写。</p>
<p>Spring AOP 使用的是 AspectJ 切点指示器中的一部分，包括如下的内容</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>AspectJ指示器</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>arg()</td>
<td>限制连接点匹配参数为指定类型的执行方法</td>
</tr>
<tr>
<td>@args()</td>
<td>限制连接点匹配参数由指定注解标注的执行方法</td>
</tr>
<tr>
<td>execution()</td>
<td>用于匹配是连接点的执行方法</td>
</tr>
<tr>
<td>this()</td>
<td>限制连接点匹配AOP代理的bean引用为指定类型的类</td>
</tr>
<tr>
<td>target</td>
<td>限制连接点匹配目标对象为指定类型的类</td>
</tr>
<tr>
<td>@target()</td>
<td>限制连接点匹配特定的执行对象，这些对象对应的类要具有指定类型的注解</td>
</tr>
<tr>
<td>within()</td>
<td>限制连接点匹配指定的类型</td>
</tr>
<tr>
<td>@within()</td>
<td>限制连接点匹配指定注解所标注的类型（当使用Spring AOP时，方法定义在由指定的注解所标注的类里）</td>
</tr>
<tr>
<td>@annotation</td>
<td>限定匹配带有指定注解的连接点</td>
</tr>
</tbody>
</table>
</div>
<p>通过组合使用这些类似于函数的指示器的，就可以确定我们想要引入通知的连接点究竟在哪里。接下来我们通过一些示例展示切点表达式的使用。如<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">execution(* concert.Performance.perform(..))</span><br></pre></td></tr></table></figure><br>表示匹配一个在方法执行时触发的连接点，这个方法是 <code>concert</code> 包下的 <code>Performance</code> 类中名为 <code>perform</code> 的方法，不考虑方法的返回值和参数（匹配所有同名的 <code>perform</code> 方法）。</p>
<p>切点表达式中还可以使用与（&amp;&amp;）或（||）非（!）操作。如<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">execution(* concert.Performance.perform(..)) &amp;&amp; within(concert.*)</span><br></pre></td></tr></table></figure><br>表示同时满足是 concert 包下的类方法调用，并且满足上一条的条件的切点。</p>
<p>另外因为 Spring 具有依赖注入的功能，因此添加了一个新的切点指示器 <code>bean()</code> 用来通过 bean id 选择切点。<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">execution(* concert.Performance.perform()) &amp;&amp; bean(<span class="string">&#x27;woodstock&#x27;</span>)</span><br></pre></td></tr></table></figure></p>
<h2 id="四、Spring的AOP：基于注释的切面创建"><a href="#四、Spring的AOP：基于注释的切面创建" class="headerlink" title="四、Spring的AOP：基于注释的切面创建"></a>四、Spring的AOP：基于注释的切面创建</h2><h3 id="（1）创建第一个切面"><a href="#（1）创建第一个切面" class="headerlink" title="（1）创建第一个切面"></a>（1）创建第一个切面</h3><p>我们还以 CDPlayer 为例子，创建一个 Listener 作为切片。<br>我们首先要为切面类添加注释 <code>@Aspect</code>。<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Listener</span></span><br></pre></td></tr></table></figure></p>
<p>之后我们定义一些方法作为通知。并通过注释将其引入 <code>CDPlayer</code> 类。我们会在如下注释中选择：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>注解</th>
<th>通知调用位置</th>
</tr>
</thead>
<tbody>
<tr>
<td>@After</td>
<td>通知方法会在目标方法返回或抛出异常后调用</td>
</tr>
<tr>
<td>@AfterReturning</td>
<td>通知方法会在目标方法返回后调用</td>
</tr>
<tr>
<td>@AfterThrowing</td>
<td>通知方法会在目标方法抛出异常后调用</td>
</tr>
<tr>
<td>@Around</td>
<td>通知方法会将目标方法封装起来</td>
</tr>
<tr>
<td>@Before</td>
<td>通知方法会在目标方法调用之前执行</td>
</tr>
</tbody>
</table>
</div>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Listener</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="meta">@Before(&quot;execution(* playCD()) &amp;&amp; bean(cdPlayer)&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">waitingForMusic</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;waiting for listening...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@AfterReturning(&quot;execution(* playCD()) &amp;&amp; bean(cdPlayer)&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">appreciateTheMusic</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;this music is amazing!!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@AfterThrowing(&quot;execution(* playCD()) &amp;&amp; bean(cdPlayer)&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleSomethingWrongWithTheCDPlayer</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;there is something wrong, I need to fix this player.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@After(&quot;execution(* playCD()) &amp;&amp; bean(cdPlayer)&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">leaveAfterPlayingMusic</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;music finished, I will leave.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如上，我们确定了切点为 <code>CDPlayer</code> 的 <code>playCD</code> 方法，并对调用该方法之前，成功返回之后和抛出异常之后分别设置了通知。这样切面就创建完成了。接下来我们还需在配置类中将切面设置为 Bean，并添加注释 <code>@EnableAspectJAutoProxy</code> 以启用切片。这样所有的配置就完成了。<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableAspectJAutoProxy</span> <span class="comment">// here!!!</span></span><br><span class="line"><span class="meta">@PropertySource(&quot;classpath:application.properties&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CDPlayerConfig</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> CompactDisc <span class="title function_">blankDisc</span><span class="params">(</span></span><br><span class="line"><span class="params">            <span class="meta">@Value(&quot;$&#123;disc.title&#125;&quot;)</span> String title,</span></span><br><span class="line"><span class="params">            <span class="meta">@Value(&quot;$&#123;disc.artist&#125;&quot;)</span> String artist)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">BlankDisc</span>(title, artist);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> CDPlayer <span class="title function_">cdPlayer</span><span class="params">(CompactDisc cd)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">CDPlayer</span>(cd);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// here!!!</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Listener <span class="title function_">listener</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Listener</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="（2）切点的直接声明和使用"><a href="#（2）切点的直接声明和使用" class="headerlink" title="（2）切点的直接声明和使用"></a>（2）切点的直接声明和使用</h3><p>注意在定义切面的时候，切点表达式 <code>&quot;execution(* playCD()) &amp;&amp; bean(cdPlayer)&quot;</code> 出现了许多次，这无疑是代码的重复。我们可以利用注释 <code>@Pointcut</code> 声明该表达式，以便重用。<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Listener</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="meta">@Pointcut(&quot;execution(* playCD()) &amp;&amp; bean(cdPlayer)&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">playCDPointcut</span><span class="params">()</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Before(&quot;playCDPointcut()&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">waitingForMusic</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;waiting for listening...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@AfterReturning(&quot;playCDPointcut()&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">appreciateTheMusic</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;this music is amazing!!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@AfterThrowing(&quot;playCDPointcut()&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleSomethingWrongWithTheCDPlayer</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;there is something wrong, I need to fix this player.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@After(&quot;playCDPointcut()&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">leaveAfterPlayingMusic</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;music finished, I will leave.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><br>注意 <code>playCDPointcut()</code> 函数的声明和其他方法注释中值的变化。</p>
<h3 id="（3）环绕通知的使用"><a href="#（3）环绕通知的使用" class="headerlink" title="（3）环绕通知的使用"></a>（3）环绕通知的使用</h3><p>Spring AOP 中最强大的是环绕通知，由注释 <code>@Around</code> 声明。其他的通知调用位置注释不过是环绕通知的一部分。环绕通知的使用方法有些特殊，因此在这一节中单独讲解。</p>
<p>首先需要明确的是，切面的本质不过是一个代理（proxy），代理类的方法调用委托类中的对应方法，并在调用的前后添加一些额外的代码，从而实现更多功能。AOP 的作用不过是去除了声明代理类的过程，减少了事务与切面间的耦合而已。</p>
<p>环绕通知的使用也类似，如下就是通过环绕通知实现的与上一节等价的代码：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Listener</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="meta">@Pointcut(&quot;execution(* playCD()) &amp;&amp; bean(cdPlayer)&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">playCDPointcut</span><span class="params">()</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Around(&quot;playCDPointcut()&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">listenCDPlayer</span><span class="params">(ProceedingJoinPoint pjp)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;waiting for listening...&quot;</span>);</span><br><span class="line">            pjp.proceed();</span><br><span class="line">            System.out.println(<span class="string">&quot;this music is amazing!!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;there is something wrong, I need to fix this player.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">finally</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;music finished, I will leave.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="（4）处理参数"><a href="#（4）处理参数" class="headerlink" title="（4）处理参数"></a>（4）处理参数</h3><p>调用方法时，可能会传入参数，这些参数也可以被通知所处理。</p>
<p>我们可以在 CDPlayer 中添加一个方法 <code>playCD(int)</code> 设定播放的次数。然后获取该参数。<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">playCD</span><span class="params">(<span class="type">int</span> times)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; times; i++) &#123;</span><br><span class="line">        playCD();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>接着我们重写 <code>Listener</code> 切面。如下的代码我们将 times 传入了通知方法 <code>listenCDPlayer</code> 中。<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Listener</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="meta">@Pointcut(&quot;execution(* playCD(int)) &amp;&amp; bean(cdPlayer) &amp;&amp; args(times)&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">playCDPointcut</span><span class="params">(<span class="type">int</span> times)</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Before(&quot;playCDPointcut(times)&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">listenCDPlayer</span><span class="params">(<span class="type">int</span> times)</span> &#123;</span><br><span class="line">        System.out.printf(<span class="string">&quot;this music will play %d times.\n&quot;</span>, times);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>当使用多个参数时，函数中的类型名和 args() 中的参数名都用逗号隔开，如 <code>args(arg1, arg2)</code></p>
</blockquote>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>Spring</tag>
        <tag>面向切面</tag>
        <tag>AOP</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring高级装配</title>
    <url>/posts/fe377a4/</url>
    <content><![CDATA[<p>上一篇文章已经讲解了 spring 依赖注入装配的方法。但是为了处理一些特殊的问题，或者为了更好地实现某些功能，spring 还提供了更多的装配设置。</p>
<h2 id="一、条件化声明-Bean"><a href="#一、条件化声明-Bean" class="headerlink" title="一、条件化声明 Bean"></a>一、条件化声明 Bean</h2><p>让我们回到上一篇第一节的例子，假设这次我们需要在开发时使用 SQLite，而在生产环境使用 Oracle 要怎么办呢？</p>
<p>或许可以这样，我们在生产环境注意将 <code>DBUtil</code> Bean 改成 Oracle，把原来的部分注释掉，就像是这样。<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> DBUtil <span class="title function_">databaseUtil</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// return new SQLiteUtil(); // for dev</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">OracleUtil</span>(); <span class="comment">// for prod</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>但这样做很明显是不合适的。如果许多组件都需要进行调整的话，修改上就会十分复杂，且很容易出错。</p>
<p>我们可以使用注释 <code>@Profile</code> 实现不同环境条件下选择不同的装配方式。这需要给带有 <code>@Bean</code> 或 <code>@Configuration</code> 注释的方法或类添加注释 <code>@Profile(&quot;某某环境&quot;)</code>。于是数据库的选择就可以改为如下形式：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@Profile(&quot;dev&quot;)</span></span><br><span class="line"><span class="keyword">public</span> DBUtil <span class="title function_">sqliteUtil</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">SQLiteUtil</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@Profile(&quot;prod&quot;)</span></span><br><span class="line"><span class="keyword">public</span> DBUtil <span class="title function_">oracleUtil</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">OracleUtil</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>想要启用某个 Bean 需要设置环境。具体来说，这通过两个环境变量来实现，<code>spring.profiles.default</code> 和 <code>spring.profiles.active</code>。这两个值可以在许多地方定义。一种方式是在 properties 或 yaml 文件中定义，如<br><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment">#application.properties</span></span><br><span class="line"><span class="attr">spring.profiles.default</span>=<span class="string">dev #默认环境为 dev</span></span><br><span class="line"><span class="attr">spring.profiles.active</span>=<span class="string">prod #当前环境为 prod</span></span><br></pre></td></tr></table></figure></p>
<p>为了指明所使用的配置文件，还需在配置类添加注释 <code>@PropertySource</code>。<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@PropertySource(&quot;classpath:application.properties&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DBUtilConfig</span></span><br></pre></td></tr></table></figure></p>
<p>最终配置类代码为<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@PropertySource(&quot;classpath:application.properties&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DBUtilConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@Profile(&quot;dev&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> DBUtil <span class="title function_">sqliteUtil</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">SQLiteUtil</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@Profile(&quot;prod&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> DBUtil <span class="title function_">oracleUtil</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">OracleUtil</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>更一般的，还可以自定义使 Bean 或配置生效的条件，这需要用到 <code>@Conditional</code> 注释。</p>
<p>注释的使用形式如下<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@Conditional(SomethingIsTrueCondition.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConditionalConfig</span></span><br></pre></td></tr></table></figure><br>我们把一个类作为 <code>@Conditional</code> 注释的参数，这个类要继承 <code>Condition</code> 类，实现 <code>boolen matches(ConditionContext context, AnnotatedTypeMetadata metadata)</code> 方法。只有 <code>matches</code> 方法的返回值为真，才会使由 <code>@Conditional</code> 修饰的部分生效。</p>
<blockquote>
<p>其实 <code>@Profile</code> 注释也是由 <code>@Conditional</code> 所实现的。查看源码，就会发现<code>@Profile</code> 也有一个 <code>@Conditional</code> 注释。<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target(&#123;ElementType.TYPE, ElementType.METHOD&#125;)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Conditional(&#123;ProfileCondition.class&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Profile &#123;</span><br><span class="line">    String[] value();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
</blockquote>
<h2 id="二、消除自动装配的歧义"><a href="#二、消除自动装配的歧义" class="headerlink" title="二、消除自动装配的歧义"></a>二、消除自动装配的歧义</h2><p>在自动装配时，如果在 <code>@ComponentScan</code> 的扫描范围内有多个可以满足装配条件的组件（<code>@Component</code>），就会产生装配的歧义。自动装配无法决定应该装配哪一个。</p>
<p>还举数据库作为例子，有 <code>OracleDBUtil</code> <code>MySQLDBUtil</code> <code>SQLiteDBUtil</code> 都可以作为自动装配的组件，那么就无法确定应该装配哪一个。<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OracleDBUtil</span> <span class="keyword">extends</span> <span class="title class_">DBUtil</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MySQLDBUtil</span> <span class="keyword">extends</span> <span class="title class_">DBUtil</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SQLiteDBUtil</span> <span class="keyword">extends</span> <span class="title class_">DBUtil</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyDAO</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> DBUtil databaseUtil;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这种情况可以选择一个组件添加 <code>@Primary</code> 注释，表示若出现歧义时，优先选择该组件作为装配对象。<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Primary</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MySQLDBUtil</span> <span class="keyword">extends</span> <span class="title class_">DBUtil</span> &#123;&#125;</span><br></pre></td></tr></table></figure></p>
<p>另外也可以在注释的地方增加 <code>@Qualifier</code> 并添加参数，这将在注入处指定依赖。<code>@Qualifier</code> 的参数是 Bean 的 id，默认是将对应的类名的首字母变为小写作为 id，当然也可以通过在 <code>@Bean</code> 注释添加参数指定一个 id。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyDAO</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="meta">@Qualifier(&quot;mySQLDBUtil&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> DBUtil databaseUtil;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>指定 bean id<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean(&quot;renameBean&quot;)</span></span><br><span class="line"><span class="keyword">public</span> DBUtil <span class="title function_">mySQLDBUtil</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">MySQLDBUtil</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
</blockquote>
<h3 id="三、Bean-的作用域"><a href="#三、Bean-的作用域" class="headerlink" title="三、Bean 的作用域"></a>三、Bean 的作用域</h3><p>默认的情况下，经过 Spring 托管的对象都是以单例的形式存在的。但一些时候，只有单例无法实现想要的效果。我们还需要一些类来完成保存状态、存储信息等操作。在网络应用中，我们也需要为每个会话创建对应的实例。这都需要调整 Bean 的作用域，一部分 Bean 存在于全局，一部分 Bean 存在于每次创建，一部分 Bean 存在于每次请求，等等。</p>
<p>Spring 定义了多种作用域，包括：</p>
<ul>
<li>单例（Singleton）：在整个应用中，只创建bean的一个实例。</li>
<li>原型（Prototype）：每次注入或者通过Spring应用上下文获取的时候，都会创建一个新的bean实例。</li>
<li>会话（Session）：在Web应用中，为每个会话创建一个bean实例。</li>
<li>请求（Rquest）：在Web应用中，为每个请求创建一个bean实例。</li>
</ul>
<p>设定作用域的方法很简单，只要使用 <code>@Scope</code> 注释即可。这一注释可以用在 <code>@Component</code> 或 <code>@Bean</code> 所修饰的对象上。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Scope(ConfigurableBeanFactory.SCOPE_PROTOTYPE)</span></span><br><span class="line"><span class="comment">// @Scope(&quot;prototype&quot;) // 另一种方式</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserInfo</span></span><br></pre></td></tr></table></figure>
<h3 id="四、运行时值注入"><a href="#四、运行时值注入" class="headerlink" title="四、运行时值注入"></a>四、运行时值注入</h3><p>让我们重新审视一下 <code>SgtPeppers</code> 类。<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SgtPeppers</span> <span class="keyword">implements</span> <span class="title class_">CompactDisc</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">String</span> <span class="variable">title</span> <span class="operator">=</span> <span class="string">&quot;Sgt. Pepper&#x27;s Lonely Hearts Club Band&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">String</span> <span class="variable">artist</span> <span class="operator">=</span> <span class="string">&quot;The Beatles&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">play</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Playing &quot;</span> + title + <span class="string">&quot; by &quot;</span> + artist);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>就能感觉到，<code>title</code> 和 <code>artist</code> 的值还是紧密的与 <code>SgtPeppers</code> 耦合在了一起，被硬编码到了类中。按照依赖注入的原则，我们利用构造函数将 title 和 artist 的值移到类的定义之外。当然，这样的话这个类就不能称为 <code>SgtPeppers</code> 了。<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BlankDisc</span> <span class="keyword">implements</span> <span class="title class_">CompactDisc</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String title;</span><br><span class="line">    <span class="keyword">private</span> String artist;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SgtPeppers</span><span class="params">(String title, String artist)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.title = title;</span><br><span class="line">        <span class="built_in">this</span>.artist = artist;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">play</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Playing &quot;</span> + title + <span class="string">&quot; by &quot;</span> + artist);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>那么自然地，字符串就转而出现在装配的过程中。<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> CompactDisc <span class="title function_">sgtPeppers</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">SgtPeppers</span>(</span><br><span class="line">        <span class="string">&quot;Sgt. Pepper&#x27;s Lonely Hearts Club Band&quot;</span>,</span><br><span class="line">        <span class="string">&quot;The Beatles&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>但是这还不够，因为要修改字符串值的话还需要对配置类进行修改。我们希望这些值被保存在配置中，只在运行时才注入到程序中。</p>
<p>方法有两种，<strong>第一种</strong>是通过 <code>Environment</code> 访问环境变量。与使用 <code>@Profile</code> 时类似，我们要引入配置位置，并通过自动注入获取环境变量类 <code>Environment</code>。调用其方法 <code>getProperty()</code> 获取对应名称的配置值。<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// CDPlayerConfig.java</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@PropertySource(&quot;classpath:application.properties&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CDPlayerConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    Environment env;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> CompactDisc <span class="title function_">blankDisc</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">BlankDisc</span>(</span><br><span class="line">                env.getProperty(<span class="string">&quot;disc.title&quot;</span>),</span><br><span class="line">                env.getProperty(<span class="string">&quot;disc.artist&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> CDPlayer <span class="title function_">cdPlayer</span><span class="params">(CompactDisc cd)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">CDPlayer</span>(cd);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>设置的配置如下：<br><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment">#application.properties</span></span><br><span class="line"><span class="attr">disc.title</span>=<span class="string">Sgt. Pepper&#x27;s Lonely Hearts Club Band</span></span><br><span class="line"><span class="attr">disc.artist</span>=<span class="string">The Beatles</span></span><br></pre></td></tr></table></figure></p>
<p><strong>第二种</strong>方法是使用 <code>@Value</code> 注释。<code>@Value</code> 与 <code>@Autowired</code> 类似，只不过 <code>@Value</code> 注入的是值，而 <code>@Autowired</code> 注入的是对象。<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@PropertySource(&quot;classpath:application.properties&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CDPlayerConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> CompactDisc <span class="title function_">blankDisc</span><span class="params">(</span></span><br><span class="line"><span class="params">            <span class="meta">@Value(&quot;$&#123;disc.title&#125;&quot;)</span> String title,</span></span><br><span class="line"><span class="params">            <span class="meta">@Value(&quot;$&#123;disc.artist&#125;&quot;)</span> String artist)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">BlankDisc</span>(title, artist);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> CDPlayer <span class="title function_">cdPlayer</span><span class="params">(CompactDisc cd)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">CDPlayer</span>(cd);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><code>@Value</code> 使用时需要参数，<code>&quot;$&#123;disc.title&#125;&quot;</code> 是一个属性占位符，表示取 <code>disc.title</code> 的值，这个值将作为 <code>title</code> 的值。</p>
<blockquote>
<p>另外 <code>@Value</code> 中还可以使用以 <code>#&#123;...&#125;</code> 表示的 SpEL 表达式。可以以更灵活且强大的方式取值，在这里不赘述。</p>
</blockquote>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>Spring</tag>
        <tag>依赖注入</tag>
      </tags>
  </entry>
  <entry>
    <title>pybind11实现python与c++混合编程</title>
    <url>/posts/71181fb7/</url>
    <content><![CDATA[<h2 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h2><p>最近在尝试写一个简单的<a href="https://github.com/wokron/Gamo">游戏引擎</a>，我决定用 python 作为脚本，所以了解了一些混合编程的知识。</p>
<h3 id="（1）python-api"><a href="#（1）python-api" class="headerlink" title="（1）python api"></a>（1）python api</h3><p>从原理来说，根据<a href="https://docs.python.org/3/extending/extending.html">文档</a>所述，python 提供了 <code>Python.h</code> 头文件，能够将 c 或 c++ 代码编译成可供 python 引入的动态链接库。该库中定义的可供 python 调用的函数中所有的入参都是名为 <code>PyObject</code> 结构体的指针。在代码中可以通过一系列函数对 <code>PyObject</code> 进行操作。</p>
<p>举一个简单的例子，我们希望 python 调用一个由 c 编写的简单的加法函数<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<span id="more"></span>
<p>我们期望在 python 中这样调用<br><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment"># test_mymodule.py</span></span><br><span class="line"><span class="keyword">from</span> mymodule <span class="keyword">import</span> add</span><br><span class="line">a = <span class="number">10</span></span><br><span class="line">b = <span class="number">20</span></span><br><span class="line">c = add(a, b)</span><br><span class="line"><span class="keyword">assert</span> c == <span class="number">30</span></span><br></pre></td></tr></table></figure></p>
<p>那么我们首先需要对该函数进行包装，包装函数 <code>_add</code> 的参数和返回值都应该是 <code>PyObject *</code>。在包装函数中调用了 <code>PyArg_ParseTuple</code> 将传入的参数转换为 <code>int</code> 类型，调用原本的 <code>add</code> 函数得到返回值，之后又通过 <code>PyLong_FromLong</code> 将 <code>int</code> 转换为 <code>PyObject</code>。<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// mymodule.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Python.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> PyObject *_add(PyObject *self, PyObject *args) &#123;</span><br><span class="line">    <span class="type">int</span> _a, _b, rt;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!PyArg_ParseTuple(args, <span class="string">&quot;ii&quot;</span>, &amp;_a, &amp;_b)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    rt = add(_a, _b);</span><br><span class="line">    <span class="keyword">return</span> PyLong_FromLong(rt);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在此之后还需要定义函数和模块，并定义初始化函数<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// mymodule.c</span></span><br><span class="line"><span class="comment">// omit...</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> PyMethodDef MyModuleMethods[] = &#123;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">&quot;add&quot;</span>,</span><br><span class="line">        _add,</span><br><span class="line">        METH_VARARGS,</span><br><span class="line">        <span class="string">&quot;a simple add function&quot;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;<span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="number">0</span>, <span class="literal">NULL</span>&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">PyModuleDef</span> <span class="title">mymodule</span> =</span> &#123;</span><br><span class="line">    PyModuleDef_HEAD_INIT,</span><br><span class="line">    <span class="string">&quot;mymodule&quot;</span>,</span><br><span class="line">    <span class="string">&quot;this is my simple module&quot;</span>, </span><br><span class="line">    <span class="number">-1</span>,</span><br><span class="line">    MyModuleMethods</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">PyMODINIT_FUNC <span class="title function_">PyInit_mymodule</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> PyModule_Create(&amp;mymodule);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>最后构建并测试<br><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># build_test.sh</span></span><br><span class="line"><span class="comment">#!/bin/bash</span></span><br><span class="line">PYTHON_VER=3.10</span><br><span class="line">MODULE_NAME=mymodule</span><br><span class="line">TEST_FILE=test_mymodule.py</span><br><span class="line"></span><br><span class="line">gcc -fPIC -shared <span class="variable">$&#123;MODULE_NAME&#125;</span>.c -o <span class="variable">$&#123;MODULE_NAME&#125;</span>.so -I/usr/include/python<span class="variable">$&#123;PYTHON_VER&#125;</span>/ -lpython<span class="variable">$&#123;PYTHON_VER&#125;</span></span><br><span class="line"></span><br><span class="line">python <span class="variable">$&#123;TEST_FILE&#125;</span> || python3 <span class="variable">$&#123;TEST_FILE&#125;</span> || ! <span class="built_in">echo</span> <span class="string">&quot;fail to finish test&quot;</span> || <span class="built_in">exit</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;test pass&quot;</span></span><br></pre></td></tr></table></figure></p>
<p>可是这种直接使用原始 api 的方式太过繁琐了，并不推荐。庆幸的是已经有库封装了这一过程，提供了更简便的实现方法。这就是 pybind11。</p>
<h3 id="（2）用-pybind11-重写"><a href="#（2）用-pybind11-重写" class="headerlink" title="（2）用 pybind11 重写"></a>（2）用 pybind11 重写</h3><p>首先下载 pybind11 库，这里使用 git 的 submodule 的方式。<br><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git submodule add -b stable https://github.com/pybind/pybind11 extern/pybind11</span><br><span class="line">git submodule update --init</span><br></pre></td></tr></table></figure></p>
<p>之后在项目根目录的 CMakeLists.txt 中写入如下内容，源代码文件为 mymodule.cpp<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">cmake_minimum_required(VERSION <span class="number">3.4</span>..<span class="number">.3</span><span class="number">.18</span>)</span><br><span class="line">project(example LANGUAGES CXX)</span><br><span class="line"></span><br><span class="line">add_subdirectory(<span class="keyword">extern</span>/pybind11)</span><br><span class="line">include_directories(<span class="keyword">extern</span>/pybind11/include)</span><br><span class="line"></span><br><span class="line">pybind11_add_module(mymodule mymodule.cpp)</span><br></pre></td></tr></table></figure></p>
<p>此时要实现之前例子中的加法函数就很简单了。<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// mymodule.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pybind11/pybind11.h&gt;</span></span></span><br><span class="line"><span class="keyword">namespace</span> py = pybind11;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> pybind11::literals;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">PYBIND11_MODULE</span>(mymodule, m) &#123;</span><br><span class="line">    m.<span class="built_in">doc</span>() = <span class="string">&quot;this is my simple module&quot;</span>;</span><br><span class="line">    m.<span class="built_in">def</span>(<span class="string">&quot;add&quot;</span>, &amp;add, <span class="string">&quot;a simple add function&quot;</span>, <span class="string">&quot;a&quot;</span>_a, <span class="string">&quot;b&quot;</span>_a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>当然本文不会详细解释 pybind11 的所有内容，只是列出一些自己用到的方法罢了，详细内容还请参考 <a href="https://pybind11.readthedocs.io/en/stable/index.html">pybind11</a> 文档。</p>
<h2 id="二、函数与结构体"><a href="#二、函数与结构体" class="headerlink" title="二、函数与结构体"></a>二、函数与结构体</h2><p>在 pybind11 中，每个模块在一个 <code>PYBIND11_MODULE</code> 宏所指定的区域内定义，其中第一个参数是模块名，第二个参数是模块 handler 变量的名称，为 m 即可。<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">PYBIND11_MODULE</span>(module_name, m) &#123;</span><br><span class="line">    <span class="comment">// omit...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>函数的绑定很简单，只需要使用 <code>m.def()</code> 即可。其中第一个参数是在 python 中调用所使用的函数名，第二个参数是 c++ 代码中要绑定的函数的函数指针，之后还可以添加对函数的描述、变量名、默认值等等内容，这里不再详述。<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">PYBIND11_MODULE</span>(mymodule, m) &#123;</span><br><span class="line">    m.<span class="built_in">def</span>(<span class="string">&quot;add&quot;</span>, &amp;add, <span class="string">&quot;a simple add function&quot;</span>, <span class="string">&quot;a&quot;</span>_a, <span class="string">&quot;b&quot;</span>_a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>结构体和类没有本质区别，因此在 pybind11 中都是使用 <code>pybind11::class_&lt;T&gt;()</code> 定义。比如说这里有一个结构体。<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Pet</span> &#123;</span><br><span class="line">    std::string name;</span><br><span class="line">    <span class="function"><span class="type">const</span> std::string &amp;<span class="title">getName</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> name; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>可以将该结构体绑定到 python<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">PYBIND11_MODULE</span>(mymodule, m) &#123;</span><br><span class="line">    py::<span class="built_in">class_</span>&lt;Pet&gt;(m, <span class="string">&quot;Pet&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>但是此时 Pet 在 Python 看来不过是一个没有任何属性和方法的类。使用 <code>class_&lt;T&gt;().def_readwrite()</code> 定义可读可写的属性、使用 <code>class_&lt;T&gt;().def()</code> 定义成员方法。<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">PYBIND11_MODULE</span>(mymodule, m) &#123;</span><br><span class="line">    py::<span class="built_in">class_</span>&lt;Pet&gt;(m, <span class="string">&quot;Pet&quot;</span>)</span><br><span class="line">        .<span class="built_in">def_readwrite</span>(<span class="string">&quot;name&quot;</span>, &amp;Pet::name)</span><br><span class="line">        .<span class="built_in">def</span>(<span class="string">&quot;get_name&quot;</span>, &amp;Pet::getName);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>在 pybind11 中可以使用 lambda 表达式作为函数，此时需要注意，当 lambda 表达式作为成员方法时，需要让第一个参数为类的实例，例如<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">py::<span class="built_in">class_</span>&lt;Pet&gt;(m, <span class="string">&quot;Pet&quot;</span>)</span><br><span class="line">    .<span class="built_in">def</span>(<span class="string">&quot;pat&quot;</span>, [](<span class="type">const</span> Pet &amp;self, <span class="type">int</span> times)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;pat pet&quot;</span> + self.<span class="built_in">getName</span>() + std::<span class="built_in">tostring</span>(times) + <span class="string">&quot;times&quot;</span>;</span><br><span class="line">    &#125;)</span><br></pre></td></tr></table></figure></p>
</blockquote>
<h2 id="三、面向对象"><a href="#三、面向对象" class="headerlink" title="三、面向对象"></a>三、面向对象</h2><h3 id="（1）封装"><a href="#（1）封装" class="headerlink" title="（1）封装"></a>（1）封装</h3><p>面向对象编程中经常将属性设为 <code>private</code>，而使用 getter、setter 方法对值进行读写。c++ 和 java 并没有提供语法糖，可 python 与 c# 类似，提供了 <code>property</code> 简化这一过程。</p>
<blockquote>
<p>当然 python 的这一点可能有些人并不知道，可以尝试一下如下代码<br><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Pet</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name</span>):</span><br><span class="line">        self.__name = name</span><br><span class="line"></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">name</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> self.__name</span><br><span class="line">    </span><br><span class="line"><span class="meta">    @name.setter</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">name</span>(<span class="params">self, name</span>):</span><br><span class="line">        <span class="keyword">if</span> name == self.__name:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;name cannot be same&quot;</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.__name = name</span><br><span class="line"></span><br><span class="line">p = Pet(<span class="string">&quot;tom&quot;</span>)</span><br><span class="line"><span class="keyword">assert</span> p.name == <span class="string">&quot;tom&quot;</span></span><br><span class="line"></span><br><span class="line">p.name = <span class="string">&quot;kitty&quot;</span></span><br><span class="line"><span class="keyword">assert</span> p.name == <span class="string">&quot;kitty&quot;</span></span><br><span class="line"></span><br><span class="line">p.name = <span class="string">&quot;kitty&quot;</span></span><br></pre></td></tr></table></figure></p>
</blockquote>
<p>pybind11 中提供了将 c++ 中的 getter、setter 函数改为 python 的 property 的方法。使用 <code>class_&lt;T&gt;().def_property()</code><br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">PYBIND11_MODULE</span>(mymodule, m) &#123;</span><br><span class="line">    py::<span class="built_in">class_</span>&lt;Pet&gt;(m, <span class="string">&quot;Pet&quot;</span>)</span><br><span class="line">        .<span class="built_in">def_property</span>(<span class="string">&quot;name&quot;</span>, &amp;Pet::getName, &amp;Pet::setName);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="（2）继承"><a href="#（2）继承" class="headerlink" title="（2）继承"></a>（2）继承</h3><p>比如说现在想要为 <code>Pet</code> 类增加一个子类 <code>Dog</code>。<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Dog</span> : Pet &#123;</span><br><span class="line">    <span class="function">std::string <span class="title">bark</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> <span class="string">&quot;woof!&quot;</span>; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>那么在子类绑定的时候就要声明 Pet 为 Dog 的父类，注意此处 <code>class_&lt;Dog, Pet&gt;</code><br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">py::<span class="built_in">class_</span>&lt;Dog, Pet&gt;(m, <span class="string">&quot;Dog&quot;</span>)</span><br><span class="line">        .<span class="built_in">def</span>(<span class="string">&quot;bark&quot;</span>, &amp;Dog::bark);</span><br></pre></td></tr></table></figure></p>
<p>对于多继承的情况，只需要在同样的位置添加多个父类即可。即 <code>class_&lt;Child, Father1, Father2, Father3&gt;</code> 的形式。</p>
<p>大多数情况，只需要父类绑定其方法，子类也能够调用父类所绑定的方法。但是当父类为抽象类的时候就不同了，此时并不能绑定一个不存在的方法。这时需要使用一个辅助函数来实现，具体方法可见<a href="https://pybind11.readthedocs.io/en/stable/advanced/classes.html#overriding-virtual-functions-in-python">此处</a></p>
<h3 id="（3）多态"><a href="#（3）多态" class="headerlink" title="（3）多态"></a>（3）多态</h3><p>这里的多态主要指函数重载，分为两个方面。一是如何指定 c++ 侧重载的函数、二是如何在 python 侧实现重载。当然因为有了 pybind11 的帮助，这两点也很简单。</p>
<p>c 语言中是没有函数多态的，因此函数名就是函数地址，但是 c++ 中就不同了，并不能通过函数名明确到底是哪一个函数。pybind11 中提供了根据函数签名获取地址的方法。这需要使用模板 <code>pybind11::overload_cast&lt;T1, T2, ...&gt;()</code>。其中 <code>T1, T2, ...</code> 是函数参数的类型，之后提供函数地址。例如<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">PYBIND11_MODULE</span>(mymodule, m) &#123;</span><br><span class="line">    py::<span class="built_in">class_</span>&lt;Pet&gt;(m, <span class="string">&quot;Pet&quot;</span>)</span><br><span class="line">        .<span class="built_in">def</span>(<span class="string">&quot;get_name&quot;</span>, py::overload_cast&lt;&gt;(&amp;Pet::Name))</span><br><span class="line">        .<span class="built_in">def</span>(<span class="string">&quot;set_name&quot;</span>, py::<span class="built_in">overload_cast</span>&lt;std::string&gt;(&amp;Pet::Name));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>python 中同样是没有函数多态的，因为函数重载的目的就是实现可变参数个数和可变参数类型，而 python 使用 <code>*args</code> 和 <code>**kwargs</code> 已经从另一个角度解决了这一问题。不过不要担心， pybind11 已经为我们做出处理，我们并不需要关心这一问题。我们只需要大胆的使用相同的函数名即可。在进行调用时，pybind11 会尝试调用所有同名函数，直到成功调用并成功返回或找不到匹配的函数报错。<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">PYBIND11_MODULE</span>(mymodule, m) &#123;</span><br><span class="line">    py::<span class="built_in">class_</span>&lt;Pet&gt;(m, <span class="string">&quot;Pet&quot;</span>)</span><br><span class="line">        .<span class="built_in">def</span>(<span class="string">&quot;name&quot;</span>, py::overload_cast&lt;&gt;(&amp;Pet::Name))</span><br><span class="line">        .<span class="built_in">def</span>(<span class="string">&quot;name&quot;</span>, py::<span class="built_in">overload_cast</span>&lt;std::string&gt;(&amp;Pet::Name));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="四、单例模式"><a href="#四、单例模式" class="headerlink" title="四、单例模式"></a>四、单例模式</h2><p>说实话这不能算是一节内容，但是在 python 中绑定单例类还是很有意思的。首先写一个简单的单例：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MySingleton</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> MySingleton *<span class="title">GetInstance</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">static</span> MySingleton _instance;</span><br><span class="line">        <span class="keyword">return</span> &amp;instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="built_in">MySingleton</span>() &#123;&#125;</span><br><span class="line">    ~<span class="built_in">MySingleton</span>() &#123;&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MySingleton</span>(MySingleton <span class="type">const</span> &amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    MySingleton &amp;<span class="keyword">operator</span>=(MySingleton <span class="type">const</span> &amp;) = <span class="keyword">delete</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>第一种方法当然是绑定静态方法，注意这里需要加上 <code>std::unique_ptr&lt;MySingleton, py::nodelete&gt;</code> 不引用析构函数。<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">PYBIND11_MODULE</span>(mymodule, m) &#123;</span><br><span class="line">    py::class_&lt;MySingleton, std::unique_ptr&lt;MySingleton, py::nodelete&gt;&gt;(m, <span class="string">&quot;MySingleton&quot;</span>)</span><br><span class="line">        .<span class="built_in">def_static</span>(<span class="string">&quot;get_instance&quot;</span>, &amp;MySingleton::GetInstance);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>第二种方法是这样，因为 pybind11 中可以使用 lambda 自定义构造函数，所以可以将 <code>GetInstance</code> 包装成构造函数使用。这样可以在 python 中构造“不同”的实例，但这些实例其实都指向一个单例。<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">PYBIND11_MODULE</span>(mymodule, m) &#123;</span><br><span class="line">    py::class_&lt;MySingleton, std::unique_ptr&lt;MySingleton, py::nodelete&gt;&gt;(m, <span class="string">&quot;MySingleton&quot;</span>)</span><br><span class="line">        .<span class="built_in">def</span>(py::<span class="built_in">init</span>([]()&#123; <span class="keyword">return</span> MySingleton::<span class="built_in">GetInstance</span>(); &#125;));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>pybind11</tag>
        <tag>c++</tag>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>Test</title>
    <url>/posts/784dd132/</url>
    <content><![CDATA[<h1 id="Article-Test"><a href="#Article-Test" class="headerlink" title="Article Test"></a>Article Test</h1><blockquote>
<p>测试，第一篇推文</p>
</blockquote>
<p>I wonder if this can be seen…</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// this is what a string cat can do.</span></span><br><span class="line">StringCat.new(<span class="string">&quot;black&quot;</span>).meow(<span class="number">2</span>).jump().sleep(<span class="number">1000</span>);</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>测试</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>使用transformer进行机器翻译</title>
    <url>/posts/6afa4e5d/</url>
    <content><![CDATA[<h2 id="一、transformer-简介"><a href="#一、transformer-简介" class="headerlink" title="一、transformer 简介"></a>一、transformer 简介</h2><p>transformer 是 Google 在 2017 年发表的文章 <a href="https://arxiv.org/abs/1706.03762">Attention Is All You Need</a> 中提出的网络架构。transformer 中只使用了注意力，实现了序列数据的处理，而未使用之前常用的 RNN 或 CNN。</p>
<p>对 nlp 问题，我们希望的是尽可能的获取句子的整体含义。使用 RNN，我们必须逐词获取语义，因此容易导致开头词汇词义的遗忘；使用 CNN，我们必须通过增加层数来扩大获取信息的范围。这两种方法都有很大的局限。</p>
<p>注意力方法则可以直接获得全局信息。方法是对一条序列，求其对于本身的注意力，这被称为自注意力。</p>
<blockquote>
<p>transformer 的原理和模型较为复杂，在这里只是简单说明。</p>
</blockquote>
<h2 id="二、数据集"><a href="#二、数据集" class="headerlink" title="二、数据集"></a>二、数据集</h2><p>此为训练模型所用的<a href="https://www.kaggle.com/datasets/concyclics/machine-translation-chinese-and-english">数据集</a>。设定英文为源语言，中文为要翻译成的语言。</p>
<h3 id="（1）Dataset-类编写"><a href="#（1）Dataset-类编写" class="headerlink" title="（1）Dataset 类编写"></a>（1）Dataset 类编写</h3><p>我们根据路径打开文件，获取中英文序列和单词表。并将序列直接转化为 tensor，方便读取。<br><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TranslateDataset</span>(<span class="title class_ inherited__">Dataset</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, en_path, zh_path</span>):</span><br><span class="line">        en_seqs, self.en_vocab = get_seq_and_vocab(en_path, get_tokenizer(<span class="string">&quot;basic_english&quot;</span>))</span><br><span class="line"></span><br><span class="line">        zh_seqs, self.zh_vocab = get_seq_and_vocab(zh_path, zh_simple_tokenizer)</span><br><span class="line"></span><br><span class="line">        self.items = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(en_seqs)):</span><br><span class="line">            en_seq = en_seqs[i]</span><br><span class="line">            zh_seq = zh_seqs[i]</span><br><span class="line"></span><br><span class="line">            src = en_seq</span><br><span class="line">            tgt = zh_seq[:-<span class="number">1</span>]</span><br><span class="line">            pdt = zh_seq[<span class="number">1</span>:]</span><br><span class="line"></span><br><span class="line">            self.items.append((</span><br><span class="line">                torch.as_tensor(src),</span><br><span class="line">                torch.as_tensor(tgt),</span><br><span class="line">                torch.as_tensor(pdt),</span><br><span class="line">            ))</span><br></pre></td></tr></table></figure></p>
<p>其中 <code>get_seq_and_vocab</code> 方法用于根据路径打开文件，根据第二个参数选择的 tokenizer 进行分词。构建序列和单词表。</p>
<p>我们首先定义了存储序列的列表和记录词频的字典。<code>Counter</code> 类可以直接根据列表统计列表中元素频率。<br><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">get_seq_and_vocab</span>(<span class="params">file_path, tokenizer</span>):</span><br><span class="line">    token_freq = Counter()</span><br><span class="line">    seqs = []</span><br></pre></td></tr></table></figure></p>
<p>打开文件，依次读取文件中每一行，通过 <code>tokenizer</code> 进行分词。序列保存到 <code>seqs</code> 中。更新词频。<br><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(file_path, encoding=<span class="string">&quot;UTF-8&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    <span class="keyword">with</span> tqdm(f) <span class="keyword">as</span> tqdm_file:</span><br><span class="line">        tqdm_file.set_description(<span class="string">f&quot;Load <span class="subst">&#123;file_path&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> idx, line <span class="keyword">in</span> <span class="built_in">enumerate</span>(tqdm_file):</span><br><span class="line">            <span class="keyword">if</span> args.debug <span class="keyword">and</span> idx &gt; <span class="number">10000</span>:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">            tokens_in_line = tokenizer(line)</span><br><span class="line">            tokens_in_line.insert(<span class="number">0</span>, <span class="string">&#x27;&lt;sos&gt;&#x27;</span>)</span><br><span class="line">            tokens_in_line.append(<span class="string">&#x27;&lt;eos&gt;&#x27;</span>)</span><br><span class="line"></span><br><span class="line">            seqs.append(tokens_in_line)</span><br><span class="line"></span><br><span class="line">            token_freq += Counter(tokens_in_line)</span><br></pre></td></tr></table></figure></p>
<p>根据词频生成单词表，把单词序列转化为数值序列。<br><figure class="highlight py"><table><tr><td class="code"><pre><span class="line">v = vocab(token_freq, <span class="number">5</span>, [<span class="string">&#x27;&lt;pad&gt;&#x27;</span>, <span class="string">&#x27;&lt;unk&gt;&#x27;</span>, <span class="string">&#x27;&lt;sos&gt;&#x27;</span>, <span class="string">&#x27;&lt;eos&gt;&#x27;</span>])</span><br><span class="line">v.set_default_index(v[<span class="string">&#x27;&lt;unk&gt;&#x27;</span>])</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> idx <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(seqs)):</span><br><span class="line">    seqs[idx] = [v[token] <span class="keyword">for</span> token <span class="keyword">in</span> seqs[idx]]</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> seqs, v</span><br></pre></td></tr></table></figure></p>
<p>英文分词可以使用 pytorch 自带的 <code>get_tokenizer(&quot;basic_english&quot;)</code>。中文分词可以采用如下方式。此方法考虑了中文中掺杂英文的情况。<br><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">zh_simple_tokenizer</span>(<span class="params">line</span>):</span><br><span class="line">    <span class="keyword">return</span> re.findall(<span class="string">&quot;[a-zA-Z]+|[^\s]&quot;</span>, line)</span><br></pre></td></tr></table></figure></p>
<p>最后在 <code>TranslateDataset</code> 中，简单实现 <code>__getitem__</code> 和 <code>__len__</code>。<br><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">__getitem__</span>(<span class="params">self, item</span>):</span><br><span class="line">    <span class="keyword">return</span> self.items[item]</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">__len__</span>(<span class="params">self</span>):</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">len</span>(self.items)</span><br></pre></td></tr></table></figure></p>
<h3 id="（2）保存和加载处理后的数据"><a href="#（2）保存和加载处理后的数据" class="headerlink" title="（2）保存和加载处理后的数据"></a>（2）保存和加载处理后的数据</h3><p>本数据集规模较大，如果每次都要重新进行分词处理的话需要耗费不少时间。因此可以只处理一次，以后只需调用之前处理后的结果即可。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> os.path.exists(args.processed_dataset_path):</span><br><span class="line">    dataset = torch.load(args.processed_dataset_path)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    dataset = TranslateDataset(args.en_path, args.zh_path)</span><br><span class="line">    torch.save(dataset, args.processed_dataset_path)</span><br></pre></td></tr></table></figure>
<h3 id="（3）划分数据集"><a href="#（3）划分数据集" class="headerlink" title="（3）划分数据集"></a>（3）划分数据集</h3><p>因为本数据集只有完整的文件，没有进行划分，所以还需要对加载后的 <code>dataset</code> 进行划分。我们需要使用 <code>random_split</code> 方法实现。<br><figure class="highlight py"><table><tr><td class="code"><pre><span class="line">train_set, dev_set, test_set = random_split(</span><br><span class="line">    dataset,</span><br><span class="line">    [train_size, dev_size, test_size],</span><br><span class="line">    generator=torch.Generator().manual_seed(<span class="number">42</span>)</span><br><span class="line">)</span><br></pre></td></tr></table></figure></p>
<p>需要注意的是，<code>random_split</code> 会进行随机划分。随机划分有助于避免过拟合，但是如果每次运行程序划分的方式都不同，就会导致信息泄露。为了使每次运行时的随机划分结果一致，需要指定随机划分的种子，即代码中的 <code>generator=torch.Generator().manual_seed(42)</code>。</p>
<h2 id="三、模型"><a href="#三、模型" class="headerlink" title="三、模型"></a>三、模型</h2><h3 id="（1）整体结构"><a href="#（1）整体结构" class="headerlink" title="（1）整体结构"></a>（1）整体结构</h3><p>我们要实现一个机器翻译模型。它的输入是源语句 src，和经过右移的目标语句 tgt，输出是包含结束词的目标语句 predict。</p>
<p>首先，我们将输入的序列扩展为词向量<br><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TranslationModel</span>(nn.Module):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, <span class="built_in">input</span></span>):</span><br><span class="line">        src, tgt = <span class="built_in">input</span>  <span class="comment"># (seq1_len, batch_size) (seq2_len, batch_size)</span></span><br><span class="line">        src_embed = self.embed(src)  <span class="comment"># (seq1_len, batch_size, embed_size)</span></span><br><span class="line">        tgt_embed = self.embed(tgt)  <span class="comment"># (seq2_len, batch_size, embed_size)</span></span><br></pre></td></tr></table></figure></p>
<p>随后，我们为词向量添加位置编码。采取此操作的原因是注意力模型中整个序列被同时输入，模型无法得知位置信息，因此需要添加位置编码。具体的添加位置编码的方式会在后面说明。<br><figure class="highlight py"><table><tr><td class="code"><pre><span class="line">src_embed_encoded = self.positional_encoding(src_embed)</span><br><span class="line"><span class="comment"># (seq1_len, batch_size, embed_size)</span></span><br><span class="line">tgt_embed_encoded = self.positional_encoding(tgt_embed)</span><br><span class="line"><span class="comment"># (seq2_len, batch_size, embed_size)</span></span><br></pre></td></tr></table></figure></p>
<p>我们根据输入 <code>src</code> 和 <code>tgt</code> 确定各类掩码，并将掩码与 <code>src_embed_encoded</code>、<code>tgt_embed_encoded</code> 一同输入到 transformer 中。</p>
<p><code>tgt_mask</code> 用于处理预测时的时序问题。因为如果将 tgt_embed_encoded 直接输入到 transformer，则 transformer 就会在同一时刻得知序列的全部信息，无法实现逐词生成。</p>
<p><code>src_pad_mask</code> 和 <code>src_pad_mask</code> 用于将 <code>&#39;&lt;pad&gt;&#39;</code> 忽略。避免填充词影响模型的权重。<br><figure class="highlight py"><table><tr><td class="code"><pre><span class="line">tgt_mask = get_tgt_mask(tgt.shape[<span class="number">0</span>])  <span class="comment"># (seq2_len, seq2_len)</span></span><br><span class="line">src_pad_mask = get_pad_mask(src)  <span class="comment"># (seq1_len, batch_size, embed_size)</span></span><br><span class="line">tgt_pad_mask = get_pad_mask(tgt)  <span class="comment"># (seq2_len, batch_size, embed_size)</span></span><br><span class="line"></span><br><span class="line">out = self.transformer(</span><br><span class="line">    src_embed_encoded,</span><br><span class="line">    tgt_embed_encoded,</span><br><span class="line">    tgt_mask=tgt_mask,</span><br><span class="line">    src_key_padding_mask=src_pad_mask,</span><br><span class="line">    tgt_key_padding_mask=tgt_pad_mask,</span><br><span class="line">)  <span class="comment"># (seq2_len, batch_size, embed_size)</span></span><br></pre></td></tr></table></figure></p>
<p>最后将 transformer 的输出经过多层感知机调整为适当的形状，输出预测结果。<br><figure class="highlight py"><table><tr><td class="code"><pre><span class="line">predict = self.multi(out)  <span class="comment"># (seq2_len, batch_size, class_num)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> predict</span><br></pre></td></tr></table></figure></p>
<h3 id="（2）词向量"><a href="#（2）词向量" class="headerlink" title="（2）词向量"></a>（2）词向量</h3><p>我们定义嵌入层为 <code>TokenEmbedding</code>，而不是直接使用 <code>nn.Embedding</code>。<br><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TranslationModel</span>(nn.Module):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, vocab_size, embed_size, class_num, dropout</span>):</span><br><span class="line">        <span class="built_in">super</span>(TranslationModel, self).__init__()</span><br><span class="line">        self.embed = TokenEmbedding(vocab_size, embed_size)</span><br></pre></td></tr></table></figure></p>
<p><code>TokenEmbedding</code> 定义如下。很容易看出，我们只是将 <code>Embedding</code> 输出的词向量乘以了 $\sqrt{\text{emb size}}$。这样做更便于训练。具体原因可见<a href="https://zhuanlan.zhihu.com/p/442509602">Transformer 3. word embedding 输入为什么要乘以 embedding size的开方</a>。<br><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TokenEmbedding</span>(nn.Module):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, vocab_size, embed_size</span>):</span><br><span class="line">        <span class="built_in">super</span>(TokenEmbedding, self).__init__()</span><br><span class="line"></span><br><span class="line">        self.embedding = nn.Embedding(vocab_size, embed_size)</span><br><span class="line">        self.embed_size = embed_size</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, seq</span>):</span><br><span class="line">        <span class="keyword">return</span> self.embedding(seq) * math.sqrt(self.embed_size)</span><br></pre></td></tr></table></figure></p>
<h3 id="（3）位置编码"><a href="#（3）位置编码" class="headerlink" title="（3）位置编码"></a>（3）位置编码</h3><p>在模型中，我们随后定义了位置编码层<br><figure class="highlight py"><table><tr><td class="code"><pre><span class="line">self.positional_encoding = PositionalEncoding(embed_size, dropout)</span><br></pre></td></tr></table></figure></p>
<p><code>PositionalEncoding</code> 定义如下。位置编码得到的结果是一个形状为 <code>(max_len, 1, embed_size)</code> 的张量 $pos<em>embedding$。其中 $p</em>{i1}$ 表示第 $i$ 个位置的编码。将该编码与原来的 <code>seq_embed</code> 相加，就得到了经过位置编码后的词向量序列。</p>
<p>关于位置编码的原理，可以参考<a href="https://zhuanlan.zhihu.com/p/338592312">一文教你彻底理解Transformer中Positional Encoding</a>。该编码使用正余弦函数生成，可以保证不同位置的编码唯一。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">PositionalEncoding</span>(nn.Module):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, embed_size, dropout, max_len=<span class="number">5000</span></span>):</span><br><span class="line">        <span class="built_in">super</span>(PositionalEncoding, self).__init__()</span><br><span class="line"></span><br><span class="line">        den = torch.exp(- torch.arange(<span class="number">0</span>, embed_size, <span class="number">2</span>) * math.log(<span class="number">10000</span>) / embed_size)</span><br><span class="line">        pos = torch.arange(<span class="number">0</span>, max_len).reshape(max_len, <span class="number">1</span>)</span><br><span class="line">        pos_embedding = torch.zeros((max_len, embed_size))</span><br><span class="line">        pos_embedding[:, <span class="number">0</span>::<span class="number">2</span>] = torch.sin(pos * den)</span><br><span class="line">        pos_embedding[:, <span class="number">1</span>::<span class="number">2</span>] = torch.cos(pos * den)</span><br><span class="line">        pos_embedding = pos_embedding.unsqueeze(-<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">        self.dropout = nn.Dropout(dropout)</span><br><span class="line">        self.register_buffer(<span class="string">&#x27;pos_embedding&#x27;</span>, pos_embedding)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, seq_embed</span>):</span><br><span class="line">        seq_embed_encoded = seq_embed + self.pos_embedding[:seq_embed.size(<span class="number">0</span>), :]</span><br><span class="line">        <span class="comment"># (seq_len, batch_size, embed_size) + (seq_len, 1, embed_size)</span></span><br><span class="line">        <span class="keyword">return</span> self.dropout(seq_embed_encoded)</span><br></pre></td></tr></table></figure>
<h3 id="（4）掩码"><a href="#（4）掩码" class="headerlink" title="（4）掩码"></a>（4）掩码</h3><p>填充掩码用来屏蔽 <code>&#39;&lt;pad&gt;&#39;</code> 索引，是一个和输入同大小的张量，其中每一个值表示对应的位置是否需要被屏蔽。计算方式如下，进行了转置是因为 pytorch 的 transformer 要求第一维为 batch。<br><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">get_pad_mask</span>(<span class="params">seq, pad_idx=<span class="number">0</span></span>):</span><br><span class="line">    <span class="keyword">return</span> (seq == pad_idx).permute(<span class="number">1</span>, <span class="number">0</span>)</span><br></pre></td></tr></table></figure></p>
<p>后继掩码用来模拟时间步，防止模型在进行预测时查看未来的单词。我们需要用一个三角形矩阵来模拟此过程。<br><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">get_tgt_mask</span>(<span class="params">size</span>):</span><br><span class="line">    mask = torch.tril(torch.ones(size, size) == <span class="number">1</span>).<span class="built_in">float</span>()</span><br><span class="line">    mask = mask.masked_fill(mask == <span class="number">0</span>, <span class="built_in">float</span>(<span class="string">&quot;-inf&quot;</span>))</span><br><span class="line">    mask = mask.masked_fill(mask == <span class="number">1</span>, <span class="built_in">float</span>(<span class="number">0.0</span>))</span><br><span class="line">    mask = mask.to(args.device)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> mask</span><br></pre></td></tr></table></figure></p>
<h2 id="四、训练"><a href="#四、训练" class="headerlink" title="四、训练"></a>四、训练</h2><p>训练时的通用步骤不再详述。只说明一些值得注意的地方。</p>
<h3 id="（1）自定义-collate-fn"><a href="#（1）自定义-collate-fn" class="headerlink" title="（1）自定义 collate_fn"></a>（1）自定义 collate_fn</h3><p>因为序列长度不定，所以需要自行对其，需要自定义 <code>dataloader</code> 的 <code>collate_fn</code>。在其中，使用了 <code>pad_sequence</code> 对一批序列进行对齐。<code>pad_sequence</code> 的默认填充值为 0。如果 <code>&#39;&lt;pad&gt;&#39;</code> 的对应值不是 0，还需要自行设定。<br><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">collate_fn</span>(<span class="params">data</span>):</span><br><span class="line">    src, tgt, pdt = <span class="built_in">zip</span>(*data)</span><br><span class="line">    src = pad_sequence(src)</span><br><span class="line">    tgt = pad_sequence(tgt)</span><br><span class="line">    pdt = pad_sequence(pdt)</span><br><span class="line">    <span class="keyword">return</span> [src, tgt], pdt</span><br></pre></td></tr></table></figure></p>
<h3 id="（2）交叉熵损失函数-ignore-index-的设置"><a href="#（2）交叉熵损失函数-ignore-index-的设置" class="headerlink" title="（2）交叉熵损失函数 ignore_index 的设置"></a>（2）交叉熵损失函数 ignore_index 的设置</h3><p>虽然我们使用 <code>&#39;&lt;pad&gt;&#39;</code> 进行了对齐，但是 <code>&#39;&lt;pad&gt;&#39;</code> 还没有被认为是特殊的符号。此时在损失函数中，<code>&#39;&lt;pad&gt;&#39;</code> 与其他字符的预测差距还是会被计算到损失之中。又因为 <code>&#39;&lt;pad&gt;&#39;</code>会在序列中经常出现，所以如果不特殊处理 <code>&#39;&lt;pad&gt;&#39;</code>，则训练后预测的结果便一定总是 <code>&lt;pad&gt;</code>。</p>
<p>因此我们希望损失函数忽略 <code>&#39;&lt;pad&gt;&#39;</code>。只需要设定 <code>ignore_index</code> 参数。如下所示将 <code>ignore_index</code> 设定为 <code>&#39;&lt;pad&gt;&#39;</code> 对应的数值。<br><figure class="highlight py"><table><tr><td class="code"><pre><span class="line">loss_fn = nn.CrossEntropyLoss(ignore_index=dataset.zh_vocab[<span class="string">&#x27;&lt;pad&gt;&#x27;</span>]).to(args.device)</span><br></pre></td></tr></table></figure></p>
<h3 id="（3）计算损失函数时对输入进行处理"><a href="#（3）计算损失函数时对输入进行处理" class="headerlink" title="（3）计算损失函数时对输入进行处理"></a>（3）计算损失函数时对输入进行处理</h3><p>阅读一下 pytorch 文档中关于交叉熵损失函数的说明，就可以得知我们的模型默认的输出不能直接传入损失函数进行计算，必须重新设定维度。</p>
<p>模型的预测形状为 <code>(seq_len, batch_size, class_num)</code>， 需要的输入为 <code>(batch_size, class_num, seq_len)</code>；目标的形状为 <code>(seq_len, batch_size)</code>，需要的输入为 <code>(batch_size, seq_len)</code>。因此重新定义了 <code>criterion</code> 方法作为损失函数，使用 <code>permute</code> 方法调整维度。将 <code>criterion</code> 传入 <code>train</code>、<code>eval</code> 方法中作为损失函数。<br><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">criterion</span>(<span class="params">predict, target</span>):</span><br><span class="line">    <span class="keyword">return</span> loss_fn(predict.permute(<span class="number">1</span>, <span class="number">2</span>, <span class="number">0</span>), target.permute(<span class="number">1</span>, <span class="number">0</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(args.max_epoch):</span><br><span class="line">    global_epoch += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    train(train_loader, net, criterion, optim)</span><br><span class="line"></span><br><span class="line">    save_checkpoint(net, optim, global_epoch, global_train_step)</span><br><span class="line"></span><br><span class="line">    evaluate(<span class="string">&quot;dev&quot;</span>, dev_loader, net, criterion)</span><br><span class="line"></span><br><span class="line">    evaluate(<span class="string">&quot;test&quot;</span>, test_loader, net, criterion)</span><br></pre></td></tr></table></figure></p>
<h3 id="（4）训练结果"><a href="#（4）训练结果" class="headerlink" title="（4）训练结果"></a>（4）训练结果</h3><img src="/posts/6afa4e5d/train_loss.png" class="" title="train_loss">
<img src="/posts/6afa4e5d/train_acc.png" class="" title="train_acc">
<img src="/posts/6afa4e5d/test_loss.png" class="" title="test_loss">
<img src="/posts/6afa4e5d/test_acc.png" class="" title="test_acc">
<blockquote>
<p>本来应该用机器翻译的评价指标，如 BLEU 的，但是一开始没有考虑到</p>
<p>从图中可以看到，模型的翻译能力并不算强，并且还有继续训练下去的空间。为什么不继续训练了呢？因为 Colab 时间用完了<code>:(</code><br><img src="/posts/6afa4e5d/example.png" class="" title="example"></p>
</blockquote>
<h2 id="五、总结"><a href="#五、总结" class="headerlink" title="五、总结"></a>五、总结</h2><p>本次实践了 transformer 模型的构建和训练。在训练过程中学到了一些知识，主要有</p>
<ul>
<li>transformer 模型的结构</li>
<li>注意力的掩码机制</li>
<li>位置编码</li>
<li>损失函数 ignore_index 的使用</li>
<li>数据集处理后的存储和加载</li>
<li>通过scheduler动态调整学习率的方法（本次未使用，之后应该会应用）</li>
<li>深度学习上层架构，如 ignite、lightning（本次未使用，之后应该会应用）</li>
</ul>
<p>也出现了一些问题</p>
<ul>
<li>未考虑张量形状，导致出现了“位置编码时为不同 batch 赋予了不同的编码“的bug</li>
<li>因为上一条内容浪费了大量的训练时间</li>
<li>未能设置适当的学习率，导致训练缓慢</li>
<li>没有使用 BLEU 等指标进行评价</li>
<li>没有对中文进行分词，一字多义可能增加了训练难度</li>
</ul>
<p>希望下一次避免犯下类似的错误。</p>
<h2 id="六、参考资料"><a href="#六、参考资料" class="headerlink" title="六、参考资料"></a>六、参考资料</h2><ul>
<li><a href="https://zhuanlan.zhihu.com/p/264468193">【通俗易懂】大白话讲解 Transformer</a></li>
<li><a href="https://pytorch.org/tutorials/beginner/translation_transformer.html">Language Translation with nn.Transformer and torchtext</a></li>
</ul>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>AI</tag>
        <tag>机器学习</tag>
        <tag>pytorch</tag>
      </tags>
  </entry>
  <entry>
    <title>关于git推送失败</title>
    <url>/posts/ebe0c30f/</url>
    <content><![CDATA[<h2 id="问题背景"><a href="#问题背景" class="headerlink" title="问题背景"></a>问题背景</h2><p>其实这个问题出现过许多次了，可每次的解决方法都不尽相同。因此这里做一个简单的汇总，也为之后再次出现提供一个总结的位置。</p>
<p>曾经出现该问题的情况：</p>
<ol>
<li>VS推送失败</li>
<li>hexo推送失败</li>
</ol>
<p>问题形式类似于<code>fatal: unable to access &#39;https://github.com/.../.git&#39;:...</code></p>
<h2 id="问题原因"><a href="#问题原因" class="headerlink" title="问题原因"></a>问题原因</h2><p>貌似是代理产生的问题。根据网上资料，通过取消代理就可以解决问题。但本人也曾有过通过更换VPN线路解决的情况，不知是否仅仅是凑巧解决。</p>
<h2 id="问题解决"><a href="#问题解决" class="headerlink" title="问题解决"></a>问题解决</h2><p>查看代理：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git config --global --get http.proxy</span><br><span class="line">git config --global --get https.proxy</span><br></pre></td></tr></table></figure><br>如果发现<code>git</code>使用了代理，则取消代理：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git config --global --<span class="built_in">unset</span> http.proxy</span><br><span class="line">git config --global --<span class="built_in">unset</span> https.proxy</span><br></pre></td></tr></table></figure><br>需要再次设置代理请使用如下命令（设置当前代理为 <a href="http://127.0.0.1:1080）：">http://127.0.0.1:1080）：</a><br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git config --global http.proxy <span class="string">&#x27;http://127.0.0.1:1080&#x27;</span></span><br><span class="line">git config --global https.proxy <span class="string">&#x27;http://127.0.0.1:1080&#x27;</span></span><br></pre></td></tr></table></figure></p>
<p>值得注意的是，<code>git</code>还可以对单一网站设置代理，例如只对<code>github</code>使用代理<a href="http://127.0.0.1:58591：">http://127.0.0.1:58591：</a><br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git config --global http.https://github.com.proxy http://127.0.0.1:58591</span><br></pre></td></tr></table></figure><br>该类代理无法通过前面的查看代理命令查看，需要明确指出网站才可查询到：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git config --global --get http.https://github.com.proxy</span><br></pre></td></tr></table></figure><br>取消对github的代理：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git config --global --<span class="built_in">unset</span> http.https://github.com.proxy</span><br></pre></td></tr></table></figure><br>另外代理设置也可以直接在git配置文件中查看，为<code>C:\Users\&#123;用户名&#125;\.gitconfig</code>。也可以在其中直接修改。</p>
]]></content>
      <categories>
        <category>踩坑记录</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>利用ASM库实现Java反射</title>
    <url>/posts/3a041e16/</url>
    <content><![CDATA[<h2 id="一、ASM库简介"><a href="#一、ASM库简介" class="headerlink" title="一、ASM库简介"></a>一、ASM库简介</h2><p>ASM 库是一款基于 Java 字节码层面的代码分析和修改工具。它能分析二进制的 class 文件并对其进行动态修改。ASM 库侧重性能，设计和实现尽可能小和快。</p>
<p>通过 ASM 库，我们可以方便地获取类信息，并实现类似于反射的功能。ASM 库处理字节码，因此能得到仅仅使用反射无法获取的信息，如方法内的结构。</p>
<p>ASM 库同样具有动态修改和创建类文件的功能，但本篇文章主要使用 ASM 库的字节码读取功能。</p>
<blockquote>
<p>本篇文章假设读者能自行通过Maven或其他方式添加ASM库依赖。</p>
</blockquote>
<h2 id="二、利用ASM库访问类文件"><a href="#二、利用ASM库访问类文件" class="headerlink" title="二、利用ASM库访问类文件"></a>二、利用ASM库访问类文件</h2><p>ASM 库的核心库提供了读取和修改字节码的基本 API。核心库包含如下几个工具类：</p>
<h3 id="ClassReader"><a href="#ClassReader" class="headerlink" title="ClassReader"></a>ClassReader</h3><p><code>ClassReader</code> 类用于从 class 文件中加载字节码。这样，这一 <code>ClassReader</code> 对象就拥有了关于某一类的所有信息。</p>
<h3 id="ClassVisitor"><a href="#ClassVisitor" class="headerlink" title="ClassVisitor"></a>ClassVisitor</h3><p><code>ClassVisitor</code> 类可以从 <code>ClassReader</code> 中获取想要的信息。</p>
<p><code>ClassVisitor</code> 是访问者模式的访问类。简单解释访问者模式，就是被访问的对象调用访问者类的方法，从而使得访问者获取希望得到的数据。</p>
<p>还是通过 ASM 的例子来理解吧，<code>ClassVisitor</code> 实际是一个抽象类，其中定义了一个方法 <code>visit</code>。该方法的签名为：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">visit(<span class="type">int</span> version, <span class="type">int</span> access, String name, String signature, String superName, String[] interfaces)</span><br></pre></td></tr></table></figure></p>
<p>假设我们继承 <code>ClassVisitor</code> 创建了一个新的访问类，那么获取信息的方式如下：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">ClassReader</span> <span class="variable">cr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassReader</span>(<span class="string">&quot;className&quot;</span>);</span><br><span class="line"><span class="type">ClassVisitor</span> <span class="variable">cv</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassVisitor</span>(Opcodes.ASM5) &#123;</span><br><span class="line">    <span class="comment">// this is an anonymous class </span></span><br><span class="line">&#125;;</span><br><span class="line">cr.accept(cv, <span class="number">0</span>); <span class="comment">// second argument is the parsingOptions</span></span><br></pre></td></tr></table></figure></p>
<p>如上代码中，<code>ClassReader</code> 调用 <code>accept</code> 方法允许一个 <code>ClassVisitor</code>。在 <code>accept</code> 方法内部，会按一定解析规则调用 <code>ClassVisitor</code> 中的 <code>visit</code> 方法。这样我们就可以获得该类的类名、父类名、接口名等等信息。</p>
<p><code>ClassVisitor</code> 类中还有许多访问方法可以重写，如<code>visitAnnotation</code>、<code>visitField</code>、<code>visitMethod</code> 等等。其中 <code>visitField</code>、<code>visitMethod</code> 等方法的返回值类似 <code>FieldVisitor</code>、<code>MethodVisitor</code> 等等 ，同样是访问者模式的抽象访问者类型。使用方法与 <code>ClassVisitor</code> 类似。</p>
<h3 id="ClassWriter"><a href="#ClassWriter" class="headerlink" title="ClassWriter"></a>ClassWriter</h3><p><code>ClassWriter</code> 用于修改或创建 class 文件，虽然在本篇文章中不会使用，但因为是ASM核心库的组成部分，还是略微介绍一下。</p>
<p><code>ClassWriter</code> 继承了 <code>ClassVisitor</code>。因此也具有 <code>visit</code> 等方法。不同于 <code>ClassVisitor</code> 通过 <code>ClassReader</code> 调用访问函数，<code>ClassWriter</code> 应由程序员自行调用，并由此让 <code>ClassWriter</code> 构建起类结构。最后，调用 <code>ClassWriter</code> 的 <code>toByteArray</code> 方法生成字节码，通过文件流生成新的文件。</p>
<p>例子如下，这里不赘述<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">ClassWriter</span> <span class="variable">cw</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassWriter</span>(<span class="number">0</span>);</span><br><span class="line">cw.visit(V1_5, ACC_PUBLIC + ACC_ABSTRACT + ACC_INTERFACE,<span class="string">&quot;pkg/Comparable&quot;</span>, <span class="literal">null</span>, <span class="string">&quot;java/lang/Object&quot;</span>,<span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;pkg/Mesurable&quot;</span>&#125;);</span><br><span class="line">cw.visitField(ACC_PUBLIC + ACC_FINAL + ACC_STATIC, <span class="string">&quot;LESS&quot;</span>,<span class="string">&quot;I&quot;</span>, <span class="literal">null</span>, <span class="keyword">new</span> <span class="title class_">Integer</span>(-<span class="number">1</span>)).visitEnd();</span><br><span class="line">cw.visitField(ACC_PUBLIC + ACC_FINAL + ACC_STATIC, <span class="string">&quot;EQUAL&quot;</span>,<span class="string">&quot;I&quot;</span>, <span class="literal">null</span>, <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">0</span>)).visitEnd();</span><br><span class="line">cw.visitField(ACC_PUBLIC + ACC_FINAL + ACC_STATIC, <span class="string">&quot;GREATER&quot;</span>,<span class="string">&quot;I&quot;</span>, <span class="literal">null</span>, <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">1</span>)).visitEnd();</span><br><span class="line">cw.visitMethod(ACC_PUBLIC + ACC_ABSTRACT, <span class="string">&quot;compareTo&quot;</span>,<span class="string">&quot;(Ljava/lang/Object;)I&quot;</span>, <span class="literal">null</span>, <span class="literal">null</span>).visitEnd();</span><br><span class="line">cw.visitEnd();</span><br><span class="line"><span class="type">byte</span>[] b = cw.toByteArray();</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出</span></span><br><span class="line"><span class="type">FileOutputStream</span> <span class="variable">fileOutputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;F:/asm/Comparable.class&quot;</span>));</span><br><span class="line">fileOutputStream.write(b);</span><br><span class="line">fileOutputStream.close();</span><br></pre></td></tr></table></figure></p>
<p>示例出自<a href="https://segmentfault.com/a/1190000040160637">java - ASM入门篇 - ksfzhaohui技术专栏 - SegmentFault 思否</a></p>
<h2 id="三、利用ASM-Tree实现反射"><a href="#三、利用ASM-Tree实现反射" class="headerlink" title="三、利用ASM Tree实现反射"></a>三、利用ASM Tree实现反射</h2><p>ASM 将各种不同功能的 API 组织在不同的库中。Tree库就是其中之一，能够将解析后的类信息组织成树的形式。即，类用ClassNode表示，ClassNode中包含类的相关信息，以及包含的字段，用FieldNode表示；和方法，用MethodNode表示。</p>
<p>首先，我们需要获取字节码。字节码可能是项目中已经被加载的文件，也可能是未被加载的其他文件。我们可以通过包括包名的类全称获取已加载的类的字节码，也可以通过文件流加载字节码。<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">var</span> <span class="variable">cr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassReader</span>(<span class="string">&quot;package.name.ClassName&quot;</span>);</span><br></pre></td></tr></table></figure><br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">var</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;fileName&quot;</span>);</span><br><span class="line"><span class="type">var</span> <span class="variable">cr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CLassReader</span>(in);</span><br></pre></td></tr></table></figure></p>
<p>接着我们创建一个 <code>ClassNode</code> 实例作为访问和存储类信息的对象。并使用该对象获取类信息。<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">var</span> <span class="variable">cls</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassNode</span>();</span><br><span class="line">cr.accept(cls, <span class="number">0</span>);</span><br></pre></td></tr></table></figure></p>
<p>接着我们就可以获取 <code>ClassNode</code> 中保存的类信息。<code>ClassNode</code> 的所有字段都是公共的。这样做是因为 <code>ClassNode</code> 类只作为保存数据的对象，而没有其他功能。因此使用公共字段是合理的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ClassNode中的一些字段：</span></span><br><span class="line"><span class="keyword">public</span> List&lt;Attribute&gt; attrs;</span><br><span class="line"><span class="keyword">public</span> List&lt;InnerClassNode&gt; innerClasses;</span><br><span class="line"><span class="keyword">public</span> String nestHostClass;</span><br><span class="line"><span class="keyword">public</span> List&lt;String&gt; nestMembers;</span><br><span class="line"><span class="keyword">public</span> List&lt;String&gt; permittedSubclasses;</span><br><span class="line"><span class="keyword">public</span> List&lt;RecordComponentNode&gt; recordComponents;</span><br><span class="line"><span class="keyword">public</span> List&lt;FieldNode&gt; fields;</span><br><span class="line"><span class="keyword">public</span> List&lt;MethodNode&gt; methods;</span><br></pre></td></tr></table></figure>
<p>这样我们就利用 ASM Tree 库实现了类似反射的功能。</p>
<h2 id="四、自定义访问器实现反射"><a href="#四、自定义访问器实现反射" class="headerlink" title="四、自定义访问器实现反射"></a>四、自定义访问器实现反射</h2><p>在这一部分，我们自定义一个简单的访问器，实现对类、方法、字段信息的获取。以此为例演示 ASM 核心库的使用方法。</p>
<p>我们创建 <code>MyClassVisitor</code> 类继承 <code>ClassVisitor</code>。<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyClassVisitor</span> <span class="keyword">extends</span> <span class="title class_">ClassVisitor</span></span><br></pre></td></tr></table></figure></p>
<p>添加希望获取的字段<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> String className;</span><br><span class="line"><span class="keyword">public</span> String superClassName;</span><br><span class="line"><span class="keyword">public</span> List&lt;String&gt; interfacesName = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br></pre></td></tr></table></figure></p>
<p>重写 <code>visit</code> 方法。这样我们就获取到了类名、父类名和接口名等信息。<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">visit</span><span class="params">(<span class="type">int</span> version, <span class="type">int</span> access, String name, String signature, String superName, String[] interfaces)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">super</span>.visit(version, access, name, signature, superName, interfaces);</span><br><span class="line">    className = name;</span><br><span class="line">    superClassName = superName;</span><br><span class="line">    interfacesName.addAll(List.of(interfaces));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>类似的，我们创建 <code>MyMethodVisitor</code> 和 <code>MyFieldVisitor</code> 类，并添加字段<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyMethodVisitor</span> <span class="keyword">extends</span> <span class="title class_">MethodVisitor</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String methodName;</span><br><span class="line">    <span class="keyword">public</span> String descriptor;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyFieldVisitor</span> <span class="keyword">extends</span> <span class="title class_">FieldVisitor</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String fieldType;</span><br><span class="line">    <span class="keyword">public</span> String fieldName;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>然后重写 <code>ClassVisitor</code> 的 <code>visitMethod</code> 和 <code>visitField</code>。<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> MethodVisitor <span class="title function_">visitMethod</span><span class="params">(<span class="type">int</span> access, String name, String descriptor, String signature, String[] exceptions)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">var</span> <span class="variable">mv</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyMethodVisitor</span>(Opcodes.ASM5,</span><br><span class="line">            <span class="built_in">super</span>.visitMethod(access, name, descriptor, signature, exceptions));</span><br><span class="line">    mv.methodName = name;</span><br><span class="line">    mv.descriptor = descriptor;</span><br><span class="line">    methods.add(mv);</span><br><span class="line">    <span class="keyword">return</span> mv;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> FieldVisitor <span class="title function_">visitField</span><span class="params">(<span class="type">int</span> access, String name, String descriptor, String signature, Object value)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">var</span> <span class="variable">fv</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyFieldVisitor</span>(Opcodes.ASM5,</span><br><span class="line">            <span class="built_in">super</span>.visitField(access, name, descriptor, signature, value));</span><br><span class="line">    fv.fieldName = name;</span><br><span class="line">    fv.fieldType = descriptor;</span><br><span class="line">    fields.add(fv);</span><br><span class="line">    <span class="keyword">return</span> fv;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这样就可以利用 <code>MyMethodVisitor</code> 获取 <code>ClassReader</code> 中的字节码信息了。<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">var</span> <span class="variable">cr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassReader</span>(<span class="string">&quot;org.objectweb.asm.ClassVisitor&quot;</span>);</span><br><span class="line"><span class="type">var</span> <span class="variable">cv</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyClassVisitor</span>(Opcodes.ASM5);</span><br><span class="line">cr.accept(cv, <span class="number">0</span>);</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>反射</tag>
        <tag>Java</tag>
        <tag>ASM</tag>
      </tags>
  </entry>
  <entry>
    <title>利用Colab训练神经网络</title>
    <url>/posts/3190f9b2/</url>
    <content><![CDATA[<h2 id="一、算力从哪里来？"><a href="#一、算力从哪里来？" class="headerlink" title="一、算力从哪里来？"></a>一、算力从哪里来？</h2><p>曾听到过这样一种说法，深度学习 “自学 + 没经费 = 天坑”。不幸的是我似乎正处于这种状态中。自学的方面还比较好克服，可没有 gpu 进行训练就 “难为无米之炊” 了。就算理论学得再好，自己构建的模型电脑带不动，没有实践的机会，也是难以学好这门学科的。</p>
<p>最近我正开始学着实现更大的模型，我的笔记本此前的小模型还可以勉强撑住，可现在却完全带不动了。一方面，训练的时间太长，挤占了我使用笔记本做其他事的时间；另一方面，我的 gpu 显存太小，不能调大参数，可参数较小时又无法收敛。这就是我面临的双重两难问题。</p>
<p>我希望找到一处租用算力的平台。它应该同时满足如下的条件</p>
<ol>
<li>算力丰富，能快速训练模型</li>
<li>对用户友好，和本机环境差别不大，能够迅速上手训练模型</li>
<li>费用便宜，最好有免费的算力</li>
</ol>
<p>综合以上各点，通过搜索，我找到了 Colab。Colab(oratory) 是一个 Google 研究项目，旨在帮助传播机器学习培训和研究成果。它是一个 Jupyter 笔记本环境，不需要进行任何设置就可以使用，并且完全在云端运行。Colab 笔记本存储在 Google 云端硬盘中，并且可以共享。利用Colaboratory ，可以方便的使用Keras, TensorFlow, PyTorch, OpenCV 等框架进行深度学习应用的开发。最重要的是，Colab 可免费使用。</p>
<h2 id="二、Colab基本操作"><a href="#二、Colab基本操作" class="headerlink" title="二、Colab基本操作"></a>二、Colab基本操作</h2><h3 id="（1）创建笔记本"><a href="#（1）创建笔记本" class="headerlink" title="（1）创建笔记本"></a>（1）创建笔记本</h3><blockquote>
<p>在正式介绍 Colab 之前需要说明一点，<strong>使用 Colab 需要科学上网</strong>。</p>
</blockquote>
<p>要新建 Colab 需要创建笔记，笔记是 Colab 编辑文本、代码和运行程序的地方。使用过 jupyter notebook 的人应该很了解。不同笔记之间内容互不相通，可以把每一个笔记看做一台独立运行的虚拟机。</p>
<p>Colab 是谷歌的产品，因此需要实现注册好一个谷歌账号。</p>
<h4 id="通过-Google-Drive-创建笔记本"><a href="#通过-Google-Drive-创建笔记本" class="headerlink" title="通过 Google Drive 创建笔记本"></a>通过 Google Drive 创建笔记本</h4><p><a href="https://drive.google.com/drive/">Google Drive</a> 是 Google 的一款云端硬盘，操作与其他云盘，如百度网盘、阿里云盘，类似。</p>
<p>通过 Google Drive 可以创建 Colab 笔记。方式是：点击左上角的“新建”按钮或右击背景 =&gt; 在弹出的窗口中选择“更多” =&gt; 选择 “Google Colaboratory” 选项。</p>
<img src="/posts/3190f9b2/drive_disk_colab.jpg" class="" title="drive_disk_colab">
<h4 id="通过-Colab-创建笔记本"><a href="#通过-Colab-创建笔记本" class="headerlink" title="通过 Colab 创建笔记本"></a>通过 Colab 创建笔记本</h4><p>还有另一种方式，直接访问 <a href="https://colab.research.google.com/">Colab</a> 网页。</p>
<p>在欢迎页处点击左上角，文件 =&gt; 新建笔记本即可创建。</p>
<img src="/posts/3190f9b2/colab_colab.jpg" class="" title="colab_colab">
<h3 id="（2）装载-Google-Drive"><a href="#（2）装载-Google-Drive" class="headerlink" title="（2）装载 Google Drive"></a>（2）装载 Google Drive</h3><p>讲解两种创建方法的原因，是指出 Colab 和 Google Drive 可以进行信息交互。Colab 笔记本身存储在 Google Drive 中，而 Google Drive 中的其他内容也可以被 Colab 笔记访问。另外，因为 Colab 虚拟机中的内容只在会话中保存，因此将数据集和训练过的模型存储在 Google Drive 也是必要的。</p>
<p>我们要建立 Colab 到 Google Drive 的连接。方法是点击左侧边栏文件夹图标 =&gt; 点击如下图标</p>
<img src="/posts/3190f9b2/load_disk.png" class="" title="load_disk">
<p>随后会在笔记本中创建如下的代码段<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> google.colab <span class="keyword">import</span> drive</span><br><span class="line">drive.mount(<span class="string">&#x27;/content/drive&#x27;</span>)</span><br></pre></td></tr></table></figure></p>
<p>运行这段代码（点击左侧“播放”按钮），随后点击新出现的内容中的url，按指示进行授权即可。</p>
<p>成功后，我们可以看到文件夹目录中多出了一个文件夹，其中即为 Google Drive 的内容。我们可以像对其他目录一样，直接用路径访问 Google Drive 中的文件。</p>
<h3 id="（3）Jupyter-笔记本"><a href="#（3）Jupyter-笔记本" class="headerlink" title="（3）Jupyter 笔记本"></a>（3）Jupyter 笔记本</h3><p>Jupyter Notebook 是一款应用程序，以网页的形式打开，可以在网页页面中直接编写代码和运行代码，代码的运行结果也会直接在代码块下显示。Colab 也使用了 Jupyter Notebook 作为编写代码的途径。下面简单介绍一下（Colab的） Jupyter 笔记本的使用。</p>
<p>Jupyter Notebook 中有两种单元格，其一是文本格、其二是代码格。文本格支持 markdown 语法，可以方便地进行排版。</p>
<p>代码格中能够编写代码，除了 python 外也支持其他语言，但使用 python 的为多。值得强调的是 Jupyter Notebook 中代码的执行方式。在 Notebook 中，代码被划分在不同的单元格中，每个单元格中的代码都可以单独执行，不需要考虑顺序，每个单元格也可以多次重复执行。唯一的约束是跨越单元格使用的变量、方法、类等等，应该先执行其声明，再执行其引用。当然，这是十分合理的要求。</p>
<p>可以看出，Jupyter Notebook 和 python 的命令行模式有相似之处。</p>
<h3 id="（4）命令行"><a href="#（4）命令行" class="headerlink" title="（4）命令行"></a>（4）命令行</h3><p>有时我们不止需要编写文本和代码，还需要进行系统的操作，这就需要执行系统命令。Colab 中提供了执行命令的方法：可以在代码格中输入命令，只需要在命令之前加上叹号 <code>!</code> 即可。例如</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">!ls -a</span><br></pre></td></tr></table></figure>
<h3 id="（5）管理会话"><a href="#（5）管理会话" class="headerlink" title="（5）管理会话"></a>（5）管理会话</h3><h4 id="必要性"><a href="#必要性" class="headerlink" title="必要性"></a>必要性</h4><p>我们已经知道了如何使用 Colab 编写代码、执行命令并持久地保存数据。这对于操作一台虚拟机来说已经足够了。在这一小节中，要讨论的是另一个问题，如何节省算力资源？</p>
<p>Colab 有免费的算力，但这是有限的。在资源不紧张的情况下，Colab 允许免费使用 gpu，但一旦资源紧张或者你占用了太多的资源，Colab 就可能在一段时间内禁止你使用 gpu。因此算力需要节省使用。</p>
<p>Colab 中，“会话” 指 Colab 前端到算力平台的连接。每当某一个笔记运行程序时，都会创建会话。会话一般不会自行结束（除非超过了24小时未使用），如果忘记关闭的会话恰好连接了一个 gpu，那么造成的算力浪费将是惊人的。</p>
<p>说道这里，恰好解释一下会话的不同类型。会话分为 cpu、gpu 和 tpu。cpu 的会话几乎不会消耗资源（消耗得很少）；gpu 和 tpu 的会话则会消耗资源，并且根据使用的 gpu 和 tpu 类型的不同，消耗资源的速度也不同。</p>
<h4 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h4><p>因此，我们可以在平时编写代码时只连接 cpu，而到了训练时才连接 gpu 或 tpu。这需要进行会话的切换，具体方法如下：</p>
<p>新建笔记，我们可以在笔记的右上角看到下图红色框所指示的按钮。点击该按钮，或者运行某一段代码，就会使笔记连接到服务器。会话的类型由设置决定，如果是第一次使用，则连接的便为 cpu。</p>
<img src="/posts/3190f9b2/session1.png" class="" title="session1">
<p>连接成功后，图标变为类似下图的样子。</p>
<img src="/posts/3190f9b2/session2.png" class="" title="session2">
<p>点击旁边的小箭头，会弹出更多选项。</p>
<img src="/posts/3190f9b2/session3.jpg" class="" title="session3">
<ul>
<li>连接到托管运行时，为使用谷歌的资源</li>
<li>连接到本地运行时，为使用本机的资源</li>
<li>断开连接，将删除当前的会话，当然在会话中创建的文件等内容也会一并消除，需要事先移动到 Google Drive 中。</li>
</ul>
<p>更重要的是更下面的选项</p>
<ul>
<li><p>查看资源，点击后出现如下的窗口，点击 “更改运行时类型” 即可选择会话的类型。点击 “管理会话” 和选项 “管理会话” 的结果相同。</p>
<blockquote>
<p>在连接成功后点击图标，同样能显示此窗口，但这时再更改运行时类型，只会创建一个新的会话。因此应该在连接断开时更改。</p>
  <img src="/posts/3190f9b2/session3.jpg" class="" title="session3">
</blockquote>
</li>
<li><p>管理会话，点击后显示正在进行的会话。太多不使用的会话会占用更多的资源，可以点击右侧垃圾桶图标结束会话。</p>
</li>
</ul>
<p>通过合理地创建会话和结束会话，可以做到资源利用的最大化。</p>
<h2 id="三、Colab训练神经网络"><a href="#三、Colab训练神经网络" class="headerlink" title="三、Colab训练神经网络"></a>三、Colab训练神经网络</h2><p>虽然 Colab 笔记能编写代码，但是代码组织在同一个文件中，同时难以调试，很不方便。</p>
<p>使用 Colab 训练神经网络比较好的方法是在本地把代码跑通；把代码和数据集打包上传到 Google Drive 中；随后 Colab 装载 Google Drive，并通过命令执行 python 代码文件。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">!python <span class="string">&quot;/content/drive/train.py&quot;</span></span><br></pre></td></tr></table></figure>
<p>训练神经网络时经常使用 tensorboard，在 Colab 中也可以使用。只需要在代码块中执行如下两条：</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">%load_ext tensorboard</span><br><span class="line">%tensorboard --logdir=<span class="string">&quot;/content/drive/logs&quot;</span></span><br></pre></td></tr></table></figure>
<h2 id="四、购买算力和订阅"><a href="#四、购买算力和订阅" class="headerlink" title="四、购买算力和订阅"></a>四、购买算力和订阅</h2><p>有时，Colab 提供的免费算力依旧不够用，这时就需要购买额外的算力了。在资源窗口中点击 “升级到 <a href="https://colab.research.google.com/signup/pricing">Colab Pro</a>” 或在设置中选择 “<a href="https://colab.research.google.com/signup/pricing">Colab Pro</a>” 选项。即可跳转到购买界面。可以选择只购买计算单元或是每月订阅。</p>
<p>需要注意的是，Colab 只支持信用卡支付。对一些学生来说，这可能不太方便。一种解决办法是使用虚拟信用卡。这一部分和本文关系不大，上网可以搜索到相关资料，因此不详细说明。</p>
<h2 id="五、参考资料"><a href="#五、参考资料" class="headerlink" title="五、参考资料"></a>五、参考资料</h2><ul>
<li><a href="https://zhuanlan.zhihu.com/p/386162610">Google Colab 快速上手</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/218133131">Google Colab 的正确使用姿势</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/111343423">使用colab进行深度学习训练</a></li>
</ul>
]]></content>
      <categories>
        <category>踩坑记录</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
        <tag>Colab</tag>
      </tags>
  </entry>
  <entry>
    <title>只出现一次的数字</title>
    <url>/posts/2c835ddc/</url>
    <content><![CDATA[<h2 id="136-只出现一次的数字"><a href="#136-只出现一次的数字" class="headerlink" title="136. 只出现一次的数字"></a>136. 只出现一次的数字</h2><blockquote>
<p>给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出&gt;那个只出现了一次的元素。</p>
<p>说明：<br>你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？</p>
</blockquote>
<h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><p>题目本身很简单，但是要做到O(1)的空间复杂度还是需要思考的。正确的做法是使用位运算，</p>
<p>具体来说，是利用异或的运算性质。即两个相同的数异或为0，任何数与0异或得其本身。异或的这一性质用于偶数次出现的元素很有用处。</p>
<p>对于本道题，就是需要将所有数一同进行异或运算。因为异或满足交换律，所以所有出现偶数次（两次）的数结合都得0，而所有出现奇数次（一次）的数则保持其本身不变。又因数组中只有一个元素出现一次，因此全部异或的结果就是只出现一次的数本身。<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">singleNumber</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> num : nums)</span><br><span class="line">            ans ^= num;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>或许以后会总结一篇位运算的用法</p>
</blockquote>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>LeetCode</tag>
        <tag>位运算</tag>
      </tags>
  </entry>
  <entry>
    <title>后端开发笔记之Docker</title>
    <url>/posts/a2d88011/</url>
    <content><![CDATA[<h2 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h2><p>最近事情有些多，这篇短文写写停停，花费了很长时间。本来想着在五一假期结束前完成这一系列文章的，现在看来还有些困难呀。</p>
<p>这篇文章总结了自己使用 Docker 时用到的一些知识，可能内容不深，还请见谅。<br><span id="more"></span></p>
<h2 id="二、镜像的构筑"><a href="#二、镜像的构筑" class="headerlink" title="二、镜像的构筑"></a>二、镜像的构筑</h2><h3 id="（1）Docker-镜像简介"><a href="#（1）Docker-镜像简介" class="headerlink" title="（1）Docker 镜像简介"></a>（1）Docker 镜像简介</h3><p>正如在“准备工作”那篇文章中所说的，镜像时静态的容器，容器是运行的镜像。我们在使用 Docker 时，需要做的就是像编写代码一样构建 Docker 镜像。</p>
<p>Docker 镜像中包含了一套文件系统，其所维护的文件包含了项目运行所需的环境以及项目本身。但是镜像和一般的文件系统不同，镜像由一系列层构成，每一层中存储了对之前镜像的修改信息。</p>
<p>这样做有一定的优点，在下载镜像时，我们不需要每次都下载完整的镜像；而只需要下载与本地镜像不相同的层就可以了。另一方面，容器基于镜像进行构筑，在容器运行时，分层设计也有利于不同容器的共享。采取写时复制技术可以减少内存的占用。</p>
<p>我们进行镜像的构筑时，也不需要从头开始，而可以选择在已有的镜像上添加新的层，通过修改已有环境来构建我们所需的项目运行环境。</p>
<h3 id="（2）Dockerfile-简介"><a href="#（2）Dockerfile-简介" class="headerlink" title="（2）Dockerfile 简介"></a>（2）Dockerfile 简介</h3><p>Docker 中使用 Dockerfile 来设置镜像构建的操作流程，这一点类似于 Makefile。这里借我的后端项目中的 Dockerfile 的内容来稍微解释一下。<br><figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="comment"># python alpine is the smallest python image</span></span><br><span class="line"><span class="keyword">FROM</span> python:<span class="number">3.9</span>-alpine</span><br><span class="line"></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> ./src /src</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> ./start.sh ./</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> ./config.ini ./</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> pip install -r ./src/requirements.txt</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># ash is shell for alpine</span></span><br><span class="line"><span class="keyword">CMD</span><span class="language-bash"> ash start.sh </span></span><br></pre></td></tr></table></figure></p>
<p>Dockerfile 中使用一系列大写关键字作为指令，构建镜像时，从头到尾依次执行。</p>
<p>第一句使用了 <code>FROM</code> 指令。该指令指定了构筑时的基础镜像，接下来的指令都是对镜像的修改，会在基础镜像上增加新的层。这里 <code>FROM python:3.9-alpine</code> 指定了一个镜像，来自仓库 python，标签为 3.9-alpine。该镜像包含了 python3.9 的运行环境，底层的操作系统为 <code>alpine</code>，这也是 Linux 的一个发行版，以体积小著称。</p>
<p>接下来的三条指令为 <code>COPY</code>，该指令用于将本地的文件复制到镜像中，第一个参数为本地的路径，第二个为镜像中路径。对第一条指令 <code>COPY ./src /src</code>，本地路径为目录，这意味着复制该目录下的所有文件，到镜像中的 <code>/src</code> 路径下。后两条指令中本地路径为目录，则只将该文件复制到对应路径下。</p>
<p>之后使用了 <code>RUN</code> 指令，该指令用于运行一条 shell 命令。这里我们使用 pip 命令下载 python 依赖包。注意此处提供给 pip 的路径为镜像内路径。</p>
<p>最后 <code>CMD</code> 指令同样用于运行命令，只不过该命令在启动容器时才会调用。这里我们执行了 start.sh 脚本以启动服务。ash 类似于 bash，但是是属于 alpine 的 shell 程序。<code>CMD</code> 还有另外一种写法，<code>CMD [&quot;ash&quot;, &quot;start.sh&quot;]</code></p>
<p>除此之外 Dockerfile 中还可以使用其他许多指令。这里在列举几个在我看来较为重要的指令。</p>
<h4 id="ENTRYPOINT"><a href="#ENTRYPOINT" class="headerlink" title="ENTRYPOINT"></a>ENTRYPOINT</h4><p><code>ENTRYPOINT</code> 指令和 <code>CMD</code> 类似，都可以执行 shell 命令。但是 <code>ENTRYPOINT</code> 和 <code>CMD</code> 结合使用，可以实现可变参数的效果。<br><figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 定参</span></span><br><span class="line"><span class="keyword">ENTRYPOINT</span><span class="language-bash"> [<span class="string">&quot;nginx&quot;</span>, <span class="string">&quot;-c&quot;</span>]</span></span><br><span class="line"><span class="comment"># 变参</span></span><br><span class="line"><span class="keyword">CMD</span><span class="language-bash"> [<span class="string">&quot;/etc/nginx/nginx.conf&quot;</span>]</span></span><br></pre></td></tr></table></figure></p>
<p>如上所示，这里 <code>ENTRYPOINT</code> 和 <code>CMD</code> 并非两条指令，而是一条指令 <code>nginx -c /etc/nginx/nginx.conf</code>。<code>CMD</code> 中的内容作为 <code>ENTRYPOINT</code> 中命令的参数。</p>
<p>当我们运行容器时，想要修改 <code>CMD</code> 所设置的参数，只需要在命令中增加参数 <code>-c /etc/nginx/new.conf</code> 即可。</p>
<h4 id="ENV-和-ARG"><a href="#ENV-和-ARG" class="headerlink" title="ENV 和 ARG"></a>ENV 和 ARG</h4><p>这两个指令都用于设定环境变量，只不过 ARG 设定的环境变量在完成镜像构筑后便被移除。设定环境变量的语法如下<br><figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ENV</span> &lt;key1&gt;=&lt;val1&gt; &lt;key2&gt;=&lt;val2&gt;</span><br><span class="line"><span class="keyword">ARG</span> &lt;key3&gt;=&lt;val3&gt; &lt;key4&gt;=&lt;val4&gt;</span><br></pre></td></tr></table></figure></p>
<h4 id="VOLUME"><a href="#VOLUME" class="headerlink" title="VOLUME"></a>VOLUME</h4><p>Docker 中用 “卷” 来表示主机目录和容器目录的映射关系。当设定容器目录中的某个路径为卷后，该路径下的内容便会直接保存在主机上。这样可以避免重要的数据因为容器重启而丢失；也可以避免容器大小增大。</p>
<p>在 Dockerfile 中使用 <code>VOLUME</code> 指定哪些路径作为卷。但是此处只是指定某些路径被映射到主机，而并未指出要映射到主机的哪些路径。这是因为不同主机的文件系统本就不同，设定映射应该交由镜像的使用者根据自身情况设定。在这里进行设置，只是映射到默认的路径上。<br><figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">VOLUME</span><span class="language-bash"> [<span class="string">&quot;&lt;path1&gt;&quot;</span>, <span class="string">&quot;&lt;path2&gt;&quot;</span>]</span></span><br></pre></td></tr></table></figure></p>
<h4 id="EXPOSE"><a href="#EXPOSE" class="headerlink" title="EXPOSE"></a>EXPOSE</h4><p><code>EXPOSE</code> 指令设定了容器内运行的服务对外提供的端口，可以方便镜像的使用者进行设置。此指令只是用于声明而已，并不具有更多的作用。</p>
<h3 id="（3）镜像构筑"><a href="#（3）镜像构筑" class="headerlink" title="（3）镜像构筑"></a>（3）镜像构筑</h3><p>在 Dockerfile 中我们已经完成了大部分镜像构筑时的配置操作。在最后，我们需要执行 <code>build</code> 命令完成镜像的构筑。<br><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">docker build -t myimage:v1 ./</span><br></pre></td></tr></table></figure></p>
<p>这里 <code>-t</code> 参数为镜像命名。其中这里的 <code>myimage</code> 为镜像所属的仓库名，而 <code>v1</code> 表示该镜像的标签。仓库中常常保存同一个应用的不同镜像，而标签则用于区分仓库中不同镜像间的区别，因此常用版本号作为标签。</p>
<p>最后的 <code>./</code> 指定了 Dockerfile 所在的位置。这样 docker 就将按指定路径的 Dockerfile 中的指令进行镜像的构筑。</p>
<p>最后执行命令 <code>docker images</code>，就可以看到本地的所有镜像信息了，这其中包含了我们新创建的镜像。</p>
<h2 id="三、容器的运行"><a href="#三、容器的运行" class="headerlink" title="三、容器的运行"></a>三、容器的运行</h2><h3 id="（1）容器运行"><a href="#（1）容器运行" class="headerlink" title="（1）容器运行"></a>（1）容器运行</h3><p>我们以镜像作为模板创建容器并运行。要运行容器，需要使用 <code>run</code> 命令。</p>
<p>如果我们希望基于上一节构筑的镜像运行，需要如下命令<br><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">docker run -d --name mycontainer -p 5000:5000 myimage:v1</span><br></pre></td></tr></table></figure></p>
<p>这里我们除了传入 <code>myimage:v1</code> 作为容器运行的镜像外，还设定了一些参数。</p>
<p>首先 <code>-d</code> 设定容器启动后移到后台运行。类似的有前台交互的方式运行的选项，<code>-it</code>，其中 <code>-i</code> 指交互式操作，<code>-t</code> 指终端，这两者常常同时使用</p>
<p><code>--name</code> 设定了容器名为 <code>mycontainer</code>。不同的容器有容器 ID 作为标识符，但容器 ID 常常难以记忆，于是经常为容器起名作为第二种指代容器的手段</p>
<p><code>-p</code> 参数设定了容器的端口映射方式。在上面的例子中 <code>5000:5000</code> 表示将容器内的 5000 端口映射到了容器外的 5000 端口。前者为本地主机的端口，后者为容器内的端口。这样的映射意味着对本机的 5000 端口的请求，会转为请求容器内的 5000 端口。</p>
<h3 id="（2）操纵容器"><a href="#（2）操纵容器" class="headerlink" title="（2）操纵容器"></a>（2）操纵容器</h3><p>当容器在后台运行时，我们可能需要得知其状态。可以使用 <code>logs</code> 指令获取容器内的标准输出结果<br><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">docker logs mycontainer</span><br></pre></td></tr></table></figure></p>
<p>有时我们还需要进入到后台运行的容器内部。这可以使用 <code>exec</code> 指令实现。该指令用于执行一条 shell 命令。当我们选择执行 shell 终端，并附加 <code>-it</code> 参数时，就能进入到容器的命令行中。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">docker <span class="built_in">exec</span> -it mycontainer /bin/bash</span><br></pre></td></tr></table></figure>
<p>如果想要暂停容器，可以使用 <code>stop</code>。执行该命令后容器暂停运行，但依旧存在。<br><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">docker stop mycontainer</span><br></pre></td></tr></table></figure></p>
<p>我们可以使用 <code>ps</code> 查看容器信息。不加额外参数则只显示正在运行的容器。<br><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">docker ps</span><br></pre></td></tr></table></figure></p>
<p>在执行 <code>stop</code> 之前，应该可以看到 <code>mycontainer</code> 的相关信息；而在之后就看不到 <code>mycontainer</code> 的信息了。</p>
<p>这时为 <code>ps</code> 增加参数 <code>-a</code> 就可以查看所有容器，包括正在运行和暂未运行的容器的信息。<br><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">docker ps -a</span><br></pre></td></tr></table></figure></p>
<p>想要真正的移除容器需要 <code>rm</code> 命令。该命令将删除容器的一切信息，包括容器运行过程中产生的数据。<br><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">docker <span class="built_in">rm</span> mycontainer</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>Docker</tag>
        <tag>后端</tag>
      </tags>
  </entry>
  <entry>
    <title>后端开发笔记之Flask简介</title>
    <url>/posts/b7c97beb/</url>
    <content><![CDATA[<h2 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h2><p>这一篇文章中主要讲解了为完成后端项目所使用的 Flask 框架。对于自己所使用的功能和特性进行了着重的讨论。当然说是着重讨论，其实还是皮毛罢了。想要更加系统地了解 Flask，还请查看<a href="https://dormousehole.readthedocs.io/en/latest/index.html">官方文档</a></p>
<span id="more"></span>
<h2 id="二、Flask"><a href="#二、Flask" class="headerlink" title="二、Flask"></a>二、Flask</h2><h3 id="（1）Flask-介绍"><a href="#（1）Flask-介绍" class="headerlink" title="（1）Flask 介绍"></a>（1）Flask 介绍</h3><p>Flask 是一个 Python Web 框架，十分轻量灵活，可以用于开发小型 Web 应用。Flask 高度可扩展，可以通过添加不同的组件来实现定制化的功能。对于简单的后端任务来说，Flask 十分合适。</p>
<h3 id="（2）Flask-用于后端"><a href="#（2）Flask-用于后端" class="headerlink" title="（2）Flask 用于后端"></a>（2）Flask 用于后端</h3><p>虽然 Flask 可以实现经典的 MVC 架构，但是本项目只进行后端开发，提供一些用于数据库操作的 RESTful 接口，并不涉及显示的部分。因此只讨论 Flask 用于后端开发的方面。</p>
<p>对于后端项目，我们希望其向下管理数据库，向上为前端提供接口。这就需要用到 ORM 来通过对象管理数据库关系；同时通过 Route 提供 api 接口。</p>
<p>另外，我们还需要对项目进行管理，以合理的结构组织项目。我们需要了解 Flask 的 BluePrint。</p>
<h2 id="三、ORM"><a href="#三、ORM" class="headerlink" title="三、ORM"></a>三、ORM</h2><h3 id="（1）数据库设置"><a href="#（1）数据库设置" class="headerlink" title="（1）数据库设置"></a>（1）数据库设置</h3><p>Flask 使用 Flask-SQLAlchemy 组件实现 ORM。SQLAlchemy 本是独立于 Flask 的 ORM 库，但在 Flask 中使用时，又针对 Flask 进行了一定封装。</p>
<p>我们希望创建到数据库的连接，这需要在后端项目中进行设置。对 Flask 来说，设置以字符串的形式保存于项目的配置变量 <code>SQLALCHEMY_DATABASE_URI</code> 中。<br><figure class="highlight py"><table><tr><td class="code"><pre><span class="line">app = Flask(__name__)</span><br><span class="line">app.config[<span class="string">&#x27;SQLALCHEMY_DATABASE_URI&#x27;</span>] = <span class="string">f&#x27;mysql+pymysql://<span class="subst">&#123;username&#125;</span>:<span class="subst">&#123;password&#125;</span>@<span class="subst">&#123;host&#125;</span>:<span class="subst">&#123;port&#125;</span>/<span class="subst">&#123;name&#125;</span>?charset=utf8mb4&#x27;</span></span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>配置存储于 <code>app.config</code> 中。其中 <code>app</code> 是一个 <code>Flask</code> 类型的对象，用于表示 Flask 项目这个整体。</p>
</blockquote>
<p>通过查看上面的代码，应该可以理解该配置的具体格式是样子的了。比如说<br><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;mysql+pymysql://root:123456@localhost:3306/db_test?charset=utf8mb4&#x27;</span></span><br></pre></td></tr></table></figure></p>
<p>表示连接的数据库为 mysql，用户名为 root，密码为 123456，连接地址为 localhost:3306，选用的数据库名为 db_test，使用字符集为 utf8mb4。</p>
<p>我们通过这样的设置创建数据库连接，命名为 <code>db</code>。接下来我们所有的 ORM 操作都要通过 <code>db</code> 实现。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> flask_sqlalchemy <span class="keyword">import</span> SQLAlchemy</span><br><span class="line"></span><br><span class="line">db = SQLAlchemy(app)</span><br></pre></td></tr></table></figure>
<h3 id="（2）字段设置"><a href="#（2）字段设置" class="headerlink" title="（2）字段设置"></a>（2）字段设置</h3><p>在数据库中有着不同的表格，有着各自的列，记录着一条条数据。反映到 SQLAlchemy 中，表格对应着类，所有表示着表格的类都是 <code>db.Model</code> 的子类；而表的列对应着类的字段，类的字段的类型都为 <code>db.Column</code>，通过设置 <code>db.Column</code> 的属性来表示不同的列。</p>
<p>举例来说，我们想要设置 departments 表，它有 <code>dept_no</code> 和 <code>dept_name</code> 作为列。那么对应的类表示如下<br><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Department</span>(db.Model):</span><br><span class="line">    __tablename__ = <span class="string">&quot;departments&quot;</span></span><br><span class="line">    dept_no = db.Column(db.String(<span class="number">4</span>), nullable=<span class="literal">False</span>, primary_key=<span class="literal">True</span>)</span><br><span class="line">    dept_name = db.Column(db.String(<span class="number">40</span>), nullable=<span class="literal">False</span>, unique=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure></p>
<p>我们将 <code>Department</code> 类作为 departments 表的对应（<code>__tablename__</code> 字段用于表示表名，必须设定，否则以类名作为表名）。通过 <code>db.Column</code> 设置列的约束，如类型约束、是否可空、是否主键、是否唯一，以及索引等等内容。</p>
<p>需要注意 <code>db.String</code>，Flask-SQLAlchemy 使用这种方式设定字段的类型。类似的还有 <code>db.Integer</code>，<code>db.Enum</code>，<code>db.Date</code> 等等。它们的使用可看如下的例子<br><figure class="highlight py"><table><tr><td class="code"><pre><span class="line">emp_no = db.Column(db.Integer, primary_key=<span class="literal">True</span>, nullable=<span class="literal">False</span>)</span><br><span class="line">gender = db.Column(db.Enum(<span class="string">&#x27;M&#x27;</span>, <span class="string">&#x27;F&#x27;</span>), nullable=<span class="literal">False</span>)</span><br><span class="line">birth_date = db.Column(db.Date, nullable=<span class="literal">False</span>)</span><br></pre></td></tr></table></figure></p>
<h3 id="（3）关系设置"><a href="#（3）关系设置" class="headerlink" title="（3）关系设置"></a>（3）关系设置</h3><p>我们还需要为数据库对象间设定关系，即一对一、一对多、多对多关系。一对一、一对多关系只需要将某一列设定为外键即可，较为简单，因此这里只考虑多对多关系。我们先看如下的例子，其中展示了如何实现多对多关系<br><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Department</span>(db.Model):</span><br><span class="line">    __tablename__ = <span class="string">&quot;departments&quot;</span></span><br><span class="line">    dept_no = db.Column(db.String(<span class="number">4</span>), nullable=<span class="literal">False</span>, primary_key=<span class="literal">True</span>)</span><br><span class="line">    dept_name = db.Column(db.String(<span class="number">40</span>), nullable=<span class="literal">False</span>, unique=<span class="literal">True</span>)</span><br><span class="line">    <span class="comment"># relation</span></span><br><span class="line">    employees = db.relationship(<span class="string">&#x27;Dept2Emp&#x27;</span>, back_populates=<span class="string">&#x27;department&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Employee</span>(db.Model):</span><br><span class="line">    __tablename__ = <span class="string">&quot;employees&quot;</span></span><br><span class="line">    emp_no = db.Column(db.Integer, nullable=<span class="literal">False</span>, primary_key=<span class="literal">True</span>)</span><br><span class="line">    birth_date = db.Column(db.Date, nullable=<span class="literal">False</span>)</span><br><span class="line">    first_name = db.Column(db.String(<span class="number">14</span>), nullable=<span class="literal">False</span>, index=<span class="literal">True</span>)</span><br><span class="line">    last_name = db.Column(db.String(<span class="number">16</span>), nullable=<span class="literal">False</span>)</span><br><span class="line">    gender = db.Column(db.Enum(<span class="string">&#x27;M&#x27;</span>, <span class="string">&#x27;F&#x27;</span>), nullable=<span class="literal">False</span>)</span><br><span class="line">    hire_date = db.Column(db.Date, nullable=<span class="literal">False</span>)</span><br><span class="line">    <span class="comment"># relation</span></span><br><span class="line">    departments = db.relationship(<span class="string">&#x27;Dept2Emp&#x27;</span>, back_populates=<span class="string">&#x27;employee&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dept2Emp</span>(db.Model):</span><br><span class="line">    __tablename__ = <span class="string">&quot;dept_emp&quot;</span></span><br><span class="line">    emp_no = db.Column(db.Integer, db.ForeignKey(<span class="string">&#x27;employees.emp_no&#x27;</span>, ondelete=<span class="string">&#x27;cascade&#x27;</span>), primary_key=<span class="literal">True</span>,</span><br><span class="line">                       nullable=<span class="literal">False</span>)</span><br><span class="line">    dept_no = db.Column(db.String(<span class="number">4</span>), db.ForeignKey(<span class="string">&#x27;departments.dept_no&#x27;</span>, ondelete=<span class="string">&#x27;cascade&#x27;</span>), primary_key=<span class="literal">True</span>,</span><br><span class="line">                        nullable=<span class="literal">False</span>, index=<span class="literal">True</span>)</span><br><span class="line">    from_date = db.Column(db.Date, nullable=<span class="literal">False</span>)</span><br><span class="line">    to_date = db.Column(db.Date, nullable=<span class="literal">False</span>)</span><br><span class="line">    <span class="comment"># relation</span></span><br><span class="line">    department = db.relationship(<span class="string">&#x27;Department&#x27;</span>, back_populates=<span class="string">&#x27;employees&#x27;</span>)</span><br><span class="line">    employee = db.relationship(<span class="string">&#x27;Employee&#x27;</span>, back_populates=<span class="string">&#x27;departments&#x27;</span>)</span><br></pre></td></tr></table></figure></p>
<p>首先我们创建关系表 dept_emp，对应类 <code>Dept2Emp</code>。在作为外键的字段 <code>emp_no</code> 和 <code>dept_no</code> 上用 <code>db.ForeignKey</code> 加以标识，指示外键对应的表和字段、以及删除时的操作 <code>on_delete</code>。<br><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Dept2Emp</span>(db.Model):</span><br><span class="line">    __tablename__ = <span class="string">&quot;dept_emp&quot;</span></span><br><span class="line">    emp_no = db.Column(db.Integer, db.ForeignKey(<span class="string">&#x27;employees.emp_no&#x27;</span>, ondelete=<span class="string">&#x27;cascade&#x27;</span>), primary_key=<span class="literal">True</span>,</span><br><span class="line">                       nullable=<span class="literal">False</span>)</span><br><span class="line">    dept_no = db.Column(db.String(<span class="number">4</span>), db.ForeignKey(<span class="string">&#x27;departments.dept_no&#x27;</span>, ondelete=<span class="string">&#x27;cascade&#x27;</span>), primary_key=<span class="literal">True</span>,</span><br><span class="line">                        nullable=<span class="literal">False</span>, index=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure></p>
<p>之后通过 <code>db_relationship</code> 创建关系。在 <code>Dept2Emp</code> 中我们需要分别建立到 <code>Department</code> 和 <code>Employee</code> 的联系<br><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment"># relation</span></span><br><span class="line">department = db.relationship(<span class="string">&#x27;Department&#x27;</span>, back_populates=<span class="string">&#x27;employees&#x27;</span>)</span><br><span class="line">employee = db.relationship(<span class="string">&#x27;Employee&#x27;</span>, back_populates=<span class="string">&#x27;departments&#x27;</span>)</span><br></pre></td></tr></table></figure></p>
<p>同样分别对于 <code>Department</code> 和 <code>Employee</code>，都需要建立到 <code>Dept2Emp</code> 的联系<br><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Department</span>(db.Model):</span><br><span class="line">    __tablename__ = <span class="string">&quot;departments&quot;</span></span><br><span class="line">    <span class="comment"># relation</span></span><br><span class="line">    employees = db.relationship(<span class="string">&#x27;Dept2Emp&#x27;</span>, back_populates=<span class="string">&#x27;department&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Employee</span>(db.Model):</span><br><span class="line">    __tablename__ = <span class="string">&quot;employees&quot;</span></span><br><span class="line">    <span class="comment"># relation</span></span><br><span class="line">    departments = db.relationship(<span class="string">&#x27;Dept2Emp&#x27;</span>, back_populates=<span class="string">&#x27;employee&#x27;</span>)</span><br></pre></td></tr></table></figure></p>
<p>唯一需要注意的是对参数 <code>back_populates</code> 的设置。该参数指示了当前设定的关系要与对应类的哪个字段发生联系，在具有关系的两个字段间需要同时设置。</p>
<h3 id="（4）事件设置"><a href="#（4）事件设置" class="headerlink" title="（4）事件设置"></a>（4）事件设置</h3><p>有时我们会希望实现类似触发器的功能。SQLAlchemy 提供了事件，用于在 Python 代码而非数据库中实现事件处理。</p>
<p>比如说，如果想要在某一表中插入数据的同时在另一个表中插入对应的数据，只需要这样<br><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="meta">@db.event.listens_for(<span class="params">Dept2Manager, <span class="string">&#x27;after_insert&#x27;</span></span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">insert_into_dept_manager_title_simultaneously</span>(<span class="params">mapper, connection, target</span>):</span><br><span class="line">    new_elm = DeptManagerTitle(target.emp_no, target.from_date, target.to_date)</span><br><span class="line">    db.session.add(new_elm)</span><br><span class="line">    db.session.commit()</span><br></pre></td></tr></table></figure><br><code>@db.event.listens_for(Dept2Manager, &#39;after_insert&#39;)</code> 设定了监听的事件为对 <code>Dept2Manager</code> 的插入操作，此时我们会获取新插入的数据 <code>target</code>，并进行一系列后续处理。对本处理函数来说，即为在 <code>DeptManagerTitle</code> 中同时插入数据。</p>
<h3 id="（5）MDL-语句"><a href="#（5）MDL-语句" class="headerlink" title="（5）MDL 语句"></a>（5）MDL 语句</h3><h4 id="insert"><a href="#insert" class="headerlink" title="insert"></a>insert</h4><p>因为 ORM 技术，我们只需要创建新的对象，并将该对象添加到数据库中即可完成插入操作，如<br><figure class="highlight py"><table><tr><td class="code"><pre><span class="line">department = Department(dept_no=<span class="string">&quot;A001&quot;</span>, dept_name=<span class="string">&quot;first&quot;</span>)</span><br><span class="line"><span class="comment"># departments = [department]</span></span><br><span class="line">db.session.add(department)</span><br><span class="line"><span class="comment"># db.session.add_all(departments)</span></span><br><span class="line">db.commit()</span><br></pre></td></tr></table></figure></p>
<p>注意所有的数据库修改，都只有在调用 <code>db.commit()</code> 后才会执行。</p>
<blockquote>
<p>有可能存在通过字典创建对象的操作，这时只需要调用 <code>YourClass(**d)</code> 即可。</p>
</blockquote>
<h4 id="delete"><a href="#delete" class="headerlink" title="delete"></a>delete</h4><p>删除类似，只需要将对象从数据库中删除即可<br><figure class="highlight py"><table><tr><td class="code"><pre><span class="line">db.session.delete(target)</span><br><span class="line">db.session.commit()</span><br></pre></td></tr></table></figure></p>
<h4 id="update"><a href="#update" class="headerlink" title="update"></a>update</h4><p>对于修改，只需要直接修改对象的字段，并调用 <code>db.session.commit()</code> 即可。<br><figure class="highlight py"><table><tr><td class="code"><pre><span class="line">target.count += <span class="number">1</span></span><br><span class="line">db.session.commit()</span><br></pre></td></tr></table></figure></p>
<p>当然还有基于查询的更新，这需要对于查询结果执行 <code>update</code> 方法，传入的参数为一个字典，其中包含要修改的字段名和修改后的值。<br><figure class="highlight py"><table><tr><td class="code"><pre><span class="line">update_dict = &#123;<span class="string">&quot;count&quot;</span>: <span class="number">10</span>&#125;</span><br><span class="line">Department.query.update(update_dict)</span><br><span class="line">db.session.commit()</span><br></pre></td></tr></table></figure></p>
<h3 id="query"><a href="#query" class="headerlink" title="query"></a>query</h3><p>SQLAlchemy 的查询通过 <code>filter</code> 实现 where，通过 <code>group_by</code> 实现 group by，通过 <code>order_by</code> 实现 order by。对于查询结果，使用 <code>first</code>、<code>all</code> 等进行输出。<br><figure class="highlight py"><table><tr><td class="code"><pre><span class="line">result = Employee.query.<span class="built_in">filter</span>(Employee.emp_no &gt;= <span class="number">10100</span>).order_by(Employee.emp_no).first()</span><br></pre></td></tr></table></figure></p>
<p>对于只进行等值查询的情况，还可使用 <code>filter_by</code> 替换 <code>filter</code><br><figure class="highlight py"><table><tr><td class="code"><pre><span class="line">result = Employee.query.<span class="built_in">filter</span>(first_name=<span class="string">&quot;Tom&quot;</span>).<span class="built_in">all</span>()</span><br></pre></td></tr></table></figure></p>
<p>当然查询部分还有很多内容，不过由于本文只是简介，因此就像其他部分没有讲解的内容一样，就此打住吧。</p>
<h2 id="四、Route"><a href="#四、Route" class="headerlink" title="四、Route"></a>四、Route</h2><h3 id="（1）路由简介"><a href="#（1）路由简介" class="headerlink" title="（1）路由简介"></a>（1）路由简介</h3><p>路由是路径到函数的映射过程。通过路由，我们就将路径请求转化为了函数调用。Flask 实现了路由机制，能让我们通过简单地编写函数就提供了 api。</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">/api/v1/xxx/yyy?x1=a&amp;x2=b =====&gt; func(xxx, yyy)</span><br></pre></td></tr></table></figure>
<h3 id="（2）路由的使用"><a href="#（2）路由的使用" class="headerlink" title="（2）路由的使用"></a>（2）路由的使用</h3><p>路由的使用十分简单，我们只需要为作为接口的函数增加一个修饰器即可，例如<br><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&#x27;/api/v1/&lt;table_name&gt;&#x27;</span>, methods=[<span class="string">&#x27;POST&#x27;</span>]</span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">insert</span>(<span class="params">table_name</span>):</span><br></pre></td></tr></table></figure></p>
<p>我们为 insert 函数增加了修饰器<code>@app.route</code>（其中 <code>app = Flask(__name__)</code>），将路径 <code>/api/v1/&lt;table_name&gt;</code> 映射到该函数，同时设定只响应 POST 类型请求。</p>
<p>注意这里我们使用了路径参数 <code>table_name</code>，这需要添加 Flask_RESTful 组件。路径参数使用时在路径中需要用尖括号声明，同时函数中也要声明同名的参数。</p>
<p>同一个函数可以有多个路由，如<br><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&#x27;/api/v1/&lt;table_name&gt;&#x27;</span>, methods=[<span class="string">&#x27;GET&#x27;</span>]</span>)</span></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&#x27;/api/v1/&lt;table_name&gt;/&lt;int:id&gt;&#x27;</span>, methods=[<span class="string">&#x27;GET&#x27;</span>]</span>)</span></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&#x27;/api/v1/&lt;table_name&gt;/&lt;int:id&gt;/&lt;int:id2&gt;&#x27;</span>, methods=[<span class="string">&#x27;GET&#x27;</span>]</span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">query</span>(<span class="params">table_name, <span class="built_in">id</span>=<span class="literal">None</span>, id2=<span class="literal">None</span></span>):</span><br></pre></td></tr></table></figure></p>
<p>这里 <code>&lt;int:id&gt;</code> 设定 <code>id</code> 参数的类型为 <code>int</code>，如果不设定的话，默认为字符串。另外我们也可以为参数赋予默认值，以适应路径参数缺省的情况。</p>
<p>在处理完成后，函数可以进行返回。返回的结果有 5 种。分别为：字符串、重定向、html页面、文件或json。对后四种，需要有对应的函数进行处理。</p>
<p><strong>重定向</strong><br><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">return</span> redirect(<span class="string">&#x27;redirect/url&#x27;</span>)</span><br></pre></td></tr></table></figure></p>
<p><strong>html</strong><br><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">return</span> render_template(<span class="string">&#x27;index.html&#x27;</span>)</span><br></pre></td></tr></table></figure></p>
<p><strong>文件</strong><br><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">return</span> send_file(<span class="string">&#x27;images/img1.jpg&#x27;</span>)</span><br></pre></td></tr></table></figure></p>
<p><strong>json</strong><br><figure class="highlight py"><table><tr><td class="code"><pre><span class="line">dict_obj = &#123;</span><br><span class="line">  <span class="string">&#x27;a&#x27;</span>: <span class="number">1</span>,</span><br><span class="line">  <span class="string">&#x27;b&#x27;</span>: <span class="string">&quot;123&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> jsonfy(dict_obj)</span><br></pre></td></tr></table></figure></p>
<h2 id="五、BluePrint"><a href="#五、BluePrint" class="headerlink" title="五、BluePrint"></a>五、BluePrint</h2><h3 id="（1）项目的组织"><a href="#（1）项目的组织" class="headerlink" title="（1）项目的组织"></a>（1）项目的组织</h3><p>我们的项目并不只有一个部分，而是由功能不同的模块组成的。不同模块会提供不同的接口，用于不同的服务。这样的话将所有文件堆在一起就很不合适了。如果不及时整理，随着项目的增大，将会造成很大的软件工程灾难。</p>
<p>Flask 提供了蓝图，能够将项目拆封成不同的功能模块，同时在使用时将各个模块结合起来，形成统一的整体。</p>
<h3 id="（2）蓝图的使用"><a href="#（2）蓝图的使用" class="headerlink" title="（2）蓝图的使用"></a>（2）蓝图的使用</h3><p>在之前曾两次出现 <code>app = Flask(__name__)</code> 的语句，我们知道 <code>app</code> 表示着整个项目。现在蓝图的创建也是类似的，只不过这次只表示着项目的一个部分。<br><figure class="highlight py"><table><tr><td class="code"><pre><span class="line">api = Blueprint(<span class="string">&#x27;api&#x27;</span>, __name__, url_prefix=<span class="string">&quot;/api/v1&quot;</span>)</span><br></pre></td></tr></table></figure></p>
<p>这里我们创建了一个蓝图，名为 <code>api</code>，该模块所在的路径为 /api/v1，所有处于该模块下的路由都会以 /api/v1 作为前缀。</p>
<p>蓝图的使用也和 <code>app</code> 十分类似。现在我们可以把第四节中列出的路由稍微修改一下<br><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="meta">@api.route(<span class="params"><span class="string">&#x27;/&lt;table_name&gt;&#x27;</span>, methods=[<span class="string">&#x27;POST&#x27;</span>]</span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">insert</span>(<span class="params">table_name</span>):</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@api.route(<span class="params"><span class="string">&#x27;/&lt;table_name&gt;&#x27;</span>, methods=[<span class="string">&#x27;GET&#x27;</span>]</span>)</span></span><br><span class="line"><span class="meta">@api.route(<span class="params"><span class="string">&#x27;/&lt;table_name&gt;/&lt;int:id&gt;&#x27;</span>, methods=[<span class="string">&#x27;GET&#x27;</span>]</span>)</span></span><br><span class="line"><span class="meta">@api.route(<span class="params"><span class="string">&#x27;/&lt;table_name&gt;/&lt;int:id&gt;/&lt;int:id2&gt;&#x27;</span>, methods=[<span class="string">&#x27;GET&#x27;</span>]</span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">query</span>(<span class="params">table_name, <span class="built_in">id</span>=<span class="literal">None</span>, id2=<span class="literal">None</span></span>):</span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure></p>
<p>这样这些路由就变为属于 <code>api</code> 蓝图的路由了。我们可以将路由和蓝图的声明放在同一个文件中或者同一个软件包中，这样就可以组织起项目的结构了。Flask 并无固定的项目结构，因此可以按照自己的需求进行安排。我自己的项目因为比较简单，安排的很是随意<br><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">.</span><br><span class="line">├── Dockerfile</span><br><span class="line">├── config.ini</span><br><span class="line">├── readme.md</span><br><span class="line">├── src</span><br><span class="line">│   ├── __init__.py</span><br><span class="line">│   ├── api.py</span><br><span class="line">│   ├── database</span><br><span class="line">│   │   ├── __init__.py</span><br><span class="line">│   │   ├── dbs.py</span><br><span class="line">│   │   ├── events.py</span><br><span class="line">│   │   ├── models.py</span><br><span class="line">│   │   └── utils.py</span><br><span class="line">│   ├── main.py</span><br><span class="line">│   └── requirements.txt</span><br><span class="line">└── start.sh</span><br></pre></td></tr></table></figure></p>
<p>最后我们还要将 <code>api</code> 模块启用。只需要调用 <code>app</code> 的 <code>register_blueprint</code> 方法即可<br><figure class="highlight py"><table><tr><td class="code"><pre><span class="line">app.register_blueprint(api)</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>后端</tag>
        <tag>Flask</tag>
      </tags>
  </entry>
  <entry>
    <title>后端开发笔记之脚本</title>
    <url>/posts/2594d393/</url>
    <content><![CDATA[<h2 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h2><p>这篇文章只是记录一些自己编写脚本时用到的零碎知识而已。这也是这一系列的最后一篇。<br><span id="more"></span></p>
<h2 id="二、shell-的异常处理"><a href="#二、shell-的异常处理" class="headerlink" title="二、shell 的异常处理"></a>二、shell 的异常处理</h2><p>有时我们希望在 shell 脚本命令执行出现异常时进行处理，比如说输出异常情况或退出等等。我们知道发生异常时返回值不为 0，如果是在 c 语言中我们可以这样处理<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (!do_something()) &#123;</span><br><span class="line">  <span class="comment">// handle exception</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>类似的在 shell 中<br><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">dosomething arg1 arg2</span><br><span class="line"><span class="keyword">if</span> [ $? -ne 0 ]</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">  <span class="comment"># handle exception</span></span><br><span class="line"><span class="keyword">if</span></span><br></pre></td></tr></table></figure></p>
<p>但是这样编写起来太过麻烦了，我们可以采用另一种方法，那就是使用短路逻辑运算符。</p>
<p>我们还先以 c 语言为例，假设现在我们有两个函数，对他们取逻辑或<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> r = func1() &amp;&amp; func2()</span><br></pre></td></tr></table></figure></p>
<p>那么在 <code>func1</code> 的返回值为 0 时，就会发生短路，不执行 <code>func2</code>。而在返回值为；而当 <code>func1</code> 的返回值不为 0 时，则会继续执行 <code>func2</code>。我们可以让 <code>func2</code> 完成 <code>func1</code> 的异常处理。</p>
<p>当然，在 c 语言中这种方法很是牵强，因为不同函数的栈帧并不一样，很难跨函数进行处理。可是 shell 中就不同了，所有的变量都是全局变量。</p>
<p>但还需要注意一点，shell 中 0 表示真，1 表示假。（因为 0 表示程序正常结束，所以为真。）所以在 shell 中就需要使用 <code>||</code> 而非 <code>&amp;&amp;</code>。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">cmd1 arg1 arg2 || cmd2 arg3 arg4</span><br></pre></td></tr></table></figure>
<p>举我写的脚本中的例子。<br><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&quot;try to import csv files in <span class="variable">$source_path</span>, execute insert.py script to do this&quot;</span></span><br><span class="line">python3 ./insert.py <span class="variable">$host</span> <span class="variable">$port</span> <span class="variable">$username</span> <span class="variable">$password</span> <span class="variable">$source_path</span> <span class="variable">$database</span> || ! <span class="built_in">echo</span> <span class="string">&quot;error: fail to import all csv files&quot;</span> || <span class="built_in">exit</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;import csv files success!!!&quot;</span></span><br></pre></td></tr></table></figure></p>
<p>需要注意这里用 <code>||</code> 连接了三条命令，其中第二条输出错误提示，我们为了在该命令正常执行后依旧执行后面的 <code>exit</code> 操作，在该命令前面加上 <code>!</code> 进行取反。需要注意这里不能将 <code>!</code> 和 <code>echo</code> 连接起来 <code>!echo</code>。</p>
<p>另外在学习使用命令行时你一定见过这样的操作，只是使用的是 <code>&amp;&amp;</code>。<br><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">cmd1 arg1 arg2 &amp;&amp; cmd2 arg3 arg4</span><br></pre></td></tr></table></figure></p>
<p>虽然各位应该理解两者的区别，但这里还是说明一下：</p>
<ul>
<li><code>||</code> 表示如果发生错误，才执行下一条</li>
<li><code>&amp;&amp;</code> 表示只要不发生错误，就不断依次执行</li>
</ul>
<h2 id="三。执行-sql-脚本"><a href="#三。执行-sql-脚本" class="headerlink" title="三。执行 sql 脚本"></a>三。执行 sql 脚本</h2><p>当进行项目维护的时候，可能需要使用大量的 sql 语句，这时将这些语句编写成 sql 脚本，批量执行更有效率。</p>
<p>我自己的数据导入脚本就有用到了 sql 脚本。实际上执行脚本不过就是进行了一个文件重定向而已。<br><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&quot;try to create tables by create.sql...&quot;</span></span><br><span class="line">mysql -h <span class="variable">$host</span> -P <span class="variable">$port</span> -u <span class="variable">$username</span> -p<span class="variable">$password</span> &lt; ./create.sql || ! <span class="built_in">echo</span> <span class="string">&quot;error: fail to execute create.sql&quot;</span> || <span class="built_in">exit</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;tables are now created&quot;</span></span><br></pre></td></tr></table></figure></p>
<p>当然还有使用管道的方法，如果想要执行多个 sql 脚本，可以使用通配符将文件连接起来统一执行<br><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cat</span> ./*.sql | mysql -h <span class="variable">$host</span> -P <span class="variable">$port</span> -u <span class="variable">$username</span> -p<span class="variable">$password</span></span><br></pre></td></tr></table></figure></p>
<p>还可以在命令行中执行单一语句，这需要在使用 <code>mysql</code> 命令时设置 <code>-e</code> 参数<br><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">mysql -h <span class="variable">$host</span> -P <span class="variable">$port</span> -u <span class="variable">$username</span> -p<span class="variable">$password</span> -e <span class="string">&quot;SHOW DATABASES&quot;</span></span><br></pre></td></tr></table></figure></p>
<h2 id="四、csv-数据导入"><a href="#四、csv-数据导入" class="headerlink" title="四、csv 数据导入"></a>四、csv 数据导入</h2><p>mysql 中有 <code>LOAD DATA INFILE</code> 语句用于文件导入，不过其他数据库似乎并不支持这种方法。更普适的方法还是通过 <code>INSERT</code> 插入数据。这里我写了一个 python 脚本用于通过 <code>insert</code> 从 csv 文件中导入数据。我个人认为还是编写地比较灵活，可以通过简单修改导入不同数据。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sys <span class="keyword">import</span> argv</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> pymysql</span><br><span class="line"></span><br><span class="line">insert_template = <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">insert into &#123;&#125;(&#123;&#125;)</span></span><br><span class="line"><span class="string">values (&#123;&#125;)</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">tables = [<span class="string">&#x27;departments&#x27;</span>, <span class="string">&#x27;employees&#x27;</span>, <span class="string">&#x27;titles&#x27;</span>, <span class="string">&#x27;dept_emp&#x27;</span>, <span class="string">&#x27;dept_manager&#x27;</span>]</span><br><span class="line"></span><br><span class="line">_, host, port, username, password, source_path, database = argv</span><br><span class="line">port = <span class="built_in">int</span>(port)</span><br><span class="line"></span><br><span class="line">error = <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">db = pymysql.connect(</span><br><span class="line">    host=host,</span><br><span class="line">    user=username,</span><br><span class="line">    passwd=password,</span><br><span class="line">    database=database,</span><br><span class="line">    port=port,</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">cursor = db.cursor()</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> table <span class="keyword">in</span> tables:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;start to import csv file to table <span class="subst">&#123;table&#125;</span>...&quot;</span>)</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">f&#x27;<span class="subst">&#123;source_path&#125;</span>/<span class="subst">&#123;table&#125;</span>.csv&#x27;</span>, <span class="string">&#x27;r&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        args = <span class="built_in">list</span>(<span class="built_in">map</span>(<span class="keyword">lambda</span> line: <span class="built_in">tuple</span>(line.strip().split(<span class="string">&#x27;,&#x27;</span>)), f.readlines()))</span><br><span class="line">        fields = <span class="string">&#x27;, &#x27;</span>.join(args[<span class="number">0</span>])</span><br><span class="line">        argc = <span class="built_in">len</span>(args[<span class="number">0</span>])</span><br><span class="line">        <span class="keyword">del</span> args[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">    sql = insert_template.<span class="built_in">format</span>(table, fields, <span class="string">&#x27;, &#x27;</span>.join([<span class="string">&#x27;%s&#x27;</span>]*argc))</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        cursor.executemany(sql, args)</span><br><span class="line">        db.commit()</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;import csv file to table <span class="subst">&#123;table&#125;</span> success!!!&quot;</span>)</span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">        db.rollback()</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;error: fail to import into table <span class="subst">&#123;table&#125;</span>, <span class="subst">&#123;e&#125;</span>&quot;</span>)</span><br><span class="line">        error = <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">db.close()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> error:</span><br><span class="line">    exit(<span class="number">1</span>)</span><br></pre></td></tr></table></figure>
<p>这里使用了 <code>executemany</code> 用于一次执行许多条类似的语句，相较于逐个插入数据有很大的速度提升。这似乎是因为 <code>INSERT</code> 语句执行后默认会直接提交到数据库，写入磁盘。过多的 <code>INSERT</code> 语句就会增加大量的磁盘写入时间。</p>
<p>直接使用 sql 插入数据也有同样的问题，一个解决办法是在进行多次插入之前禁用自动提交 <code>SET AUTOCOMMIT = 0;</code>，再插入结束后再开启 <code>SET AUTOCOMMIT = 1;</code>。</p>
<p>这里我们举一例子，如下的 sql 语句创建了一个存储过程，该存储过程会向表 <code>table_random</code> 中插入 400000 条随机生成的数据。在 <code>WHILE</code> 循环的前后，我们设置了 <code>AUTOCOMMIT</code> 的值以禁用和开启自动提交。可以试着注释这两条语句，在注释前和注释后分别执行该存储过程，看一下完成所需时间。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">DELIMITER $$</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> random_insert()</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">	<span class="keyword">DECLARE</span> i <span class="type">INTEGER</span> <span class="keyword">DEFAULT</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">DECLARE</span> sparse_val <span class="type">INTEGER</span>;</span><br><span class="line">	<span class="keyword">DECLARE</span> dense_val <span class="type">INTEGER</span>;</span><br><span class="line">	<span class="keyword">DECLARE</span> num <span class="type">INTEGER</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">SET</span> AUTOCOMMIT <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	WHILE i <span class="operator">&lt;</span> <span class="number">400000</span> DO</span><br><span class="line">		<span class="keyword">SET</span> sparse_val <span class="operator">=</span> ROUND(RAND()<span class="operator">*</span><span class="number">5000001</span> <span class="operator">-</span> <span class="number">0.5</span>);</span><br><span class="line">		<span class="keyword">SET</span> dense_val <span class="operator">=</span> ROUND(RAND()<span class="operator">*</span><span class="number">10</span> <span class="operator">-</span> <span class="number">0.5</span>);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">INSERT</span> <span class="keyword">INTO</span> table_random(sparse, dense)</span><br><span class="line">		<span class="keyword">VALUES</span> (sparse_val, dense_val);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">SET</span> i <span class="operator">=</span> i <span class="operator">+</span> <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">END</span> WHILE;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">SET</span> AUTOCOMMIT <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">	</span><br><span class="line"><span class="keyword">END</span> $$</span><br><span class="line">DELIMITER ;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>后端</tag>
        <tag>shell</tag>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>基本正则表达式总结</title>
    <url>/posts/815aaabe/</url>
    <content><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>正则表达式是用于描述字符串匹配模式的表达式。利用正则表达式进行匹配，可以实现检查字符串是否符合某种规则、字符串是否含有某种子串；替换匹配的子串或者从某个串中取出符合某个条件的子串。</p>
<p>正则表达式的引擎是一种自动机，在根据规则完成自动机的构建后，对任意字符串的匹配都将花费 O(n) 的时间复杂度。有关正则表达式的理论及实现本文并不继续深入。</p>
<h2 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h2><p>这里将介绍正则表达式的基本语法。另外这里推荐网站 <a href="https://regex101.com/">regex101</a>，可以用于验证正则表达式。</p>
<h3 id="字符与字符集"><a href="#字符与字符集" class="headerlink" title="字符与字符集"></a>字符与字符集</h3><p>正则表达式中一般的字符用于匹配字符串中对应的相同字符。例如正则表达式 “a” 可以匹配字符串中的字符 ‘a’ 。 “abc” 可以匹配字符串中的子串 “abc” 。</p>
<blockquote>
<p>对于在正则表达式中具有特殊含义的字符，需要进行转义，在原字符前加上反斜杠 “\“</p>
</blockquote>
<p>用方括号将一个或多个字符括起来表示一个字符集，一个字符集匹配在该字符集中出现的字符。例如 [abc]，可以匹配 ‘a’ ‘b’ 或 ‘c’。</p>
<p>还可以在字符集中指定要匹配的字符的范围，例如 [a-z]，用来匹配所有的小写英文字母。在同一字符集内可以有多个范围，例如 [a-zA-Z0-9]。</p>
<p>在字符集括号内的所有字符之前添加 “^” 表示对该字符集取反，即匹配所有不在字符集内的元素。例如 <sup><a href="#fn_a-b" id="reffn_a-b">a-b</a></sup> 匹配所有不是小写英文字母的元素。</p>
<blockquote>
<p>字符 “.” 可用于匹配换行符为所有字符。</p>
</blockquote>
<h3 id="限定符"><a href="#限定符" class="headerlink" title="限定符"></a>限定符</h3><p>限定符用来指定其前面的部分将要匹配几次。例如a{2,5}匹配2到5个a，即”aa”、”aaa”、”aaaa”和”aaaaa”。具体的限定符含义如下表所示：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>限定符</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td>{n}</td>
<td>匹配内容n次</td>
</tr>
<tr>
<td>{n,}</td>
<td>匹配内容次数大于等于n次</td>
</tr>
<tr>
<td>{n,m}</td>
<td>匹配内容次数为n到m次</td>
</tr>
<tr>
<td>*</td>
<td>匹配零次或多次，同{0,}</td>
</tr>
<tr>
<td>+</td>
<td>匹配一次或多次，同{1,}</td>
</tr>
<tr>
<td>?</td>
<td>匹配零次或一次，同{0,1}</td>
</tr>
</tbody>
</table>
</div>
<blockquote>
<p>注意，限定符匹配默认遵循贪婪原则，即在同样能够完成匹配的情况下，会匹配尽可能多的字符。例如要匹配<code>&lt;html&gt;&lt;dir&gt;hello,world&lt;/dir&gt;&lt;/html&gt;</code>中的标签，若使用正则表达式 “&lt;.+&gt;”，则只会匹配整个字符串。<br>解决方法是在限定符后加上一个问号 “?” 。这样限定符的匹配模式便会切换为懒惰匹配，即在同样能够完成匹配的情况下，会匹配尽可能少的字符。</p>
</blockquote>
<h3 id="组"><a href="#组" class="headerlink" title="组"></a>组</h3><p>用括号将一部分表达式括起，可以将这部分表达式作为一个整体。</p>
<p>比如说，需要匹配 “aacacaaac”，可以归纳出字符串中重复的部分 “a+c”，将该部分作为一个整体，则该部分重复了三次。最终得到可以匹配该字符串的正则表达式为 “(a+c){3}”。</p>
<p>另外，组分为捕获组与非捕获组，捕获组即单纯的括号，非捕获组包括 “(?:exp)” “(?=exp)” “(?!exp)” “(?&lt;=exp)” “(?&lt;!exp)”。这里先说明 “(exp)” 和 “(?:exp)” 的区别。”(?=exp)” “(?!exp)” “(?&lt;=exp)” “(?&lt;!exp)” 会在后一节进一步解释。</p>
<p>当使用捕获组时，表示对括号内会出现的内容更感兴趣。这时在匹配成功后缓存括号内的匹配内容，并可以访问该内容。而使用非捕获组，则说明仅仅将括号用于划分表达式，因此不会缓存括号内的匹配。</p>
<h3 id="选择"><a href="#选择" class="headerlink" title="选择"></a>选择</h3><p>将不同的内容用 “|” 分割，用来表示进行该部分匹配时不同的匹配选项。例如 “learn(ed|t)” 可以匹配 “learnt” 和 “learned”。</p>
<blockquote>
<p>正如前一节所说，这里使用了捕获；不使用捕获的表达式为 “learn(?:ed|t)”</p>
</blockquote>
<p>“(?=exp)” “(?!exp)” “(?&lt;=exp)” “(?&lt;!exp)” 也可以实现匹配选择的功能。</p>
<p>exp1(?=exp2)会匹配 exp2 前面的 exp1。例如表达式 “wok(?=[0-9]+)” 只会匹配后面带数字的 “wok”, 例如 “wok123” 中的 “wok” , 而不会匹配 “wokron”、 “wokd234” 中的 “wok” 。</p>
<blockquote>
<p>“wok(?=[0-9]+)([0-9]+)” 可以捕获 “wok” 后的数字大小。</p>
</blockquote>
<p>exp1(?!exp2)会匹配后面不是 exp2 的 exp1。例如表达式”wok(?![0-9]+)” 只会匹配后面不带有数字的 “wok”。</p>
<blockquote>
<p>“^(?:000[1-9]|(?!000)\d{4})$”会匹配0001-9999的所有值。</p>
</blockquote>
<p>(?&lt;=exp1)exp2会匹配前缀为 exp1 的 exp2。例如表达式”(?&lt;=foo)bar”会匹配前缀为foo的bar。</p>
<p>(?&lt;!epx1)exp2会匹配前缀不为 exp1 的 exp2。例如表达式”(?&lt;!foo)bar”会匹配所有前缀不为foo的bar。</p>
<blockquote>
<p>“^(?:000[1-9]|\d{3}(?&lt;!000)\d)$”同样可以匹配0001-9999的所有值。</p>
</blockquote>
<h3 id="定位符"><a href="#定位符" class="headerlink" title="定位符"></a>定位符</h3><p>定位符可以将正则表达式的匹配对象定位到行首或行尾。又或者单词的开头结尾。下表是一些定位符：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>定位符</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>^</td>
<td>匹配输入字符串开始的位置</td>
</tr>
<tr>
<td>$</td>
<td>匹配输入字符串结尾的位置</td>
</tr>
<tr>
<td>\b</td>
<td>匹配一个单词边界，即字与空格间的位置</td>
</tr>
<tr>
<td>\B</td>
<td>非单词边界匹配</td>
</tr>
</tbody>
</table>
</div>
<h3 id="常用元字符"><a href="#常用元字符" class="headerlink" title="常用元字符"></a>常用元字符</h3><p>这里总结了一些常用的元字符，见表格：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>字符</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>\</td>
<td>将下一个字符标记为特殊字符、或转义符</td>
</tr>
<tr>
<td>^</td>
<td>匹配输入字符串的开始位置</td>
</tr>
<tr>
<td>$</td>
<td>匹配输入字符串的结束位</td>
</tr>
<tr>
<td>*</td>
<td>匹配前面的子表达式零次或多次</td>
</tr>
<tr>
<td>+</td>
<td>匹配前面的子表达式一次或多次</td>
</tr>
<tr>
<td>?</td>
<td>匹配前面的子表达式零次或一次</td>
</tr>
<tr>
<td>{n}</td>
<td>匹配确定的 n 次</td>
</tr>
<tr>
<td>{n,}</td>
<td>至少匹配n 次</td>
</tr>
<tr>
<td>{n,m}</td>
<td>最少匹配 n 次且最多匹配 m 次</td>
</tr>
<tr>
<td>?</td>
<td>跟在其他限制符后面，设置匹配模式为非贪婪</td>
</tr>
<tr>
<td>.</td>
<td>匹配除换行符（\n、\r）之外的任何单个字符</td>
</tr>
<tr>
<td>x&#124;y</td>
<td>匹配 x 或 y</td>
</tr>
<tr>
<td>[xyz]</td>
<td>字符集合。匹配所包含的任意一个字符</td>
</tr>
<tr>
<td>[&#94;xyz]</td>
<td>负值字符集合。匹配未包含的任意字符</td>
</tr>
<tr>
<td>[a-z]</td>
<td>字符范围。匹配指定范围内的任意字符</td>
</tr>
<tr>
<td>[&#94;a-z]</td>
<td>负值字符范围。匹配任何不在指定范围内的任意字符</td>
</tr>
<tr>
<td>\b</td>
<td>匹配一个单词边界，即单词和空格间的位置</td>
</tr>
<tr>
<td>\B</td>
<td>匹配非单词边界</td>
</tr>
<tr>
<td>\d</td>
<td>匹配一个数字字符。等价于 [0-9]</td>
</tr>
<tr>
<td>\D</td>
<td>匹配一个非数字字符。等价于 <sup><a href="#fn_0-9" id="reffn_0-9">0-9</a></sup></td>
</tr>
<tr>
<td>\f</td>
<td>匹配一个换页符。等价于 \x0c 和 \cL</td>
</tr>
<tr>
<td>\n</td>
<td>匹配一个换行符。等价于 \x0a 和 \cJ</td>
</tr>
<tr>
<td>\r</td>
<td>匹配一个回车符。等价于 \x0d 和 \cM</td>
</tr>
<tr>
<td>\s</td>
<td>匹配任何空白字符</td>
</tr>
<tr>
<td>\S</td>
<td>匹配任何非空白字符</td>
</tr>
<tr>
<td>\t</td>
<td>匹配一个制表符。等价于 \x09 和 \cI</td>
</tr>
<tr>
<td>\v</td>
<td>匹配一个垂直制表符。等价于 \x0b 和 \cK</td>
</tr>
<tr>
<td>\w</td>
<td>匹配字母、数字、下划线。等价于’[A-Za-z0-9_]’</td>
</tr>
<tr>
<td>\W</td>
<td>匹配非字母、数字、下划线。等价于 ‘<sup><a href="#fn_A-Za-z0-9_" id="reffn_A-Za-z0-9_">A-Za-z0-9_</a></sup>‘</td>
</tr>
<tr>
<td>\num</td>
<td>匹配 num，其中 num 是一个正整数。对所获取的匹配的引用。例如，’(.)\1’ 匹配两个连续的相同字符</td>
</tr>
</tbody>
</table>
</div>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>正则表达式</tag>
      </tags>
  </entry>
  <entry>
    <title>基于概率模型的蘑菇菌丝规模分析</title>
    <url>/posts/7a0960e5/</url>
    <content><![CDATA[<p><strong>摘要：</strong><br>本文提出了一种将菌丝体结构与地面上蘑菇子实体的位置联系起来的概率模型，用于分析蘑菇菌丝体的规模。我们假设地形平坦，菌丝体以恒定速率扩散。同时假设地面上蘑菇子实体的位置遵循菌丝体形状决定的均匀分布。基于这些假设，我们将菌丝体定义为以初始孢子位置 (m n) 为中心，半径为 r 的圆形区域。蘑菇子实体位置的分布服从该圆形区域内的均匀分布。</p>
<p>对于圆心位置和半径大小，我们分别提出了三种模型。对圆心位置来说：样本点平均值模型通过直接计算所有蘑菇子实体位置的平均值来估计圆心位置；最远点平均值模型通过计算横纵坐标投影上的最远点的平均值作为对圆心的估计；中位数模型通过分别计算横纵坐标轴上的中位数进行估计。</p>
<p>对半径大小来说：平均值模型通过计算所有样本点距已求得的圆心距离的平均值估计半径；第二种模型中采用了极大似然法对半径进行估计；两端间隔模型则通过考虑半径取值中两端间隔的比例关系计算半径大小。</p>
<p>我们将这些模型结合起来求解原问题。为了选择出更优的模型，我们采用了计算机数值模拟的方法。通过多次的随机模拟试验，考察模型预测结果的平均值、相对平均值的误差和标准差，对模型进行了评价，并据此选出了更好的求解结果。<br><strong>Keywords: 概率论，数值模拟</strong><br><span id="more"></span></p>
<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>蘑菇作为一种广泛存在于自然界的真菌，为人们所熟知。但其除了裸露在地表的子实体部分以外，在地下还拥有着极其庞大的菌丝结构。为了完成对蘑菇的全面详细研究，有必要对菌丝结构这一蘑菇的重要组成部分进行分析和度量。其中尤为重要的，就是确定菌丝结构的位置和范围。但是由于菌丝处于地下且规模巨大，难以通过直接测量得出结果。</p>
<h3 id="问题重述"><a href="#问题重述" class="headerlink" title="问题重述"></a>问题重述</h3><p>蘑菇的孢子落到土壤中，不断生长出菌丝。菌丝以相同的速度向外辐射，构成庞大的菌丝菌丝。当环境条件合适时，这些菌丝会生长成裸露在地面的“蘑菇”。现在我们已知地面上属于同一菌丝结构的所有蘑菇的位置，如表 1 和图 1 所示：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>序号</th>
<th>横坐标</th>
<th>纵坐标</th>
<th>序号</th>
<th>横坐标</th>
<th>纵坐标</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>21.12</td>
<td>29.84</td>
<td>11</td>
<td>24.81</td>
<td>17.16</td>
</tr>
<tr>
<td>2</td>
<td>20.39</td>
<td>11.50</td>
<td>12</td>
<td>41.31</td>
<td>31.77</td>
</tr>
<tr>
<td>3</td>
<td>38.52</td>
<td>13.34</td>
<td>13</td>
<td>20.24</td>
<td>15.50</td>
</tr>
<tr>
<td>4</td>
<td>33.85</td>
<td>15.47</td>
<td>14</td>
<td>34.63</td>
<td>26.43</td>
</tr>
<tr>
<td>5</td>
<td>44.24</td>
<td>21.49</td>
<td>15</td>
<td>42.67</td>
<td>20.42</td>
</tr>
<tr>
<td>6</td>
<td>24.87</td>
<td>22.42</td>
<td>16</td>
<td>18.52</td>
<td>14.49</td>
</tr>
<tr>
<td>7</td>
<td>46.32</td>
<td>26.41</td>
<td>17</td>
<td>17.09</td>
<td>25.83</td>
</tr>
<tr>
<td>8</td>
<td>20.27</td>
<td>11.62</td>
<td>18</td>
<td>32.33</td>
<td>17.14</td>
</tr>
<tr>
<td>9</td>
<td>44.56</td>
<td>19.73</td>
<td>19</td>
<td>18.72</td>
<td>17.83</td>
</tr>
<tr>
<td>10</td>
<td>47.69</td>
<td>19.25</td>
<td>20</td>
<td>28.52</td>
<td>25.85</td>
</tr>
</tbody>
</table>
</div>
<img src="/posts/7a0960e5/mushrooms1.png" class="" title="mushrooms1">
<p>我们的问题是，如何根据地上蘑菇子实体的位置信息，估计形成蘑菇的孢子最初落地的位置和地下菌丝结构的规模。</p>
<h3 id="我们的工作"><a href="#我们的工作" class="headerlink" title="我们的工作"></a>我们的工作</h3><p>在本篇文章中，我们建立了一种真菌生长的模型，将地下菌丝结构与地上子实体位置进行了概率上的关联。同时提出了求解该模型的不同思路，通过计算机模拟，对比选择出了更优的求解办法。</p>
<h2 id="问题假设"><a href="#问题假设" class="headerlink" title="问题假设"></a>问题假设</h2><ul>
<li>假设一：当地地形平坦，菌丝以相同的速度向外辐射，形成圆形</li>
<li>假设二：地上子实体的位置服从地下菌丝形状的均匀分布</li>
</ul>
<h2 id="符号说明"><a href="#符号说明" class="headerlink" title="符号说明"></a>符号说明</h2><div class="table-container">
<table>
<thead>
<tr>
<th>符号</th>
<th>定义</th>
</tr>
</thead>
<tbody>
<tr>
<td>$(m, n)$</td>
<td>孢子下落的最初位置</td>
</tr>
<tr>
<td>$r$</td>
<td>菌丝区域的半径</td>
</tr>
<tr>
<td>${(x_i, y_i)}$</td>
<td>子实体位置样本集合</td>
</tr>
</tbody>
</table>
</div>
<h2 id="模型的建立与分析"><a href="#模型的建立与分析" class="headerlink" title="模型的建立与分析"></a>模型的建立与分析</h2><h3 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h3><p>由于我们假设地形平坦，菌丝以相同的速度向外辐射，那么在蘑菇生长的任意时刻，菌丝结构在水平面上的投影都是正圆形。我们设孢子下落的位置为 $(m, n)$，菌丝距包子位置的最远距离为 $r$，那么菌丝结构可以视为二维平面上的圆形区域 $C: (x-m)^2 + (y-n)^2 \le r$。</p>
<p>又因为我们假设地上子实体的位置服从地下菌丝形状的均匀分布，那么对于任意子实体的位置 $(x_i, y_i)$，服从均匀分布，其概率密度函数为</p>
<script type="math/tex; mode=display">
    f(x, y)=\left\{
    \begin{aligned}
    \frac{1}{\pi r^2} & \quad (x, y) \in C \\
    0 & \quad (x, y) \notin C\\
    \end{aligned}
    \right.</script><p>这样我们就将问题转化为：已知有一组样本 $(x_1, x_2), … (x_n, y_n)$ 服从区域 $C: (x-m)^2 + (y-n)^2 \le r$ 上的均匀分布，$m, n, r$ 未知。求 $m, n, r$。</p>
<p>这一问题包含两个子问题，（1）求解 $m, n$，（2）求解 $r$。接下来我们将分别建立模型。</p>
<h3 id="模型选择与分析"><a href="#模型选择与分析" class="headerlink" title="模型选择与分析"></a>模型选择与分析</h3><h4 id="样本点平均值估计圆心"><a href="#样本点平均值估计圆心" class="headerlink" title="样本点平均值估计圆心"></a>样本点平均值估计圆心</h4><p>对样本 $(x<em>1, x_2), … (x_n, y_n)$，记 $\bar{x} = \frac{1}{n}\sum</em>{i=1}^n x<em>i$，$\bar{y} = \frac{1}{n}\sum</em>{i=1}^n y_i$。总体的平均值 </p>
<script type="math/tex; mode=display">
    \bar{X} = \int_{-\infty}^{+\infty}\int_{-\infty}^{+\infty} xf(x, y)dxdy = m \\
    \bar{Y} = \int_{-\infty}^{+\infty}\int_{-\infty}^{+\infty} yf(x, y)dxdy = n</script><p>用 $(\bar{x}, \bar{y})$ 作为 $(\bar{X}, \bar{Y})$ 的估计值，得到</p>
<script type="math/tex; mode=display">
    m = \bar{x}, n = \bar{y}</script><h4 id="最远点平均值估计圆心"><a href="#最远点平均值估计圆心" class="headerlink" title="最远点平均值估计圆心"></a>最远点平均值估计圆心</h4><p>我们设</p>
<script type="math/tex; mode=display">
    x_{min} = \min{x_i} \\
    x_{max} = \max{x_i} \\
    y_{min} = \min{y_i} \\
    y_{max} = \max{y_i}</script><p>利用最远点的平均值估计圆心，即</p>
<script type="math/tex; mode=display">
    m = \frac{x_{max} - x_{min}}{2} \\
    n = \frac{y_{max} - y_{min}}{2}</script><h4 id="横纵坐标中位数估计圆心"><a href="#横纵坐标中位数估计圆心" class="headerlink" title="横纵坐标中位数估计圆心"></a>横纵坐标中位数估计圆心</h4><p>我们记 ${x_i}$ 的中位数为 $\widetilde{x}$，${y_i}$ 的中位数为 $\widetilde{y}$。总体的中位数为 $\widetilde{X}$ 和 $\widetilde{Y}$。用 $(\widetilde{x}, \widetilde{y})$ 作为  $(\widetilde{X}, \widetilde{Y})$ 的估计值。由于 $\widetilde{X} = \bar{X}, \widetilde{Y} = \bar{Y}$，则</p>
<script type="math/tex; mode=display">
    m = \widetilde{x} \\
    n = \widetilde{y}</script><h4 id="平均值估计半径"><a href="#平均值估计半径" class="headerlink" title="平均值估计半径"></a>平均值估计半径</h4><p>假设此时我们已经确定了圆心 $(m, n)$ 的位置，那么我们可以计算出样本点相对于 $(m, n)$ 的距离</p>
<script type="math/tex; mode=display">
    r_i = \sqrt{(x_i - m)^2 + (y_i - n)^2}</script><p>我们设点到圆心的距离的平均值为 $\bar{r} = \frac{1}{n}\sum_{i=1}^n r_i$，总体到圆心的平均距离为 $\bar{R}$。用 $\bar{r}$ 作为 $\bar{R}$ 的估计值。</p>
<p>为此我们需要求得 $\bar{R}$ 的值。首先设随机变量 $Z$ 为点到圆心的距离，圆形半径为 $r$，则有概率分布函数</p>
<script type="math/tex; mode=display">
    F(z) = P\{Z \le z\} = \frac{\pi z^2}{\pi r^2} = \frac{z^2}{r^2}</script><p>对应的概率密度函数</p>
<script type="math/tex; mode=display">
    f(z) = \frac{2z}{r^2}</script><p>因此 $Z$ 的数学期望为</p>
<script type="math/tex; mode=display">
    E(Z) = \int_{0}^{r} z f(z) dz = \frac{2}{3}r</script><p>因此有 $\bar{R} = \frac{2}{3}r$。所以</p>
<script type="math/tex; mode=display">
    r = \frac{3}{2} \bar{r}</script><h4 id="极大似然法估计半径"><a href="#极大似然法估计半径" class="headerlink" title="极大似然法估计半径"></a>极大似然法估计半径</h4><p>我们已知距圆心距离的概率密度函数为 $f(z) = \frac{2z}{r^2}$。使用极大似然法估计参数 $r$。</p>
<p>构造似然函数</p>
<script type="math/tex; mode=display">
    L(x; r) = \prod_{i=1}^n f(r_i; r) = \prod_{i=1}^n \frac{2r_i}{r^2}</script><p>为方便计算，对等式两边同取对数</p>
<script type="math/tex; mode=display">
    \ln L(x; r) = \ln \prod_{i=1}^n \frac{2r_i}{r^2} = \sum_{i=1}^n \ln 2r_i - n \ln r^2</script><p>要求</p>
<script type="math/tex; mode=display">
    r = \underset{r}{\text{argmax}} \ln L(x; r)</script><p>对 $\ln L(x; r)$ 求导，即</p>
<script type="math/tex; mode=display">
    \frac{d \ln L(x; r)}{r} = \frac{2n}{r} \gt 0</script><p>又因参数 $r$ 可能的取值范围为 $[\max{r_i}, \infty)$。因此根据极大似然法得到的半径估计为</p>
<script type="math/tex; mode=display">
    r = \max{r_i}</script><h4 id="两端间隔模型估计半径"><a href="#两端间隔模型估计半径" class="headerlink" title="两端间隔模型估计半径"></a>两端间隔模型估计半径</h4><p>根据概率密度函数 $f(z) = \frac{2z}{r^2}$ 可以得知，从样本点距圆心距离来看，越靠近圆心的点应该更加稀疏，越远离圆心的点应该更加稠密。我们按从小到大的顺序排列 $r_1 \le r_2 \le …\le r_n$。那么 $r_1$ 的大小概率上应该大于 $r - r_n$。我们可以假设有这样的关系</p>
<script type="math/tex; mode=display">
    \frac{r_1 - 0}{r - r_n} = \frac{f(r)}{f(r_1)} = \frac{r}{r_1}</script><p>因此有</p>
<script type="math/tex; mode=display">
    r = \frac{r_n + \sqrt{r_n^2 + 4r_1^2}}{2}</script><h2 id="模型求解"><a href="#模型求解" class="headerlink" title="模型求解"></a>模型求解</h2><h3 id="模型求解-1"><a href="#模型求解-1" class="headerlink" title="模型求解"></a>模型求解</h3><p>我们将上面估计圆心位置的三种模型与估计半径的三种模型两两组合，形成九种求解方案。分别求得对应的 $m, n, r$。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>圆心估计模型</th>
<th>半径估计模型</th>
<th>横坐标m</th>
<th>纵坐标n</th>
<th>半径r</th>
</tr>
</thead>
<tbody>
<tr>
<td>样本点平均值</td>
<td>半径平均值</td>
<td>34.83</td>
<td>20.92</td>
<td>11.55</td>
</tr>
<tr>
<td>样本点平均值</td>
<td>极大似然法</td>
<td>34.83</td>
<td>20.92</td>
<td>14.42</td>
</tr>
<tr>
<td>样本点平均值</td>
<td>两端间隔模型</td>
<td>34.83</td>
<td>20.92</td>
<td>14.53</td>
</tr>
<tr>
<td>最远点平均值</td>
<td>半径平均值</td>
<td>32.62</td>
<td>19.16</td>
<td>12.29</td>
</tr>
<tr>
<td>最远点平均值</td>
<td>极大似然法</td>
<td>32.62</td>
<td>19.16</td>
<td>13.87</td>
</tr>
<tr>
<td>最远点平均值</td>
<td>两端间隔模型</td>
<td>32.62</td>
<td>19.16</td>
<td>14.17</td>
</tr>
<tr>
<td>横纵坐标中位数</td>
<td>半径平均值</td>
<td>34.98</td>
<td>22.20</td>
<td>11.55</td>
</tr>
<tr>
<td>横纵坐标中位数</td>
<td>极大似然法</td>
<td>34.98</td>
<td>22.20</td>
<td>14.26</td>
</tr>
<tr>
<td>横纵坐标中位数</td>
<td>两端间隔模型</td>
<td>34.98</td>
<td>22.20</td>
<td>14.37</td>
</tr>
</tbody>
</table>
</div>
<h3 id="模型结果与分析"><a href="#模型结果与分析" class="headerlink" title="模型结果与分析"></a>模型结果与分析</h3><p>从当前已经获得的结果可知，横坐标大致在 32 ∼ 34，纵坐标大致在 19 ∼ 23，半径大致在<br>11 ∼ 15 范围内。但是不同的方案预测的结果差异较大，我们还需要从中选择出最佳的结果。为此<br>我们需要对模型进行评价。</p>
<h2 id="模型的评价"><a href="#模型的评价" class="headerlink" title="模型的评价"></a>模型的评价</h2><h3 id="数值模拟"><a href="#数值模拟" class="headerlink" title="数值模拟"></a>数值模拟</h3><p>因为我们并不知道真正的结果是什么，所以无法通过模型求得的结果判断那种模型更加精确。为了进行模型评价，我们可以采用计算机模拟的方法。</p>
<p>首先，我们需要确定生成圆形区域均匀分布的算法。对于角度，我们可以直接将 $[0, 1)$ 随机数线性映射到 $[0, 2\pi)$。但对于半径的取值，我们必须依照概率密度函数 $f(z) = \frac{2z}{r^2}$ 生成随机数。</p>
<p>我们采用的方法是反函数法。具体来说，对概率分布函数 $F(z) = \frac{z^2}{r^2}$。我们取得其反函数</p>
<script type="math/tex; mode=display">
    F^{-1}(p) = r\sqrt{p}</script><p>将 $[0, 1)$ 随机数经过该反函数的映射后即得到概率密度为 $f(z)$ 的随机数。</p>
<p>随后将生成的随机数输入到模型中进行计算，得出数值结果。</p>
<h3 id="结果评价"><a href="#结果评价" class="headerlink" title="结果评价"></a>结果评价</h3><p>我们设定 $m = 50, n = 50, r = 20$，从总体中随机取 $20$ 个点作为样本。对每个样本分别使用模型估计 $m, n, r$（其中估计 $r$ 时，给定真实的 $m, n$）。如此取 $200$ 个样本，计算 $200$ 个样本估计的 $m, n, r$ 平均值、平均值与真值的误差和标准差。结果如下：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>模型</th>
<th>x的平均值</th>
<th>x平均值的误差</th>
<th>x的标准差</th>
<th>y的平均值</th>
<th>y平均值的误差</th>
<th>y的标准差</th>
</tr>
</thead>
<tbody>
<tr>
<td>样本点平均值</td>
<td>50.2</td>
<td>0.2</td>
<td>2.47</td>
<td>50.3</td>
<td>0.3</td>
<td>2.14</td>
</tr>
<tr>
<td>最远点平均值</td>
<td>50.04</td>
<td>0.04</td>
<td>1.77</td>
<td>50.02</td>
<td>0.02</td>
<td>1.66</td>
</tr>
<tr>
<td>横纵坐标中位数</td>
<td>50.26</td>
<td>0.26</td>
<td>3.63</td>
<td>50.31</td>
<td>0.31</td>
<td>3.1</td>
</tr>
</tbody>
</table>
</div>
<div class="table-container">
<table>
<thead>
<tr>
<th>模型</th>
<th>r的平均值</th>
<th>r平均值的误差</th>
<th>r的标准差</th>
</tr>
</thead>
<tbody>
<tr>
<td>半径平均值</td>
<td>20.11</td>
<td>0.11</td>
<td>1.67</td>
</tr>
<tr>
<td>极大似然法</td>
<td>19.5</td>
<td>-0.5</td>
<td>0.48</td>
</tr>
<tr>
<td>两端间隔模型</td>
<td>20.47</td>
<td>0.47</td>
<td>1.01</td>
</tr>
</tbody>
</table>
</div>
<p>我们也根据结果绘制了频率直方图，如下所示。其中模型序号与“模型选择与分析”一节中顺序相同。<br><img src="/posts/7a0960e5/c1.png" class="" title="c1"><br><img src="/posts/7a0960e5/c2.png" class="" title="c2"><br><img src="/posts/7a0960e5/c3.png" class="" title="c3"><br><img src="/posts/7a0960e5/r1.png" class="" title="r1"><br><img src="/posts/7a0960e5/r2.png" class="" title="r2"><br><img src="/posts/7a0960e5/r3.png" class="" title="r3"></p>
<p>根据模拟的结果可以得出以下的初步结论：</p>
<ul>
<li>对于圆心位置的估计来说，最远点平均值模型优于样本点平均值和中位数模型。不仅误差较小，标准差也最小。这说明在小样本条件下，平均值和中位数未必是最优的模型。</li>
<li>对于半径的估计来说，平均值模型拥有较小的误差，但标准差较大，预测结果不稳定；极大似然估计的结果标准差较小，但结果几乎总是小于真实值；两端间隔模型标准差较小，但误差却较大。因此这部分模型的选择需要考虑实际应用情况。</li>
</ul>
<p>总体来说，对圆心位置的估计，最远点平均值模型最优；对半径的估计，如果不看重多次估计的集中程度，则平均值模型更优；反之，则可以选择两端间隔模型。因此，最远点平均值模型+平均值模型和最远点平均值模型+两端间隔模型是更合适的选择。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本篇文章中，我们从估计菌丝结构的问题出发，分析了“通过圆形区域内均匀分布的样本点，估计圆形位置和范围”的解决方法。利用概率论等相关知识，建立了一系列符合理论的数学模型，并通过数值模拟对模型进行了评价分析，选择出更加适合当前问题的模型。</p>
<h2 id="Appendices"><a href="#Appendices" class="headerlink" title="Appendices"></a>Appendices</h2><h3 id="附录-A-圆形区域均匀分布随机数生成算法"><a href="#附录-A-圆形区域均匀分布随机数生成算法" class="headerlink" title="附录 A 圆形区域均匀分布随机数生成算法"></a>附录 A 圆形区域均匀分布随机数生成算法</h3><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> math</span><br><span class="line"><span class="keyword">from</span> random <span class="keyword">import</span> Random</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">generate_circle_point</span>(<span class="params">r</span>):</span><br><span class="line">    rand = Random()</span><br><span class="line">    angle = rand.random() * (<span class="number">2</span> * np.pi)</span><br><span class="line">    r_len = r * math.sqrt(rand.random())</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> np.array([r_len * math.sin(angle), r_len * math.cos(angle)])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">generate_circle</span>(<span class="params">m, n, r, point_num</span>):</span><br><span class="line">    points = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(point_num):</span><br><span class="line">        points.append(generate_circle_point(r))</span><br><span class="line"></span><br><span class="line">    points = np.array(points)</span><br><span class="line"></span><br><span class="line">    points += np.array([m, n])</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> points</span><br></pre></td></tr></table></figure>
<h3 id="附录-B-各类数学模型的代码实现"><a href="#附录-B-各类数学模型的代码实现" class="headerlink" title="附录 B 各类数学模型的代码实现"></a>附录 B 各类数学模型的代码实现</h3><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> math</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">circle_center1</span>(<span class="params">points</span>):</span><br><span class="line">    <span class="keyword">return</span> points.mean(axis=<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">circle_center2</span>(<span class="params">points</span>):</span><br><span class="line">    x_min, y_min = points.<span class="built_in">min</span>(axis=<span class="number">0</span>)</span><br><span class="line">    x_max, y_max = points.<span class="built_in">max</span>(axis=<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> np.array([(x_min + x_max) / <span class="number">2</span>, (y_min + y_max) / <span class="number">2</span>])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">circle_center3</span>(<span class="params">points</span>):</span><br><span class="line">    <span class="keyword">return</span> np.median(points, axis=<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">circle_radius1</span>(<span class="params">radius_list</span>):</span><br><span class="line">    r_mean = radius_list.mean()</span><br><span class="line">    <span class="keyword">return</span> (<span class="number">3</span> / <span class="number">2</span>) * r_mean</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">circle_radius2</span>(<span class="params">radius_list</span>):</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">max</span>(radius_list)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">circle_radius3</span>(<span class="params">radius_list</span>):</span><br><span class="line">    r_min = <span class="built_in">min</span>(radius_list)</span><br><span class="line">    r_max = <span class="built_in">max</span>(radius_list)</span><br><span class="line">    <span class="keyword">return</span> (r_max + math.sqrt(r_max ** <span class="number">2</span> + <span class="number">4</span> * r_min ** <span class="number">2</span>)) / <span class="number">2</span></span><br></pre></td></tr></table></figure>
<h3 id="附录-C-模型求解方法"><a href="#附录-C-模型求解方法" class="headerlink" title="附录 C 模型求解方法"></a>附录 C 模型求解方法</h3><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> math_model2 <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">mushrooms = []</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;mushrooms.txt&quot;</span>, <span class="string">&quot;r&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    <span class="keyword">for</span> i, line <span class="keyword">in</span> <span class="built_in">enumerate</span>(f):</span><br><span class="line">        <span class="keyword">if</span> i == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        grid = line.split(<span class="string">&quot;\t&quot;</span>)</span><br><span class="line">        mushrooms.append([<span class="built_in">float</span>(grid[<span class="number">1</span>]), <span class="built_in">float</span>(grid[<span class="number">2</span>])])</span><br><span class="line"></span><br><span class="line">mushrooms = np.array(mushrooms)</span><br><span class="line"></span><br><span class="line">calc_center_funcs = [circle_center1, circle_center2, circle_center3]</span><br><span class="line">calc_radius_funcs = [circle_radius1, circle_radius2, circle_radius3]</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;ans.txt&quot;</span>, <span class="string">&quot;w&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    f.write(<span class="string">f&quot;圆心估计模型\t半径估计模型\t横坐标\t纵坐标\t半径\n&quot;</span>)</span><br><span class="line">    <span class="keyword">for</span> i, center_func <span class="keyword">in</span> <span class="built_in">enumerate</span>(calc_center_funcs):</span><br><span class="line">        <span class="keyword">for</span> j, radius_func <span class="keyword">in</span> <span class="built_in">enumerate</span>(calc_radius_funcs):</span><br><span class="line">            m, n = center = center_func(mushrooms)</span><br><span class="line"></span><br><span class="line">            r_list = np.linalg.norm(mushrooms - center, axis=<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">            r = radius_func(r_list)</span><br><span class="line"></span><br><span class="line">            f.write(<span class="string">f&quot;center<span class="subst">&#123;i+<span class="number">1</span>&#125;</span>\tradius<span class="subst">&#123;j+<span class="number">1</span>&#125;</span>\t<span class="subst">&#123;m:<span class="number">.2</span>f&#125;</span>\t<span class="subst">&#123;n:<span class="number">.2</span>f&#125;</span>\t<span class="subst">&#123;r:<span class="number">.2</span>f&#125;</span>\n&quot;</span>)</span><br></pre></td></tr></table></figure>
<h3 id="附录-D-数值模拟方法"><a href="#附录-D-数值模拟方法" class="headerlink" title="附录 D 数值模拟方法"></a>附录 D 数值模拟方法</h3><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> math_model2 <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> random_generator <span class="keyword">import</span> generate_circle</span><br><span class="line"></span><br><span class="line">num = <span class="number">20</span></span><br><span class="line">m = <span class="number">50</span></span><br><span class="line">n = <span class="number">50</span></span><br><span class="line">r = <span class="number">20</span></span><br><span class="line"></span><br><span class="line">calc_center_funcs = [circle_center1, circle_center2, circle_center3]</span><br><span class="line">calc_radius_funcs = [circle_radius1, circle_radius2, circle_radius3]</span><br><span class="line"></span><br><span class="line">center = [[], [], []]</span><br><span class="line">radius = [[], [], []]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> step <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">200</span>):</span><br><span class="line">    mushrooms = generate_circle(m, n, r, num)</span><br><span class="line">    radius_list = np.linalg.norm(mushrooms - np.array([m, n]), axis=<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>):</span><br><span class="line">        center_func = calc_center_funcs[i]</span><br><span class="line">        center_ans = center_func(mushrooms)</span><br><span class="line"></span><br><span class="line">        center[i].append(center_ans)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>):</span><br><span class="line">        radius_func = calc_radius_funcs[i]</span><br><span class="line">        radius_ans = radius_func(radius_list)</span><br><span class="line"></span><br><span class="line">        radius[i].append(radius_ans)</span><br><span class="line"></span><br><span class="line">table_val = np.zeros((<span class="number">3</span>, <span class="number">6</span>))</span><br><span class="line">row_label = [<span class="string">&quot;model 1&quot;</span>, <span class="string">&quot;model 2&quot;</span>, <span class="string">&quot;model 3&quot;</span>]</span><br><span class="line">col_label = [<span class="string">&quot;x avg&quot;</span>, <span class="string">&quot;x error&quot;</span>, <span class="string">&quot;x std&quot;</span>, <span class="string">&quot;y avg&quot;</span>, <span class="string">&quot;y error&quot;</span>, <span class="string">&quot;y std&quot;</span>]</span><br><span class="line"><span class="keyword">for</span> idx, one_center <span class="keyword">in</span> <span class="built_in">enumerate</span>(center):</span><br><span class="line">    x, y = <span class="built_in">zip</span>(*one_center)</span><br><span class="line">    x = np.array(x)</span><br><span class="line">    y = np.array(y)</span><br><span class="line"></span><br><span class="line">    table_val[idx][<span class="number">0</span>] = x.mean()</span><br><span class="line">    table_val[idx][<span class="number">1</span>] = x.mean() - m</span><br><span class="line">    table_val[idx][<span class="number">2</span>] = x.std()</span><br><span class="line">    table_val[idx][<span class="number">3</span>] = y.mean()</span><br><span class="line">    table_val[idx][<span class="number">4</span>] = y.mean() - n</span><br><span class="line">    table_val[idx][<span class="number">5</span>] = y.std()</span><br><span class="line"></span><br><span class="line">    plt.suptitle(<span class="string">f&quot;Centroid Estimation Model <span class="subst">&#123;idx+<span class="number">1</span>&#125;</span>&quot;</span>)</span><br><span class="line">    plt.subplot(<span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>)</span><br><span class="line">    plt.hist(x)</span><br><span class="line">    plt.title(<span class="string">&quot;Estimation for X Axis&quot;</span>)</span><br><span class="line"></span><br><span class="line">    plt.subplot(<span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>)</span><br><span class="line">    plt.hist(y)</span><br><span class="line">    plt.title(<span class="string">&quot;Estimation for Y Axis&quot;</span>)</span><br><span class="line">    plt.show()</span><br><span class="line"></span><br><span class="line">table_val = np.around(table_val, decimals=<span class="number">2</span>)</span><br><span class="line">plt.suptitle(<span class="string">f&quot;Numerical Simulation for Centroid Estimation Models&quot;</span>)</span><br><span class="line">plt.table(</span><br><span class="line">    cellText=table_val,</span><br><span class="line">    rowLabels=row_label,</span><br><span class="line">    colLabels=col_label,</span><br><span class="line">    loc=<span class="string">&quot;center&quot;</span>,</span><br><span class="line">    cellLoc=<span class="string">&quot;center&quot;</span>,</span><br><span class="line">    rowLoc=<span class="string">&quot;center&quot;</span>,</span><br><span class="line">)</span><br><span class="line">plt.axis(<span class="string">&quot;off&quot;</span>)</span><br><span class="line">plt.show()</span><br><span class="line"></span><br><span class="line">table_val = np.zeros((<span class="number">3</span>, <span class="number">3</span>))</span><br><span class="line">row_label = [<span class="string">&quot;model 1&quot;</span>, <span class="string">&quot;model 2&quot;</span>, <span class="string">&quot;model 3&quot;</span>]</span><br><span class="line">col_label = [<span class="string">&quot;r avg&quot;</span>, <span class="string">&quot;r error&quot;</span>, <span class="string">&quot;r std&quot;</span>]</span><br><span class="line"><span class="keyword">for</span> idx, one_radius <span class="keyword">in</span> <span class="built_in">enumerate</span>(radius):</span><br><span class="line">    one_radius = np.array(one_radius)</span><br><span class="line"></span><br><span class="line">    table_val[idx][<span class="number">0</span>] = one_radius.mean()</span><br><span class="line">    table_val[idx][<span class="number">1</span>] = one_radius.mean() - r</span><br><span class="line">    table_val[idx][<span class="number">2</span>] = one_radius.std()</span><br><span class="line">    </span><br><span class="line">    plt.hist(one_radius)</span><br><span class="line">    plt.suptitle(<span class="string">f&quot;Radius Estimation Model <span class="subst">&#123;idx+<span class="number">1</span>&#125;</span>&quot;</span>)</span><br><span class="line">    plt.show()</span><br><span class="line"></span><br><span class="line">table_val = np.around(table_val, decimals=<span class="number">2</span>)</span><br><span class="line">plt.suptitle(<span class="string">&quot;Numerical Simulation for Radius Estimation Models&quot;</span>)</span><br><span class="line">plt.table(</span><br><span class="line">    cellText=table_val,</span><br><span class="line">    rowLabels=row_label,</span><br><span class="line">    colLabels=col_label,</span><br><span class="line">    loc=<span class="string">&quot;center&quot;</span>,</span><br><span class="line">    cellLoc=<span class="string">&quot;center&quot;</span>,</span><br><span class="line">    rowLoc=<span class="string">&quot;center&quot;</span>,</span><br><span class="line">)</span><br><span class="line">plt.axis(<span class="string">&quot;off&quot;</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>数学建模论文</category>
      </categories>
      <tags>
        <tag>数学</tag>
        <tag>概率</tag>
        <tag>数学建模</tag>
      </tags>
  </entry>
  <entry>
    <title>后端开发笔记之准备工作</title>
    <url>/posts/e8e3ed39/</url>
    <content><![CDATA[<h2 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h2><p>当我第一次看到那份作业的时候，我绝想不到，这作业将牵扯出多少我还未曾学习过的知识；我更想不到，自己要以多久的时间涉猎完所有这些内容。当然现在这些都已经结束了，感慨不应该抒发太多，还是趁着自己没有忘记，做一下总结吧。</p>
<p>这一系列应该会有几篇文章。主要内容是回顾总结我的第一次较为系统的后端开发经历。在学习的过程中我参考了许多文章，其中一些我也会在文章中给出链接。这些文章或许在一些方面比本篇文章讲的更加深入，但是本篇文章综合了许多文章的不同信息，给出了系统的安装配置流程和自己的一些见解，因此我认为还是有一些价值的。<br><span id="more"></span></p>
<h2 id="二、WSL，一切的起点"><a href="#二、WSL，一切的起点" class="headerlink" title="二、WSL，一切的起点"></a>二、WSL，一切的起点</h2><h3 id="（1）WSL-简介"><a href="#（1）WSL-简介" class="headerlink" title="（1）WSL 简介"></a>（1）WSL 简介</h3><p>windows 系统虽然在个人电脑上常用，但是开发起后端来还是不方便，最好还是使用 linux。但是只有一台电脑的话，装双系统极其麻烦、虚拟机又太过笨重。那么有没有一种更加方便的方法呢？有的，那就是使用 WSL（Windows Subsystem for Linux），即 Windows 的 Linux 子系统。WSL 分为 WSL1 和 WSL2，此二者的实现原理并不相同。虽然有些跑题，但是还是介绍一下，毕竟是自己费力去查的结果。</p>
<p>WSL1 不是虚拟机，Hyper-V 或 VMware 等虚拟机会用软件模拟硬件的行为，其中装入的操作系统是和模拟的硬件进行交互；而 WSL1 则是通过 Windows 操作系统库模拟了一个 Linux 内核，用 Windows 的系统调用来处理 Linux 的系统调用。并且由于 WSL1 不需要模拟硬件这一中间过程，因此效率会比虚拟机高。而 WSL2 则可以看做虚拟机，但是与其他虚拟机相比更加轻量，Linux 系统运行在此虚拟机上资源占用更少、运行更快。问题是 WSL2 使用了虚拟化技术，可能与其他虚拟机冲突，不能同时使用。</p>
<p>在这里我们使用 WSL2。主要原因是 WSL2 运行了真正的 Linux 内核，和各种 Linux 程序的兼容性更好。</p>
<h3 id="（2）WSL-安装"><a href="#（2）WSL-安装" class="headerlink" title="（2）WSL 安装"></a>（2）WSL 安装</h3><p>安装 WSL 很简单。这里的安装流程参考 <a href="https://learn.microsoft.com/zh-cn/windows/wsl/install">使用 WSL 在 Windows 上安装 Linux</a>。插一句，微软的技术文档真的很有用，如果对搜索得到的关于微软的技术问题的解决方案有不确定的地方，参考微软的技术文档有时会有很大帮助。就比如 WSL 的安装，搜到的经常已经是过时的教程了。</p>
<p>安装 WSL，只需要在 PowerShell 中以管理员模式运行如下命令即可。<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">wsl --install</span><br></pre></td></tr></table></figure></p>
<p>注意网上的教程中，需要使用 <code>dism.exe</code> 的为旧版的手动安装步骤，详见 <a href="https://learn.microsoft.com/zh-cn/windows/wsl/install-manual">旧版 WSL 的手动安装步骤</a>。</p>
<p>这样 WSL2 就安装完成了。因为我们不会去使用 WSL1，因此关于 WSL1 的安装过程就略过不提了。</p>
<h2 id="三、Windows-中安装-Ubuntu"><a href="#三、Windows-中安装-Ubuntu" class="headerlink" title="三、Windows 中安装 Ubuntu"></a>三、Windows 中安装 Ubuntu</h2><h3 id="（1）Ubuntu-获取"><a href="#（1）Ubuntu-获取" class="headerlink" title="（1）Ubuntu 获取"></a>（1）Ubuntu 获取</h3><p>WSL2 只提供了 Linux 内核而非发行版。我们还需要自行安装发行版。我们选择安装 Ubuntu，一个简便的方法是直接打开 Microsoft Store，从中下载 Ubuntu。</p>
<p>我们在搜索栏里搜索 Ubuntu，在编写本文时最好下载 Ubuntu22.04LTS，而不是那个不包含版本号的。</p>
<p>点击<strong>获取</strong>按钮以现在 Ubuntu 镜像。之后<strong>获取</strong>按钮会变为<strong>安装</strong>。如果你不想自己的 c 盘爆满，此时一定不要直接点击<strong>安装</strong>。如果不实现迁移，安装后 Ubuntu 会在 c 盘中占据大约 10 GB 的空间。</p>
<h3 id="（2）符号链接——C盘搬迁的好方法"><a href="#（2）符号链接——C盘搬迁的好方法" class="headerlink" title="（2）符号链接——C盘搬迁的好方法"></a>（2）符号链接——C盘搬迁的好方法</h3><p>我们首先找到如下的文件夹 C:\Users\yourusername\AppData\Local\Packages<br>\CanonicalGroupLimited.Ubuntu22.04LTS_79rhkp1fndgsc，该路径就是 Ubuntu 将会安装到的位置。如果你查看一下文件夹现在的大小，应该只有 KB 级别。现在我们就要将该文件夹迁移到别的盘。</p>
<p>你可能会想，既然我们要迁移，那是不是应该在哪里设置一下，告知系统新的安装位置？可惜并没有这样的功能。Ubuntu 一定会安装到 c 盘的该路径。除非我们找到 Ubuntu 的安装包自行安装，可是安装包位于 C:\Program Files\WindowsApps\<br>CanonicalGroupLimited.Ubuntu22.04LTS_2204.1.23.0_x64__79rhkp1fndgsc 路径下，而 C:\Program Files\WindowsApps 路径下保存了 Windows 操作系统的文件，访问其中内容是危险的操作，所以我们不采用这样的方法。</p>
<p>我们采用的方法是符号链接。了解过 Linux 的应该熟悉 “软链接”、“硬链接” 这样的名词。Windows 下的符号链接实际上就与 Linux 中的 “软链接” 类似。他们都能将不同的路径映射到相同的文件上。这样你应该理解我们应该要做什么了。我们要做的就是将 Ubuntu 的安装目录下的内容移动到别的盘，再创建一个原路径到新路径的符号链接。这样 Ubuntu 安装时依旧使用原路径，但实际上却安装到了别的盘。同时 c 盘的原路径依旧可以访问到安装后的内容。</p>
<p>首先，我们将 C:\Users\yourusername\AppData\Local\Packages\<br>CanonicalGroupLimited.Ubuntu22.04LTS_79rhkp1fndgsc 文件夹<strong>复制</strong>到别的盘的路径下，如 E:\Linux。</p>
<p>接着，我们将 C:\Users\yourusername\AppData\Local\Packages\<br>CanonicalGroupLimited.Ubuntu22.04LTS_79rhkp1fndgsc 重命名，如在文件夹名末尾加上 bak。这样一方面避免了内容的丢失，另一方面则是创建符号链接时不能出现同名文件夹。</p>
<p>最后我们打开 CMD 或 Powershell，运行命令<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mklink \d &quot;C:\Users\&#123;yourusername&#125;\AppData\Local\Packages\CanonicalGroupLimited.Ubuntu22.04LTS_79rhkp1fndgsc&quot; &quot;E:\Linux\CanonicalGroupLimited.Ubuntu22.04LTS_79rhkp1fndgsc&quot;</span><br></pre></td></tr></table></figure></p>
<p>如果成功，应该显示创建了两个路径间的链接。这时就可以将原有的文件夹删除了。进入 C:\Users\yourusername\AppData\Local\Packages，应该可以找到名为 CanonicalGroupLimited.Ubuntu22.04LTS_79rhkp1fndgsc 的 “文件夹”，只不过该 “文件夹” 的图标左下角出现了和 “快捷方式” 相同的箭头。但需要注意的是，虽然文件夹可以创建快捷方式，图标也和符号链接相同，但是两者是不同的。双击符号链接进入文件夹后，还位于原有路径中；但双击快捷方式进入文件夹后，路径便会发生变化。</p>
<h3 id="（3）Ubuntu-安装"><a href="#（3）Ubuntu-安装" class="headerlink" title="（3）Ubuntu 安装"></a>（3）Ubuntu 安装</h3><p>这下我们就可以点击 Microsoft Store 中的<strong>安装</strong>按钮了。等待自动安装，安装完成后会弹出一个类似于 CMD 的黑底命令行窗口，提示你设置用户名及密码，成功后即进入到 Ubuntu 系统中。</p>
<p>顺便提一句，此处设置的密码不是 root 的密码。输入如下命令设置 root 的密码。<br><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">sudo passwd root</span><br></pre></td></tr></table></figure></p>
<h3 id="（4）配置-apt-镜像源"><a href="#（4）配置-apt-镜像源" class="headerlink" title="（4）配置 apt 镜像源"></a>（4）配置 apt 镜像源</h3><p>现在 Ubuntu 已经可以运行了。想要使用不同的软件只需要下载。为了便于下载，我们需要为 apt 换源。apt 的源信息保存在 /etc/apt/sources.list 文件中。</p>
<p>想要修改，最好首先备份原本的文件<br><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> /etc/apt</span><br><span class="line"><span class="built_in">cp</span> sources.list sources.list.bak</span><br></pre></td></tr></table></figure></p>
<p>清空文件并进行编辑<br><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">&gt;sources.list</span><br><span class="line">vim sources.list</span><br></pre></td></tr></table></figure></p>
<p>将新的源地址拷贝到其中，保存并退出即可。<br><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 清华源</span></span><br><span class="line"><span class="comment"># 默认注释了源码镜像以提高 apt update 速度，如有需要可自行取消注释</span></span><br><span class="line">deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ jammy main restricted universe multiverse</span><br><span class="line"><span class="comment"># deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ jammy main restricted universe multiverse</span></span><br><span class="line">deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ jammy-updates main restricted universe multiverse</span><br><span class="line"><span class="comment"># deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ jammy-updates main restricted universe multiverse</span></span><br><span class="line">deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ jammy-backports main restricted universe multiverse</span><br><span class="line"><span class="comment"># deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ jammy-backports main restricted universe multiverse</span></span><br><span class="line">deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ jammy-security main restricted universe multiverse</span><br><span class="line"><span class="comment"># deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ jammy-security main restricted universe multiverse</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 预发布软件源，不建议启用</span></span><br><span class="line"><span class="comment"># deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ jammy-proposed main restricted universe multiverse</span></span><br><span class="line"><span class="comment"># deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ jammy-proposed main restricted universe multiverse</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 中科大源</span></span><br><span class="line">deb https://mirrors.ustc.edu.cn/ubuntu/ jammy main restricted universe multiverse</span><br><span class="line">deb-src https://mirrors.ustc.edu.cn/ubuntu/ jammy main restricted universe multiverse</span><br><span class="line">deb https://mirrors.ustc.edu.cn/ubuntu/ jammy-updates main restricted universe multiverse</span><br><span class="line">deb-src https://mirrors.ustc.edu.cn/ubuntu/ jammy-updates main restricted universe multiverse</span><br><span class="line">deb https://mirrors.ustc.edu.cn/ubuntu/ jammy-backports main restricted universe multiverse</span><br><span class="line">deb-src https://mirrors.ustc.edu.cn/ubuntu/ jammy-backports main restricted universe multiverse</span><br><span class="line">deb https://mirrors.ustc.edu.cn/ubuntu/ jammy-security main restricted universe multiverse</span><br><span class="line">deb-src https://mirrors.ustc.edu.cn/ubuntu/ jammy-security main restricted universe multiverse</span><br><span class="line">deb https://mirrors.ustc.edu.cn/ubuntu/ jammy-proposed main restricted universe multiverse</span><br><span class="line">deb-src https://mirrors.ustc.edu.cn/ubuntu/ jammy-proposed main restricted universe multiverse</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>不知道如何拷贝？请右击终端的上边框，将属性-选项-编辑选项-将Ctrl+Shift+C/V 用作复制粘贴的快捷键选项勾选上即可。</p>
<p>另外顺便一提，有时你会发现点击 CMD 窗口后程序执行就会被卡住。这是因为终端默认勾选了 “快速编辑模式”，取消即可。</p>
</blockquote>
<p>源地址参考了 <a href="https://blog.csdn.net/xiangxianghehe/article/details/122856771">Ubuntu 22.04换国内源 清华源 阿里源 中科大源 163源</a></p>
<p>最后执行如下命令更新 apt 的源<br><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">sudo apt-get update</span><br></pre></td></tr></table></figure></p>
<p>注意对 sources.list 进行修改可能需要 root 权限。开启 root 使用 <code>su</code> 命令；退出 root 使用 <code>exit</code> 命令，此命令也是退出终端的命令</p>
<h3 id="（5）Anaconda-安装及配置源"><a href="#（5）Anaconda-安装及配置源" class="headerlink" title="（5）Anaconda 安装及配置源"></a>（5）Anaconda 安装及配置源</h3><p>后续会使用 flask 进行开发，因此需要使用 python。这里使用 Anaconda 管理 python 环境。</p>
<p>首先我们需要下载 Anaconda 的安装脚本。这里使用 wget 进行下载<br><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">wget https://repo.anaconda.com/archive/Anaconda3-2023.03-Linux-x86_64.sh</span><br></pre></td></tr></table></figure></p>
<p>下载的地址在 <a href="https://www.anaconda.com/download">Anaconda 的下载页</a>的最下方。选择<br>64-Bit (x86) Installer (860 MB) 即可。</p>
<p>接着我们运行 shell 脚本进行安装<br><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">bash Anaconda3-2023.03-Linux-x86_64.sh</span><br></pre></td></tr></table></figure></p>
<p>安装过程中一路 yes 即可。安装结束后可能还无法使用 <code>conda</code> 命令，这是因为 Anaconda 在安装时将环境变量的设置添加到了 <code>~/.bashrc</code> 文件中。该文件只在你登入 shell 时执行一次以设置环境变量。为了让 <code>conda</code> 命令可以直接使用，可以执行如下命令以启用对环境变量的更改。<br><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">source</span> ~/.bashrc</span><br></pre></td></tr></table></figure></p>
<p>另外 Anaconda 默认在每次登陆后都会自动进入 base 环境。我们使用 Ubuntu 并不是为了编写 python 程序这单一的目的，因此可以禁止该行为。这只需要输入如下命令。<br><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">conda config --<span class="built_in">set</span> auto_activate_base <span class="literal">false</span></span><br></pre></td></tr></table></figure></p>
<p>最后同样配置镜像，这需要修改 ~/.condarc 文件，为该文件添加清华镜像源。根据<a href="https://mirrors.tuna.tsinghua.edu.cn/help/anaconda/">清华镜像站的说明</a>，需要添加如下内容<br><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">channels:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">defaults</span></span><br><span class="line"><span class="attr">show_channel_urls:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">default_channels:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/main</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/r</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/msys2</span></span><br><span class="line"><span class="attr">custom_channels:</span></span><br><span class="line">  <span class="attr">conda-forge:</span> <span class="string">https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud</span></span><br><span class="line">  <span class="attr">msys2:</span> <span class="string">https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud</span></span><br><span class="line">  <span class="attr">bioconda:</span> <span class="string">https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud</span></span><br><span class="line">  <span class="attr">menpo:</span> <span class="string">https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud</span></span><br><span class="line">  <span class="attr">pytorch:</span> <span class="string">https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud</span></span><br><span class="line">  <span class="attr">pytorch-lts:</span> <span class="string">https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud</span></span><br><span class="line">  <span class="attr">simpleitk:</span> <span class="string">https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud</span></span><br></pre></td></tr></table></figure></p>
<p>提一句，如果你先设置了 <code>conda config --set auto_activate_base false</code> 再打开 ~/.condarc 文件，就会发现 ~/.condarc 中已经有了如下内容<br><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">auto_activate_base:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure></p>
<h2 id="四、VSCode-远程连接"><a href="#四、VSCode-远程连接" class="headerlink" title="四、VSCode 远程连接"></a>四、VSCode 远程连接</h2><h3 id="（1）WSL-远程连接"><a href="#（1）WSL-远程连接" class="headerlink" title="（1）WSL 远程连接"></a>（1）WSL 远程连接</h3><p>好了，现在我们已经具备使用 WSL 进行后端开发的条件了。可是仅仅通过 WSL 终端，使用 vim 等命令行文本编辑器进行开发的话，效率还是太低了。我们可以使用本机的 VSCode 连接 WSL，用更加现代化的编辑器进行开发。</p>
<p>使用 VScode 连接 WSL 的方式很简单。这一部分的内容同样参考微软技术文档，<a href="https://learn.microsoft.com/zh-cn/windows/wsl/tutorials/wsl-vscode">开始通过适用于 Linux 的 Windows 子系统使用 Visual Studio Code</a></p>
<p>创建链接有两种方法，分别是从 WSL 中和从本机 VSCode 中。但是这两种方式都要在 VSCode 中添加<a href="https://marketplace.visualstudio.com/items?itemName=ms-vscode-remote.vscode-remote-extensionpack">远程开发扩展包</a>。该扩展包中包含了用于不同连接的插件，如用于 WSL 的和用于 SSH 的。但我们可以不考虑这些，只需要安装就可以了。</p>
<p>从 WSL 中建立连接，只需要在 WSL 终端中，要打开的文件夹处输入如下命令<br><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">code ./</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p><code>code</code> 是 VSCode 在命令行中的名字，说实话感觉这个名字对于一个编辑器来说有点不符实了。</p>
</blockquote>
<p>然后主机上就会自动运行 VSCode，创建一个新窗口。就是这么简单。</p>
<p>但是，更多时候你并不想再打开 WSL 终端，这就需要直接通过 VSCode 建立连接。你需要：</p>
<ul>
<li>通过 Ctrl + Shift + P 打开 VSCode 的命令面板</li>
<li>输入 wsl 进行查询，选择 “远程资源管理器：焦点在 WSL Targes 视图上” 选项（什么鬼翻译），这会打开远程资源管理器的侧边栏。</li>
<li>最后在你希望连接的 WSL 子系统上右键，选择 Connect to WSL 即可连接到对应的 WSL 子系统。</li>
</ul>
<p>这样同样会新建一个 VSCode 窗口，连接到 WSL。</p>
<p>最后提一下，VSCode 左下角的蓝色方块用于指示当前的远程连接。当连接 WSL Ubuntu 成功后会变为如下内容：“WSL:Ubuntu-22.04”</p>
<h3 id="（2）Windows-和-WSL-的文件共享"><a href="#（2）Windows-和-WSL-的文件共享" class="headerlink" title="（2）Windows 和 WSL 的文件共享"></a>（2）Windows 和 WSL 的文件共享</h3><p>这一部分参考了<a href="https://learn.microsoft.com/zh-cn/windows/wsl/filesystems">跨 Windows 和 Linux 文件系统工作</a>。</p>
<p>Windows 和 WSL 间的文件共享实际上是一个很值得关注的问题。之前使用 VMware 时，共享文件需要一系列的配置，有些麻烦。而在 WSL 中，微软则已经为我们设置好了共享文件的方法。</p>
<p>WSL 中，主机的盘被挂载到了 /mnt 目录下。/mnt 目录下的各目录表示着不同的外部设备。现在进入到 /mnt 文件，你就可以看到 c d e f 盘的目录。<br><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">wokron@DESKTOP-T1ANVDS:/mnt$ <span class="built_in">cd</span> /mnt</span><br><span class="line">wokron@DESKTOP-T1ANVDS:/mnt$ <span class="built_in">ls</span></span><br><span class="line">c  d  e  f  wsl  wslg</span><br></pre></td></tr></table></figure></p>
<p>在主机中情况类似，所有的 WSL 子系统的文件都放在 \wsl$ 路径下。在资源管理器中输入该路径即可跳转。</p>
<p>这样的我们就可以像一般文件一样通过路径访问并操纵另一个系统中的文件了。</p>
<h2 id="五、Docker-的安装"><a href="#五、Docker-的安装" class="headerlink" title="五、Docker 的安装"></a>五、Docker 的安装</h2><h3 id="（1）Docker-简介"><a href="#（1）Docker-简介" class="headerlink" title="（1）Docker 简介"></a>（1）Docker 简介</h3><p>项目需要有环境来运行。当项目在不同设备上运行时，一般需要重复搭建相同的环境。但是搭建环境的这一过程可能是难以重复的，因为我们并不一定知道搭建同一个环境的方式；甚至是不可能的，因为一些机器上并不一定提供对环境的支持。</p>
<p>这样的难题时常困扰着项目开发。项目开发者便希望找到这样一种方法，能够在不同的设备上保持环境的一致性。</p>
<p>一种方法便是虚拟机，通过复制虚拟机，就能保持环境的一致性。但虚拟机的弊端在于太过底层。虚拟机从硬件开始模拟，包含了许多项目运行所并不需要的程序。尽管我们只想要运行单一的项目，却需要同时维护整套操作系统，这势必造成资源的浪费。那么有没有一种手段，在虚拟化的时候只包含项目运行所必须的环境，而将其他内容都去掉呢？</p>
<p>这就是容器技术（container，当然也可以翻译为集装箱，甚至集装箱更能表现该技术的本质。从Docker的吉祥物（Moby Dock，很明显是赫尔曼·梅尔维尔《白鲸记》的neta）来看，翻译为集装箱似乎也是一个不错的选择）。容器技术使得在不同容器内运行的程序 1. 彼此隔离；2. 但又共享同一个操作系统。这样就在保持环境一致性的同时，解决了不同虚拟机运行各自的操作系统造成资源浪费的问题。</p>
<p>Docker 是一个用于创建和使用容器的开源项目，可以让我们方便的创建和使用容器。只需要将项目和其环境依赖打包到 Docker 的容器中，那么该容器只要能在某一设备上运行，便可以在所有设备上运行。实现了 “一次构建，到处运行”。<br><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">                  ##         .</span><br><span class="line">            ## ## ##        ==</span><br><span class="line">         ## ## ## ## ##    ===</span><br><span class="line">     /&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;\___/ ===</span><br><span class="line">~~~ &#123;~~ ~~~~ ~~~ ~~~~ ~~~ ~ /  ===- ~~~</span><br><span class="line">     \______ o           __/</span><br><span class="line">       \    \         __/</span><br><span class="line">        \____\_______/</span><br></pre></td></tr></table></figure></p>
<h3 id="（2）Windows-中安装-Docker-Desktop"><a href="#（2）Windows-中安装-Docker-Desktop" class="headerlink" title="（2）Windows 中安装 Docker Desktop"></a>（2）Windows 中安装 Docker Desktop</h3><p>在 Windows 下安装 Docker 很容易，只需要进入 <a href="https://www.docker.com/">Docker 的官网</a>，下载 Docker Desktop 即可。</p>
<p>运行 Docker Desktop Installer.exe，无需设置，下载器会全自动将 Docker 下载到 c 盘 <code>:)</code>。</p>
<p>这时你的 c 盘会增加几个 GB 的占用。同时当你构建新的镜像（镜像是静态的容器，是容器的声明；镜像和容器的关系类似于程序与进程）时，你的 c 盘还会越来越满……所以我们请出之前用过的技术，符号链接。</p>
<p>Docker 在 c 盘中占用空间最大的便是C:\Users\yourusername\AppData\Local \Docker\wsl\data\ext4.vhdx 这个文件。该文件是硬盘映像文件，其来源需要解释一下 Docker 在 Windows 下的运行原理。Docker 实际上在 WSL2 中创建了新的子系统作为承载所有容器的操作系统（这也是我们先行安装 WSL2 的原因，如果先安装 Docker，则在运行 Docker 时便会提醒你安装 WSL2），而 WSL 就通过 .vhdx 硬盘映像文件在 Windows 下存储 Linux 磁盘格式的持久化数据。那么随着镜像的增加，就需要更多的空间存储镜像数据，ext4.vhdx 文件自然就增大了。</p>
<p>我们只需要移动 ext4.vhdx 文件，为了方便，我们将包含该文件的 data 文件夹复制到其他位置，如 D:\Docker。之后重命名源路径的 data 文件。</p>
<p>接着再次使用 <code>mklink</code> 命令创建符号链接<br><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">mklink \d <span class="string">&quot;C:\Users\yourusername\AppData\Local \Docker\wsl\data&quot;</span> <span class="string">&quot;D:\Docker\data&quot;</span></span><br></pre></td></tr></table></figure></p>
<p>这样 Docker 的大小再增长也不会影响 c 盘了。</p>
<blockquote>
<p>Docker Desktop 的 setting-resources-advanced 中有设置 Disk image location 的地方，但是我并没有采取这一手段。因为根据最近提出的一个 <a href="https://github.com/docker/for-win/issues/13345">issue</a>，这一方法似乎有 bug。为了避免产生更大的问题，还是采用 <code>mklink</code> 比较保守。</p>
</blockquote>
<h3 id="（3）WSL-中-Docker-使能"><a href="#（3）WSL-中-Docker-使能" class="headerlink" title="（3）WSL 中 Docker 使能"></a>（3）WSL 中 Docker 使能</h3><p>如果我是在 WSL 中编写的项目，又要如何使用 Docker 呢？难道要再安装 Linux 版的 Docker？其实并不需要，只需要下载 Docker 一次，就可以在主机和 WSL 子系统中同时使用。</p>
<p>只需要在 Docker Desktop 的界面中选择 setting-resources-WSL integration，选择使能你希望使用 Docker 的 WSL 子系统即可。</p>
<p>在使能之前，输入 <code>docker --version</code> 的结果如下<br><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">wokron@DESKTOP-T1ANVDS:~$ docker --version</span><br><span class="line">Command <span class="string">&#x27;docker&#x27;</span> not found, but can be installed with:</span><br><span class="line">sudo snap install docker         <span class="comment"># version 20.10.17, or</span></span><br><span class="line">sudo apt  install docker.io      <span class="comment"># version 20.10.21-0ubuntu1~22.04.2</span></span><br><span class="line">sudo apt  install podman-docker  <span class="comment"># version 3.4.4+ds1-1ubuntu1</span></span><br><span class="line">See <span class="string">&#x27;snap info docker&#x27;</span> <span class="keyword">for</span> additional versions.</span><br></pre></td></tr></table></figure></p>
<p>而使能之后，同样的输入结果如下<br><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">wokron@DESKTOP-T1ANVDS:~$ docker --version</span><br><span class="line">Docker version 20.10.23, build 7155243</span><br></pre></td></tr></table></figure></p>
<h2 id="六、使用-Docker-运行-MySQL"><a href="#六、使用-Docker-运行-MySQL" class="headerlink" title="六、使用 Docker 运行 MySQL"></a>六、使用 Docker 运行 MySQL</h2><h3 id="（1）Docker-Desktop-的使用"><a href="#（1）Docker-Desktop-的使用" class="headerlink" title="（1）Docker Desktop 的使用"></a>（1）Docker Desktop 的使用</h3><p>我们下载好了 Docker，现在来利用一下。正好后端需要使用数据库，那就用 Docker 来运行 MySQL 吧。</p>
<p>为了方便，这里我们就先使用 Docker Desktop，而不使用 Docker 命令。想要获取 MySQL 镜像，只需要使用最上面的搜索栏搜索一下 mysql。</p>
<p>选择第一个，点击 pull 将镜像从 DockerHub 拉取到本地。没错，Docker 和 Git 类似，也有自己的 Hub，并且 Docker 的一些命令也很有 Git 的味道。</p>
<p>现在我们回到主界面，选择查看镜像，就可以看到 mysql 镜像了。</p>
<h3 id="（2）MySQL-容器的创建"><a href="#（2）MySQL-容器的创建" class="headerlink" title="（2）MySQL 容器的创建"></a>（2）MySQL 容器的创建</h3><p>我们有了镜像，现在需要通过镜像运行容器。这一过程类似于让程序变为运行的进程。</p>
<p>我们需要点击 mysql 项右侧的运行键，之后修改 optional settings，填写容器名、将容器内的 3306 号端口映射到主机的端口上，另外还需要设置一个环境变量 <code>MYSQL_ROOT_PASSWORD=password</code>，这样我们就为 mysql 设置了 root 的初始密码。之后点击 run 即可运行容器。</p>
<p>之后会进入新创建的容器的详细信息页，我们可以从 logs 中看到容器的运行情况，其中显示的就是程序在标准输出上的结果。此时 MySQL 应该还在初始化，因此还不能连接上数据库。等到出现了类似 Plugin ready for connections 之后，才可正常连接数据库。</p>
<p>我们打开一个终端，可以是主机的 CMD、PowerShell 或是 WSL 中的其他 shell，输入命令以连接数据库，注意此时需要输入 <code>MYSQL_ROOT_PASSWORD</code> 对应的密码。<br><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">mysql -h localhost -P 3306 -u root -p</span><br></pre></td></tr></table></figure></p>
<p>之后就成功连接到数据库了。</p>
<h3 id="（3）MySQL-Server-与-Client"><a href="#（3）MySQL-Server-与-Client" class="headerlink" title="（3）MySQL Server 与 Client"></a>（3）MySQL Server 与 Client</h3><p>在输入上一小节中的命令的时候，可能出现类似 command not found 的提示。因此我们还需要在本地安装 MySQL，但是并不是安装 MySQL 的服务器，而只需要安装 MySQL 的客户端，通过客户端连接容器中的 MySQL 服务器。</p>
<p>这里以 Linux 为例，使用 apt 安装 MySQL 客户端<br><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">sudo apt-get mysql-client</span><br></pre></td></tr></table></figure></p>
<p>之后 mysql 命令就可以使用了。<br><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">wokron@DESKTOP-T1ANVDS:~$ mysql --version</span><br><span class="line">mysql  Ver 8.0.32-0ubuntu0.22.04.2 <span class="keyword">for</span> Linux on x86_64 ((Ubuntu))</span><br></pre></td></tr></table></figure></p>
<p>另外我们还希望能够可视化地使用数据库，这就需要用可视化的客户端连接服务器。我们以 Navicat for MySQL 为例。只需要点击左上角<strong>连接</strong>，输入连接需要的信息即可创建连接。但是也可能出现 1251—Client does not support authentication protocol requested by server 的问题。这是客户端和服务器的版本不一致导致的。在 Docker 容器中我们运行的是最新版本的 MySQL，采用了新的加密算法，因此会出现认证错误。</p>
<p>我们要对 MySQL 服务器的配置进行修改。首先通过 <code>docker exec</code> 命令进入终端<br><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">docker <span class="built_in">exec</span> -it &lt;container name&gt; bash</span><br></pre></td></tr></table></figure></p>
<p>进入 mysql<br><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">mysql -u root -p</span><br></pre></td></tr></table></figure></p>
<p>设置 root 的加密规则和密码，并更新设置<br><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">alter user <span class="string">&#x27;root&#x27;</span>@<span class="string">&#x27;%&#x27;</span> identified with mysql_native_password by <span class="string">&#x27;yourpassword&#x27;</span>; </span><br><span class="line">flush privileges;</span><br></pre></td></tr></table></figure></p>
<p>之后， Navicat 就可以正常连接了。</p>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
        <tag>Docker</tag>
        <tag>后端</tag>
        <tag>WSL</tag>
        <tag>Ubuntu</tag>
        <tag>VSCode</tag>
      </tags>
  </entry>
  <entry>
    <title>奇技淫巧——RNN求解常微分方程组</title>
    <url>/posts/961aefad/</url>
    <content><![CDATA[<h2 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h2><p>前一段时间接触常微分方程组拟合的时候，发现了使用 RNN 求解常微分方程组的办法。感觉很有意思，于是记录一下。</p>
<p><strong>参考：</strong></p>
<ul>
<li><a href="https://spaces.ac.cn/archives/5643">貌离神合的RNN与ODE：花式RNN简介</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/104149996">基于RNN的微分方程拟合</a></li>
</ul>
<span id="more"></span>
<h2 id="二、常微分方程组和欧拉法"><a href="#二、常微分方程组和欧拉法" class="headerlink" title="二、常微分方程组和欧拉法"></a>二、常微分方程组和欧拉法</h2><p>所谓常微分方程，指的是只具有单一自变量的微分方程，如假设加速度 $a$ 一定，则速度 $v$ 满足微分方程</p>
<script type="math/tex; mode=display">
  \frac{dv}{dt} = a</script><p>速度 $v$ 只与时间 $t$ 有关，那么该微分方程即常微分方程。与之对应的是偏微分方程，不过不在本文的讨论范围内。</p>
<p>类似的，路程 $s$ 也满足微分方程</p>
<script type="math/tex; mode=display">
  \frac{ds}{dt} = v</script><p>那么关于 $v, s$ 的两个常微分方程就可以组成常微分方程组</p>
<script type="math/tex; mode=display">
  \begin{cases}
    \frac{dv}{dt} = a  \\
    \frac{ds}{dt} = v
  \end{cases}</script><p>虽然上面的方程组很容易求出解析解，但许多常微分方程组却难以找到解析解，甚至解析解根本不存在。这种情况就需要求出数值解。</p>
<p>还举上面那个简单的物理问题为例，我们设 $t$ 时刻速度和路程为 $v_t, s_t$，那么可以令 </p>
<script type="math/tex; mode=display">
  \begin{cases}
    v_{t_m} &= v_{t_{m-1}} + a \Delta t \\
    s_{t_m} &= s_{t_{m-1}} + v_{t_m} \Delta t
  \end{cases}</script><p>其中 $t<em>{m-1} &lt; t</em>{m}, \Delta t = t<em>{m} - t</em>{m-1}$，这样就近似得到了速度和路程随时间变化的数值解。此种方法也是游戏物理引擎中进行运动学模拟的基本方法。因为是欧拉发明的，所以也叫做欧拉法。</p>
<p>更一般的，考虑函数 $y(t)$，有微分方程</p>
<script type="math/tex; mode=display">
  \frac{dy(t)}{dt} = f(y(t), t)</script><p>现在我们希望求得 $y(t)$ 的解析解，即一组点 ${(t_i, y(t_i))}$。</p>
<p>我们对 $y(t)$ 在 $t_m$ 点做泰勒展开，得到</p>
<script type="math/tex; mode=display">
  y(t) = y(t_m) + f(y(t_m), t_m)(t - t_m) + O(t)</script><p>忽略无穷小量 $O(t)$，则 $t = t_{m+1}$ 时的解近似为</p>
<script type="math/tex; mode=display">
  y(t_{m+1}) = y(t_m) + f(y(t_m), t_m) \Delta t</script><p>其中 $\Delta t = t<em>{m+1} - t</em>{m}$，这样我们就得到了一般的求得常微分方程数值解的方法。</p>
<h2 id="三、使用-RNN-表示常微分方程组"><a href="#三、使用-RNN-表示常微分方程组" class="headerlink" title="三、使用 RNN 表示常微分方程组"></a>三、使用 RNN 表示常微分方程组</h2><p>RNN 就是深度学习里的循环神经网络，具体概念就不介绍了。RNN 可以表示成如下的数学形式</p>
<script type="math/tex; mode=display">
  y_t = g(y_{t-1}, x_t, t)</script><p>我们可以对上一小节中得到的欧拉法方程做改造，令 $\forall m, t<em>{m+1} = t</em>{m} + 1$，那么原式可以改写为</p>
<script type="math/tex; mode=display">
  y_t = y_{t-1} + f(y_{t-1}, t-1)</script><p>因为等式右侧是关于 $y<em>{t-1}$ 和 $t$ 的表达式，所以可以令 $g(y</em>{t-1}, x<em>t, t) = y</em>{t-1} + f(y_{t-1}, t-1)$。</p>
<p>这样我们的 RNN 就等同于欧拉法了，因此同样可以用于常微分方程组的求解。</p>
<h2 id="四、RNN-求解常微分方程组"><a href="#四、RNN-求解常微分方程组" class="headerlink" title="四、RNN 求解常微分方程组"></a>四、RNN 求解常微分方程组</h2><p>我们考虑这样一个传染病模型</p>
<p>人群分为易感者、暴露者、患病者、康复者、死者五类人群。考虑<strong>潜伏期</strong>、<strong>重复感染</strong>和<strong>死亡</strong>的情况。</p>
<p>总人数为 $N$，$t$ 时刻各类人群数量为 $S, E, I, R, D$。设 $\beta$ 为日接触率，$\sigma$ 为日发病率，$\gamma$ 为日治愈率，$\alpha$ 为日死亡率，$\omega$ 为日免疫消失率。则 $S, E, I, R, D$ 满足如下方程组</p>
<script type="math/tex; mode=display">
    \begin{cases}
    \frac{dS}{dt} &= \omega R - \beta \frac{IS}{N} \\
    \frac{dE}{dt} &= \beta \frac{IS}{N} - \sigma E \\
    \frac{dI}{dt} &= \sigma E - \gamma I - \alpha I \\
    \frac{dR}{dt} &= \gamma I - \omega R \\
    \frac{dD}{dt} &= \alpha I \\
    N &= S + E + I + R + D
    \end{cases}</script><p>似乎很是复杂……我们现在就要用 RNN 求解该常微分方程组。</p>
<blockquote>
<p>这是我在数学建模作业中用到的模型，也是为了求解该模型，才了解到 RNN 求解常微分方程的方法的。</p>
</blockquote>
<p>现在让我们用 pytorch 建立该微分方程的网络模型 <code>SEIRSD</code>。在初始化函数中需要设定 <code>weights</code> 用来表示参数 $\beta, \sigma, \gamma, \alpha, \omega$。<br><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SEIRSD</span>(nn.Module):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, steps, h, params</span>):</span><br><span class="line">        <span class="built_in">super</span>().__init__()</span><br><span class="line">        self.steps = steps</span><br><span class="line">        self.h = h</span><br><span class="line"></span><br><span class="line">        <span class="comment"># beta, sigma, gamma, alpha, omega</span></span><br><span class="line">        self.weights = nn.Parameter(</span><br><span class="line">            params,</span><br><span class="line">            requires_grad=<span class="literal">True</span>,</span><br><span class="line">        )</span><br></pre></td></tr></table></figure></p>
<p>随后编写前向传播函数，该函数传入初始值 $y_0$，输出 <code>steps</code> 步数内的所有 $y_i$ 值，这里 $y$ 是向量 $[S, E, I, R, D]$<br><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, init</span>):</span><br><span class="line">    state = init  <span class="comment"># (5)</span></span><br><span class="line">    states = []</span><br><span class="line">    <span class="keyword">for</span> step <span class="keyword">in</span> <span class="built_in">range</span>(self.steps):</span><br><span class="line">        state = self.step_do(state)  <span class="comment"># (5)</span></span><br><span class="line">        states.append(state)</span><br><span class="line"></span><br><span class="line">    states = torch.stack(states, dim=<span class="number">0</span>)  <span class="comment"># (step, 5)</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> states</span><br></pre></td></tr></table></figure></p>
<p>其中用到了函数 <code>step_do</code> 用于计算每一步的状态。这里我们使用欧拉法，根据微分方程组计算 $g(y_{t-1}, x_t, t)$ 的结果并更新，求得下一个时间步的状态。<br><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">step_do</span>(<span class="params">self, state</span>):</span><br><span class="line">    x = state  <span class="comment"># (5) -&gt; S, E, I, R, D</span></span><br><span class="line">    beta, sigma, gamma, alpha, omega = (</span><br><span class="line">        self.weights[<span class="number">0</span>], self.weights[<span class="number">1</span>], self.weights[<span class="number">2</span>],</span><br><span class="line">        self.weights[<span class="number">3</span>], self.weights[<span class="number">4</span>]</span><br><span class="line">    )</span><br><span class="line">    S, E, I, R, D = x</span><br><span class="line">    N = x.<span class="built_in">sum</span>()</span><br><span class="line"></span><br><span class="line">    dS = omega * R - beta * (I * S) / N</span><br><span class="line">    dE = beta * (I * S) / N - sigma * E</span><br><span class="line">    dI = sigma * E - gamma * I - alpha * I</span><br><span class="line">    dR = gamma * I - omega * R</span><br><span class="line">    dD = alpha * I</span><br><span class="line"></span><br><span class="line">    dS = dS.reshape(<span class="number">1</span>)</span><br><span class="line">    dE = dE.reshape(<span class="number">1</span>)</span><br><span class="line">    dI = dI.reshape(<span class="number">1</span>)</span><br><span class="line">    dR = dR.reshape(<span class="number">1</span>)</span><br><span class="line">    dD = dD.reshape(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    dx = torch.cat((dS, dE, dI, dR, dD), dim=<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">    step_state = x + self.h * torch.clamp(dx, -<span class="number">1e5</span>, <span class="number">1e5</span>)  <span class="comment"># (5)</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> step_state</span><br></pre></td></tr></table></figure></p>
<p>之后我们定义函数 <code>odeint</code> 用于计算常微分方程组，<br><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">odeint</span>(<span class="params">y0, steps, params</span>):</span><br><span class="line">    model = SEIRSD(steps, <span class="number">1</span>, params).to(device)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">with</span> torch.no_grad():</span><br><span class="line">        result = model(y0)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result.numpy()</span><br></pre></td></tr></table></figure></p>
<p>设定初始状态</p>
<script type="math/tex; mode=display">
\begin{align*}
  y_0 =& [100000, 10, 0, 0, 0] \\
  \beta =& 1 \\
  \sigma =& 0.4 \\
  \gamma =& 0.4 \\
  \alpha =& 0.001 \\
  \omega =& 0.01
\end{align*}</script><p>求解常微分方程组，并画出图像<br><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    y0 = torch.tensor([<span class="number">100000</span>, <span class="number">10</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>])</span><br><span class="line">    steps = <span class="number">365</span></span><br><span class="line">    params = torch.tensor([<span class="number">1</span>, <span class="number">0.4</span>, <span class="number">0.4</span>, <span class="number">0.001</span>, <span class="number">0.01</span>])</span><br><span class="line"></span><br><span class="line">    result = odeint(y0, steps, params)</span><br><span class="line"></span><br><span class="line">    steps = np.arange(<span class="number">365</span>)</span><br><span class="line">    plt.plot(steps, result[:, <span class="number">0</span>], label=<span class="string">&quot;S&quot;</span>)</span><br><span class="line">    plt.plot(steps, result[:, <span class="number">1</span>], label=<span class="string">&quot;E&quot;</span>)</span><br><span class="line">    plt.plot(steps, result[:, <span class="number">2</span>], label=<span class="string">&quot;I&quot;</span>)</span><br><span class="line">    plt.plot(steps, result[:, <span class="number">3</span>], label=<span class="string">&quot;R&quot;</span>)</span><br><span class="line">    plt.plot(steps, result[:, <span class="number">4</span>], label=<span class="string">&quot;D&quot;</span>)</span><br><span class="line">    plt.legend()</span><br><span class="line">    plt.show()</span><br></pre></td></tr></table></figure></p>
<img src="/posts/961aefad/rnnint.png" class="" title="rnnint">
<p>另外我们使用 scipy 库同样求解该微分方程组<br><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">ode</span>(<span class="params">ini, t, beta, sigma, gamma, alpha, omega</span>):</span><br><span class="line">    N = ini.<span class="built_in">sum</span>()</span><br><span class="line">    S, E, I, R, D = ini</span><br><span class="line">    dS = omega * R - beta * I * S / N</span><br><span class="line">    dE = beta * I * S / N - sigma * E</span><br><span class="line">    dI = sigma * E - gamma * I - alpha * I</span><br><span class="line">    dR = gamma * I - omega * R</span><br><span class="line">    dD = alpha * I</span><br><span class="line">    <span class="keyword">return</span> [dS, dE, dI, dR, dD]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">beta = <span class="number">1</span></span><br><span class="line">sigma = <span class="number">0.4</span></span><br><span class="line">gamma = <span class="number">0.4</span></span><br><span class="line">alpha = <span class="number">0.001</span></span><br><span class="line">omega = <span class="number">0.01</span></span><br><span class="line">t = np.linspace(<span class="number">0</span>, <span class="number">360</span>, <span class="number">360</span>)</span><br><span class="line">result = odeint(ode, y0=[<span class="number">100000</span>, <span class="number">10</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>], t=t, args=(beta, sigma, gamma, alpha, omega))</span><br><span class="line"><span class="comment"># print(result[:, 0])</span></span><br><span class="line">plt.plot(t, result[:, <span class="number">0</span>], label=<span class="string">&#x27;S&#x27;</span>)</span><br><span class="line">plt.plot(t, result[:, <span class="number">1</span>], label=<span class="string">&#x27;E&#x27;</span>)</span><br><span class="line">plt.plot(t, result[:, <span class="number">2</span>], label=<span class="string">&#x27;I&#x27;</span>)</span><br><span class="line">plt.plot(t, result[:, <span class="number">3</span>], label=<span class="string">&#x27;R&#x27;</span>)</span><br><span class="line">plt.plot(t, result[:, <span class="number">4</span>], label=<span class="string">&#x27;D&#x27;</span>)</span><br><span class="line">plt.legend()</span><br><span class="line">plt.show()</span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<p>得到的图像如下所示<br><img src="/posts/961aefad/odeint.png" class="" title="odeint"></p>
<p>可以看出两者差别不大。当然 scipy 中的 <code>odeint</code> 函数采用了精度更高的 lsoda 算法，得到的图像应该更加准确。</p>
<h2 id="五、RNN-拟合常微分方程组"><a href="#五、RNN-拟合常微分方程组" class="headerlink" title="五、RNN 拟合常微分方程组"></a>五、RNN 拟合常微分方程组</h2><p>RNN 在常微分方程组中的作用不至于求出数值解而已，如果只是根据提供的参数进行计算的话，不使用 pytorch 也可以实现欧拉法。然而不要忘了深度学习中的反向传播这样一个利器。对于 RNN，我们能做到的是根据提供的数据进行拟合，反向得到可能的参数。</p>
<p>首先我们创建要进行拟合的数据集<br><figure class="highlight py"><table><tr><td class="code"><pre><span class="line">beta = <span class="number">1</span></span><br><span class="line">sigma = <span class="number">0.4</span></span><br><span class="line">gamma = <span class="number">0.4</span></span><br><span class="line">alpha = <span class="number">0.001</span></span><br><span class="line">omega = <span class="number">0.01</span></span><br><span class="line">t = np.linspace(<span class="number">0</span>, <span class="number">360</span>, <span class="number">360</span>)</span><br><span class="line">result = odeint(ode, y0=[<span class="number">100000</span>, <span class="number">10</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>], t=t, args=(beta, sigma, gamma, alpha, omega))</span><br><span class="line">np.save(<span class="string">&quot;./data.npy&quot;</span>, result)</span><br></pre></td></tr></table></figure></p>
<p>接着编写模型的训练代码。设定初始参数为 <code>[5, 0.5, 0.5, 0.05, 0.05]</code>，训练步数 2000 步。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">device = torch.device(<span class="string">&#x27;cuda&#x27;</span> <span class="keyword">if</span> torch.cuda.is_available() <span class="keyword">else</span> <span class="string">&#x27;cpu&#x27;</span>)</span><br><span class="line"></span><br><span class="line">writer = SummaryWriter(<span class="string">&quot;/content/logs&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    y0 = torch.tensor([<span class="number">100000</span>, <span class="number">10</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>]).to(device)</span><br><span class="line">    steps = <span class="number">360</span></span><br><span class="line"></span><br><span class="line">    target = torch.tensor(np.load(<span class="string">&quot;data.npy&quot;</span>), dtype=torch.<span class="built_in">float</span>).to(device) </span><br><span class="line"></span><br><span class="line">    criterion = torch.nn.MSELoss().to(device)</span><br><span class="line">    model = SEIRSD(steps, <span class="number">1</span>, torch.tensor([<span class="number">5</span>, <span class="number">0.5</span>, <span class="number">0.5</span>, <span class="number">0.05</span>, <span class="number">0.05</span>], dtype=torch.<span class="built_in">float</span>).to(device)).to(device)</span><br><span class="line">    optimizer = Adam(model.parameters(), lr=<span class="number">8e-3</span>)</span><br><span class="line"></span><br><span class="line">    bar = tqdm(<span class="built_in">range</span>(<span class="number">2000</span>))</span><br><span class="line">    <span class="keyword">for</span> epoch <span class="keyword">in</span> bar:</span><br><span class="line">        outputs = model(y0)</span><br><span class="line">        loss = criterion(outputs, target)</span><br><span class="line"></span><br><span class="line">        optimizer.zero_grad()</span><br><span class="line">        loss.backward()</span><br><span class="line">        optimizer.step()</span><br><span class="line"></span><br><span class="line">        bar.set_postfix(loss=loss.item(), weights=model.weights.data)</span><br><span class="line">        writer.add_scalar(<span class="string">&quot;train loss&quot;</span>, loss.item(), epoch)</span><br><span class="line">        <span class="keyword">if</span> epoch % <span class="number">100</span> == <span class="number">0</span>:</span><br><span class="line">            torch.save(model.state_dict(), <span class="string">f&quot;/content/checkpoints/checkpoint<span class="subst">&#123;<span class="built_in">int</span>(epoch / <span class="number">1000</span>)&#125;</span>.pth&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>进行训练，损失不断下降<br><img src="/posts/961aefad/loss.png" class="" title="loss"></p>
<p>得到训练后的参数为</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>$\beta$</th>
<th>$\sigma$</th>
<th>$ \gamma$</th>
<th>$ \alpha$</th>
<th>$ \omega$</th>
</tr>
</thead>
<tbody>
<tr>
<td>3.4432e+00</td>
<td>2.2585e-01</td>
<td>1.3888e+00</td>
<td>1.9691e-03</td>
<td>1.0094e-02</td>
</tr>
</tbody>
</table>
</div>
<p>得到的参数似乎和我们最初设定的参数不同，但是如果我们画出图像，就会发现该参数对应的图像同样反映了真实数据的变化趋势，有效地拟合了数据<br><img src="/posts/961aefad/predict.png" class="" title="predict"></p>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>RNN</tag>
        <tag>ODE</tag>
      </tags>
  </entry>
  <entry>
    <title>对不重复随机数的数学分析</title>
    <url>/posts/f44f8530/</url>
    <content><![CDATA[<h2 id="一、引子——双色球"><a href="#一、引子——双色球" class="headerlink" title="一、引子——双色球"></a>一、引子——双色球</h2><p>我们知道，双色球每注投注号码由 6 个红色球号码和 1 个蓝色球号码组成。红色球号码从 1—33 中选择；蓝色球号码从 1—16 中选择。现在要求写出一个程序，模拟双色球的抽奖过程。</p>
<p>我们很容易想到使用某种方法生成一定范围内的随机数。蓝色球很好解决，但对于红色球，需要的是随机生成 6 个号码不同的数，可一定范围内的随机数总可能出现相同的情况，这样要如何解决？</p>
<p>也就是说：对于 $1, 2, …, m$ 这 m 个数字，随机抽取其中 $n(n \lt m)$ 个数。要采取怎样的算法？</p>
<h2 id="二、两种思路"><a href="#二、两种思路" class="headerlink" title="二、两种思路"></a>二、两种思路</h2><h3 id="其一-暴力方法"><a href="#其一-暴力方法" class="headerlink" title="其一 : 暴力方法"></a>其一 : 暴力方法</h3><p>的确，随机数总有可能出现相同的情况，但是我们知道，同一个数多次出现的概率很小，以至于我们可以将其忽略。因此，我们只需要不断地取范围内的随机数，遇到重复的舍弃，直到取得的数字数目达到 n 即可。<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">rand1</span><span class="params">(<span class="type">int</span> m, <span class="type">int</span> n, <span class="type">int</span> rands[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span>* hasSelect = <span class="built_in">calloc</span>(m+<span class="number">1</span>, <span class="keyword">sizeof</span>(<span class="type">char</span>));</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> r = randomInt(<span class="number">1</span>, m);</span><br><span class="line">        <span class="keyword">if</span> (!hasSelect[r])</span><br><span class="line">        &#123;</span><br><span class="line">            rands[i++] = r;</span><br><span class="line">            hasSelect[r] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(hasSelect);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>但这种算法是有缺陷的。问题在于，概率达到多小才算作可以忽略？<br>考虑 $m=100, n=99$ 的情况。首先，取得第一个球，一定只需要选取 1 次；但是，我们再计算一下取得最后一个球的选取次数。为了取得第 99 个数，选中的概率为 $p_{99} = \frac{1}{50}$。我们设离散型随机变量 $X$ 表示为了取得第 99 个数所需的选取次数，则 $P{X = k} = (1-p)^{k-1}p$ 服从几何分布。因此 $E(X) = \frac{1}{p} = 50$。从期望上看，需要整整 50 次才能取到第 99 个数！！这中间的差距说明了，在 m 一定时，随着 n 的增大，随机的效率明显降低。</p>
<h3 id="其二-洗牌算法"><a href="#其二-洗牌算法" class="headerlink" title="其二 : 洗牌算法"></a>其二 : 洗牌算法</h3><p>还从双色球这一实际问题来看，我们要从 33 个球中取得 6 个球，实际上是从球的一个随机排列中取得前 6 个球。这样，我们的问题就等价于找到一种将序列打乱顺序，使每一个数在每一个位置的概率相等的算法。</p>
<p>这里介绍 Knuth 的洗牌算法，如下：</p>
<blockquote>
<p>在整个数组 [0, n-1] 中（包括最后一个元素）随机选出一个元素，将它和最后那个元素 [n-1] 交换，然后再在数组 [0, n-2] 中随机选出一个元素，将它与倒数第二个元素 [n-2] 交换…一直到最后一个元素。</p>
</blockquote>
<p>洗牌之后，我们再取前 n 个数，就求得了 n 个不重复随机数。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">rand2</span><span class="params">(<span class="type">int</span> m, <span class="type">int</span> n, <span class="type">int</span> rands[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span>* nums = <span class="built_in">calloc</span>(m, <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++)</span><br><span class="line">        nums[i] = i+<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = m<span class="number">-1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> j = randomInt(<span class="number">0</span>, i);</span><br><span class="line">        <span class="type">int</span> tmp = nums[i];</span><br><span class="line">        nums[i] = nums[j];</span><br><span class="line">        nums[j] = tmp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        rands[i] = nums[i];</span><br><span class="line">    <span class="built_in">free</span>(nums);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从直觉上看，这种算法的用时是与 n 无关的。在 n 足够小时，暴力方法的用时会小于该算法。我们需要对着两种方法进一步分析，以做权衡。</p>
<h2 id="三、数学上的分析"><a href="#三、数学上的分析" class="headerlink" title="三、数学上的分析"></a>三、数学上的分析</h2><p>我们首先需要解决的问题是，对于序列 $1, 2, …, m$ 我们随机放回抽取，求当取得 n 个不同的数时所用次数的数学期望。</p>
<p>我们设随机变量 $X<em>i$ 表示已经取到了 $i-1$ 个不同的数后，还需要多少次才能取到第 $i$ 个不同的数。并设随机变量 $T_n$ 表示取得 n 个不同的数所需要的总次数，即 $T_n = \sum</em>{i=1}^n X_i$。</p>
<p>在已经取得 $i-1$ 个不同的数的条件下，取一次，不属于已经取到过的数的概率为</p>
<script type="math/tex; mode=display">
    p_i = \frac{m-i+1}{m}</script><p>因 $X<em>i$ 服从几何分布, $P{X_i = k} = (1-p_i)^{k-1}p</em>{i}$ 则有</p>
<script type="math/tex; mode=display">
    EX_i = \sum_{k=1}^{\infty} k (1-p_{i})^{k-1}p_{i}
    = -p_{i}[\sum_{k=1}^{\infty} (1-p_{i})^{k}]^{'}
    = \frac{1}{p_i} = \frac{m}{m-i+1}</script><p>又因随机变量序列 ${X_n}$ 相互独立，则</p>
<script type="math/tex; mode=display">
    ET_n = E(\sum_{i=1}^n X_i) = \sum_{i=1}^nEX_i
    = m \sum_{i=1}^n \frac{1}{m-i+1}
    = m(\sum_{i=1}^m \frac{1}{i} - \sum_{i=1}^{m-n} \frac{1}{i})</script><p>即</p>
<script type="math/tex; mode=display">
    ET_n = m(\sum_{i=1}^m \frac{1}{i} - \sum_{i=1}^{m-n} \frac{1}{i})
    = m(H_m - H_{m-n})</script><p>其中 $H<em>m, H</em>{m-n}$ 分别表示第 m，m-n 个调和数（Harmonic number）。</p>
<p>又因 </p>
<script type="math/tex; mode=display">
    H_n = \ln(n) + \gamma + \frac{1}{2} + O(\frac{1}{n}) \\
    \gamma \approx 0.57721 56649</script><p>则</p>
<script type="math/tex; mode=display">
    ET_n = -m \ln({1-\frac{n}{m}}) + O(\frac{1}{m})</script><blockquote>
<p>由上式可知，$n \ll m$ 时，$ET_n \approx 0$。这是符合直觉的。但 $m =n$ 的情况却并不满足上式子，因为并不存在 $H_0$。 $m=n$ 时的公式应为</p>
<script type="math/tex; mode=display">
    ET_n = mH_m = m\ln(m) + \gamma + \frac{1}{2} + O(\frac{1}{m})</script></blockquote>
<p>此暴力算法的时间复杂度为 $O(-m\log(1-\frac{n}{m}))$ （认为 n 会小于 m）。</p>
<p>而对于洗牌算法，其时间复杂度为 $O(m)$。</p>
<p>要使第一种算法用时少于第二种，则需要</p>
<script type="math/tex; mode=display">
    -m\log(1-\frac{n}{m}) \lt m</script><p>得</p>
<script type="math/tex; mode=display">
    n \lt (1-\frac{1}{e})m \approx 0.632m</script><p>可见在一些情况下，暴力算法能取得很好的效果。但在 $n \ge 0.632m$ 的时候，或许采用洗牌算法效率更高。</p>
<blockquote>
<p>当然，由于第二种算法的系数更高，所以实践中的情况会更为复杂。</p>
</blockquote>
<h2 id="四、代码"><a href="#四、代码" class="headerlink" title="四、代码"></a>四、代码</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">randomInt</span><span class="params">(<span class="type">int</span> from, <span class="type">int</span> to)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> rand() % (to - from + <span class="number">1</span>) + from;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">rand1</span><span class="params">(<span class="type">int</span> m, <span class="type">int</span> n, <span class="type">int</span> rands[])</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">rand2</span><span class="params">(<span class="type">int</span> m, <span class="type">int</span> n, <span class="type">int</span> rands[])</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    srand(time(<span class="number">0</span>));</span><br><span class="line">    <span class="type">int</span> n = <span class="number">5</span>;</span><br><span class="line">    <span class="type">int</span> rands[<span class="number">10</span>];</span><br><span class="line">    rand1(<span class="number">10</span>, n, rands);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, rands[i]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    rand1(<span class="number">10</span>, n, rands);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, rands[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">rand1</span><span class="params">(<span class="type">int</span> m, <span class="type">int</span> n, <span class="type">int</span> rands[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span>* hasSelect = <span class="built_in">calloc</span>(m+<span class="number">1</span>, <span class="keyword">sizeof</span>(<span class="type">char</span>));</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> r = randomInt(<span class="number">1</span>, m);</span><br><span class="line">        <span class="keyword">if</span> (!hasSelect[r])</span><br><span class="line">        &#123;</span><br><span class="line">            rands[i++] = r;</span><br><span class="line">            hasSelect[r] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(hasSelect);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">rand2</span><span class="params">(<span class="type">int</span> m, <span class="type">int</span> n, <span class="type">int</span> rands[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span>* nums = <span class="built_in">calloc</span>(m, <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++)</span><br><span class="line">        nums[i] = i+<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = m<span class="number">-1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> j = randomInt(<span class="number">0</span>, i);</span><br><span class="line">        <span class="type">int</span> tmp = nums[i];</span><br><span class="line">        nums[i] = nums[j];</span><br><span class="line">        nums[j] = tmp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        rands[i] = nums[i];</span><br><span class="line">    <span class="built_in">free</span>(nums);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title>机器学习nlp基本知识</title>
    <url>/posts/b2ab0f69/</url>
    <content><![CDATA[<h2 id="一、自然语言处理（nlp）简介"><a href="#一、自然语言处理（nlp）简介" class="headerlink" title="一、自然语言处理（nlp）简介"></a>一、自然语言处理（nlp）简介</h2><p><strong>一份思绪奔驰的前言：</strong><br>语言的边界就是思想的边界。如果从人类所具有的一切中挑出一个事物，让它来显示出人与其他生物的不同之处，那一定是语言。语言是我们用来思考和交流的方式，我们的一切文明都构筑在这简单的一维序列中，可我们却几乎不曾深入了解过它。</p>
<p>有人说，我们不曾真正的理解语言，我们所有对语言的运用和理解，不过建立在婴儿及此后对他人的声音与书本上符号的猜测上。或许正是如此，但是我们依旧要做出猜测，向着语言的神秘进发，这是我们的信念，是我们认识我们的认识的开始。</p>
<h3 id="（1）作为语言学的-nlp"><a href="#（1）作为语言学的-nlp" class="headerlink" title="（1）作为语言学的 nlp"></a>（1）作为语言学的 nlp</h3><p>早在计算机的上古时代，深度学习还未诞生的时候，自然语言处理作为语言学的一个领域就已诞生了，这个领域也被语言学家们称为计算机语言学。两个名称在一起，才表达出 nlp 的真正含义——通过机器处理语言。nlp 最早的研究方向是机器翻译，那时人们人为地总结语言的规律，对词汇进行标注，对语句进行句法分析。结果是人为的规则覆盖面不足，所设计的系统无法扩展。</p>
<h3 id="（2）作为机器学习研究领域的-nlp"><a href="#（2）作为机器学习研究领域的-nlp" class="headerlink" title="（2）作为机器学习研究领域的 nlp"></a>（2）作为机器学习研究领域的 nlp</h3><p>随着计算机的发展，出现了基于传统统计学习模型的自然语言处理方式。这些原始的模型较之之前有所进步，但受限于计算机性能，统计方法也遭遇了瓶颈。</p>
<p>直到近年来算力的发展，使得深度神经网络成为可能。深度神经网络结构中潜在的学习能力，在 nlp 领域发挥了作用。通过多维数据表示语言和含义，深度学习以高效且与人类认知过程相似的方式发挥了巨大的效果。</p>
<h2 id="二、词向量"><a href="#二、词向量" class="headerlink" title="二、词向量"></a>二、词向量</h2><p>词汇作为符号，其形象是离散的；但词汇的所指作为定义，其含义却是丰富而连续的。比如说“母亲”这个词汇，既表示了这个概念所对应的事物是在一种血缘关系中的一方（她是孩子的母亲）；又表示了这个事物是能繁殖者（母鸡）；在一定程度上，同样表示了非血缘关系，但具有类似血缘关系的行为的个体（大地是母亲）。</p>
<blockquote>
<p>偏个题，《来自深渊》中有对生骸语的类似的描述.</p>
</blockquote>
<p>因此，我们就不能再将词汇只作为离散的符号看待了，不能认为词汇之间是相互排斥的关系了。我们需要将词汇看做某些元含义在不同程度下的集合，或者从机器学习的角度，把这些元含义称作特征。那么也就是说，我们将每个词汇都看成一定维度的向量。</p>
<p>但是我们要如何确定特征呢？特征的数量又有多少？如果人工地确定特征为“存在、含义、物质、精神”等等，这一过程将耗费精力且永无止境。实际上按照机器学习的一般策略，我们只需要通过统计文本，自发的构建词汇向量即可。</p>
<p>这一方面有许多算法，如 N-gram 算法，GloVe 算法等等。另外也可以在深度学习的过程中利用反向传播自发的调整词向量，在 pytorch 中这通过 Embedding 层来实现。</p>
<h2 id="三、循环神经网络（RNN）及其变体"><a href="#三、循环神经网络（RNN）及其变体" class="headerlink" title="三、循环神经网络（RNN）及其变体"></a>三、循环神经网络（RNN）及其变体</h2><h3 id="（1）朴素-RNN"><a href="#（1）朴素-RNN" class="headerlink" title="（1）朴素 RNN"></a>（1）朴素 RNN</h3><p>考虑我们说话或写作时的基本逻辑。对于一段语言序列，在之后的词汇总是和之前的词汇有关，未表达的部分总是已表达部分的补全或补充。循环神经网络的机制类似，我们需要用一个或多个隐藏变量作为对之前语句含义的表示，在输出下一个词汇时，会让隐藏变量参与决策；同时每多说完一个词汇，这个词汇也会更新隐藏变量，以实现表达含义的更新。</p>
<p>具体来说，我们用 $t$ 表示时间序列，对某一时间 $t$，$x_t$ 表示输入，$y_t$ 表示输出，$h_t$ 表示隐含状态。那么朴素的 RNN 网络即：</p>
<script type="math/tex; mode=display">
    h_t = tanh(W^{(hx)} x_t + W^{(hh)} h_{t-1})</script><script type="math/tex; mode=display">
    y_t = W^{(S)} h_t</script><blockquote>
<p>容易看出 RNN 和 Moore 自动机有相似之处。</p>
</blockquote>
<p>其中 $W^{(hx)}, W^{(hh)}, W^{(S)} h_t$ 分别为三个不同的矩阵。RNN 的激活函数也可以选择 <code>ReLU</code>。同时可以为激活函数中的部分添加偏置（bias）$b^{(hx)}, b^{(hh)}$ 等。</p>
<h3 id="（2）GRU"><a href="#（2）GRU" class="headerlink" title="（2）GRU"></a>（2）GRU</h3><p>但是简单的 RNN 也存在着问题，那就是其结构不能很好地控制对不同词汇的关注程度以及当前内容和上文的关系。我们希望设计一种机制，在 RNN 的基础上做到对上下文关系的更好掌握。其中一种机制就是 GRU（Gate Recurrent Unit，门循环单元），它是对 RNN 的推广。</p>
<p>首先我们定义运算符 $\circ$，$k \circ M$，其中 $k$ 为数字 $M$ 为矩阵，表示对 $M$ 中每个元素均乘以 $k$。</p>
<p>那么对某一时间 $t$，$x_t$ 表示输入，$h_t$ 表示隐含状态，我们定义更新门 $z_t$ 和重置门 $r_t$</p>
<script type="math/tex; mode=display">
    z_t = \sigma (W^{(z)} x_t + U^{(z)} h_{t-1})</script><script type="math/tex; mode=display">
    r_t = \sigma (W^{(r)} x_t + U^{(r)} h_{t-1})</script><p>再令</p>
<script type="math/tex; mode=display">
    \tilde{h}_t = tanh (W x_t + r_t \circ U h_{t-1})</script><script type="math/tex; mode=display">
    h_t = z_t \circ h_{t-1} + (1 - z_t) \circ \tilde{h}_t</script><p>我们就定义了隐含状态的更新方式，求输出的方式与 RNN 相同。</p>
<p>所以 GRU 到底做了什么呢？GRU 实际上等同于在 RNN 上增加了两个连续的开关 $z<em>t$ 和 $r_t$。注意这两个变量由 Sigmoid 函数得到，他们的范围是 0~1。我们可以令 $z_t = 0, r_t = 1$，此时就有 $h_t = tanh (W x_t + U h</em>{t-1})$，这与 RNN 中相同。</p>
<p>与 RNN 相比，我们在学习过程中多训练了两个开关。它们的取值暗示了语句中的某些结构。直观上讲，重置门 $r_t$ 反映了当前词汇与上文含义之间的关系和相互作用，当 $r_t = 0$ 时，当前词汇的含义不会受到上文意思的影响。而更新门 $z_t$ 则反映了当前词汇对整体语义的影响，当 $z_t = 0$ 时，更新后的语义将只与当前词汇的意思有关。</p>
<p>更简单来说：</p>
<ul>
<li>$r_t$ 反映了上文对当前词汇的作用程度（如 “你妈” 的意思受到语境的影响）</li>
<li>$z_t$ 反映了当前词汇对整体语义的影响程度（如词汇 “但是” 之后的部分更能反映整体语义）</li>
</ul>
<h3 id="（3）LSTM"><a href="#（3）LSTM" class="headerlink" title="（3）LSTM"></a>（3）LSTM</h3><p>我们还可以对 RNN 模型做相似但不同的改动，形成 LSTM （Long Short-Term Memory，长<strong>短期</strong>记忆）模型，这将使模型更加复杂，但同时也使得对前文语义的记忆得以更加长久的保存。</p>
<p>与 GRU 类似，首先我们定义三个门，分别是输入门 $i_t$，遗忘门 $f_t$ 和输出门 $o_t$。</p>
<script type="math/tex; mode=display">
    i_t = \sigma (W^{(i)} x_t + U^{(i)} h_{t-1})</script><script type="math/tex; mode=display">
    f_t = \sigma (W^{(f)} x_t + U^{(f)} h_{t-1})</script><script type="math/tex; mode=display">
    o_t = \sigma (W^{(o)} x_t + U^{(o)} h_{t-1})</script><p>再定义记忆格（memory cell，或记忆细胞？）$c_t$，计算方式为</p>
<script type="math/tex; mode=display">
    \tilde{c}_t = tanh(W^{(c)}  x_t + U^{(c)} h_{t-1})</script><script type="math/tex; mode=display">
    c_t = f_t \circ c_{t-1} + i_t \circ \tilde{c}_t</script><p>最后定义隐藏状态</p>
<script type="math/tex; mode=display">
    h_t = o_t \circ tanh(c_t)</script><p>LSTM 的特点是采用了两个隐藏状态 $c_t$ 和 $h_t$。从直觉上、或哲学上讲，这反映了两种不同的意义。一是作为表层的，被表达出来的语句的语义；另一是作为深层的，作为记忆的整体的意味。当我们在诉说或理解时，我们首先所接触到的是作为连续序列的语义，这一浅表的概念为了被更深入的理解，它就进入到记忆的层次，并再次从其中返回，在记忆上留下痕迹的同时带来新的表达并言说或写作下来。因此，我们可以将各个门理解为：</p>
<ul>
<li>输入门反映了新的词汇对记忆的影响</li>
<li>遗忘门反映了旧的记忆在语言环境的更新下被抛弃的程度</li>
<li>输出门反映了由记忆到能言说的语言的转变的过程。</li>
</ul>
<p>从这一模型中似乎也能体会出流利但没有内涵的口才与深思熟虑的话语间的差别。</p>
<h3 id="（4）注意力机制"><a href="#（4）注意力机制" class="headerlink" title="（4）注意力机制"></a>（4）注意力机制</h3><p>我们试图让模型拥有更长的记忆，但是不管什么模型，应用什么样的隐藏状态，能存储的信息终归是有限的。只要时间序列足够长，总归会忘记最开始的内容。</p>
<p>注意力机制能够解决这一问题。它的想法是，既然当下的隐藏状态中不包含对很久之前内容的记忆，那我只要选择包含之前内容的隐藏状态不就可以了吗？但是为了保持模型的可微性，我们不能仅仅离散的选择一些包含需要的内容的前面的隐藏状态，而是按照一定方法依据权重，选择在此之前的所有的隐藏状态。</p>
<blockquote>
<p>这实际上形成了一种类似于内存访问的机制。只不过内存是离散的地址和数据，而注意力机制却是连续的“地址”和“数据”。也有依照这一对应关系进一步推广的研究，如神经图灵机，但在此不做赘述。</p>
</blockquote>
<p>注意力机制本身的实现如下。首先我们要以前一个隐藏状态 $h_{t-1}$ 作为评价其他更早的隐藏状态 $\overline{h}_s$ 的基准。对每一个 $\overline{h}_s$ 实施评价函数</p>
<script type="math/tex; mode=display">
    score(h_{t-1}, \overline{h}_s)</script><p>接着运用 softmax 函数获取百分比权重</p>
<script type="math/tex; mode=display">
    a_t(s) = \frac{e^{score(s)}}{\sum_{s'}score(s')}</script><p>然后按照权重对隐藏状态进行合成即可。</p>
<script type="math/tex; mode=display">
    c_t = \sum_s a_t(s) \overline{h}_s</script><p>对于评价函数，可以有多种选择，其中比较好的一种为</p>
<script type="math/tex; mode=display">
    score(h_{t-1}, \overline{h}_s) = h_t^T W_a \overline{h}_s</script><p>$W_a$ 也可以在训练的过程中不断学习优化。</p>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>AI</tag>
        <tag>机器学习</tag>
        <tag>nlp</tag>
      </tags>
  </entry>
  <entry>
    <title>机器学习之决策树</title>
    <url>/posts/55036469/</url>
    <content><![CDATA[<h2 id="一、引言"><a href="#一、引言" class="headerlink" title="一、引言"></a>一、引言</h2><p>决策树是另一种十分有效的机器学习模型。该模型采取树状分支结构，能够很快地进行模型训练，并具有较高的准确率。</p>
<p>本文将以决策树的最简单形式开始，即特征只包括真值特征，或只有两种选择的特征，且结果也只有两种的情况。</p>
<h2 id="二、决策树基本模型"><a href="#二、决策树基本模型" class="headerlink" title="二、决策树基本模型"></a>二、决策树基本模型</h2><p>决策树是一个二叉树，树的非叶节点存储需要区分的特征，叶节点存储预测的分类。对于每一个要进行预测的数据，从根节点开始，根据当前节点所对应的特征，选择移动到左子节点或右子节点。直到最终移动到一个叶节点，返回预测结果。</p>
<p>可以认为决策树的预测过程就是通过不同特征将当前数据分组归类的过程。决策树的构建过程，或者更一般地说，该模型的学习过程，也就是不断确定如何分类的过程。</p>
<h2 id="三、决策树的构建"><a href="#三、决策树的构建" class="headerlink" title="三、决策树的构建"></a>三、决策树的构建</h2><p>总体上讲，对于我们已有的样本数据，构建决策树的过程时这样的。</p>
<ol>
<li>选择一个特征，将该特征作为当前节点的特征</li>
<li>根据该特征将样本数据分为两组</li>
<li>对于两组被分类的数据，分别递归执行如上操作，从而确定当前节点的左右子节点。直到当前数据已经全部是要预测的某个结果了、或者所有特征都被用完、又或者递归进行到了最大层数。</li>
</ol>
<p>可以看到，决策树构建的过程中大部分过程都可以用简单的程序逻辑实现。现在唯一要解决的就是在每个节点时，如何选择一个特征了。</p>
<blockquote>
<p>当然，对于神经网络来说也是这样的。唯一要解决的是如何选择权重。</p>
</blockquote>
<h2 id="四、特征的选择"><a href="#四、特征的选择" class="headerlink" title="四、特征的选择"></a>四、特征的选择</h2><p>我们要衡量选择不同特征对训练样本的区分效果。这点类似于损失函数。</p>
<p>我们区分的目标是使得所有当前组的样本属于同一个预测结果。那么我们就要找到一种衡量纯度的指标，数据越纯指标越小，数据越不纯指标越大。这种指标就是熵。假设某一种类在数据总体中的占比为 $p_1$，则熵 $H(p_1)$ 为</p>
<script type="math/tex; mode=display">
    p_0 = 1 - p_1 \\
    H(p_1) = -p_1log_2(p_1) - p_0 log_2(p_0)</script><p>即</p>
<script type="math/tex; mode=display">
    H(p_1) = -p_1log_2(p_1) - (1-p_1) log_2(1 - p_1)</script><p>当 $p_1 = 0$ 或 $p_1 = 1$ 时</p>
<script type="math/tex; mode=display">
    H(0) = H(0+0) = 0 \\
    H(1) = H(1-0) = 0</script><blockquote>
<p>可以看出熵与交叉熵损失函数之间有联系。确实，交叉熵损失函数也是用来衡量预测的纯度的。对于一个预测，我们总希望它接近 0 或者 1，也就是纯度最大的比例。</p>
</blockquote>
<p>我们不妨设决策树中预测可能结果中一个为正例，一个为负例。假设对于当前节点处的训练样本集合 $X$， 我们选择第 j 个特征，将该集合分为两个部分 $A<em>j$ 和 $B_j$。设此时 $A_j$ 和 $B_j$ 中正例所占比例分别为 $p</em>{Aj}, p_{Bj}$，则对应的熵为：</p>
<script type="math/tex; mode=display">
    H(p_{Aj}) 和 H(p_{Bj})</script><p>对于不同的 j，两个熵值均会不同，那么我们如何比较哪种选择更为合适呢？我们需要对熵取加权平均，权重为该集合中元素数量占原集合数量的比重。</p>
<script type="math/tex; mode=display">
    \frac{\#A_jH(p_{Aj}) + \#B_jH(p_{Bj})}{\#X}</script><blockquote>
<p>这是很合理的。举个例子，假设选择了一个特征将一个样本和其他样本分开，虽然第一个样本的熵为 0，可是该分类对样本整体的影响较小，决定整体纯度的还是其他样本的部分，最终平均后的熵可能并不会减少太多</p>
</blockquote>
<p>我们将分类后的平均熵值对分类前的总熵的减少量称为信息增益（Information Gain）。假设选择某一特征时，子集合元素数量占原集合的比重为 $w^{left}, w^{right}$，则</p>
<script type="math/tex; mode=display">
    \text{Information Gain} = H(p^{root}_1) - (w^{left}H(p^{left}_1) + w^{right}H(p^{right}_1))</script><p>这样我们就解决了选择特征的问题，只要选择使信息增益最大的特征即可。</p>
<blockquote>
<p>很明显，如果一个特征在祖先节点已经被选择过了，则信息增益为 0。当所有特征的信息增益都为 0 时，说明所有特征都已经被使用过了，此时就可以返回递归了。</p>
</blockquote>
<h2 id="五、多取值特征"><a href="#五、多取值特征" class="headerlink" title="五、多取值特征"></a>五、多取值特征</h2><p>之前，我们的每一个特征都只能有两个取值，我们要将特征的取值推广到多个。这里采用的方法是将多取值特征转化为双取值特征。</p>
<p>解决方案是采用独热（one-hot）编码。举例来说，如果有一个特征 x，取值为1、2或3。那么我们可以将其转化为三个特征 is_x_equal1、is_x_equal2和is_x_equal3。这样，三个新的特征就可以只取 0、1 两个值了。</p>
<h2 id="六、连续取值特征"><a href="#六、连续取值特征" class="headerlink" title="六、连续取值特征"></a>六、连续取值特征</h2><p>对于连续取值的特征，我们要将其转化为离散特征。</p>
<p>具体来说，我们可以取一个阈值 n，将样本按该特征的值分为大于 n 和小于等于 n 的两个部分。为了方便选择，我们可以取样本的值进行分割，也就是分别取每一个样本中该特征对应的值作为划分时所用的值，计算其信息增益，最后选择使信息增益最大的值作为对该特征的划分即可。</p>
<h2 id="七、回归树——对连续取值结果的预测"><a href="#七、回归树——对连续取值结果的预测" class="headerlink" title="七、回归树——对连续取值结果的预测"></a>七、回归树——对连续取值结果的预测</h2><p>回归树是对决策树的进一步扩展。使得决策树模型可以学习结果为连续值的训练样本。</p>
<p>这样，原本的计算信息增益的方法就不再适用了。现在的数据不再有纯度的分别了，取而代之的是疏密的区别。这里我们采用样本结果的方差来衡量数据的离散程度。依旧设子集合元素数量占原集合的比重为 $w^{left}, w^{right}$，样本结果的方差则为 $var^{root}, var^{left}, var^{right}$</p>
<p>则增益的大小为</p>
<script type="math/tex; mode=display">
    \text{Gain} = var^{root} - (w^{left}var^{left} + w^{right}var^{right})</script><p>经过不断的递归构建，我们最终在叶节点处得到一组方差较小的样本。将这组样本的结果取平均，即得到叶节点对应的预测值。</p>
<h2 id="八、决策树林"><a href="#八、决策树林" class="headerlink" title="八、决策树林"></a>八、决策树林</h2><p>决策树的缺点之一是其可能对数据中的微小变化十分敏感，以至于稍有不同的数据就会产生截然不同的决策树结构。对于需要有比较大可靠性的预测，这是需要避免的。</p>
<p>解决方法是生成许多不同结构的决策树，通过这些决策树的预测结果表决或取平均，得到最终的预测结果。但确定的训练样本只会产生确定的决策树。因此这里采用随机化保证生成不同结构的决策树。</p>
<p>也就是说，对于大小为 m 的训练集，我们从中随机放回抽取 m 个样本，组成一个新的训练集，用该训练集生成一个决策树。重复这样的过程多次，就可以得到许多不同结构的决策树。</p>
<blockquote>
<p>还有一种名为 XGBoost 的方法。这样方法在选取样本组成新的训练集的过程中，会倾向于选择之前并未被选取的样本，这样组成的样本集合将更为一般化，从而使得学习效果更好。</p>
</blockquote>
<p>这样，我们就得到了能解决大部分机器学习问题的决策树算法。</p>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>AI</tag>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title>机器学习之K均值聚类</title>
    <url>/posts/af468c0b/</url>
    <content><![CDATA[<h2 id="一、引言——非监督学习"><a href="#一、引言——非监督学习" class="headerlink" title="一、引言——非监督学习"></a>一、引言——非监督学习</h2><p>之前介绍的算法都是监督学习算法。需要样本中包含各特征信息以及结果标签来让模型学习特征与结果的对应关系。但是，如果我们此时只有特征信息，而不指明具体结果是什么，又需要什么样的算法和模型才能得知哪些样本会有同样的标签呢？</p>
<p>这种从原始数据中探索样本间联系的学习方式称为非监督学习。其中非监督意指，模型不需要人来告知他 “什么是什么”，而能自己从数据中挖掘信息。</p>
<h2 id="二、聚类算法"><a href="#二、聚类算法" class="headerlink" title="二、聚类算法"></a>二、聚类算法</h2><p>非监督学习中的一种算法为聚类算法。它的目的是将数据按照一定特征进行分组。</p>
<p>最广泛使用的聚类算法称为 K 均值（K-means）算法。</p>
<h2 id="三、K均值算法"><a href="#三、K均值算法" class="headerlink" title="三、K均值算法"></a>三、K均值算法</h2><p>假设我们要将所有数据分成 k 组，并称在一组中的数据为一个簇。那么对于每一簇内的数据，我们就希望他们之间的距离相对较小，而他们与其他簇中的数据的距离较大。直观上讲，就是同簇的数据点形成一个较为密集的区域，不同簇之间则有较大的空隙（这或许就是聚类的含义）。</p>
<p>我们用簇内的数据的平均作为对簇的描述，相当于指示了簇在特征空间中的位置。这一平均后得到的点称为簇质心。假设我们现在已经得到了一种分组，那么这种分组现在是否有优化的可能呢？要回答这个问题就要查看每一数据点相对于各个簇质心的距离，如果某个数据点相对于其他簇质心的距离要小于其相对于当前所在的簇的质心的距离，就说明该点被错分类了。我们就要将其重新划分为与其距离最小的簇质心所对应的簇内。</p>
<p>但是，这种重新划分又会使得簇质心的位置发生变化，这又导致一些之前是距离该质心位置最小的数据点不再是距离该质心位置最小，又需要再次调整分类。就这样，不断地调整，直到最终所有的点距离当前所在簇的质心距离都为最小，就代表了分类完成。</p>
<p>经过了上面的分析，我们现在给出 K 均值算法的流程：</p>
<ol>
<li>初始化 k 个簇质心位置，分别对应 k 个簇</li>
<li>对每个数据点，选择与其距离最近的簇质心对应的簇作为其当前分组</li>
<li>对所有同一簇的数据点，计算其平均值，作为新的当前簇的簇质心</li>
<li>不断重复 2、3，直到所有簇的簇质心不再发生变化，即代表分组完成</li>
</ol>
<p>可以看出，该算法具有很简单的流程，且没有复杂的数据结构。</p>
<blockquote>
<p>算法中还需要明确两个点：</p>
<ul>
<li>如何初始化簇质心：<br>一般是随机选取点作为质心，或者在样本数据中随机选取 k 个点</li>
<li>怎么计算数据点到簇质心的距离<br>该算法使用二范数，或者说欧氏距离作为距离</li>
</ul>
</blockquote>
<h2 id="四、K均值算法的损失函数"><a href="#四、K均值算法的损失函数" class="headerlink" title="四、K均值算法的损失函数"></a>四、K均值算法的损失函数</h2><p>这里我们要更理论化地解释为什么这样的算法可以将数据成功分类</p>
<p>假设总共有 m 个样本数据 $x^{(1)}, x^{(2)}, …, x^{(m)}$，需要将其分为 k 类（k &lt; m）。我们用 $c^{(i)}$ 表示第 i 个数据点选择第几个簇。用 $\mu_{j}$ 表示第 j 个簇的簇质心。</p>
<p>要衡量当前分组，按照之前所说的 “同簇的数据点形成一个较为密集的区域，不同簇之间则有较大的空隙”，很容易采用簇中数据点相对于质心的距离的平均作为标准。这里直接给出损失函数</p>
<script type="math/tex; mode=display">
    J(c^{(1)}, ..., c^{(m)}, \mu_{1}, ..., \mu_{k}) =
    \frac{1}{m}\sum_{i=1}^m \Vert x^{(i)} - \mu_{c^{(i)}} \Vert^2</script><p>该损失函数在这里又叫做失真函数。很明显，失真函数是所有数据点到其对应的簇质心的距离的平方的平均。距离取平方是因为这样并不影响损失函数的衡量效果，而又方便计算。</p>
<p>根据失真函数，我们可以证明上一节算法的正确性。</p>
<ul>
<li>步骤 2 时，对第 i 个样本，我们重新选择 $c^{(i)}$ 使得 $\min\Vert x^{(i)} - \mu_{c^{(i)}} \Vert$ 从而使得 $\min J$。</li>
<li>步骤 3 时，我们使 $\mu<em>j$ 取所有簇内数据点的平均。可以数学证明，此时依旧使得 $\min \Vert x^{(i)} - \mu</em>{c^{(i)}} \Vert$。</li>
<li>这样我们就对失真函数中的每一个参数进行了调整，相当于进行了一次梯度下降。通过不断重复这一过程，最终便可达到使失真函数最小的位置。</li>
</ul>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>AI</tag>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title>机器学习之异常检测</title>
    <url>/posts/9b69f0a/</url>
    <content><![CDATA[<h2 id="一、引言"><a href="#一、引言" class="headerlink" title="一、引言"></a>一、引言</h2><p>另一种常用的非监督学习应用场景是异常检测。异常检测会学习正常情况下的样本数据，并在应用时检测出现的异常数据。</p>
<p>异常检测会运用正态分布等知识，这里先介绍一下正态分布（同时也作为自己对概率统计中的相关知识的一点总结）。</p>
<h2 id="二、正态分布"><a href="#二、正态分布" class="headerlink" title="二、正态分布"></a>二、正态分布</h2><p>对于连续型随机变量 X，若其概率密度函数为如下的形式</p>
<script type="math/tex; mode=display">
    f(x) = \frac{1}{\sqrt{2\pi}\sigma} e^{-\frac{(x-\mu)^2}{2\sigma^2}}</script><p>其中 $\sigma &gt; 0, \mu \in R$</p>
<p>则称 X 服从正态分布（Normal distribution），记 $X \sim N(\mu, \sigma^2)$。</p>
<p>取 $\mu = 0, \sigma = 1$，此时 $X \sim N(0, 1)$，称 X 服从标准正态分布。记标准正态分布的概率密度为 $\phi(x)$，分布函数为 $\Phi(x)$，则任意的服从正态分布的随机变量 X，其分布函数为 $F(x) = \Phi(\frac{x - \mu}{\sigma})$。</p>
<blockquote>
<ul>
<li>标准正态分布的分布函数数值有表可查。</li>
<li>任意正态分布的分布函数等式中的 $\frac{x - \mu}{\sigma}$ 是不是有点熟悉？在特征放缩那一篇文章中的 Z score 标准化部分有出现。 Z score 标准化似乎就是假定特征数值服从正态分布，并将其转化为标准正态分布形式。</li>
</ul>
</blockquote>
<h2 id="三、算法"><a href="#三、算法" class="headerlink" title="三、算法"></a>三、算法</h2><p>我们假设不同训练样本的每一个特征服从服从正态分布。那么，对每一个特征 <code>x_j</code>，求其期望 $\mu_j$ 和方差 $\sigma_j^2$，则该特征对应的概率密度为 $p(x_j, \mu_j, \sigma_j^2) = \Phi(\frac{x - \mu}{\sigma})$。我们假设各个特征之间相互独立，则对于任意的 $\vec{x}=(x_1, x_2, …, x_m)$，总的概率密度为</p>
<script type="math/tex; mode=display">
    p(\vec{x}) = p(x_1, \mu_1, \sigma_1^2) \times p(x_2, \mu_2, \sigma_2^2) \cdots \times p(x_m, \mu_m, \sigma_m^2)</script><p>即</p>
<script type="math/tex; mode=display">
    p(\vec{x}) = \prod_{j=1}^n p(x_j, \mu_j, \sigma_j^2)</script><p>求得的 $p(\vec{x})$ 能够反映 $\vec{x}$ 相对于训练样本正常的程度。当 $p(\vec{x})$ 很小时，说明该数据相对于训练样本的偏差很大，即异常。我们用一个很小的值 $\epsilon$ 作为判断是否异常的阈值。当 $p(\vec{x}) \lt \epsilon$，即判断为异常。</p>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>AI</tag>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title>机器学习之模型评估与优化</title>
    <url>/posts/5b526508/</url>
    <content><![CDATA[<h2 id="一、引言"><a href="#一、引言" class="headerlink" title="一、引言"></a>一、引言</h2><p>对于一个训练好的模型，我们需要知道它是否能很好地适应现实应用。也就是说，我们希望得知该模型对于训练样本之外的数据，是否也能有较好的预测效果。</p>
<blockquote>
<p>模型的这种能力称为泛化能力</p>
</blockquote>
<p>这一问题本质上还是我们之前讨论过的拟合问题。只不过对于一个较为复杂的模型来说，常常不能将其拟合或分类的结果用图像直观表示。如果我们不能较为清晰地评估模型，那就无法进一步进行优化调整（如调整正则化系数、增加或减少特征、增加样本数量等）。因此我们需要方法，来一般化地评估模型的质量。</p>
<h2 id="二、泛化能力的衡量指标"><a href="#二、泛化能力的衡量指标" class="headerlink" title="二、泛化能力的衡量指标"></a>二、泛化能力的衡量指标</h2><p>正如前一节所说，泛化能力的衡量就是衡量模型对训练样本集之外的数据集的预测效果。我们知道衡量模型对训练样本预测效果的指标是损失函数，那么对于其他数据，我们同样可以把损失函数的概念迁移到这里来。</p>
<p>我们可以将已经获得的数据划分为两部分，一部分用于训练模型，称为训练集；另一部分用于测试模型的泛化能力，称为测试集。对于用训练集训练后的数据，我们再求该模型对测试集数据的损失函数。</p>
<p>举个例子，如果我们采用简单的平方误差损失函数，则我们就是要求</p>
<script type="math/tex; mode=display">
    J_{test}(\vec{w},b) = 
    \frac{1}{2m_{test}}\sum_{i=0}^{m_{test}-1} ( f_{\vec{w},b}(\vec{x}^{(i)}_{test}) - y^{(i)}_{test} )^2</script><p>$J_{test}(\vec{w},b)$ 就是我们对该模型泛化能力的衡量指标，称为测试误差。</p>
<p>我们可以将该指标与训练集的损失函数值 $J<em>{train}(\vec{w},b)$（注意这里没有正则项，称为训练误差）进行比较。一般的情况是 $J</em>{test}(\vec{w},b)$ 大于 $J_{train}(\vec{w},b)$。</p>
<p>我们还可以将该模型的泛化能力与其他模型的泛化能力，或者与人类的误差进行比较。这样我们就可以评价我们所训练的模型的优劣了。</p>
<h2 id="三、交叉验证集"><a href="#三、交叉验证集" class="headerlink" title="三、交叉验证集"></a>三、交叉验证集</h2><p>在我们继续评估模型之前，我们要先来考虑一些我们究竟要如何进行优化。你可能会想，我们既然有了评价模型泛化能力的指标 $J_{test}$，那么只要试图让该指标减小不就可以了吗？这是一个很直接的想法。</p>
<p>但问题是，如果我们向着使 $J_{test}$ 减小的目标优化，那么测试集与训练集有什么区别呢？按照这种方法，测试集就相当于变成了训练集的一部分，而不再能成为衡量训练集之外泛化能力的样本了。</p>
<p>因此，我们不能将训练集作为优化的方向，而只能将其作为评价的指标。我们需要再分出一部分数据，作为优化时的参考。这就是交叉验证（Cross-validation）集。对应的衡量指标为 $J_{cv}$</p>
<h2 id="四、模型评价"><a href="#四、模型评价" class="headerlink" title="四、模型评价"></a>四、模型评价</h2><p>我们用偏差和方差来评价一个模型。</p>
<ul>
<li>偏差表示模型对训练集的预测相对于真实情况的误差，如果模型对训练样本都不能很好地拟合或分类，就称其为高偏差的。 $J_{train}$ 可衡量模型的偏差。</li>
<li>方差表示模型对测试集的预测相对于真实情况的误差（也就是泛化能力本身），如果模型不能很好地预测测试集中数据，就称其为高方差的。$J_{cv}$ 可衡量模型的方差。</li>
</ul>
<blockquote>
<p>一般来说，模型的方差会大于偏差。因此高偏差的模型都是高方差的。</p>
<p>随着模型复杂度的提升，模型的偏差会逐渐降低，但偏差会先降低再升高；随着训练样本量的提升，偏差会逐渐减小，方差会逐渐升高，直到最后方差和偏差程度接近。</p>
</blockquote>
<h2 id="五、倾斜数据集的误差指标"><a href="#五、倾斜数据集的误差指标" class="headerlink" title="五、倾斜数据集的误差指标"></a>五、倾斜数据集的误差指标</h2><p>对于正面例子和负面例子比例差距较大的训练样本（也就是说，被标记为某一结果的样本数量占样本总数的比例很大或很小），根据全概率分布可知，可能就算全部预测同一结果，其正确的概率也很大。因此我们需要能消除样本本身概率分布导致的正确率偏差的指标。</p>
<p>有两种误差指标用于评价这种情况。分别为准确率（Precision）和召回率（Recall）。</p>
<ul>
<li>准确率衡量的是，模型预测为某一结果的情况中，有多少是预测正确的。</li>
<li>召回率衡量的是，对所有真正为某一结果的情况，有多少是模型预测到的。</li>
</ul>
<p>也就是说，设</p>
<ul>
<li>TP表示将正类预测为正类的数量</li>
<li>FN表示将正类预测为负类的数量</li>
<li>FP表示将负类预测为正类的数量</li>
<li>TN表示将负类预测为负类的数量</li>
</ul>
<p>则准确率为</p>
<script type="math/tex; mode=display">
    P = \frac{TP}{TP + FP}</script><p>召回率为</p>
<script type="math/tex; mode=display">
    R = \frac{TP}{TP + FN}</script><p>可以这样理解，把预测的过程当做选择的过程，准确率高就是“不重”，不过多的选择，以致把许多不属于的也包括在内；召回率高就是“不漏”，不过少地选择，把一些属于的漏掉了。</p>
<p>我们很容易就能得知，准确率和召回率在一定程度上是矛盾的。想要准确率高，就很可能漏掉一些；想要召回率高，就可能包含了不属于的东西。</p>
<blockquote>
<p>对于逻辑回归来说，提高阈值（即把多少数值以上的设定为真），准确率上升，召回率下降；降低阈值，准确率下降，召回率上升。</p>
</blockquote>
<p>要权衡准确率和召回率，对模型进行整体的评价的方法是采用 F1 分数（F1 Score）。即</p>
<script type="math/tex; mode=display">
    F1 = \frac{1}{\frac{1}{2}(\frac{1}{P} + \frac{1}{R})}</script><blockquote>
<p>相当于对准确率和召回率的调和平均</p>
</blockquote>
<h2 id="五、优化策略"><a href="#五、优化策略" class="headerlink" title="五、优化策略"></a>五、优化策略</h2><p>优化模型需要考虑不同的情况。</p>
<p>一种是模型具有高偏差的情况。<br>模型具有高偏差，常常意味着当前的模型复杂度不足以拟合当前数据。此时若一味地增加训练数据量，并不会使得拟合效果提高太多。应该做的是提高模型复杂度。如增加特征、增加层数、减小正则化系数等等。</p>
<p>另一种是模型具有高方差，且偏差较低的情况。<br>这种情况常常意味着模型对样本产生了过拟合。需要做的是降低拟合程度。采取如减少特征、增大正则化系数等手段。增加训练数据量在这种情况下可以起到效果。</p>
<p><strong>这里再介绍一些增加数据量的方法：</strong></p>
<p>除了通过各种手段获取新数据以外，我们还可以利用现有数据创造新数据。如对于图像，可以将其经过旋转、伸缩、扭曲等操作生成新的图像；又比如音频，可以增加背景音、噪声等来模拟更加真实的环境。这些手段都能增加模型的稳健性和泛用性。</p>
<p>迁移学习同样是一种利用数据的手段。该方法获得经过其他数据训练过的用于完成类似任务的模型，修改部分神经层（如输出层），再进行当前任务的训练。这样做相当于使用了其他任务中的数据。（这种方法可行的原因是，相似的任务，在位置靠前的部分常有类似的处理过程）</p>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>AI</tag>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title>机器学习之神经网络基础</title>
    <url>/posts/76c44d63/</url>
    <content><![CDATA[<h2 id="一、神经元模型"><a href="#一、神经元模型" class="headerlink" title="一、神经元模型"></a>一、神经元模型</h2><p>在研究人工智能的过程中，模拟生物的神经是一条很显然的道路。神经网络模型最初便是以模拟生物的神经网络为目的的。但是在早期算力不足的情况下，神经网络的效果并不怎么好。直到硬件基础成熟的最近一段时间，神经网络才发挥出超常的能力。</p>
<p>当然，此时经过改进、优化后的神经网络也在一定程度上偏离了最初模拟生物神经系统的初衷。当前的，以统计为基础的神经网络模型是否是实现强人工智能的有效方法也不得而知。但是我们还是有必要对神经网络模型，特别是作为神经网络的最小单元——神经元模型，做充分的介绍。因为事实证明了，这是一条有效的创造 AI 工具的途径。</p>
<p>单个神经元可以看做有多个输入 $x_j$，单个输出 $a$ 的函数。神经元模型具有如下属性：</p>
<ul>
<li>权重 $\vec{w}, b$</li>
<li>激发函数 $g(z)$</li>
</ul>
<p>所对应的函数为</p>
<script type="math/tex; mode=display">
    f_{\vec{w}, b, g(z)}(\vec{x}) = g(\vec{w} \cdot \vec{x} + b)</script><blockquote>
<p>取 $g(z) = \frac{1}{1 + e^{-z}}$, 与我们之前学习过的逻辑回归没有差别。</p>
</blockquote>
<p>通过对这样的神经元按一定规则进行组合，便可以构造用于完成某种功能的神经网络。</p>
<h2 id="二、神经网络层"><a href="#二、神经网络层" class="headerlink" title="二、神经网络层"></a>二、神经网络层</h2><p>对于一组输入，我们可以将其依次通过不同的神经元进行计算，计算的结果可以按顺序组成向量，作为一组新的输入。这种不断迭代的能力是神经网络的基础。我们称同一次计算使用的所有神经元为<strong>同一层</strong>的神经元。这些神经元组成了神经网络上的一<strong>层</strong>。不同层的组合构成了整个神经网络。</p>
<blockquote>
<p>注意，同一层的神经元需要满足输入个数相同、激发函数相同。</p>
</blockquote>
<p>从数学上讲，设输入为 $\vec{x} = (x_1, x_2, …, x_n)$，输出为 $\vec{a} = (a_1, a_2, …, a_m)$，神经元函数为 $f_1(\vec{x}), f_2(\vec{x}), … f_m(\vec{x})$ 则</p>
<script type="math/tex; mode=display">
    \vec{a} = (f_1(\vec{x}), f_2(\vec{x}), ... f_m(\vec{x}))</script><p>对于不同层上的属性或参数 x，我们加上上标 $x^{[i]}$ 表示该属性或参数属于第 i 层（第几层指示神经元计算的顺序）；对于同一层的不同神经元，加上下标 $x^{[i]}_j$ 表示第 i 层的第 j 个神经元的属性或参数。</p>
<p>则更一般的，假设第 i 层接受 n 个参数的输入，并具有 m 个神经元，则第 i 层上的运算可表示为：</p>
<script type="math/tex; mode=display">
        \left\{
        \begin{array}{lr}
            a^{[i]}_1 = g(\vec{w}^{[i]}_1 \cdot \vec{a}^{[i-1]} + b^{[i]}_1) \\
            a^{[i]}_2 = g(\vec{w}^{[i]}_2 \cdot \vec{a}^{[i-1]} + b^{[i]}_2) \\
            \vdots \\
            a^{[i]}_m = g(\vec{w}^{[i]}_m \cdot \vec{a}^{[i-1]} + b^{[i]}_m)
        \end{array}
    \right.</script><blockquote>
<p>$\vec{a}^{[0]}$ 表示神经网络的总输入</p>
</blockquote>
<h2 id="三、神经网络的矩阵表示"><a href="#三、神经网络的矩阵表示" class="headerlink" title="三、神经网络的矩阵表示"></a>三、神经网络的矩阵表示</h2><p>神经网络所以一种有效的机器学习方法，在于其清晰的结构和高效的计算方式。清晰的结构已经在上一部分有所说明，这里进一步阐述神经网络的矩阵表示形式。通过矩阵并行化计算，神经网络的运行速度将得到极大地提升。</p>
<p>对于单一神经元上的权重，我们可以将其表示成列向量的形式，即</p>
<script type="math/tex; mode=display">
    W^{[i]}_j = \begin{bmatrix}
        w_1 & w_2 & \cdots & w_n
    \end{bmatrix}^T</script><p>按照上一节中的公式，要进行点乘运算，则应该将输入表示为行向量的形式</p>
<script type="math/tex; mode=display">
    A^{[i-1]} = \begin{bmatrix}
        a_1 & a_2 & \cdots & a_n
    \end{bmatrix}</script><p>则 $\vec{w}^{[i]}_j \cdot \vec{a}^{[i-1]}$ 就可以转化为 $A^{[i-1]}W^{[i]}_j$。</p>
<p>之后，我们可以先忽略激发函数。只看激发函数内的一组线性表达式，将这组表达式的结果也按顺序表示为行向量</p>
<script type="math/tex; mode=display">
    Z^{[i]} = \begin{bmatrix}
        z^{[i]}_1 & z^{[i]}_2 & \cdots & z^{[i]}_m
    \end{bmatrix}</script><p>把 b 的部分提出单独作为一个向量，记</p>
<script type="math/tex; mode=display">
    B^{[i]} = \begin{bmatrix}
        b_1 & b_2 & \cdots & b_m
    \end{bmatrix}</script><p>则</p>
<script type="math/tex; mode=display">
    Z^{[i]} = \begin{bmatrix}
        A^{[i-1]}W^{[i]}_1 & A^{[i-1]}W^{[i]}_2 & \cdots & A^{[i-1]}W^{[i]}_m
    \end{bmatrix} + B^{[i]}</script><p>再将输入 $A^{[i-1]}$ 提出来</p>
<script type="math/tex; mode=display">
    Z^{[i]} = A^{[i-1]} \begin{bmatrix}
        W^{[i]}_1 & W^{[i]}_2 & \cdots & W^{[i]}_m
    \end{bmatrix} + B^{[i]}</script><p>此时各个神经元的权重组合成了一个新的矩阵，记</p>
<script type="math/tex; mode=display">
    W^{[i]} = \begin{bmatrix}
        W^{[i]}_1 & W^{[i]}_2 & \cdots & W^{[i]}_m
    \end{bmatrix}_{n \times m}</script><blockquote>
<p>可以认为，神经网络的层的本质就是矩阵 $W^{[i]}$ 和向量 $B^{[i]}$</p>
</blockquote>
<p>此时如果我们认为函数 $g(Z)$ 表示对矩阵中的每一个元素应用激活函数 $g(z)$ ，则整个神经网络层就可以表示为</p>
<script type="math/tex; mode=display">
    A^{[i]} = g(A^{[i-1]} W^{[i]} + B^{[i]})</script><p>这不只是形式上的化简。利用 numpy 等数学库，可以极大加快运算的速度。</p>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>AI</tag>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title>机器学习笔记之一元线性回归</title>
    <url>/posts/5371358e/</url>
    <content><![CDATA[<h2 id="一、引言——房价预测问题"><a href="#一、引言——房价预测问题" class="headerlink" title="一、引言——房价预测问题"></a>一、引言——房价预测问题</h2><p><strong>问题：</strong><br>假设我们知道一些房价与距离的对应关系，通过这些已知的信息，能否预测在一定范围内任意距离对应的房价？</p>
<p>首先考虑最为简单的情况，也就是只有两个房价信息的情况。<br><img src="/posts/5371358e/simpleScatterPrice.png" class="" title="scatter"></p>
<p>如图所示，1km时对应房价为300，2km 时对应房价为500。很容易可以在这两点间连一条直线，这条直线就可以作为对房价的预测。这样用曲线对已知数据中的关系进行估计的方法称为拟合。</p>
<blockquote>
<p>（注意，本文只考虑以一元线性函数进行拟合）</p>
</blockquote>
<img src="/posts/5371358e/simplePredict.png" class="" title="predict">
<p>类似的，增加房价信息为三个点，如果三点共线，则该直线依然可以作为对房价的拟合。<br><img src="/posts/5371358e/threePredict.png" class="" title="predict2"></p>
<p>但更可能的情况是三点不共线，对于更多的数据的情况则更是如此。这样的话要如何找到一条直线来拟合房价信息呢？</p>
<h2 id="二、损失函数"><a href="#二、损失函数" class="headerlink" title="二、损失函数"></a>二、损失函数</h2><p>我们需要找到一种标准来衡量直线对已有信息的拟合程度。</p>
<p>假设当前直线为：</p>
<script type="math/tex; mode=display">
    y = wx+b</script><p>房子距离为 $x^{(1)},x^{(2)},x^{(3)}…,x^{(m)}$，对应的房价为 $y^{(1)},y^{(2)},y^{(3)}…,y^{(m)}$。<br>则对于每个距离 $x^{(i)}$，当前直线所预测的房价为:</p>
<script type="math/tex; mode=display">
    \hat{y}^{(i)} = wx^{(i)} + b</script><p>该房价与真正的房价的差距为</p>
<script type="math/tex; mode=display">
    d = |y^{(i)} - \hat{y}^{(i)}|</script><p>绝对值不可导，不妨用平方来代替</p>
<script type="math/tex; mode=display">
    d_2 = (y^{(i)} - \hat{y}^{(i)})^2</script><p>对于每个已知的房价信息，当前直线的预测都可能会有偏差，将这些偏差求和得到总的偏差</p>
<script type="math/tex; mode=display">
    \sum_{i=1}^{m}(y^{(i)} - \hat{y}^{(i)})^2</script><p>为了排除样本数量不同对偏差的影响，将偏差总和除以样本数量</p>
<script type="math/tex; mode=display">
    \frac{1}{m}\sum_{i=1}^{m}(y^{(i)} - \hat{y}^{(i)})^2</script><p>这也就是总体方差的计算式：</p>
<script type="math/tex; mode=display">
    \sigma^2 = \frac{1}{m}\sum_{i=1}^{m}(y^{(i)} - \hat{y}^{(i)})^2</script><p>对于机器学习，我们将$\hat{y}^{(i)}$展开，并将方差除以2，得到一元线性回归的损失函数（loss function），即</p>
<script type="math/tex; mode=display">
    J(w, b) = \frac{1}{2m}\sum_{i=1}^{m}(y^{(i)} - wx^{(i)} - b)^2</script><p>在 $x^{(i)}$，$y^{(i)}$ 确定的情况下，损失函数是关于 $w$ 和 $b$ 的连续可导的二元函数。该函数可以用来衡量 $w，b$ 所确定的直线与已知数据之间的偏差。</p>
<h2 id="三、梯度下降"><a href="#三、梯度下降" class="headerlink" title="三、梯度下降"></a>三、梯度下降</h2><p>既然我们已经可以用 $J(w, b)$ 衡量直线对数据的拟合程度了，那么对于“如何找到最佳的拟合曲线”这一问题，就转化为了“如何找到使得 $J(w, b)$ 最小的 $w，b$ 值”。</p>
<p>我们可以确定一个任意的点 $(w_0, b_0)$ 作为初始位置，那么要到达 $J(w, b)$ 最小的位置， 要如何移动呢？我们要向能使 $J(w, b)$ 减小，并减小得最快的方向移动。具体的，也就是向着梯度的反方向移动。</p>
<script type="math/tex; mode=display">
    (w_1, b_1) = (w_0, b_0) - \alpha\nabla{J(w, b)}</script><p>或</p>
<script type="math/tex; mode=display">
    \left\{
        \begin{array}{lr}
            w_1 = w_0 - \alpha\frac{\partial{J(w, b)}}{\partial{w}} & \\
            & \\
            b_1 = b_0 - \alpha\frac{\partial{J(w, b)}}{\partial{b}}
        \end{array}
    \right.</script><p>其中 $\alpha$ 称为步长，表示一次迭代时的移动程度。</p>
<p>通过多次重复迭代这一过程，最终得到的 $(w_n, b_n)$ 将位于梯度为 0 的位置。即损失函数的一个极小值点。这时对应的直线将能较好地拟合原本的数据。</p>
<blockquote>
<p>当然，极小值点不意味着对应的值便是损失函数的最小值。在一些情况下，这一算法也可能会使拟合的直线处于局部最优而非全局最优的情况。但本文暂不处理这种情况。</p>
</blockquote>
<h2 id="四、代码实现"><a href="#四、代码实现" class="headerlink" title="四、代码实现"></a>四、代码实现</h2><p>我们先导入<code>numpy</code>和<code>Matplotlib</code><br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br></pre></td></tr></table></figure></p>
<p>之后定义一些需要用到的函数。</p>
<p>计算损失函数<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">get_cost</span>(<span class="params">w, b, x, y</span>):</span><br><span class="line">    m = x.shape[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">    sum_cost = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(m):</span><br><span class="line">        actual_y = w * x[i] + b</span><br><span class="line">        sum_cost += (actual_y - y[i]) ** <span class="number">2</span></span><br><span class="line">    total_cost = (<span class="number">1</span> / (<span class="number">2</span> * m)) * sum_cost</span><br><span class="line">    <span class="keyword">return</span> total_cost</span><br></pre></td></tr></table></figure></p>
<p>计算损失函数对应的梯度<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">get_gradient</span>(<span class="params">w, b, x, y</span>):</span><br><span class="line">    m = x.shape[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">    sum_w = <span class="number">0</span></span><br><span class="line">    sum_b = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(m):</span><br><span class="line">        sum_w += x[i] * (w * x[i] + b - y[i])</span><br><span class="line">        sum_b += (w * x[i] + b - y[i])</span><br><span class="line">    gradient_w = (<span class="number">1</span> / m) * sum_w</span><br><span class="line">    gradient_b = (<span class="number">1</span> / m) * sum_b</span><br><span class="line">    <span class="keyword">return</span> gradient_w, gradient_b</span><br></pre></td></tr></table></figure></p>
<p>进行一次梯度下降迭代<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">gradient_descent</span>(<span class="params">w, b, x, y, alpha</span>):</span><br><span class="line">    d_w, d_b = get_gradient(w, b, x, y)</span><br><span class="line">    w -= alpha * d_w</span><br><span class="line">    b -= alpha * d_b</span><br><span class="line">    <span class="keyword">return</span> w, b</span><br></pre></td></tr></table></figure></p>
<p>接下来是主体部分</p>
<p>设置已知数据<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">x_train = np.array([<span class="number">1.0</span>, <span class="number">1.7</span>, <span class="number">2.0</span>, <span class="number">2.5</span>, <span class="number">3.0</span>, <span class="number">3.2</span>])</span><br><span class="line">y_train = np.array([<span class="number">250</span>, <span class="number">300</span>, <span class="number">480</span>, <span class="number">430</span>, <span class="number">630</span>, <span class="number">730</span>,])</span><br></pre></td></tr></table></figure><br>初始化 $w$, $b$ 及步长 $\alpha$<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">w = <span class="number">0</span></span><br><span class="line">b = <span class="number">0</span></span><br><span class="line">alpha = <span class="number">1e-2</span></span><br></pre></td></tr></table></figure></p>
<p>使用梯度下降迭代 20000 次。每 1000 次打印当前的信息。<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">20000</span>):</span><br><span class="line">    w, b = gradient_descent(w, b, x_train, y_train, alpha)</span><br><span class="line">    <span class="keyword">if</span> i % <span class="number">1000</span> == <span class="number">0</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;w:<span class="subst">&#123;w&#125;</span>, b:<span class="subst">&#123;b&#125;</span>, cost:<span class="subst">&#123;get_cost(w, b, x_train, y_train)&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure><br><img src="/posts/5371358e/print.png" class="" title="print"></p>
<p>最后输出拟合结果<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">plt.xlabel(<span class="string">&quot;house location(km)&quot;</span>)</span><br><span class="line">plt.ylabel(<span class="string">&quot;price($)&quot;</span>)</span><br><span class="line">plt.scatter(x_train, y_train)</span><br><span class="line">plt.plot([<span class="number">0</span>, <span class="number">4</span>], [b, w*<span class="number">4</span>+b])</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><br>拟合效果如图：<br><img src="/posts/5371358e/actualPredict.png" class="" title="predict3"></p>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>AI</tag>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title>机器学习笔记之多元线性回归</title>
    <url>/posts/2cfef6f1/</url>
    <content><![CDATA[<h2 id="一、引言——多特征的房价预测"><a href="#一、引言——多特征的房价预测" class="headerlink" title="一、引言——多特征的房价预测"></a>一、引言——多特征的房价预测</h2><p>现实中，某一变量并不一定只与单一变量有关。还以房价来举例，除了位置以外，房价还可能与房子面积、卧室数量、层数、房龄等因素有关。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">面积</th>
<th style="text-align:center">卧室数</th>
<th style="text-align:center">层数</th>
<th style="text-align:center">房龄</th>
<th style="text-align:center">房价</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">2104</td>
<td style="text-align:center">5</td>
<td style="text-align:center">1</td>
<td style="text-align:center">45</td>
<td style="text-align:center">460</td>
</tr>
<tr>
<td style="text-align:center">1416</td>
<td style="text-align:center">3</td>
<td style="text-align:center">2</td>
<td style="text-align:center">40</td>
<td style="text-align:center">232</td>
</tr>
<tr>
<td style="text-align:center">1534</td>
<td style="text-align:center">3</td>
<td style="text-align:center">2</td>
<td style="text-align:center">30</td>
<td style="text-align:center">315</td>
</tr>
<tr>
<td style="text-align:center">852</td>
<td style="text-align:center">2</td>
<td style="text-align:center">1</td>
<td style="text-align:center">36</td>
<td style="text-align:center">178</td>
</tr>
<tr>
<td style="text-align:center">…</td>
<td style="text-align:center">…</td>
<td style="text-align:center">…</td>
<td style="text-align:center">…</td>
<td style="text-align:center">…</td>
</tr>
</tbody>
</table>
</div>
<p>对于多个特征的情况，我们需要对之前的一元线性回归进行推广。但在此之前，需要先约定一下使用的符号：</p>
<p>和前面一样，这里将用 $x^{(i)}$ 表示第 i 组样本中的特征。 $y^{(i)}$ 表示第 i 组样本对应的目标结果。不同的是，对于第 j 个<strong>特征组</strong>，也就是第j个特征对应的数值的序列，采用 $x_{j}$ 表示。那么很自然的， $x^{(i)}_j$ 表示第 j 个特征中的第 i 个值，或者说表示第 i 组样本中的第 j 个特征。</p>
<blockquote>
<p>与上文中的列表相结合进行理解，相当于 $x^{(i)}$ 表示第 i 行中非房价的部分，$x_{j}$ 则表示第 j 列中的数值。</p>
</blockquote>
<p>要对多元特征进行拟合，也就是找到适当的 $w_1, w_2, …, w_n$ 使得对任意的 i，有</p>
<script type="math/tex; mode=display">
    y^{(i)} = w_1 * x^{(i)}_1 + w_2 * x^{(i)}_2 + ... + w_n * x^{(i)}_n + b</script><p>设</p>
<script type="math/tex; mode=display">
    \vec{w} = (w_1, w_2, ... w_n)</script><script type="math/tex; mode=display">
    \vec{x}^{(i)} = (x^{(i)}_1, x^{(i)}_2, ..., x^{(i)}_n)</script><p>则原等式可以表示为</p>
<script type="math/tex; mode=display">
    y^{(i)} = \vec{w}\cdot\vec{x}^{(i)} + b</script><h2 id="二、损失函数"><a href="#二、损失函数" class="headerlink" title="二、损失函数"></a>二、损失函数</h2><p>假设给定 $\vec{w}, b$ 。对样本信息 $\vec{x}^{(i)}$ ，有对房价的预测</p>
<script type="math/tex; mode=display">
    \hat{y}^{(i)} = \vec{w}\cdot\vec{x}^{(i)} + b</script><p>与一元线性回归时同理，损失函数</p>
<script type="math/tex; mode=display">
    J(\vec{w}, b) = \frac{1}{2m}\sum_{i=1}^{m}(\hat{y}^{(i)} - y^{(i)})^2 = \frac{1}{2m}\sum_{i=1}^{m}(\vec{w}\cdot\vec{x}^{(i)} + b - y^{(i)})^2</script><h2 id="三、梯度下降"><a href="#三、梯度下降" class="headerlink" title="三、梯度下降"></a>三、梯度下降</h2><p>对于损失函数，求对 $w_j$ 的偏导数：</p>
<script type="math/tex; mode=display">
    \frac{\partial{J(\vec{w}, b)}}{\partial{w_j}} = \frac{1}{m}\sum_{i=1}^{m}(\vec{w}\cdot\vec{x}^{(i)} + b - y^{(i)})x^{(i)}_j</script><p>对 $b$ 的偏导数：</p>
<script type="math/tex; mode=display">
    \frac{\partial{J(\vec{w}, b)}}{\partial{b}} = \frac{1}{m}\sum_{i=1}^{m}(\vec{w}\cdot\vec{x}^{(i)} + b - y^{(i)})</script><p>则每次迭代计算</p>
<script type="math/tex; mode=display">
    w_j = w_j -  \alpha \frac{\partial J(\mathbf{w},b)}{\partial w_j}</script><script type="math/tex; mode=display">
    b = b -  \alpha \frac{\partial J(\mathbf{w},b)}{\partial b}</script><p>最终就可得到拟合样本数据的多元线性方程。</p>
<h2 id="四、矩阵形式"><a href="#四、矩阵形式" class="headerlink" title="四、矩阵形式"></a>四、矩阵形式</h2><p>上述公式也可以表示为矩阵形式，设</p>
<script type="math/tex; mode=display">
    Y = \begin{bmatrix}
        y^{(1)}&y^{(2)}&\cdots&y^{(m)}
    \end{bmatrix}^T</script><script type="math/tex; mode=display">
    W = \begin{bmatrix}
        w_1&w_2&\cdots&w_n
    \end{bmatrix}^T</script><script type="math/tex; mode=display">
    X = \begin{bmatrix}
        x^{(1)}_1 & x^{(1)}_2 & \cdots & x^{(1)}_n \\
        x^{(2)}_1 & x^{(2)}_2 & \cdots & x^{(2)}_n \\
        \vdots&\vdots& \ddots & \vdots \\
        x^{(m)}_1 & x^{(m)}_2 & \cdots & x^{(m)}_n
    \end{bmatrix}</script><script type="math/tex; mode=display">
    B = \begin{bmatrix}
        b&b&\cdots&b
    \end{bmatrix}_{1\times{m}}^T</script><p>则原等式可以表示为</p>
<script type="math/tex; mode=display">
    Y = XW + B</script><p>对特定的 $W, B$ 对当前样本 $X$ 的预测为</p>
<script type="math/tex; mode=display">
    \hat{Y} = XW + B</script><p>则损失函数可以表示为</p>
<script type="math/tex; mode=display">
    J(W, B) = \frac{1}{2m}(Y - \hat{Y})^T(Y - \hat{Y})</script><p>设</p>
<script type="math/tex; mode=display">
    G = \begin{bmatrix}
        \frac{\partial{J(W, B)}}{w_1}&\frac{\partial{J(W, B)}}{w_2}&\cdots&\frac{\partial{J(W, B)}}{w_n}
    \end{bmatrix}^T</script><p>则有</p>
<script type="math/tex; mode=display">
    G = \frac{1}{m}X^T(\hat{Y} - Y)</script><p>另有</p>
<script type="math/tex; mode=display">
    \frac{\partial{J(W, B)}}{b} = \frac{1}{m}sum(\hat{Y} - Y)</script><p>其中 $sum$ 表示对向量上各元素求和</p>
<blockquote>
<p>注意公式只经过个人推导，不保证正确性</p>
</blockquote>
<h2 id="五、代码实现"><a href="#五、代码实现" class="headerlink" title="五、代码实现"></a>五、代码实现</h2><h3 id="常规形式"><a href="#常规形式" class="headerlink" title="常规形式"></a>常规形式</h3><p>同样的，我们先导入<code>numpy</code>和<code>Matplotlib</code><br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br></pre></td></tr></table></figure></p>
<p>之后定义一些需要用到的函数。</p>
<p>计算损失函数<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">get_cost</span>(<span class="params">w, b, X, y</span>):</span><br><span class="line">    m = X.shape[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">    sum_cost = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(m):</span><br><span class="line">        actual_y = np.dot(X[i], w) + b</span><br><span class="line">        sum_cost += (actual_y - y[i]) ** <span class="number">2</span></span><br><span class="line">    total_cost = sum_cost / (<span class="number">2</span> * m)</span><br><span class="line">    <span class="keyword">return</span> total_cost</span><br></pre></td></tr></table></figure></p>
<p>计算损失函数对应的梯度<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">get_gradient</span>(<span class="params">w, b, X, y</span>):</span><br><span class="line">    m, n = X.shape</span><br><span class="line"></span><br><span class="line">    sum_w = np.zeros((n, ))</span><br><span class="line">    sum_b = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(m):</span><br><span class="line">        err = (np.dot(w, X[i]) + b - y[i])</span><br><span class="line">        sum_b += err</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            sum_w[j] += X[i,j] * err</span><br><span class="line"></span><br><span class="line">    gradients_w = sum_w / m</span><br><span class="line">    gradient_b = sum_b / m</span><br><span class="line">    <span class="keyword">return</span> gradients_w, gradient_b</span><br></pre></td></tr></table></figure></p>
<p>进行一次梯度下降迭代<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">gradient_descent</span>(<span class="params">w, b, X, y, alpha</span>):</span><br><span class="line">    d_w, d_b = get_gradient(w, b, X, y)</span><br><span class="line">    w = w - alpha * d_w</span><br><span class="line">    b = b - alpha * d_b</span><br><span class="line">    <span class="keyword">return</span> w, b</span><br></pre></td></tr></table></figure></p>
<p>接下来是主体部分</p>
<p>设置已知数据<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">X_train = np.array(</span><br><span class="line">    [[<span class="number">2104</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">45</span>],</span><br><span class="line">    [<span class="number">1416</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">40</span>],</span><br><span class="line">    [<span class="number">852</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">35</span>]])</span><br><span class="line">y_train = np.array([<span class="number">460</span>, <span class="number">232</span>, <span class="number">178</span>])</span><br></pre></td></tr></table></figure><br>初始化 $w$, $b$ 及步长 $\alpha$<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">w = np.zeros((X_train.shape[<span class="number">1</span>], ))</span><br><span class="line">b = <span class="number">0</span></span><br><span class="line">alpha = <span class="number">1e-7</span></span><br></pre></td></tr></table></figure></p>
<p>使用梯度下降迭代 1000 次。每 10 次打印当前的信息。<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1000</span>):</span><br><span class="line">    w, b = gradient_descent(w, b, X_train, y_train, alpha)</span><br><span class="line">    <span class="keyword">if</span> i % <span class="number">100</span> == <span class="number">0</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;times:<span class="subst">&#123;i&#125;</span>, w:<span class="subst">&#123;np.around(w, <span class="number">3</span>)&#125;</span>, b:<span class="subst">&#123;b:<span class="number">0.2</span>f&#125;</span>, cost:<span class="subst">&#123;get_cost(w, b, X_train, y_train):<span class="number">.4</span>f&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure><br><img src="/posts/2cfef6f1/print.png" class="" title="print"></p>
<p>代价随着迭代次数的增加而减少<br><img src="/posts/2cfef6f1/loss.png" class="" title="loss"></p>
<h3 id="矩阵形式"><a href="#矩阵形式" class="headerlink" title="矩阵形式"></a>矩阵形式</h3><p>可以利用矩阵形式重写损失函数计算和梯度计算。<br>重写损失函数<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">get_cost</span>(<span class="params">w, b, X, y</span>):</span><br><span class="line">    m= X.shape[<span class="number">0</span>]</span><br><span class="line">    B = np.ones((m, )) * b</span><br><span class="line">    actual_y = np.matmul(X, w.T) + B</span><br><span class="line">    err = actual_y - y.T</span><br><span class="line">    total_cost = np.matmul(err.T, err) / (<span class="number">2</span> * m)</span><br><span class="line">    <span class="keyword">return</span> total_cost</span><br></pre></td></tr></table></figure><br>重写梯度<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">get_gradient</span>(<span class="params">w, b, X, y</span>):</span><br><span class="line">    m, n = X.shape</span><br><span class="line">    </span><br><span class="line">    sum_w = np.zeros((n, ))</span><br><span class="line">    sum_b = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    B = np.ones((m, )) * b</span><br><span class="line">    y_hat = np.matmul(X, w.T) + B</span><br><span class="line">    sum_w = np.matmul(X.T, y_hat - y.T)</span><br><span class="line">    sum_b = np.<span class="built_in">sum</span>(y_hat - y.T)</span><br><span class="line"></span><br><span class="line">    gradients_w = sum_w / m</span><br><span class="line">    gradient_b = sum_b / m</span><br><span class="line">    <span class="keyword">return</span> gradients_w, gradient_b</span><br></pre></td></tr></table></figure><br>运行，与重写之前结果相同<br><img src="/posts/2cfef6f1/printMatrix.png" class="" title="printMatrix"></p>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>AI</tag>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title>机器学习笔记之多项式回归</title>
    <url>/posts/dfc6ce5/</url>
    <content><![CDATA[<h2 id="一、引言——拟合多项式"><a href="#一、引言——拟合多项式" class="headerlink" title="一、引言——拟合多项式"></a>一、引言——拟合多项式</h2><p>考虑如图所示的样本数据：<br><img src="/posts/dfc6ce5/poly.png" class="" title="poly"></p>
<p>如果我们用一元线性回归去拟合该数据，会发现直线与数据点拟合效果很差。<br><img src="/posts/dfc6ce5/linearTry.png" class="" title="linearTry"></p>
<p>通过观察，我们很容易得知数据点满足二次函数，具体地，函数是 $\frac{1}{2}x^2 + 5$。既然用直线 $y = wx + b$ 不能拟合，那么换用二次函数 $y = w_1x^2 + w_2x + b$ 拟合的话效果会如何？</p>
<h2 id="二、多项式回归的步骤"><a href="#二、多项式回归的步骤" class="headerlink" title="二、多项式回归的步骤"></a>二、多项式回归的步骤</h2><p>对于一元多项式函数</p>
<script type="math/tex; mode=display">
    y = w_1x + w_2x^2 + \cdots + w_nx^n + b</script><p>令 $x^i = y_i$，则原函数变为</p>
<script type="math/tex; mode=display">
    y = w_1y_1 + w_2y_2 + \cdots + w_ny_n + b</script><p>对于自变量 $x$，只需将 $x^2, x^3, \cdots, x^n$ 看成与 $x$ 不同的特征。此时一个一元多项式函数的拟合问题就转变成了我们已知的多元线性拟合问题。同理，对于多元多项式函数，也可以将其转化为多元线性函数进行拟合。</p>
<h2 id="三、代码实现"><a href="#三、代码实现" class="headerlink" title="三、代码实现"></a>三、代码实现</h2><p>对于如下样本：<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">x = np.array(<span class="built_in">range</span>(-<span class="number">1</span>, <span class="number">10</span>))</span><br><span class="line">y = (x ** <span class="number">2</span>) / <span class="number">2</span> + <span class="number">5</span></span><br></pre></td></tr></table></figure></p>
<p>将 $x^2$ 也作为一个特征<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">X_train = np.c_[x.T, (x ** <span class="number">2</span>).T] <span class="comment"># np.c_ 用于进行列的扩展</span></span><br><span class="line">y_train = y</span><br></pre></td></tr></table></figure></p>
<p>剩下的与多元线性回归同理<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">alpha = <span class="number">1e-3</span></span><br><span class="line">w = np.zeros(X_train.shape[<span class="number">1</span>])</span><br><span class="line">b = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1000</span>):</span><br><span class="line">    w, b = gradient_descent(w, b, X_train, y_train, alpha)</span><br></pre></td></tr></table></figure></p>
<p>迭代信息：<br><img src="/posts/dfc6ce5/print.png" class="" title="print"></p>
<p>拟合效果：<br><img src="/posts/dfc6ce5/result.png" class="" title="result"></p>
<p>损失函数：<br><img src="/posts/dfc6ce5/cost.png" class="" title="cost"></p>
<hr>
<p><strong>扩展：</strong></p>
<p>对于较为复杂的表达式，如 $y = sinx$<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">x = np.array(<span class="built_in">range</span>(-<span class="number">1</span>, <span class="number">10</span>))</span><br><span class="line">y = np.sin(x)</span><br></pre></td></tr></table></figure></p>
<p>只要增加多项式次数<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">X_train = np.c_[x.T, (x**<span class="number">2</span>).T, (x**<span class="number">3</span>).T, (x**<span class="number">4</span>).T, (x**<span class="number">5</span>).T, (x**<span class="number">6</span>).T, (x**<span class="number">7</span>).T, (x**<span class="number">8</span>).T, (x**<span class="number">9</span>).T, (x**<span class="number">10</span>).T, (x**<span class="number">11</span>).T]</span><br></pre></td></tr></table></figure></p>
<p>再加上特征缩放<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">X_train, _, _ = featureScaling(X_train)</span><br></pre></td></tr></table></figure></p>
<p>在一定的步长和迭代次数下<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">alpha = <span class="number">0.2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">50000</span>):</span><br><span class="line">    w, b = gradient_descent(w, b, X_train, y_train, alpha)</span><br></pre></td></tr></table></figure></p>
<p>同样可以取得一定的拟合效果<br><img src="/posts/dfc6ce5/complex.png" class="" title="complex"></p>
<img src="/posts/dfc6ce5/complex_cost.png" class="" title="complex_cost">]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>AI</tag>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title>机器学习笔记之正则化</title>
    <url>/posts/6d380668/</url>
    <content><![CDATA[<h2 id="一、前言——过拟合"><a href="#一、前言——过拟合" class="headerlink" title="一、前言——过拟合"></a>一、前言——过拟合</h2><p>我们知道，经过一组点可以有无数条曲线。这些曲线对于这组样本点的损失函数同为 0。但是对于预测来说，这些曲线产生的结果却并不相同。这就意味着，进行梯度下降到达某一最低点时，依旧不一定能得到“最好的”预测（拟合/分类）效果。甚至可能对于一些情况，此时的（预测/分类）效果反而更差了。这样的情况就称为过拟合。</p>
<p>过拟合的存在是很合理的。从感性上讲，将机器学习的过程类比人类的认知，一个观念的形成不能超出经验之外，认知的结果永远是片面而非客观的。那么在与更广泛的客观现实接触之前，我们必然无法得知已经形成的认知是否是依旧可以应用的。</p>
<p>这是一个很休谟的观点。但却无法解决现实问题。我们依旧需要找到减少过拟合的方法。</p>
<h2 id="二、惩罚"><a href="#二、惩罚" class="headerlink" title="二、惩罚"></a>二、惩罚</h2><p>我们的思想中存在着一种先验观念，它规范天地万物，在冥冥中告诉我们什么是“合理的”。对于机器学习模型来说也是一样的，它应当具有这样的机制，告诉它什么情况是不可能的。</p>
<p>就比如说，对于房价，我们知道一些特征是更加重要的，而另一些是更加不重要的。很显然，那些更重要的特征对应的权重应该较不重要的特征对应的权重大。那么我们就需要对那些不重要的权重进行“惩罚”，以避免这些权重过大，从而导致模型过拟合。这样的“惩罚”在损失函数中体现。即，当这些权重过大时，损失函数也会相应增大。</p>
<p>具体而言，对如下的表达式</p>
<script type="math/tex; mode=display">
    y = w_1x_1 + w_2x_2 + w_3x_3 + b</script><p>假设要使第二、三个权重相对较小，则可以在损失函数中加上惩罚项 $\lambda_2 w_2 + \lambda_3 w_3$。其中 $\lambda_2, \lambda_3$ 取较大值。则损失函数变为</p>
<script type="math/tex; mode=display">
    J_{new}(\vec{w}, b) = J(\vec{w}, b) + \lambda_2 w_2 + \lambda_3 w_3</script><p>具体地比如说</p>
<script type="math/tex; mode=display">
    J_{new}(\vec{w}, b) = J(\vec{w}, b) + 1000 w_2 + 2000 w_3</script><p>那么此时很显然，当 $w_2, w_3$ 较大时，损失函数也会相应更大。</p>
<p>可是对于大多数情况，我们无法事先知晓权重的重要程度。对于这些一般化的问题，还需要有一般化的解决办法。</p>
<h2 id="三、正则化"><a href="#三、正则化" class="headerlink" title="三、正则化"></a>三、正则化</h2><p>正则化是惩罚的一种。该方法在损失函数中增加了正则项：</p>
<script type="math/tex; mode=display">
    \frac{\lambda}{2m} \sum_{j=1}^n w^2_j</script><p>其中 $\lambda$ 称为正则化参数。</p>
<p>则新的损失函数为</p>
<script type="math/tex; mode=display">
    J_{new}(\vec{w}, b) = J(\vec{w}, b) + \frac{\lambda}{2m} \sum_{j=1}^n w^2_j</script><p>这里有几个值得解释的地方：</p>
<h3 id="惩罚所有权重"><a href="#惩罚所有权重" class="headerlink" title="惩罚所有权重"></a>惩罚所有权重</h3><p>第一是<strong>对所有权重的惩罚</strong>。如果按照上一节的解释，很容易认为，正则化等同于对所有权重的相同比例的惩罚。这是否相当于对所有权重都不惩罚呢？若是如此，那么正则化是否还有意义？</p>
<p>关键在于正则项的 $w^2_j$ 上。这是权重的平方而非权重本身。我们对损失函数求 $w_j$ 的偏导。</p>
<script type="math/tex; mode=display">
    \frac{\partial{J_{new}(\vec{w}, b)}}{\partial{w_j}}
    = \frac{\partial{J(\vec{w}, b)}}{\partial{w_j}}
    + \frac{\lambda}{m} w_j</script><p>我们可以得到两个结论。<br>首先，正则项永远使权重不断趋于0。即便在到达或接近原损失函数最小值时，$\frac{\partial{J(\vec{w}, b)}}{\partial{w_j}} \approx 0$，但此时正则项依旧会发挥作用。这就使得权重无法安定在拟合效果最好的位置。</p>
<p>并且，权重（绝对值）更大的特征，其权重值趋近于 0 的“速度”要快于权重更小的特征。这就避免了对所有权重同一的惩罚。</p>
<p>由此我们也可以看出正则项“眼中”最好的权重是什么样子的。那就是所有权重均为 0。当然，通过合理选择学习率 $\alpha$ 和正则化参数 $\lambda$，是不可能让这种情况发生的。但正则项却可以实实在在地提供一种“拉力”，用来纠正过于“复杂”的模型结构，使得拟合得到的超平面倾向于平缓。</p>
<h3 id="除-m-缩放"><a href="#除-m-缩放" class="headerlink" title="除 m 缩放"></a>除 m 缩放</h3><p>第二需要解释的是<strong>正则项中的除 m 缩放</strong>。这样做的目的是保证同一正则化参数在不同的样本数量下都有效。</p>
<p>我们以正则化了的多元线性回归损失函数对 $w_j$ 偏导为例。</p>
<script type="math/tex; mode=display">
    \frac{\partial{J(\vec{w}, b)}}{\partial{w_j}}
    = \frac{1}{m}\sum_{i=1}^{m}(\vec{w}\cdot\vec{x}^{(i)} + b - y^{(i)})x^{(i)}_j
    + \frac{\lambda}{m} w_j</script><p>假设正则项并不除以 m，或者按照感觉，除以 n。那么在学习率和正则化参数不变的情况下，随着样本量的增加，梯度下降时正则化对权重的影响保持不变；可原损失函数却因为除以了m，对权重的影响减小。这样就会影响正则化参数在不同样本量时的有效性。</p>
<p>因此对正则项也采取除 m。这样在样本量增加时，原损失函数和正则项对权重的影响就是同比例减小的了。</p>
<h2 id="四、代码实现"><a href="#四、代码实现" class="headerlink" title="四、代码实现"></a>四、代码实现</h2><p>这一部分很简单，就不具体写出来了。</p>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>AI</tag>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title>机器学习笔记之特征缩放</title>
    <url>/posts/9d18f94a/</url>
    <content><![CDATA[<h2 id="一、引言——参数数值对权重的影响"><a href="#一、引言——参数数值对权重的影响" class="headerlink" title="一、引言——参数数值对权重的影响"></a>一、引言——参数数值对权重的影响</h2><p>考虑有两个特征的房价预测。其一为房子面积，其二为卧室数量。参数的范围为</p>
<script type="math/tex; mode=display">
    x_1 \in [300, 2000] \\
    x_2 \in [0, 5]</script><p>预测直线为</p>
<script type="math/tex; mode=display">
    y = w_1x_1 + w_2x_2 + b</script><p>从感性上认知，如果 $w_1$ 的数值大于 $w_2$，那么由特征 $x_1$ 贡献的房价就会远大于特征 $x_2$。因为这样的话，对于同等数值的变化，特征 $x_1$ 的贡献变化大于 $x_2$，而 $x_1$ 的范围又更大，则其对贡献的变化也会更加得大。这是很不合常理的。因此从感性上讲，$w_1$ 的数值应该小于 $w_2$。</p>
<p>另外，根据损失函数的定义</p>
<script type="math/tex; mode=display">
    J(\vec{w}, b)  = \frac{1}{2m}\sum_{i=1}^{m}(\vec{w}\cdot\vec{x}^{(i)} + b - y^{(i)})^2</script><p>当损失函数值固定时，改变权重 $w_1$, 则对应的权重 $w_2$ 的变化要大于 $w_1$。从图像来说，此时损失函数形成陡峭的“山谷”，它的等高线图类似于椭圆。这时进行梯度下降，在步长较大时可能出现在“崖壁”上来回跳跃的情况。</p>
<img src="/posts/9d18f94a/contours.png" class="" title="contours">
<p>为了避免这种情况，我们需要找到一种优化的方法。</p>
<h2 id="二、特征缩放"><a href="#二、特征缩放" class="headerlink" title="二、特征缩放"></a>二、特征缩放</h2><p>我们要做的是避免出现不同特征的范围差距较大的情况。那么对于极差较大的特征，我们需要将其数值所在的区间范围缩小。这就是特征放缩。</p>
<p>在进行过特征放缩后，损失函数从图像上看将会较原来更接近正圆形，这样的话，寻找通向最低点的路径将会更加容易。</p>
<p>特征缩放有许多不同的方法，如：</p>
<ol>
<li>除数特征缩放</li>
<li>均值归一化（Mean normalization）</li>
<li>Z-score标准化（Z-score normalization）</li>
</ol>
<p>除数特征缩放指的是将该特征的所有值同除以某一个数，比如说最大值。</p>
<script type="math/tex; mode=display">
    x_{scaled} = \frac{x}{x_{max}}</script><p>均值归一化是以均值为参照对所有数值进行缩放，公式：</p>
<script type="math/tex; mode=display">
    x_{scaled} = \frac{x - x_{mean}}{x_{max} - x_{min}}</script><p>Z-score标准化将数值转换为正态分布。公式：</p>
<script type="math/tex; mode=display">
    x_{scaled} = \frac{x - \mu}{\sigma}</script><p>其中</p>
<script type="math/tex; mode=display">
    \mu = \frac{1}{m}\sum_{i = 1}^m x^{(i)} \\
    \sigma^2 = \frac{1}{m}\sum_{i = 1}^m (x^{(i)} - \mu)^2</script><h2 id="三、代码实现"><a href="#三、代码实现" class="headerlink" title="三、代码实现"></a>三、代码实现</h2><p>利用 Z-score 标准化对特征进行缩放<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">featureScaling</span>(<span class="params">X</span>):</span><br><span class="line">    mu = np.mean(X, axis=<span class="number">0</span>)</span><br><span class="line">    <span class="comment"># mean 方法求平均值，其中 axis 参数指定对哪一个维度求平均。</span></span><br><span class="line"></span><br><span class="line">    sigma = np.std(X, axis=<span class="number">0</span>)</span><br><span class="line">    <span class="comment"># std 方法用来求标准差</span></span><br><span class="line"></span><br><span class="line">    X_scaled = (X - mu) / sigma</span><br><span class="line">    <span class="comment"># 直接利用运算符，X中的每一组样本，减去 mu， 除以 sigma。</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> X_scaled, mu, sigma</span><br></pre></td></tr></table></figure></p>
<p>多元线性回归代码，在初始化 <code>X_train</code> 变量的代码后添加<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">X_train, mu, sigma = featureScaling(X_train)</span><br></pre></td></tr></table></figure></p>
<p>并将步长改为 0.01（$0.01 \gg 1 \times 10^{-7}$ ！！！）<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">alpha = <span class="number">0.01</span></span><br></pre></td></tr></table></figure></p>
<p>因为采用的是经过缩放后的特征值，所以回归之后得到的权重也和原来的权重不同。为了检验代码的正确性，在代码末尾增加语句：<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(X_train.shape[<span class="number">0</span>]):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;predict:<span class="subst">&#123;np.dot(X_train[i], w) + b&#125;</span>, actual:<span class="subst">&#123;y_train[i]&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure></p>
<p>执行代码，在迭代次数较多时能明显感到执行速度变快。最终结果：<br><img src="/posts/9d18f94a/result.png" class="" title="result"><br>说明梯度下降后得到的权重能够比较好的拟合样本数据</p>
<p>损失函数值随着迭代次数增加而下降。<br><img src="/posts/9d18f94a/cost.png" class="" title="cost"></p>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>AI</tag>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title>机器学习笔记之逻辑回归</title>
    <url>/posts/ba0d6023/</url>
    <content><![CDATA[<h2 id="一、前言——逻辑分类"><a href="#一、前言——逻辑分类" class="headerlink" title="一、前言——逻辑分类"></a>一、前言——逻辑分类</h2><p>机器学习研究的另一种问题为分类问题。给出一些信息，判断是或不是某种物体、属性。比如说给出病人的各项检测指标，判断其是否患病。</p>
<p>对于是、否的判断，这里用 1、0 表示。则训练样本就与之前的线性与多项式回归样本类似。</p>
<p>我们可以试着用一元线性回归来拟合分类问题的样本。</p>
<p>比如对于如下的样本数据<br><img src="/posts/ba0d6023/scatter1.png" class="" title="scatter1"></p>
<p>进行一元线性回归后得到<br><img src="/posts/ba0d6023/linear1.png" class="" title="linear1"></p>
<p>我们将数值大于 0.5 的部分看做预测为真，小于 0.5 的部分看做预测为假。可以看到，此时一元线性回归就已经可以使所有样本点符合判断结果了。</p>
<p>但如果我们在 x 值更大的区域增加更多的样本点，再进行回归<br><img src="/posts/ba0d6023/linear2.png" class="" title="linear2"></p>
<p>可以看到，有一部分应为 1 的点被分在了 y &lt; 0.5 的部分，被预测为 0。这说明只凭线性回归无法解决分类问题。我们需要另一种回归方法。</p>
<h2 id="二、逻辑回归"><a href="#二、逻辑回归" class="headerlink" title="二、逻辑回归"></a>二、逻辑回归</h2><p>线性回归失效的原因在于，拟合的目标是对所有点的方差最小，在分类边界上的样本可能因为其他样本的影响而被分到另一类。而为什么会受到其他样本的影响呢？因为线性回归得到的表达式值域趋向于无穷；而样本的结果却只有 0、1。所以对于一个样本，只要它的特征数值足够大或足够小，就足以产生极大的损失。（为什么可能出现足够远的样本？因为分类问题需要划分出一个边界，在边界两侧可能存在足够大的范围。）</p>
<p>我们要对线性回归进行修改，需要将回归得到的表达式的值域缩小到 0 至 1 的范围。</p>
<p>这里引入 Sigmoid 函数</p>
<script type="math/tex; mode=display">
    S(z) = \frac{1}{1 + e^{-z}}</script><p>它的图像如下<br><img src="/posts/ba0d6023/sigmoid.png" class="" title="sigmoid"></p>
<p>该函数定义域为 $(-\infty, +\infty)$，值域为 $(0, 1)$</p>
<p>假设原本线性回归的函数为</p>
<script type="math/tex; mode=display">
    f_{\vec{w}, b}(\vec{x}) = \vec{w} \cdot \vec{x} + b</script><p>则现在令</p>
<script type="math/tex; mode=display">
    f_{\vec{w}, b}(\vec{x}) = S(\vec{w} \cdot \vec{x} + b)</script><p>即</p>
<script type="math/tex; mode=display">
    f_{\vec{w}, b}(\vec{x}) = \frac{1}{1 + e^{\vec{w} \cdot \vec{x} + b}}</script><p>为新的函数。其中 $S(z)$ 即为 Sigmoid 函数。这样，表达式的值域就缩小为了 $(0, 1)$，从而消除了值域对损失的影响。</p>
<h2 id="三、损失函数"><a href="#三、损失函数" class="headerlink" title="三、损失函数"></a>三、损失函数</h2><p>如果我们依旧采用线性回归时的损失函数计算方式，就会发现函数非凸，那么梯度下降法将不能得到很好的结果。因此我们重新定义损失函数。</p>
<p>设单样本损失函数</p>
<script type="math/tex; mode=display">
    loss(f_{\vec{w},b}(\vec{x}^{(i)}), y^{(i)}) = \begin{cases}
        -log(f_{\vec{w},b}(\vec{x}^{(i)}))  &  \text{if } y^{(i)} = 1 \\
        -log(1 - f_{\vec{w},b}(\vec{x}^{(i)})) & \text{if } y^{(i)} = 0
    \end{cases}</script><p>这个损失函数保证了在样本真实结果为真或为假的条件下都能以同样的标准衡量预测的误差。</p>
<p>另外，因为 $y^{(i)}$ 的取值只有 0、1。所以可以将上式化简为单个公式的形式</p>
<script type="math/tex; mode=display">
    loss(f_{\vec{w},b}(\vec{x}^{(i)}), y^{(i)}) = 
    -y^{(i)}log(f_{\vec{w},b}(\vec{x}^{(i)})) - (1 - y^{(i)})log(1 - f_{\vec{w},b}(\vec{x}^{(i)}))</script><p>则全样本代价函数</p>
<script type="math/tex; mode=display">
    J(\vec{w}, b) = \frac{1}{m} \sum_{i = 1}^m loss(f_{\vec{w},b}(\vec{x}^{(i)}), y^{(i)})</script><h2 id="四、梯度下降"><a href="#四、梯度下降" class="headerlink" title="四、梯度下降"></a>四、梯度下降</h2><p>我们对损失函数求导，得</p>
<script type="math/tex; mode=display">
    \frac{\partial{J(\vec{w}, b)}}{\partial{w_j}}
    = \frac{1}{m}\sum_{i=1}^m (f_{\vec{w},b}(\vec{x}^{(i)}) - y^{(i)}) x^{(i)}_j \\
    \frac{\partial{J(\vec{w}, b)}}{\partial{b}}
    = \frac{1}{m}\sum_{i=1}^m (f_{\vec{w},b}(\vec{x}^{(i)}) - y^{(i)})</script><p>可以发现求导后的公式形式与线性回归时的相同，这是有意为之的。但是要注意的是， $f_{\vec{w},b}(\vec{x}^{(i)})$ 在线性回归与逻辑回归时并不相同。逻辑回归时的表达式是线性回归时的加上 Sigmoid 函数。</p>
<p>按照与线性回归相同的方法，以确定的步长 $\alpha$ 进行梯度下降，不断迭代</p>
<script type="math/tex; mode=display">
    w_j = w_j - \alpha \frac{\partial{J(\vec{w}, b)}}{\partial{w_j}} \\
    b = b - \alpha \frac{\partial{J(\vec{w}, b)}}{\partial{b}}</script><p>最终便可找到使损失函数最小的 $\vec{w}, b$。</p>
<h2 id="五、代码实现"><a href="#五、代码实现" class="headerlink" title="五、代码实现"></a>五、代码实现</h2><p>在线性回归的基础上，修改损失函数的计算<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">sigmoid</span>(<span class="params">x</span>):</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span> / (<span class="number">1</span> + np.exp(-x))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_loss</span>(<span class="params">actual_y, y</span>):</span><br><span class="line">    <span class="keyword">return</span> -y * math.log(actual_y) - (<span class="number">1</span> - y) * math.log(<span class="number">1</span> - actual_y)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_cost</span>(<span class="params">w, b, X, y</span>):</span><br><span class="line">    m = X.shape[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">    sum_cost = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(m):</span><br><span class="line">        z = np.dot(X[i], w) + b</span><br><span class="line">        actual_y = sigmoid(z)</span><br><span class="line">        sum_cost += get_loss(actual_y, y[i])</span><br><span class="line">    total_cost = sum_cost / m</span><br><span class="line">    <span class="keyword">return</span> total_cost</span><br></pre></td></tr></table></figure></p>
<p>修改梯度的计算<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">get_gradient</span>(<span class="params">w, b, X, y</span>):</span><br><span class="line">    m, n = X.shape</span><br><span class="line"></span><br><span class="line">    sum_w = np.zeros((n, ))</span><br><span class="line">    sum_b = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(m):</span><br><span class="line">        err = sigmoid(np.dot(w, X[i]) + b) - y[i]</span><br><span class="line">        sum_b += err</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            sum_w[j] += X[i,j] * err</span><br><span class="line"></span><br><span class="line">    gradients_w = sum_w / m</span><br><span class="line">    gradient_b = sum_b / m</span><br><span class="line">    <span class="keyword">return</span> gradients_w, gradient_b</span><br></pre></td></tr></table></figure></p>
<p>拟合结果<br><img src="/posts/ba0d6023/logical.png" class="" title="logical"></p>
<p>损失函数<br><img src="/posts/ba0d6023/cost.png" class="" title="cost"></p>
<p>对样本的预测<br><img src="/posts/ba0d6023/predict.png" class="" title="predict"></p>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>AI</tag>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title>用pytorch实现简单循环神经网络</title>
    <url>/posts/e7ad966d/</url>
    <content><![CDATA[<h2 id="一、歌词生成项目"><a href="#一、歌词生成项目" class="headerlink" title="一、歌词生成项目"></a>一、歌词生成项目</h2><p>想要在 nlp 方面深入，于是选择训练生成一个 RNN 网络，主要目标是自动生成歌词。在这里受到了 <a href="https://www.bilibili.com/video/BV1oq4y1E7Vd">最浅显易懂的 PyTorch 深度学习入门</a> 的启发，并利用 up 主提供的 <a href="https://github.com/rossning92/ai-lyrics-writing">源码</a> 中的数据集。</p>
<p>相关代码的编写也有参考该 up 主的部分，但均为在理解内容的基础上自行编写的。另外也有对该 up 主代码中的疏漏进行修改的地方。</p>
<h2 id="二、数据的获取"><a href="#二、数据的获取" class="headerlink" title="二、数据的获取"></a>二、数据的获取</h2><h3 id="（1）编写数据集"><a href="#（1）编写数据集" class="headerlink" title="（1）编写数据集"></a>（1）编写数据集</h3><p>原作者用爬虫获取的歌词数据被保存在 lyrics.txt 文件中。我们要将数据按可供训练的模型加载。具体来说</p>
<ul>
<li>我们希望每一次获取数据，都能得到输入和目标输出（对本项目来说就是两段有一个文字偏差的序列）</li>
<li>并且将文字数字化，即 nlp 的 tokenize</li>
<li>为了实现批量训练，需要每次获取定长的序列</li>
</ul>
<p>为了实现第一点，我们要继承 dataset；实现第二点，需要根据数据建立字符表；实现第三点，需要定长截取歌词句子的一部分。</p>
<blockquote>
<p>另外，为了减少每次加载数据所用的时间，还需要将数据集的信息持久化。</p>
</blockquote>
<p>我们的 LyricsDataset 具体实现如下。首先，我们在构造函数中通过传入的路径加载数据，判断是否已经存在处理过后的数据，如存在则加载；如不存在则读入原始数据并处理</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">LyricsDataset</span>(<span class="title class_ inherited__">Dataset</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, root_path, seq_size</span>):</span><br><span class="line">        self.seq_size = seq_size</span><br><span class="line"></span><br><span class="line">        processed_name = <span class="string">&quot;/processed/lyrics.pth&quot;</span></span><br><span class="line">        raw_name = <span class="string">&quot;/raw/lyrics.txt&quot;</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> os.path.exists(root_path + processed_name):</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;find processed data&quot;</span>)</span><br><span class="line">            self.__load_processed_data(root_path + processed_name)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;processed data not found, will process raw data&quot;</span>)</span><br><span class="line">            self.__load_raw_data(root_path + raw_name)</span><br><span class="line">            self.__save_processed_data(root_path + processed_name)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__load_raw_data</span>(<span class="params">self, file_path</span>):</span><br><span class="line">        <span class="keyword">with</span> <span class="built_in">open</span>(file_path, encoding=<span class="string">&quot;utf-8&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">            sentences = f.readlines()</span><br><span class="line"></span><br><span class="line">        self.vocab = &#123;<span class="string">&quot;&lt;sos&gt;&quot;</span>: <span class="number">0</span>, <span class="string">&quot;&lt;eos&gt;&quot;</span>: <span class="number">1</span>&#125;</span><br><span class="line">        self.data = []</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> sentence <span class="keyword">in</span> sentences:</span><br><span class="line">            sentence = sentence.strip()</span><br><span class="line">            self.data.append(self.vocab[<span class="string">&quot;&lt;sos&gt;&quot;</span>])</span><br><span class="line">            <span class="keyword">for</span> char <span class="keyword">in</span> sentence:</span><br><span class="line">                <span class="keyword">if</span> char <span class="keyword">not</span> <span class="keyword">in</span> self.vocab:</span><br><span class="line">                    self.vocab[char] = <span class="built_in">len</span>(self.vocab)</span><br><span class="line">                self.data.append(self.vocab[char])</span><br><span class="line">            self.data.append(self.vocab[<span class="string">&quot;&lt;eos&gt;&quot;</span>])</span><br><span class="line"></span><br><span class="line">        self.index2word = &#123;u: v <span class="keyword">for</span> v, u <span class="keyword">in</span> self.vocab.items()&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__save_processed_data</span>(<span class="params">self, file_path</span>):</span><br><span class="line">        torch.save(&#123;<span class="string">&quot;data&quot;</span>: self.data, <span class="string">&quot;vocab&quot;</span>: self.vocab&#125;, file_path)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__load_processed_data</span>(<span class="params">self, file_path</span>):</span><br><span class="line">        data_dict = torch.load(file_path)</span><br><span class="line">        self.data = data_dict[<span class="string">&quot;data&quot;</span>]</span><br><span class="line">        self.vocab = data_dict[<span class="string">&quot;vocab&quot;</span>]</span><br><span class="line">        self.index2word = &#123;u: v <span class="keyword">for</span> v, u <span class="keyword">in</span> self.vocab.items()&#125;</span><br></pre></td></tr></table></figure>
<p>我们将所有的字转化为数值并按顺序添加到 <code>data</code> 属性中，这将有助于后续操作。另外我们还提供了由数值转化回字的字典，这是翻转（nlp 意义下的）字典的键值得到的。</p>
<p>在保存和加载数据的时候，我们使用了 <code>torch</code> 的 <code>save()</code> 和 <code>load()</code> 方法，这些方法提供了简单的序列化和反序列化功能，并非只能保存模型的参数。另外在保存模型的时候，也可以通过字典同时保存一些附加信息。这将在之后有所体现。</p>
<blockquote>
<p>这里还可以补充两个 python 中的知识。</p>
<ol>
<li>python 中也有类方法的访问修饰，在方法名前有两个下划线的是 <code>private</code>，一个下划线的是 <code>protected</code>，没有下划线的是 <code>public</code></li>
<li>for 可用于容器中，如 <code>arr2 = [i+1 for i in arr]</code>，可用于对容器中所有元素做某种处理并保存在新容器中。代码中有使用 <code>index2word = &#123;u: v for v, u in self.vocab.items()&#125;</code>。注意对于字典需要调用 <code>items()</code> 以表示对键值对的操作，否则默认为对键集合操作。</li>
</ol>
</blockquote>
<p>接着一如往常，我们要实现 <code>__getitem__</code> 和 <code>__len__</code>。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">__getitem__</span>(<span class="params">self, item</span>):</span><br><span class="line">    start = item * self.seq_size + <span class="number">1</span></span><br><span class="line">    end = start + self.seq_size</span><br><span class="line"></span><br><span class="line">    input_seq = self.data[start:end]</span><br><span class="line">    output_seq = self.data[start + <span class="number">1</span>:end + <span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> torch.tensor(input_seq), torch.tensor(output_seq)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">__len__</span>(<span class="params">self</span>):</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">int</span>((<span class="built_in">len</span>(self.data) - <span class="number">1</span>) / self.seq_size)</span><br></pre></td></tr></table></figure>
<p>在初始化的时候，我们传入了 <code>seq_size</code> 参数用于指定一条文字转化而成的序列的长度。在通过下标读取数据的过程中，我们也以序列作为基本的数据单元。另外请注意，我们为了方便后续操作，将序列转化为了一维的张量（<code>[seq_size]</code>）。</p>
<p>在编写获取长度的函数时，原作者的实现似乎除了些问题。这里指示的长度应该是总共能获取的序列的个数，肯定不能仅仅 <code>len(self.data)</code> 就可以了。应该是字符的总数除以序列的长度向下取整。<code>len(self.data) - 1</code> 考虑了输入和目标一个字符的偏差。</p>
<h3 id="（2）划分数据集"><a href="#（2）划分数据集" class="headerlink" title="（2）划分数据集"></a>（2）划分数据集</h3><p>我们现在能获取数据集了，可是这个数据集包含了所有数据，我们还希望划分出训练集和测试集。<code>torch</code> 提供一个随机划分的方法 <code>random_split</code>，但这无法在程序多次执行时保持不变。不过我们可以选择将划分后的数据集保存。这里我们定义一个函数</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">load_or_split_dataset</span>(<span class="params">dataset_root, dataset, lengths: <span class="built_in">list</span></span>):</span><br><span class="line">    processed_path = dataset_root + <span class="string">&quot;/processed&quot;</span></span><br><span class="line">    train_set_path = processed_path + <span class="string">&quot;/train.pth&quot;</span></span><br><span class="line">    test_set_path = processed_path + <span class="string">&quot;/test.pth&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(train_set_path) <span class="keyword">or</span> <span class="keyword">not</span> os.path.exists(test_set_path):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;train and test datasets not found, start random split&quot;</span>)</span><br><span class="line">        train_set, test_set = random_split(dataset, lengths)</span><br><span class="line">        torch.save(train_set, train_set_path)</span><br><span class="line">        torch.save(test_set, test_set_path)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;find train and test datasets&quot;</span>)</span><br><span class="line">        train_set = torch.load(train_set_path)</span><br><span class="line">        test_set = torch.load(test_set_path)</span><br><span class="line">    <span class="keyword">return</span> train_set, test_set</span><br></pre></td></tr></table></figure>
<p>就可以同时实现划分或加载了<br><figure class="highlight py"><table><tr><td class="code"><pre><span class="line">train_set, test_set = load_or_split_dataset(</span><br><span class="line">    dataset_root</span><br><span class="line">    lyrics_dataset,</span><br><span class="line">    [train_set_size, test_set_size])</span><br></pre></td></tr></table></figure></p>
<h3 id="（3）加载数据"><a href="#（3）加载数据" class="headerlink" title="（3）加载数据"></a>（3）加载数据</h3><figure class="highlight py"><table><tr><td class="code"><pre><span class="line">train_loader = DataLoader(train_set, batch_size, drop_last=<span class="literal">True</span>)</span><br><span class="line">test_loader = DataLoader(test_set, batch_size, drop_last=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure>
<p>按照常规创建 <code>DataLoader</code>。注意需要加上 <code>drop_last=True</code>，否则 RNN 网络可能会因为无法批处理而报错，类似<br><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">RuntimeError: Expected hidden[0] size (2, 20, 256), got (2, 50, 256)</span><br></pre></td></tr></table></figure></p>
<p>此时每次从 DataLoader 中获取的数据为两个二维张量（<code>[batch_size, seq_size]</code>）</p>
<h2 id="三、网络的搭建"><a href="#三、网络的搭建" class="headerlink" title="三、网络的搭建"></a>三、网络的搭建</h2><p>先给出总体的模型结构，这个模型只使用了 LSTM 循环神经网络加上线性层作为输出，结构较为简单，与原作者的模型相比变化不大。<br><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">LyricsModule</span>(nn.Module):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, vocab_size, embed_size, hidden_size, num_rnn_layers</span>):</span><br><span class="line">        <span class="built_in">super</span>().__init__()</span><br><span class="line"></span><br><span class="line">        self.embed = nn.Embedding(vocab_size, embed_size)</span><br><span class="line">        self.rnn = nn.LSTM(embed_size, hidden_size, num_rnn_layers, batch_first=<span class="literal">True</span>)</span><br><span class="line">        self.linear = nn.Sequential(</span><br><span class="line">            nn.Linear(hidden_size, hidden_size),</span><br><span class="line">            nn.Linear(hidden_size, vocab_size)</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, <span class="built_in">input</span>, hidden=<span class="literal">None</span></span>):</span><br><span class="line">        word_vec = self.embed(<span class="built_in">input</span>)</span><br><span class="line">        x, hidden_next = self.rnn(word_vec, hidden)</span><br><span class="line">        predict = self.linear(x)</span><br><span class="line">        <span class="keyword">return</span> predict, hidden_next</span><br></pre></td></tr></table></figure></p>
<p>接下来要分层对该模型进行介绍。</p>
<h3 id="（1）Embedding-层的使用"><a href="#（1）Embedding-层的使用" class="headerlink" title="（1）Embedding 层的使用"></a>（1）Embedding 层的使用</h3><p>在输入的一开始，我们使用了一层 <code>Embedding</code> 层。<br><figure class="highlight py"><table><tr><td class="code"><pre><span class="line">self.embed = nn.Embedding(vocab_size, embed_size)</span><br></pre></td></tr></table></figure><br>创建 <code>Embedding</code> 层需要两个必须的参数，<code>num_embeddings</code> 和 <code>embedding_dim</code>。这一层的作用，本质上是创建一个数值到向量的映射，<code>num_embeddings</code> 即为映射最多的数量；效果上，一是给传入的张量升高一个维度，维度的大小为 <code>embedding_dim</code>，二是给每个词指定一个词向量，这个词向量还可以在反向传播的过程中不断调整。</p>
<p>对于传入模型的二维张量，经过 <code>Embedding</code> 层后变为三维张量（<code>[batch_size, seq_size, embedding_dim]</code>）</p>
<h3 id="（2）LSTM-层的使用"><a href="#（2）LSTM-层的使用" class="headerlink" title="（2）LSTM 层的使用"></a>（2）LSTM 层的使用</h3><figure class="highlight py"><table><tr><td class="code"><pre><span class="line">self.rnn = nn.LSTM(embed_size, hidden_size, num_rnn_layers, batch_first=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure>
<p>LSTM 的数学表示在上一篇文章中就有说明，这里只看 pytorch 中 LSTM 的使用。<code>LSTM</code> 层输入一个三维张量，输出一个同等大小的三维张量，以及隐藏层。<code>LSTM</code> 有两个必须的参数 <code>input_size</code> 和 <code>hidden_size</code> ，分别指输入的特征数（第三维大小）和隐藏层的维度大小。在本模型使用时还使用了一个可选参数 <code>num_layers</code> 表示 <code>LSTM</code> 的层数。</p>
<p>有几点需要注意的地方。</p>
<ul>
<li>如果不添加 <code>batch_first=True</code>，则 <code>LSTM</code> 层默认第一位为 seq_size，第二维才是 batch_size。添加后才为 <code>[batch_size, seq_size, embedding_dim]</code>。</li>
<li><code>LSTM</code> 层以一个序列为一个输入单元，输出时就已经进行过 seq_size 次循环了。因此在训练的时候，不需要保存每一步后的隐藏状态并传递给下一步。</li>
<li>每个隐藏状态是一个三维张量（<code>[batch_size, seq_size, hidden_size]</code>）表示对这一批中的不同序列，在经过第几次循环之后的隐藏状态。另外因为 LSTM 有两个隐藏状态 h_t 和 c_t，返回的隐藏状态实际上是一个二元组 <code>(h_t, c_t)</code>。</li>
</ul>
<h3 id="（3）模型的输出"><a href="#（3）模型的输出" class="headerlink" title="（3）模型的输出"></a>（3）模型的输出</h3><p>我们的目标是歌词的生成，也就是根据前一个字符判断下一个字符应该生成哪一个。那么这就需要对每一个字符的输入，对应一个字典字符数目维数的输出，选择最大的数值所对应的字符。也正是因为训练之前我们就需要确定确定的维数，所以要事先确定字典。</p>
<p>对于张量来说，我们就是需要一个三维张量，其中第三维的维数为字典的字符总数。即 <code>[batch_size, seq_size, vocab_size]</code></p>
<p>我们增加的线性层就将输出如此规范：<br><figure class="highlight py"><table><tr><td class="code"><pre><span class="line">self.linear = nn.Sequential(</span><br><span class="line">    nn.Linear(hidden_size, hidden_size),</span><br><span class="line">    nn.Linear(hidden_size, vocab_size)</span><br><span class="line">)</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p><code>LSTM</code> 层的输出为二元组，因此不能用 <code>Sequential</code> 直接包含</p>
</blockquote>
<h2 id="四、更完善的训练结构"><a href="#四、更完善的训练结构" class="headerlink" title="四、更完善的训练结构"></a>四、更完善的训练结构</h2><p>在这一部分，我们希望优化代码，尽量减少每次训练时所需要的对代码的修改。首先，这需要及时对训练模型进行保存；其次我们还需要设置全局的 epoch。</p>
<h3 id="（1）设置检查点"><a href="#（1）设置检查点" class="headerlink" title="（1）设置检查点"></a>（1）设置检查点</h3><p>我们要用 <code>torch.save()</code> 保存模型和优化器的参数，这些保存的信息称为检查点（checkpoint）。为了方便确定检查点保存模型的先后顺序，我们可以将日期加到文件的命名中。</p>
<p>我们定义如下函数用来保存检查点<br><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">save_checkpoint</span>(<span class="params">root_path, module: Module, optimizer: Optimizer</span>):</span><br><span class="line">    checkpoint_name = <span class="string">&quot;checkpoint-&#123;&#125;.pth&quot;</span>.<span class="built_in">format</span>(datetime.now().strftime(<span class="string">&quot;%y%m%d-%H%M%S&quot;</span>))</span><br><span class="line">    torch.save(</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="string">&quot;module_state_dict&quot;</span>: module.state_dict(),</span><br><span class="line">            <span class="string">&quot;optim_state_dict&quot;</span>: optimizer.state_dict()</span><br><span class="line">        &#125;,</span><br><span class="line">        root_path + <span class="string">&quot;/&quot;</span> + checkpoint_name</span><br><span class="line">    )</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;save checkpoint file \&quot;<span class="subst">&#123;checkpoint_name&#125;</span>\&quot; success&quot;</span>)</span><br></pre></td></tr></table></figure><br>注意我们在确定检查点名字时获取了当前时间 <code>datetime.now().strftime(&quot;%y%m%d-%H%M%S&quot;)</code></p>
<blockquote>
<p>这里 <code>torch.save()</code> 保存的是一个字典</p>
</blockquote>
<p>接着我们定义函数以加载检查点数据<br><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">load_checkpoint</span>(<span class="params">checkpoint_path</span>):</span><br><span class="line">    checkpoint_info = torch.load(checkpoint_path)</span><br><span class="line">    <span class="keyword">return</span> checkpoint_info</span><br></pre></td></tr></table></figure></p>
<p>通过检查点名称，我们可以找到最近一次训练后的数据，定义加载最近的检查点函数<br><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">load_latest_checkpoint</span>(<span class="params">root_path</span>):</span><br><span class="line">    checkpoints = glob.glob(root_path + <span class="string">&quot;/checkpoint-*.pth&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> load_checkpoint(checkpoints[-<span class="number">1</span>])</span><br></pre></td></tr></table></figure></p>
<p>这样我们每次训练时就可以加载之前最近一次训练的数据，继续训练了。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">lyrics_module = LyricsModule(vocab_size, embed_size, hidden_size, num_layers).to(device)</span><br><span class="line"></span><br><span class="line">optimizer = torch.optim.Adam(lyrics_module.parameters(), learning_rate)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> checkpoint_exist(checkpoint_root):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;find exist checkpoint, load checkpoint information&quot;</span>)</span><br><span class="line">    checkpoint_info = load_latest_checkpoint(checkpoint_root)</span><br><span class="line">    lyrics_module.load_state_dict(checkpoint_info[<span class="string">&quot;module_state_dict&quot;</span>])</span><br><span class="line">    optimizer.load_state_dict(checkpoint_info[<span class="string">&quot;optim_state_dict&quot;</span>])</span><br></pre></td></tr></table></figure>
<h3 id="（2）连续的训练过程"><a href="#（2）连续的训练过程" class="headerlink" title="（2）连续的训练过程"></a>（2）连续的训练过程</h3><p>我们通常使用 tensorboard 查看损失函数和准确度等参数的变化趋势。但是如果每次训练时的步数都从头开始，tensorboard 的图像就会交织在一起，无法分辨。因此我们需要确定全局的步数。</p>
<p>我们在检查点中添加 <code>total_epoch</code>  参数，表示该检查点所保存的是几轮训练后的数据。在加载检查点是，<code>total_epoch</code> 也会一并加载。<br><figure class="highlight py"><table><tr><td class="code"><pre><span class="line">torch.save(</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">&quot;total_epoch&quot;</span>: total_epoch, <span class="comment"># here!</span></span><br><span class="line">        <span class="string">&quot;module_state_dict&quot;</span>: module.state_dict(),</span><br><span class="line">        <span class="string">&quot;optim_state_dict&quot;</span>: optimizer.state_dict()</span><br><span class="line">    &#125;,</span><br><span class="line">    root_path + <span class="string">&quot;/&quot;</span> + checkpoint_name</span><br><span class="line">)</span><br></pre></td></tr></table></figure></p>
<p>这样我们就能在训练中确定当前的全局轮数<br><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(epoch_size):</span><br><span class="line">    epoch = i + <span class="number">1</span></span><br><span class="line">    now_total_epoch = total_epoch + epoch</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;--- start epoch <span class="subst">&#123;epoch&#125;</span>, total epoch <span class="subst">&#123;now_total_epoch&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure><br>在训练中确定全局的训练步数<br><figure class="highlight py"><table><tr><td class="code"><pre><span class="line">global_train_step = (now_total_epoch - <span class="number">1</span>) * total_train_step + train_step</span><br><span class="line">writer.add_scalar(<span class="string">&quot;train loss&quot;</span>, loss.item(), global_train_step)</span><br><span class="line">writer.add_scalar(<span class="string">&quot;train accuracy&quot;</span>, accuracy, global_train_step)</span><br></pre></td></tr></table></figure></p>
<p>同样的在测试中<br><figure class="highlight py"><table><tr><td class="code"><pre><span class="line">writer.add_scalar(<span class="string">&quot;test loss&quot;</span>, avg_loss, now_total_epoch)</span><br><span class="line">writer.add_scalar(<span class="string">&quot;test accuracy&quot;</span>, avg_accuracy, now_total_epoch)</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>AI</tag>
        <tag>机器学习</tag>
        <tag>pytorch</tag>
        <tag>rnn</tag>
      </tags>
  </entry>
  <entry>
    <title>用pytorch搭建神经网络</title>
    <url>/posts/2c9af791/</url>
    <content><![CDATA[<h2 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h2><p>本文作为自己学习 pytorch 的记录。以搭建一个神经网络为例，介绍 pytorch 的基本使用。</p>
<p>本文不会讲 conda、python、pycharm 等的配置和使用，也不会讲各神经层的原理及使用。只是按照自己之前学习的理解，总结神经网络训练的基本流程。</p>
<p>本文所使用的例子是自己写的第一个神经网路，如下：<br><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os.path</span><br><span class="line"><span class="keyword">import</span> torch.utils.data</span><br><span class="line"><span class="keyword">from</span> torch.utils.data <span class="keyword">import</span> DataLoader</span><br><span class="line"><span class="keyword">from</span> torch <span class="keyword">import</span> nn</span><br><span class="line"><span class="keyword">from</span> torch.utils.tensorboard <span class="keyword">import</span> SummaryWriter</span><br><span class="line"><span class="keyword">from</span> torchvision <span class="keyword">import</span> transforms, datasets</span><br><span class="line"></span><br><span class="line">device = torch.device(<span class="string">&quot;cpu&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> torch.cuda.is_available():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;cuda available, use cuda to train module&quot;</span>)</span><br><span class="line">    device = torch.device(<span class="string">&quot;cuda&quot;</span>)</span><br><span class="line"></span><br><span class="line">train_set = datasets.CIFAR10(<span class="string">&quot;./CIFAR10&quot;</span>, transform=transforms.ToTensor(), download=<span class="literal">True</span>)</span><br><span class="line">test_set = datasets.CIFAR10(<span class="string">&quot;./CIFAR10&quot;</span>, transform=transforms.ToTensor(), train=<span class="literal">False</span>, download=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">train_set_size = <span class="built_in">len</span>(train_set)</span><br><span class="line">test_set_size = <span class="built_in">len</span>(test_set)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;train set size: <span class="subst">&#123;train_set_size&#125;</span>&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;test set size: <span class="subst">&#123;test_set_size&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">train_dataloader = DataLoader(train_set, <span class="number">64</span>, shuffle=<span class="literal">True</span>, drop_last=<span class="literal">True</span>)</span><br><span class="line">test_dataloader = DataLoader(test_set, <span class="number">64</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyModule</span>(nn.Module):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">super</span>(MyModule, self).__init__()</span><br><span class="line">        self.module1 = nn.Sequential(</span><br><span class="line">            nn.Conv2d(<span class="number">3</span>, <span class="number">32</span>, <span class="number">5</span>, padding=<span class="number">2</span>),</span><br><span class="line">            nn.MaxPool2d(<span class="number">2</span>),</span><br><span class="line">            nn.Conv2d(<span class="number">32</span>, <span class="number">32</span>, <span class="number">5</span>, padding=<span class="number">2</span>),</span><br><span class="line">            nn.MaxPool2d(<span class="number">2</span>),</span><br><span class="line">            nn.Conv2d(<span class="number">32</span>, <span class="number">64</span>, <span class="number">5</span>, padding=<span class="number">2</span>),</span><br><span class="line">            nn.MaxPool2d(<span class="number">2</span>),</span><br><span class="line">            nn.Flatten(),</span><br><span class="line">            nn.Linear(<span class="number">1024</span>, <span class="number">64</span>),</span><br><span class="line">            nn.Linear(<span class="number">64</span>, <span class="number">10</span>),</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, x</span>):</span><br><span class="line">        <span class="keyword">return</span> self.module1(x)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># module</span></span><br><span class="line">my_module = MyModule().to(device)</span><br><span class="line"><span class="keyword">if</span> os.path.exists(<span class="string">&quot;./my_module/my_module_10.pt&quot;</span>):</span><br><span class="line">    my_module.load_state_dict(torch.load(<span class="string">&quot;./my_module/my_module_10.pt&quot;</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># loss function</span></span><br><span class="line">loss_func = nn.CrossEntropyLoss().to(device)</span><br><span class="line"></span><br><span class="line"><span class="comment"># learning rete</span></span><br><span class="line">learning_rate = <span class="number">1e-2</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># optimizer</span></span><br><span class="line">optim = torch.optim.SGD(my_module.parameters(), lr=learning_rate)</span><br><span class="line"></span><br><span class="line">epoch = <span class="number">10</span></span><br><span class="line"></span><br><span class="line">writer = SummaryWriter(<span class="string">&quot;./logs/my_module_log&quot;</span>)</span><br><span class="line"></span><br><span class="line">total_train_step = <span class="number">0</span></span><br><span class="line">total_test_step = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(epoch):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;----- start training epoch <span class="subst">&#123;i + <span class="number">1</span>&#125;</span> -----&quot;</span>)</span><br><span class="line"></span><br><span class="line">    my_module.train()</span><br><span class="line">    <span class="keyword">for</span> imgs, targets <span class="keyword">in</span> train_dataloader:</span><br><span class="line">        imgs = imgs.to(device)</span><br><span class="line">        targets = targets.to(device)</span><br><span class="line"></span><br><span class="line">        outputs = my_module.forward(imgs)</span><br><span class="line"></span><br><span class="line">        loss = loss_func(outputs, targets)</span><br><span class="line"></span><br><span class="line">        optim.zero_grad()</span><br><span class="line">        loss.backward()</span><br><span class="line">        optim.step()</span><br><span class="line"></span><br><span class="line">        total_train_step = total_train_step + <span class="number">1</span></span><br><span class="line">        writer.add_scalar(<span class="string">&quot;train loss&quot;</span>, loss.item(), total_train_step)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;#&quot;</span>, end=<span class="string">&quot;&quot;</span>)</span><br><span class="line">        <span class="keyword">if</span> total_train_step % <span class="number">100</span> == <span class="number">0</span>:</span><br><span class="line">            <span class="built_in">print</span>()</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&quot;train step:<span class="subst">&#123;total_train_step&#125;</span>, loss:<span class="subst">&#123;loss.item()&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">    my_module.<span class="built_in">eval</span>()</span><br><span class="line">    total_test_loss = <span class="number">0</span></span><br><span class="line">    total_accuracy = <span class="number">0</span></span><br><span class="line">    <span class="keyword">with</span> torch.no_grad():</span><br><span class="line">        <span class="keyword">for</span> imgs, targets <span class="keyword">in</span> test_dataloader:</span><br><span class="line">            imgs = imgs.to(device)</span><br><span class="line">            targets = targets.to(device)</span><br><span class="line"></span><br><span class="line">            outputs = my_module.forward(imgs)</span><br><span class="line"></span><br><span class="line">            loss = loss_func(outputs, targets)</span><br><span class="line">            total_test_loss = total_test_loss + loss.item()</span><br><span class="line"></span><br><span class="line">            step_accuracy = (outputs.argmax(<span class="number">1</span>) == targets).<span class="built_in">sum</span>()</span><br><span class="line">            total_accuracy = total_accuracy + step_accuracy</span><br><span class="line"></span><br><span class="line">    total_test_step = total_test_step + <span class="number">1</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;total loss in test set: <span class="subst">&#123;total_test_loss&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;accuracy in test set: <span class="subst">&#123;total_accuracy / test_set_size&#125;</span>&quot;</span>)</span><br><span class="line">    writer.add_scalar(<span class="string">&quot;test loss&quot;</span>, total_test_loss, total_test_step)</span><br><span class="line">    writer.add_scalar(<span class="string">&quot;test accuracy&quot;</span>, total_accuracy / test_set_size, total_test_step)</span><br><span class="line"></span><br><span class="line">    torch.save(my_module.state_dict(), <span class="string">f&quot;./my_module/my_module_<span class="subst">&#123;i+<span class="number">1</span>&#125;</span>.pt&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;save module success&quot;</span>)</span><br><span class="line"></span><br><span class="line">writer.close()</span><br></pre></td></tr></table></figure></p>
<h2 id="二、数据的获取"><a href="#二、数据的获取" class="headerlink" title="二、数据的获取"></a>二、数据的获取</h2><p>数据是深度学习十分重要的一点。模型训练的过程离不开大量数据的不断获取。pytorch 提供了数据获取的方便接口，能够简洁的实现对数据的各项操作。</p>
<h3 id="（1）Dataset"><a href="#（1）Dataset" class="headerlink" title="（1）Dataset"></a>（1）Dataset</h3><p><code>Dataset</code> 类是对数据总体的抽象。对于本地的数据，我们可以继承该类来实现数据的读取。<code>Dataset</code> 类需要实现特殊方法 <code>__getitem__</code> 和 <code>__len__</code>，以实现通过下标进行数据获取和通过 <code>len()</code> 获得数据总量。</p>
<p>比如说我们有一个图片数据集需要训练分类，每个不同标签的图片放在对应标签名的文件夹下。在需要将所有图片作为数据总体读取时，若直接操作文件将十分繁琐不美观。因此可以继承 <code>Dataset</code> 类实现如下：</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyDataset</span>(<span class="title class_ inherited__">Dataset</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, root_dir, label_dir</span>):</span><br><span class="line">        self.root_dir = root_dir</span><br><span class="line">        self.label_dir = label_dir</span><br><span class="line">        self.total_path = os.path.join(self.root_dir, self.label_dir)</span><br><span class="line">        self.img_names = os.listdir(self.total_path)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__getitem__</span>(<span class="params">self, index</span>):</span><br><span class="line">        img_name = self.img_names[index]</span><br><span class="line">        img_path = os.path.join(self.total_path, img_name)</span><br><span class="line">        img = Image.<span class="built_in">open</span>(img_path)</span><br><span class="line">        label = self.label_dir</span><br><span class="line">        <span class="keyword">return</span> img, label</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__len__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">len</span>(self.img_names)</span><br></pre></td></tr></table></figure>
<p>并利用 <code>Dataset</code> 对 + 运算符的重载实现数据集的合并。<br><figure class="highlight py"><table><tr><td class="code"><pre><span class="line">cat_train_dataset = MyDataset(<span class="string">&quot;./train&quot;</span>, <span class="string">&quot;cat&quot;</span>)</span><br><span class="line">dog_train_dataset = MyDataset(<span class="string">&quot;./train&quot;</span>, <span class="string">&quot;dog&quot;</span>)</span><br><span class="line">train_dataset = cat_train_dataset + dog_train_dataset</span><br></pre></td></tr></table></figure></p>
<p>pytorch 也自带了许多数据集，可以通过一行代码实现下载和使用。如示例代码中：<br><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment"># from torchvision import transforms, datasets</span></span><br><span class="line">train_set = datasets.CIFAR10(<span class="string">&quot;./CIFAR10&quot;</span>, transform=transforms.ToTensor(), download=<span class="literal">True</span>)</span><br><span class="line">test_set = datasets.CIFAR10(<span class="string">&quot;./CIFAR10&quot;</span>, transform=transforms.ToTensor(), train=<span class="literal">False</span>, download=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure><br>便获取了 torchvision 自带的数据集 CIFAR10。将其保存在本地。同时获取了对该数据集进行访问的 <code>Dataset</code> 实例 <code>train_set</code> 和 <code>test_set</code>。</p>
<h3 id="（2）Dataloader"><a href="#（2）Dataloader" class="headerlink" title="（2）Dataloader"></a>（2）Dataloader</h3><p><code>Dataset</code> 对应了数据集，而 <code>Dataloader</code> 则对应了如何在训练中获取数据。如示例代码中：<br><figure class="highlight py"><table><tr><td class="code"><pre><span class="line">train_dataloader = DataLoader(train_set, <span class="number">64</span>, <span class="literal">True</span>, drop_last=<span class="literal">True</span>)</span><br><span class="line">test_dataloader = DataLoader(test_set, <span class="number">64</span>)</span><br></pre></td></tr></table></figure><br><code>Dataloader</code> 确定了对于数据集，要每次取 64 个作为一个批次（batch）；并且对于训练数据集，每一次训练打乱数据顺序，对于最后一个个数小于 64 的批次，将其丢弃。</p>
<p>通过合理的设置 <code>Dataloader</code> 的参数，可以避免全量数据梯度下降训练过慢的缺点和单条数据随机梯度下降造成的无法找到最优解的问题。</p>
<h3 id="（3）transformer"><a href="#（3）transformer" class="headerlink" title="（3）transformer"></a>（3）transformer</h3><p><code>transformer</code> 并不用于获取数据，而是处理数据，将数据进行各种变换。以 <code>torchvision</code> 中的 <code>transformer</code> 为例（其他方向也有各自的 <code>transformer</code>）。比如说 <code>ToTensor</code>可以将 <code>PIL.Image</code> 类型的数据转换为 <code>Tensor</code> 类型。</p>
<blockquote>
<p>示例代码在获取 CIFAR10 数据集时，也使用了 <code>transformer</code> 将数据统一转化为 <code>Tensor</code> 类型。</p>
</blockquote>
<p>但是其他的一些 <code>transformer</code> 也可以用于对数据进行修改，以从原有数据中创造出新的数据。比如说通过 <code>Resize</code> 修改图像的尺寸。</p>
<p>另外需要介绍一个特殊的 <code>transformer</code>，<code>Compose</code>。<code>Compose</code> 可以将一系列不同的 <code>transformer</code> 组合成一个单一的变换。例如：<br><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment"># from torchvision import transforms</span></span><br><span class="line">compose_trans = transforms.Compose([</span><br><span class="line">    transforms.Resize((<span class="number">200</span>, <span class="number">200</span>)),</span><br><span class="line">    transforms.ToTensor()</span><br><span class="line">])</span><br></pre></td></tr></table></figure><br>就创建了一个 <code>transformer</code>，先对调用者执行 <code>Resize</code> 操作，再执行 <code>ToTenser</code> 操作。</p>
<h2 id="三、神经网络的构建"><a href="#三、神经网络的构建" class="headerlink" title="三、神经网络的构建"></a>三、神经网络的构建</h2><p><code>torch.nn</code> 提供了构建神经网络的组件，包括神经网络类 <code>Module</code>、各种神经网络层等等内容。</p>
<blockquote>
<p>nn 是 neural network 的缩写。这一点似乎很少有人提及？</p>
</blockquote>
<p>示例代码中我们继承 <code>nn.Module</code>，创建了自己的神经网络类：<br><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment"># from torch import nn</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyModule</span>(nn.Module):</span><br></pre></td></tr></table></figure></p>
<p>在其中，我们需要构造神经网络的结构。这在该类的构造函数中实现。<br><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">    <span class="built_in">super</span>(MyModule, self).__init__()</span><br><span class="line">    self.module1 = nn.Sequential(</span><br><span class="line">        nn.Conv2d(<span class="number">3</span>, <span class="number">32</span>, <span class="number">5</span>, padding=<span class="number">2</span>),</span><br><span class="line">        nn.MaxPool2d(<span class="number">2</span>),</span><br><span class="line">        nn.Conv2d(<span class="number">32</span>, <span class="number">32</span>, <span class="number">5</span>, padding=<span class="number">2</span>),</span><br><span class="line">        nn.MaxPool2d(<span class="number">2</span>),</span><br><span class="line">        nn.Conv2d(<span class="number">32</span>, <span class="number">64</span>, <span class="number">5</span>, padding=<span class="number">2</span>),</span><br><span class="line">        nn.MaxPool2d(<span class="number">2</span>),</span><br><span class="line">        nn.Flatten(),</span><br><span class="line">        nn.Linear(<span class="number">1024</span>, <span class="number">64</span>),</span><br><span class="line">        nn.Linear(<span class="number">64</span>, <span class="number">10</span>),</span><br><span class="line">    )</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>注意这里我们首先需要调用父类的构造函数 <code>super(MyModule, self).__init__()</code>。</p>
</blockquote>
<p>在构造函数中，我们使用了 <code>torch.nn</code> 中的卷积层 <code>Conv2d</code>、最大池化层 <code>MaxPool2d</code>、线性层 <code>Linear</code> 等不同类型的神经网络层。</p>
<p>这里需要另外说明的是 <code>nn.Sequential</code>，这个神经层可以将神经层序列按顺序合并为一层，方便后面的使用。</p>
<p>另外 <code>nn.Flatten</code> 也需要说明，这一层会将前面传来的 <code>Tensor</code> 不管维数，统一转化为一维。</p>
<p>一般的神经网络构造，就在构造函数中进行。除此之外，还需要定义 <code>forward</code> 函数。用来进行神经网络的前向传播。这一部分没有需要特别说明的地方。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, x</span>):</span><br><span class="line">    <span class="keyword">return</span> self.module1(x)</span><br></pre></td></tr></table></figure>
<h2 id="四、训练：损失函数与优化器"><a href="#四、训练：损失函数与优化器" class="headerlink" title="四、训练：损失函数与优化器"></a>四、训练：损失函数与优化器</h2><p>接下来进入了模型训练的部分，但在训练前我们还需要定义一些变量。这些变量对训练十分重要。</p>
<h3 id="（1）损失函数"><a href="#（1）损失函数" class="headerlink" title="（1）损失函数"></a>（1）损失函数</h3><p>损失函数既是评价模型预测能力的指标，也是进行反向传播，调整模型的依据。pytorch 提供了许多损失函数，它们和神经网络层一样，都在 <code>torch.nn</code> 模块下。</p>
<p>在示例代码中，我们使用了交叉熵损失函数<br><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment"># from torch import nn</span></span><br><span class="line">loss_func = nn.CrossEntropyLoss().to(device) <span class="comment"># 暂不考虑 to() 函数。</span></span><br></pre></td></tr></table></figure></p>
<h3 id="（2）优化器"><a href="#（2）优化器" class="headerlink" title="（2）优化器"></a>（2）优化器</h3><p>优化器用于设置梯度下降的策略，在 <code>torch.optim</code> 模块中。不同的优化器参数可能有所不同，但都有步长（或学习率，learning rate）作为参数。示例代码中选用 <code>SGD</code>（随机梯度下降）作为优化器。<br><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment"># learning rete</span></span><br><span class="line">learning_rate = <span class="number">1e-2</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># optimizer</span></span><br><span class="line">optim = torch.optim.SGD(my_module.parameters(), lr=learning_rate)</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>注意创建优化器需要传入要训练的模型具有的参数。在示例代码中即 <code>my_module.parameters()</code></p>
</blockquote>
<p>优化器在模型训练进行反向传播时使用，需要调用优化器的两个函数。 <code>zero_grad()</code> 和 <code>step()</code>。如在示例代码中有：<br><figure class="highlight py"><table><tr><td class="code"><pre><span class="line">optim.zero_grad()</span><br><span class="line">loss.backward()</span><br><span class="line">optim.step()</span><br></pre></td></tr></table></figure></p>
<p>优化器必须这样成对调用两函数。</p>
<h2 id="五、训练：训练主循环与模型评价"><a href="#五、训练：训练主循环与模型评价" class="headerlink" title="五、训练：训练主循环与模型评价"></a>五、训练：训练主循环与模型评价</h2><h3 id="（1）对模型进行迭代训练"><a href="#（1）对模型进行迭代训练" class="headerlink" title="（1）对模型进行迭代训练"></a>（1）对模型进行迭代训练</h3><p>训练的主体由一个双重循环构成。外层循环决定训练的轮数（epoch）；内层循环次数是数据的批数（batch）。pytorch 以一批为单位进行训练。<br><figure class="highlight py"><table><tr><td class="code"><pre><span class="line">epoch = <span class="number">10</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(epoch):</span><br></pre></td></tr></table></figure><br>epoch 参数决定训练的轮数。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">my_module.train()</span><br><span class="line"><span class="keyword">for</span> imgs, targets <span class="keyword">in</span> train_dataloader:</span><br></pre></td></tr></table></figure>
<p>在一轮训练开始前，调用模型的 <code>train()</code> 方法。这只会影响一部分网络层的行为，但最好总是加上。</p>
<p>对于每一批训练，迭代调用包含训练集数据的 <code>Dataloader</code>。每一次取得的元素是一个二元组，二元组的第一个元素为输入，第二个元素为预期输出，他们的数据类型都是 <code>Tensor</code>。需要注意的是，由于 <code>Dataloader</code> 以一个 batch 的大小进行读取，因此两个 <code>Tensor</code> 的第一维度均为 batch 的大小。</p>
<p>之后，对每一批训练，需要进行前向传播求得预测结果；利用损失函数求得预测结果和期望结果间的损失；再反向传播，对模型进行修改。如示例代码：<br><figure class="highlight py"><table><tr><td class="code"><pre><span class="line">outputs = my_module.forward(imgs)</span><br><span class="line"></span><br><span class="line">loss = loss_func(outputs, targets)</span><br><span class="line"></span><br><span class="line">optim.zero_grad()</span><br><span class="line">loss.backward()</span><br><span class="line">optim.step()</span><br></pre></td></tr></table></figure><br>这里出现了之前提到的优化器的使用。另外也需要注意，反向传播 <code>backward()</code> 的调用是在损失函数所计算得到的损失上的。</p>
<h3 id="（2）对模型进行评价"><a href="#（2）对模型进行评价" class="headerlink" title="（2）对模型进行评价"></a>（2）对模型进行评价</h3><p>对模型进行评价的过程与训练时类似，只不过所用的数据集变成了测试集。也需要进行前向传播和求损失函数，根据所得结果进行评估。但是不能进行反向传播。<br><figure class="highlight py"><table><tr><td class="code"><pre><span class="line">my_module.<span class="built_in">eval</span>()</span><br><span class="line">total_test_loss = <span class="number">0</span></span><br><span class="line">total_accuracy = <span class="number">0</span></span><br><span class="line"><span class="keyword">with</span> torch.no_grad():</span><br><span class="line">    <span class="keyword">for</span> imgs, targets <span class="keyword">in</span> test_dataloader:</span><br><span class="line">        imgs = imgs.to(device)</span><br><span class="line">        targets = targets.to(device)</span><br><span class="line"></span><br><span class="line">        outputs = my_module.forward(imgs)</span><br><span class="line"></span><br><span class="line">        loss = loss_func(outputs, targets)</span><br><span class="line">        total_test_loss = total_test_loss + loss.item()</span><br><span class="line"></span><br><span class="line">        step_accuracy = (outputs.argmax(<span class="number">1</span>) == targets).<span class="built_in">sum</span>()</span><br><span class="line">        total_accuracy = total_accuracy + step_accuracy</span><br></pre></td></tr></table></figure><br>注意在进行测试之前需要调用模型的 <code>eval()</code> 方法，与 <code>train()</code> 作用类似。另外，这里为了避免前向传播影响梯度，还需要调用 <code>torch.no_grad()</code>， 使用 <code>with</code> 语句在离开作用域时自动取消效果。</p>
<p>在模型评价部分，我们得到了 <code>total_test_loss</code> 和 <code>total_accuracy</code>，可以作为评价模型的标准。</p>
<h2 id="六、tensorboard的数据可视化"><a href="#六、tensorboard的数据可视化" class="headerlink" title="六、tensorboard的数据可视化"></a>六、tensorboard的数据可视化</h2><p>我们在训练和测试过程中得到了许多评价模型的数值。这些数值随着训练的进行发生变化。为了方便观察变化的趋势，来更好的评价训练过程，可以以训练步数为自变量，损失或准确率为因变量作图。tensorboard 就提供了方便的作图方法。</p>
<p>事先创建 <code>SummaryWriter</code> 实例<br><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment"># from torch.utils.tensorboard import SummaryWriter</span></span><br><span class="line">writer = SummaryWriter(<span class="string">&quot;./logs/my_module_log&quot;</span>)</span><br></pre></td></tr></table></figure></p>
<p>当求得损失或准确度时，调用 <code>add_scalar()</code> 方法将点添加到坐标图上。<br><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 在训练中</span></span><br><span class="line">        total_train_step = total_train_step + <span class="number">1</span></span><br><span class="line">        writer.add_scalar(<span class="string">&quot;train loss&quot;</span>, loss.item(), total_train_step)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;#&quot;</span>, end=<span class="string">&quot;&quot;</span>)</span><br><span class="line">        <span class="keyword">if</span> total_train_step % <span class="number">100</span> == <span class="number">0</span>:</span><br><span class="line">            <span class="built_in">print</span>()</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&quot;train step:<span class="subst">&#123;total_train_step&#125;</span>, loss:<span class="subst">&#123;loss.item()&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在测试中</span></span><br><span class="line">    total_test_step = total_test_step + <span class="number">1</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;total loss in test set: <span class="subst">&#123;total_test_loss&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;accuracy in test set: <span class="subst">&#123;total_accuracy / test_set_size&#125;</span>&quot;</span>)</span><br><span class="line">    writer.add_scalar(<span class="string">&quot;test loss&quot;</span>, total_test_loss, total_test_step)</span><br><span class="line">    writer.add_scalar(<span class="string">&quot;test accuracy&quot;</span>, total_accuracy / test_set_size, total_test_step)</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>并且我们还将数值打印了出来。通过打印训练和测试信息，可以使人知道训练进行到了何种程度，并在训练出问题时及时终止。</p>
</blockquote>
<p>最后不要忘记关闭 <code>SummaryWriter</code>。<br><figure class="highlight py"><table><tr><td class="code"><pre><span class="line">writer.close()</span><br></pre></td></tr></table></figure></p>
<p>接着，我们需要在控制台执行命令<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">tensorboard --logdir=logs/my_module_log</span><br></pre></td></tr></table></figure><br>然后便可在网页中查看 tensorboard 所绘制的图表。</p>
<h2 id="七、模型的保存与加载"><a href="#七、模型的保存与加载" class="headerlink" title="七、模型的保存与加载"></a>七、模型的保存与加载</h2><p>对训练好的模型，我们需要将其保存到磁盘上，而不是随着程序结束而被内存释放。保存和加载模型有两种方式。</p>
<p><strong>第一种</strong>如下所示<br><figure class="highlight py"><table><tr><td class="code"><pre><span class="line">torch.save(my_module, <span class="string">&quot;./my_module.pt&quot;</span>)</span><br><span class="line"></span><br><span class="line">torch.load(<span class="string">&quot;./my_module.pt&quot;</span>)</span><br></pre></td></tr></table></figure><br>这将同时保存模型的结构和参数，但是需要注意，在加载使用模型时，依旧需要有模型类的定义。</p>
<p><strong>第二种</strong>如下所示<br><figure class="highlight py"><table><tr><td class="code"><pre><span class="line">torch.save(my_module.state_dict(), <span class="string">&quot;./my_module.pt&quot;</span>)</span><br><span class="line"></span><br><span class="line">my_module = MyModule().to(device)</span><br><span class="line">my_module.load_state_dict(torch.load(<span class="string">&quot;./my_module.pt&quot;</span>))</span><br></pre></td></tr></table></figure><br>这样的方式将只保存模型的参数，但不保存模型的结构。可以减小一部分文件大小。示例代码中使用的便是这种方法。</p>
<h2 id="八、gpu加速"><a href="#八、gpu加速" class="headerlink" title="八、gpu加速"></a>八、gpu加速</h2><p>gpu 可以加速模型训练。pytorch 可以使用 NVIDIA 显卡进行加速。默认的情况，训练模型使用 cpu。我们需要将其切换到 cuda。切换到使用 cuda 有两种方法。</p>
<p>我们可以对模型、损失函数、张量使用 cuda。在<strong>第一种</strong>方法中，我们要调用 <code>cuda()</code> 方法。<br><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 模型</span></span><br><span class="line">my_module = MyModule()</span><br><span class="line"><span class="keyword">if</span> torch.cuda.is_available():</span><br><span class="line">    my_module = my_module.cuda()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 损失函数</span></span><br><span class="line">loss_func = nn.CrossEntropyLoss()</span><br><span class="line"><span class="keyword">if</span> torch.cuda.is_available():</span><br><span class="line">    loss_func = loss_func.cuda()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在训练中</span></span><br><span class="line">        <span class="keyword">for</span> imgs, targets <span class="keyword">in</span> test_dataloader:</span><br><span class="line">            <span class="keyword">if</span> torch.cuda.is_available():</span><br><span class="line">                imgs = imgs.cuda()</span><br><span class="line">                targets = targets.cuda()</span><br></pre></td></tr></table></figure><br>为了避免 cuda 不可用，要在使用 <code>cuda()</code> 前调用 <code>torch.cuda.is_available()</code> 做判断。</p>
<p><strong>第二种</strong>方法较为简单，需要调用 <code>to()</code> 方法。<br><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 声明训练时使用的设备</span></span><br><span class="line">device = torch.device(<span class="string">&quot;cpu&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> torch.cuda.is_available():</span><br><span class="line">    device = torch.device(<span class="string">&quot;cuda&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 模型</span></span><br><span class="line">my_module = MyModule().to(device)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 损失函数</span></span><br><span class="line">loss_func = nn.CrossEntropyLoss().to(device)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在训练中</span></span><br><span class="line">    <span class="keyword">for</span> imgs, targets <span class="keyword">in</span> train_dataloader:</span><br><span class="line">        imgs = imgs.to(device)</span><br><span class="line">        targets = targets.to(device)</span><br></pre></td></tr></table></figure><br>在第二种方法中，我们事先声明了所用的设备，然后只需要对模型、损失函数、张量调用 <code>to()</code> 方法即可。避免了重复的判断。</p>
<h2 id="九、总结"><a href="#九、总结" class="headerlink" title="九、总结"></a>九、总结</h2><p>以上便是 pytorch 的基本使用。我们可以从代码中总结出模型训练的一般流程：</p>
<ol>
<li>加载数据</li>
<li>构建神经网络</li>
<li>设置参数，比如损失函数、学习率等</li>
<li>训练模型</li>
<li>评价模型</li>
<li>保存模型</li>
</ol>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>AI</tag>
        <tag>机器学习</tag>
        <tag>pytorch</tag>
      </tags>
  </entry>
  <entry>
    <title>系统编程之shell编程</title>
    <url>/posts/757349f6/</url>
    <content><![CDATA[<h2 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h2><p>本文将简单探索shell脚本编程，介绍shell的基本语法。</p>
<h2 id="二、shell简介"><a href="#二、shell简介" class="headerlink" title="二、shell简介"></a>二、shell简介</h2><p>shell是一个命令解释器，可以用来启动、停止、编写程序；是用户和UNIX/Linux操作系统内核程序间的一个接口。</p>
<p>而shell编程则是将linux命令与shell的各种流程控制和条件判断来组合成命令与变量，形成可以进行自动处理的脚本程序。</p>
<h2 id="三、前期准备"><a href="#三、前期准备" class="headerlink" title="三、前期准备"></a>三、前期准备</h2><h3 id="创建脚本"><a href="#创建脚本" class="headerlink" title="创建脚本"></a>创建脚本</h3><p>shell脚本是一个文本文件，可用文本编辑器如vi、vim编辑保存。创建shell脚本只需按照创建文本文件的方式创建。如<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vi c1.sh</span><br><span class="line">vim c2.sh</span><br><span class="line">&gt; c3.sh</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>shell脚本一般以<code>.sh</code>为后缀，但没有后缀依旧可以执行。</p>
</blockquote>
<p>创建的shell脚本，一定要在开头第一行加上如下语句：<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br></pre></td></tr></table></figure><br>这一行将指明该脚本执行所需要的命令解释器。</p>
<h3 id="执行脚本"><a href="#执行脚本" class="headerlink" title="执行脚本"></a>执行脚本</h3><p>shell脚本的执行方法有<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sh &lt;scriptname&gt;</span><br><span class="line">bash &lt;scriptname&gt;</span><br></pre></td></tr></table></figure><br>或者使用chmod命令修改脚本为可执行，再直接使用 <code>./&lt;scriptname&gt;</code> 运行。</p>
<h2 id="四、基本语法"><a href="#四、基本语法" class="headerlink" title="四、基本语法"></a>四、基本语法</h2><h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><p>shell中的变量分为环境变量、用户定义变量、内部变量。</p>
<p>其中环境变量是操作系统的一部分，但可以利用shell脚本进行修改；用户变量即在脚本中声明的变量；而内部变量则用来指示脚本运行中出现的一些变量。</p>
<h4 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h4><p>只有用户变量可以声明。和其他语言一样，使用等号进行声明。但要注意的是，shell脚本是弱类型的，因此变量名前不需要加上类型名。<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">var=hello_world</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>注意shell对空格敏感，声明时等号两边不能有空格</p>
</blockquote>
<p>另外可以在变量名前添加 <code>readonly</code>关键字设为只读<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">readonly constVar</span><br></pre></td></tr></table></figure></p>
<p>shell中声明数组同样直接写出数组名称<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">arr[0]=1</span><br><span class="line">arr[1]=5</span><br><span class="line">arr[10]=20</span><br></pre></td></tr></table></figure><br>未赋值的部分默认为NULL。</p>
<blockquote>
<p>注意 ubuntu 默认使用 dash 而非 bash shell。dash 并不支持数组。要使用数组可以用bash运行脚本，即运行命令 <code>bash &lt;scriptname&gt;</code></p>
</blockquote>
<h4 id="赋值"><a href="#赋值" class="headerlink" title="赋值"></a>赋值</h4><p>shell变量有类似左值右值的区别。在用其他变量进行赋值时，需要对变量使用<code>$&#123; &#125;</code> 进行取值。<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">var1=hi</span><br><span class="line">var2=$&#123;var1&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="引号"><a href="#引号" class="headerlink" title="引号"></a>引号</h4><p>shell脚本是为了自动化处理命令而设计的。因此语法中有很大一部分关注于字符串和命令的相关操作。在变量上体现在，shell中所有变量默认以字符串形式存在。</p>
<p>并且，为了满足命令处理的需要，shell设计出了引号变量值。</p>
<p>shell中的引号包括单引号、双引号和倒引号。</p>
<p><strong>单引号</strong>中的字符均作为普通字符出现。（可以包括空格）<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">var1=hello_world</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">var2=hello world <span class="comment"># 不合法</span></span></span><br><span class="line">var3=&#x27;hello world&#x27;</span><br></pre></td></tr></table></figure></p>
<p><strong>双引号</strong>中的字符大部分作为普通字符对待。除了<code>$\’</code>和双引号，这些变量依旧用于对字符串内容进行变量替换。<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">var4=hello</span><br><span class="line">var5=friend</span><br><span class="line">var6=&quot;$var4, my $var5!&quot;</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">var6 means <span class="string">&quot;hello, my friend!&quot;</span>.</span></span><br></pre></td></tr></table></figure></p>
<p><strong>倒引号</strong>将引号内的内容当做命令，会先执行倒引号内的内容，再用执行后的输出替换倒引号的内容。</p>
<blockquote>
<p>倒引号可以和双引号组合使用，在双引号内使用倒引号<br>$(command) 与 `command` 功能相同</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">var7=&quot;now pwd: `pwd`&quot;</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">var6 means <span class="string">&quot;now pwd: /home/username&quot;</span> (depend on the position <span class="built_in">where</span> you execute the script)</span></span><br></pre></td></tr></table></figure>
<h3 id="基础操作"><a href="#基础操作" class="headerlink" title="基础操作"></a>基础操作</h3><h4 id="字符串操作"><a href="#字符串操作" class="headerlink" title="字符串操作"></a>字符串操作</h4><p>shell脚本自身具有一些字符串操作功能。</p>
<ul>
<li>字符串长度：<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$</span><span class="language-bash">&#123;<span class="comment">#str&#125;</span></span></span><br></pre></td></tr></table></figure></li>
<li>字符串截取：<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$</span><span class="language-bash">&#123;str:position&#125;</span></span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">&#123;str:start:length&#125;</span></span><br></pre></td></tr></table></figure></li>
<li>从字符串开头删除：<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$</span><span class="language-bash">&#123;str<span class="comment">#substr&#125;</span></span></span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">&#123;str<span class="comment">##substr&#125;</span></span></span><br></pre></td></tr></table></figure></li>
<li>从字符串末尾删除：<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$</span><span class="language-bash">&#123;str%substr&#125;</span></span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">&#123;str%%substr&#125;</span></span><br></pre></td></tr></table></figure></li>
<li>字符串替换：<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$</span><span class="language-bash">&#123;str/substr/replace&#125;</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<blockquote>
<p>字符串操作中出现匹配的部分都支持正则表达式。其中一个字符的为懒惰匹配，两个字符的为贪婪匹配。</p>
<p>使用 <code>expr</code> 等命令，可以更好地进行处理。</p>
</blockquote>
<h4 id="数字运算"><a href="#数字运算" class="headerlink" title="数字运算"></a>数字运算</h4><p>shell默认变量为字符串，因此若要进行数字运算，需要特殊指明。</p>
<p>具体地，有两种方法。一种是利用 <code>$(())</code> 运算符。指明括号内的表达式进行的不是字符串操作而是数字运算。<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">num1=10</span><br><span class="line">num2=20</span><br><span class="line">num3=$(($num1+$num2)) # 30</span><br></pre></td></tr></table></figure></p>
<p>另一种方法是调用 linux 的 expr 命令。<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">num4=3</span><br><span class="line">num5=$num4</span><br><span class="line">num6=`expr $num4 \* $num5` # 9</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>注意乘号在shell脚本中有特殊含义，因此需要加入反斜杠转义。另外 expr 命令中变量和运算符各自作为参数，因此中间需要用空格隔开.</p>
</blockquote>
<h3 id="流程控制"><a href="#流程控制" class="headerlink" title="流程控制"></a>流程控制</h3><h4 id="条件表达式"><a href="#条件表达式" class="headerlink" title="条件表达式"></a>条件表达式</h4><p>shell 利用 <code>test condition</code> 和 <code>[condition]</code> 进行条件测试。其中“condition” 表示一个条件表达式。包括字符比较、数值比较、文件操作、逻辑操作。</p>
<p>这一部分原理较为简单，但shell中判断符号与其他语言有较大差别，内容较多，就不一一列举了。</p>
<blockquote>
<p>注意使用条件表达式时，表达式与方括号间要有空格隔开</p>
</blockquote>
<h4 id="分支控制"><a href="#分支控制" class="headerlink" title="分支控制"></a>分支控制</h4><p>分支控制语句如下</p>
<p>if 分支：<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">if [ condition ]</span><br><span class="line">then</span><br><span class="line">    commands</span><br><span class="line">elif</span><br><span class="line">    commands</span><br><span class="line">else</span><br><span class="line">    commands</span><br><span class="line">fi</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>注意末尾的 fi</p>
</blockquote>
<p>case分支（类似switch）：<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">case variable in</span><br><span class="line">var1)</span><br><span class="line">    commands</span><br><span class="line">    ;;</span><br><span class="line">var2 | var3)</span><br><span class="line">    commands</span><br><span class="line">    ;;</span><br><span class="line">*)</span><br><span class="line">    commands</span><br><span class="line">esac</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>注意两个连续的分号，类似于 break。进入同样分支的变量值要用 “|” 隔开。末尾要添加 esac。</p>
</blockquote>
<h4 id="循环控制"><a href="#循环控制" class="headerlink" title="循环控制"></a>循环控制</h4><p>循环控制语句如下</p>
<p>while 循环：<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">while [ condition ]</span><br><span class="line">do</span><br><span class="line">    commands</span><br><span class="line">done</span><br></pre></td></tr></table></figure></p>
<p>until 循环：<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">until [ condition ]</span><br><span class="line">do</span><br><span class="line">    commands</span><br><span class="line">done</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>until 循环与条件取反的 while 循环等价</p>
</blockquote>
<p>for 循环如下：<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">for arg in args</span><br><span class="line">do</span><br><span class="line">    commands</span><br><span class="line">done</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>其中 args 是一组列出的变量名或字符串</p>
</blockquote>
<h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><h4 id="函数的定义"><a href="#函数的定义" class="headerlink" title="函数的定义"></a>函数的定义</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">function func_name&#123;</span><br><span class="line">    commands</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func_name()&#123;</span><br><span class="line">    commands</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>两种方式均可定义函数。</p>
<h4 id="参数取值"><a href="#参数取值" class="headerlink" title="参数取值"></a>参数取值</h4><p>shell中的函数只有可变参数。另外，整个shell脚本本身也可以看做一个函数，它同样也只有可变参数。都具有相同的取参数的方式。</p>
<p>shell中通过 <code>$0 $1 $2 ... $9</code>等参数来获取函数对应位置的参数。其中 <code>$0</code> 最开始为函数名/脚本名。当参数多于 10 个时，要获取十个之外的参数，可以使用 <code>shift</code> 命令，使得除了函数名/脚本名 $0 之外的所有参数整体左移一位。<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">sh &lt;scriptname&gt;.sh 123 456</span></span><br><span class="line">echo $1 # 123</span><br><span class="line">shift</span><br><span class="line">echo $1 # 456</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p><code>echo</code> 为输出命令</p>
</blockquote>
<h4 id="函数返回值"><a href="#函数返回值" class="headerlink" title="函数返回值"></a>函数返回值</h4><p>函数通过 <code>return [n]</code> 语句来返回变量值 n。如果没有设置返回值，那么会默认返回函数最后一条命令执行后的返回值。</p>
<p>在函数调用之后，可以使用 <code>$?</code> 获取函数的返回值。</p>
<blockquote>
<p>注意 return 的值必须只能是 0~255间的整数。要返回字符串或者更大的数字，可以直接使用 <code>echo</code> 输出内容，再通过倒引号获取输出的内容。</p>
</blockquote>
<h4 id="函数实例"><a href="#函数实例" class="headerlink" title="函数实例"></a>函数实例</h4><p>编写一个递归计算阶乘的函数<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">frac()</span><br><span class="line">&#123;</span><br><span class="line">    if [ $(($1)) -ge 1 ]</span><br><span class="line">    then</span><br><span class="line">        echo $((`frac $(($1-1))`*$1))</span><br><span class="line">    else</span><br><span class="line">        echo 1</span><br><span class="line">    fi</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">echo `frac 5` # 120</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>shell</tag>
        <tag>系统编程</tag>
      </tags>
  </entry>
  <entry>
    <title>系统编程之信号及信号处理</title>
    <url>/posts/903497ec/</url>
    <content><![CDATA[<h2 id="一、信号简介"><a href="#一、信号简介" class="headerlink" title="一、信号简介"></a>一、信号简介</h2><h3 id="（1）信号含义"><a href="#（1）信号含义" class="headerlink" title="（1）信号含义"></a>（1）信号含义</h3><p>软中断信号(signal，又简称为信号)用来通知进程发生了异步事件。在软件层次上是对中断机制的一种模拟；在原理上，一个进程收到一个信号与处理器收到一个中断请求可以说是一样的。信号是进程间通信机制中唯一的异步通信机制，一个进程不必通过任何操作来等待信号的到达，事实上，进程也不知道信号到底什么时候到达。进程之间可以互相通过系统调用 kill 发送软中断信号。内核也可以因为内部事件而给进程发送信号，通知进程发生了某个事件。信号机制除了基本通知功能外，还可以传递附加信息。</p>
<h3 id="（2）信号分类"><a href="#（2）信号分类" class="headerlink" title="（2）信号分类"></a>（2）信号分类</h3><p>可以使用<code>kill -l</code>命令查看当前系统支持的所有信号：</p>
<img src="/posts/903497ec/signal.png" class="" title="signal">
<p>信号值小于 SIGRTMIN（&lt;=34）的信号都是不可靠信号。它的主要问题是信号可能丢失。 信号值位于 SIGRTMIN 和 SIGRTMAX 之间的信号都是可靠信号，这些信号支持排队，不会丢失。</p>
<h3 id="（3）信号的产生"><a href="#（3）信号的产生" class="headerlink" title="（3）信号的产生"></a>（3）信号的产生</h3><p>信号可以由一下几种方式产生：</p>
<ul>
<li>键盘事件：ctrl+c ctrl+\ ctrl+Z 等</li>
<li>非法内存：如果内存管理出错，系统就会发送一个信号进行处理</li>
<li>硬件检测到异常：如段错误，除 0，总线错误等</li>
<li>环境切换：比如说从用户态切换到其他态，状态的改变也会发送一个信号，这个信号会告知给系统</li>
<li>系统调用：如调用<code>kill</code>，<code>raise</code>，<code>sigsend</code> ，<code>sigqueue</code>函数等</li>
</ul>
<h3 id="（4）信号处理"><a href="#（4）信号处理" class="headerlink" title="（4）信号处理"></a>（4）信号处理</h3><p>进程可以通过三种方式响应信号：</p>
<ul>
<li>接受默认处理</li>
<li>忽略信号（某些信号不能被忽略，如 SIGKILL 和 SIGSTOP）</li>
<li>捕捉信号并执行信号处理程序</li>
</ul>
<h2 id="二、信号操作"><a href="#二、信号操作" class="headerlink" title="二、信号操作"></a>二、信号操作</h2><h3 id="（1）信号发送"><a href="#（1）信号发送" class="headerlink" title="（1）信号发送"></a>（1）信号发送</h3><p>系统调用中用于发送信号的函数有 <code>kill()</code> <code>raise()</code> <code>abort()</code> 等。</p>
<h4 id="kill-函数"><a href="#kill-函数" class="headerlink" title="kill() 函数"></a><code>kill()</code> 函数</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">kill</span><span class="params">(<span class="type">pid_t</span> pid, <span class="type">int</span> sig)</span>;</span><br><span class="line"><span class="comment">//第一个参数pid代表接受信号的进程PID，第二个参数代表要发送的信号</span></span><br></pre></td></tr></table></figure>
<p>参数 pid 会影响 kill()函数的作用，取值分为以下四种情况</p>
<ol>
<li>若 pid&gt;0，则发送信号 sig 给进程号为 pid 的进程。</li>
<li>若 pid=0，则发送信号 sig 给当前进程所属进程组的所有进程。</li>
<li>若 pid=-1，则发送信号 sig 给除 1 号进程和当前进程外的所有进程。</li>
<li>若 pid&lt;-1，则发送信号 sig 给属于进程组 pid 的所有进程。</li>
</ol>
<h4 id="segqueue-函数"><a href="#segqueue-函数" class="headerlink" title="segqueue() 函数"></a><code>segqueue()</code> 函数</h4><p>sigqueue()函数支持发送信号的同时传递参数，需要配合 <code>sigaction()</code> 函数一起使用。<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sigqueue</span><span class="params">(<span class="type">pid_t</span> pid, <span class="type">int</span> sig, <span class="type">const</span> <span class="keyword">union</span> sigval value)</span>;</span><br><span class="line"><span class="comment">//第一个参数pid代表接受信号的进程PID，第二个参数代表要发送的信号，第三个参数于指定传递的数据</span></span><br></pre></td></tr></table></figure><br>参数 value 用于指定伴随信号传递的数据，为 sigval 联合体，该联合体的定义如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">sigval</span> &#123;</span></span><br><span class="line"><span class="type">int</span>   sival_int;</span><br><span class="line"><span class="type">void</span> *sival_ptr;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>如下的代码使用 <code>segqueue</code> 函数实现了数据的进程间传输</p>
</blockquote>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">./B &amp; <span class="comment"># 此时，输出进程 B 的 PID 号。</span></span><br><span class="line">./A processB_PID 123456 <span class="comment"># 第一个参数表示进程 B 的 PID，第二个参数为要传输的（数字）</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//code of A</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">pid_t</span> pid = atoi(argv[<span class="number">1</span>]);</span><br><span class="line">	<span class="type">int</span> stuID = atoi(argv[<span class="number">2</span>]);</span><br><span class="line">    <span class="class"><span class="keyword">union</span> <span class="title">sigval</span> <span class="title">v</span>;</span></span><br><span class="line">    v.sival_int = stuID;</span><br><span class="line">    sigqueue(pid, SIGINT, v);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//code of B</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="type">void</span> <span class="title function_">handler</span><span class="params">(<span class="type">int</span>, <span class="type">siginfo_t</span> *, <span class="type">void</span>*)</span>;</span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">act</span>;</span></span><br><span class="line">    act.sa_sigaction = handler;</span><br><span class="line">    sigemptyset(&amp;act.sa_mask);</span><br><span class="line">    act.sa_flags = SA_SIGINFO;</span><br><span class="line">    </span><br><span class="line">    sigaction(SIGINT, &amp;act, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">for</span>(; ;)</span><br><span class="line">      pause();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="type">void</span> <span class="title function_">handler</span><span class="params">(<span class="type">int</span> sig, <span class="type">siginfo_t</span> *info, <span class="type">void</span> *ctx)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;num received:%d\n&quot;</span>, info-&gt;si_value.sival_int);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="（2）信号捕捉"><a href="#（2）信号捕捉" class="headerlink" title="（2）信号捕捉"></a>（2）信号捕捉</h3><p>若进程捕捉某信号后，想要让其执行非默认的处理函数，则需要为该信号注册信号处理函数。进程的信号是在内核态下处理的，内核为每个进程准备了一个信号向量表，其中记录了每个信号所对应的信号处理函数。Linux 系统为用户提供了两个捕捉信号的函数，即 <code>signal()</code> 和 <code>sigaction()</code> 两个函数。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="title function_">void</span> <span class="params">(*<span class="type">sighandler_t</span>)</span><span class="params">(<span class="type">int</span>)</span>;</span><br><span class="line"><span class="type">sighandler_t</span> <span class="title function_">signal</span><span class="params">(<span class="type">int</span> signum,<span class="type">sighandler_t</span> handler)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//第一个参数表示信号编号，第二个参数一般表示信号处理函数的函数指针，除此之外还可以为SIG_IGN和SIG_DEL</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sigaction</span><span class="params">(<span class="type">int</span> signum,<span class="type">const</span> <span class="keyword">struct</span> sigaction* act,<span class="type">const</span> <span class="keyword">struct</span> sigaction* oldact)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//第一个参数表示信号编号，第二个为传入参数，包含自定义处理函数和其他信息，第三个参数为传出参数，包含旧处理函数等信息</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>如下的代码通过信号实现了异步回收子进程。避免了 <code>wait()</code> 函数回收子进程时对父进程的阻塞。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">collect</span><span class="params">(<span class="type">int</span> sig)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    signal(SIGCHLD, collect);</span><br><span class="line">    <span class="type">pid_t</span> pid;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        pid = fork();</span><br><span class="line">        <span class="keyword">if</span> (pid == <span class="number">0</span>) <span class="comment">// child</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;child pid:%d\n&quot;</span>, getpid());</span><br><span class="line">            fflush(<span class="built_in">stdout</span>);</span><br><span class="line">            <span class="built_in">exit</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 模拟父进程继续执行</span></span><br><span class="line">    <span class="type">int</span> time = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">while</span> ((time = sleep(time)) != <span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">collect</span><span class="params">(<span class="type">int</span> sig)</span></span><br><span class="line">&#123;</span><br><span class="line">   signal(SIGCHLD, collect);</span><br><span class="line">   <span class="type">int</span> status;</span><br><span class="line">   <span class="type">pid_t</span> pid;</span><br><span class="line">   <span class="keyword">while</span> ((pid = waitpid(<span class="number">-1</span>, &amp;status, WNOHANG)) &gt; <span class="number">0</span>)</span><br><span class="line">   &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;child collected, pid:%d, status:%d\n&quot;</span>,</span><br><span class="line">         pid, WEXITSTATUS(status));</span><br><span class="line">      fflush(<span class="built_in">stdout</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="（3）信号屏蔽"><a href="#（3）信号屏蔽" class="headerlink" title="（3）信号屏蔽"></a>（3）信号屏蔽</h3><p>信号屏蔽机制是用于解决常规信号不可靠这一问题。在进程的 PCB 中存在两个信号集，分别为信号掩码和未决信号集。两个信号集实质上都是位图，其中每一位对应一个信号，若信号掩码某一位为 1，则其对应的信号会被屏蔽，进入阻塞状态，此时内核会修改未决信号集中该信号对应的位为 1，表示信号处于未决状态，之后除非信号被解除屏蔽，否则内核不会再向该进程发送该信号。</p>
<p>信号集设定函数：</p>
<ul>
<li><p><code>sigemptyset()</code>——将指定信号集清 0</p>
</li>
<li><p><code>sigfillset()</code>——将指定信号集置 1</p>
</li>
<li><p><code>sigaddset()</code>——将某信号加入指定信号集</p>
</li>
<li><p><code>sigdelset()</code>——将某信号从信号集中删除</p>
</li>
<li><p><code>sigismember()</code>——判断某信号是否已被加入指定信号集</p>
</li>
</ul>
<p>信号集函数：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">sigprocmask</span><span class="params">(<span class="type">int</span> how,<span class="type">const</span> <span class="type">sigset_t</span>* <span class="built_in">set</span>,<span class="type">sigset_t</span>* oldset)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//第一个参数用于设置位操作方式，第二个参数一般为用户指定信号集，第三个参数用于保存原信号集</span></span><br><span class="line"><span class="comment">//how=SIG_BLOCK：mask=mask|set</span></span><br><span class="line"><span class="comment">//how=SIG_UNBLOCK：mask=mask&amp;~set</span></span><br><span class="line"><span class="comment">//how=SIG_SETMASK：mask=set</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>如下的代码展示了信号遮蔽的使用方式。通过阻塞所有信号，避免了 printf() 函数因使用全局缓冲区而产生的异步信号不安全问题。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">print_safe</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">sigset_t</span> <span class="built_in">set</span>;</span><br><span class="line">    <span class="comment">// 1~64 为所有信号的编号</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">64</span>; i++)</span><br><span class="line">        sigaddset(&amp;<span class="built_in">set</span>, i);</span><br><span class="line">    <span class="comment">// 阻塞所有信号</span></span><br><span class="line">    sigprocmask(SIG_BLOCK, &amp;<span class="built_in">set</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;safe print!\n&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 恢复所有信号</span></span><br><span class="line">    sigprocmask(SIG_UNBLOCK, &amp;<span class="built_in">set</span>, <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="（4）定时信号"><a href="#（4）定时信号" class="headerlink" title="（4）定时信号"></a>（4）定时信号</h3><p>Linux 下的 <code>alarm()</code> 函数可以用来设置闹钟，该函数的原型为：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> <span class="title function_">alarm</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> seconds)</span>;</span><br><span class="line"><span class="comment">//第一个参数seconds用来指明时间，经过seconds秒后发送SIGALRM信号给当前进程，当参数为0则取消之前的闹钟</span></span><br></pre></td></tr></table></figure>
<p>返回值：</p>
<ul>
<li>如果本次调用前已有正在运行的闹钟，alarm()函数返回前一个闹钟的剩余秒数</li>
<li>如果本次调用前无正在运行的闹钟，alarm()函数返回 0</li>
</ul>
<p>Linux 系统中 sleep()函数内部使用 nanosleep()函数实现，该函数与信号无关；而其他系统中可能使用 alarm()和 pause()函数实现，此时不应该混用 alarm()和 sleep()。</p>
<blockquote>
<p>如下的代码实现了这样的功能：程序每间隔 1 秒输出信息，当按下 ctrl+c 后，程序询问是否退出程序（此时停止输出学号），输入 Y 或 5 秒未进行任何输入则退出程序，输入 N 程序恢复运行，继续输出信息</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">chooseIfExit</span><span class="params">(<span class="type">int</span> signal)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">doExit</span><span class="params">(<span class="type">int</span> signal)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	signal(SIGINT, chooseIfExit);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;21371326\n&quot;</span>);</span><br><span class="line">		sleep(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">chooseIfExit</span><span class="params">(<span class="type">int</span> sig)</span></span><br><span class="line">&#123;</span><br><span class="line">	signal(SIGINT, chooseIfExit);</span><br><span class="line">	signal(SIGALRM, doExit);</span><br><span class="line">	alarm(<span class="number">5</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;want to exit? (Y/N)\n&quot;</span>);</span><br><span class="line">	<span class="type">char</span> choose;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot; %c&quot;</span>, &amp;choose);</span><br><span class="line">	<span class="keyword">if</span> (choose == <span class="string">&#x27;N&#x27;</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		alarm(<span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		doExit(SIGINT);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">doExit</span><span class="params">(<span class="type">int</span> signal)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;exit...\n&quot;</span>);</span><br><span class="line">	<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="（5）计时器"><a href="#（5）计时器" class="headerlink" title="（5）计时器"></a>（5）计时器</h3><p>Linux 下的 <code>setitimer()</code> 和 <code>getitimer()</code> 系统调用可以用于访问和设置计时器，计时器在初次经过设定的时间后发出信号，也可以设置为每间隔相同的时间发出信号，该函数的原型为：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">getitimer</span><span class="params">(<span class="type">int</span> which, <span class="keyword">struct</span> itimerval *curr_value)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">setitimer</span><span class="params">(<span class="type">int</span> which, <span class="type">const</span> <span class="keyword">struct</span> itimerval *<span class="keyword">restrict</span> new_value,</span></span><br><span class="line"><span class="params">                     <span class="keyword">struct</span> itimerval *<span class="keyword">restrict</span> old_value)</span>;</span><br></pre></td></tr></table></figure>
<p>通过指定 which 参数，可以设置不同的计时器，不同的计时器触发后也会发出不同的信号，一个进程同时只能有一种计时器：</p>
<ul>
<li>ITIMER_REAL：真实计时器，计算程序运行的真实时间（墙钟时间），产生 SIGALRM 信号</li>
<li>ITIMER_VIRTUAL：虚拟计时器，计算当前进程处于用户态的 cpu 时间，产生 SIGVTALRM 信号</li>
<li>ITIMER_PROF：使用计时器，计算当前进程处于用户态和内核态的 cpu 时间，产生 SIGPROF 信号</li>
</ul>
<p>计时器的值有以下结构体定义：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">itimerval</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">it_interval</span>;</span> <span class="comment">//定期触发的间隔</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">it_value</span>;</span> <span class="comment">//初次触发时间</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> &#123;</span></span><br><span class="line">  <span class="type">time_t</span> tv_sec; <span class="comment">//秒</span></span><br><span class="line">  <span class="type">suseconds_t</span> tv_usec; <span class="comment">//微秒</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>若 new_value.it_value 的两个字段不全为 0，则定时器初次将会在设定的时间后触发；若 new_value.it_value 的两个字段全为 0，则计时器不工作。</p>
<p>若 new_value.it_interval 的两个字段不全为 0，则定时器将会在初次触发后按设定的时间间隔触发；若 new_value.it_interval 的两个字段全为 0，则计时器仅初次触发一次。</p>
<p>setitimer()函数和 alarm()函数共享同一个计时器，因此不应同时使用。</p>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>系统编程</tag>
        <tag>信号</tag>
      </tags>
  </entry>
  <entry>
    <title>系统编程之命令行编译</title>
    <url>/posts/a5aebc7b/</url>
    <content><![CDATA[<h2 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h2><p>本文将简单介绍在Linux系统下的命令行编译流程。介绍gcc、gdb、make等工具的简单使用。</p>
<h2 id="二、GCC"><a href="#二、GCC" class="headerlink" title="二、GCC"></a>二、GCC</h2><h3 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h3><h4 id="编译选项"><a href="#编译选项" class="headerlink" title="编译选项"></a>编译选项</h4><ul>
<li>无选项编译链接<ul>
<li>用法：gcc test.c<br>作用：将 test.c 预处理、编译、汇编并链接形成可执行文件。这里未指定输出文件，默认输出为 a.out。</li>
</ul>
</li>
<li>选项 -o<ul>
<li>用法：gcc test.c -o test<br>作用：将 test.c 预处理、编译、汇编并链接形成可执行文件 test。-o 选项用来指定输出文件的文件名。</li>
</ul>
</li>
<li>选项 -E<ul>
<li>用法：gcc -E test.c -o test.i<br>作用：将 test.c 预处理输出 test.i 文件。</li>
</ul>
</li>
<li>选项 -S<ul>
<li>用法：gcc -S test.i<br>作用：将预处理输出文件 test.i 编译成 test.s 文件。</li>
</ul>
</li>
<li>选项 -c<ul>
<li>用法：gcc -c test.s<br>作用：将汇编语言文件 test.s 汇编成目标代码 test.o 文件。</li>
</ul>
</li>
<li>无选项链接<ul>
<li>用法：gcc test.o -o test<br>作用：将目标代码文件 test.o 链接成最终可执行文件 test。</li>
</ul>
</li>
<li>选项 -O<ul>
<li>用法：gcc -O1 test.c -o test<br>作用：使用编译优化级别 1 编译程序。级别为 1~3，级别越大优化效果越好，但编译时间越长。</li>
</ul>
</li>
</ul>
<p>官方文档：<a href="https://gcc.gnu.org/">GCC, the GNU Compiler Collection</a></p>
<h4 id="搜索路径控制"><a href="#搜索路径控制" class="headerlink" title="搜索路径控制"></a>搜索路径控制</h4><ul>
<li>-I <strong>dir</strong>：将 <strong>dir</strong> 增加至头文件搜索路径</li>
<li>-L <strong>dir</strong>：将 <strong>dir</strong> 增加至库文件搜索路径</li>
<li>-l <strong>library</strong> 或 -l<strong>library</strong>：指定编译时搜索的库名</li>
</ul>
<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><h4 id="编译链接"><a href="#编译链接" class="headerlink" title="编译链接"></a>编译链接</h4><p>在这样的文件结构下：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">.</span><br><span class="line">├── include</span><br><span class="line">│   └── dog.h</span><br><span class="line">├── main.c</span><br><span class="line">├── v1</span><br><span class="line">│   └── dog.c</span><br><span class="line">└── v2</span><br><span class="line">    └── dog.c</span><br></pre></td></tr></table></figure></p>
<ul>
<li><p>将 <code>./main.c</code> 编译为 <code>./main.o</code>（仅编译）</p>
<blockquote>
<p>指令：gcc -I ./include -c main.c</p>
</blockquote>
</li>
<li><p>将 <code>./v1/dog.c</code> 编译为 <code>./v1/dog.o</code>（仅编译）</p>
<blockquote>
<p>指令：gcc -I ./include -c ./v1/dog.c -o ./v1/dog.o</p>
</blockquote>
</li>
<li><p>将 <code>./v2/dog.c</code> 编译为 <code>./v2/dog.o</code>（仅编译）</p>
<blockquote>
<p>指令：gcc -I ./include -c ./v2/dog.c -o ./v2/dog.o</p>
</blockquote>
</li>
<li><p>将 <code>./v1/dog.o</code> 与 <code>./main.o</code> 链接为 <code>./dog1</code></p>
<blockquote>
<p>指令：gcc main.o ./v1/dog.o -o dog1</p>
</blockquote>
</li>
<li><p>将 <code>./v2/dog.o</code> 与 <code>./main.o</code> 链接为 <code>./dog2</code></p>
<blockquote>
<p>指令：gcc main.o ./v2/dog.o -o dog2</p>
</blockquote>
</li>
</ul>
<h4 id="静态和动态库"><a href="#静态和动态库" class="headerlink" title="静态和动态库"></a>静态和动态库</h4><p>执行下面的命令：<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ar cr libdog.a ./v1/dog.o</span><br><span class="line">gcc -o main main.o -L. -ldog</span><br><span class="line">./main</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>第一条生成了一个名为libdog.a的静态库。<code>cr</code>意为“create and replace”，指如果库不存在则创建，如果存在则用新文件替换库中的同名文件。后接要生成的静态库名称，再之后接要添加入库中的文件。<br>第二条将第一条中生成的静态库与main.o文件链接，生成一个名为main的可执行文件。<code>-L</code>后跟地址表示将该地址添加到库文件的搜索路径，<code>-L.</code>表示将当前目录添加到搜索路径。<code>-l</code>指定编译时搜索的库名。</p>
</blockquote>
<p>再执行以下命令：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">ar cr libdog.a ./v2/dog.o</span><br><span class="line">./main</span><br></pre></td></tr></table></figure>
<p>两次运行main可执行文件结果相同。</p>
<blockquote>
<p>因为静态链接，程序在链接完成时就已确定。第二次只是更改了静态库本身，而没有改变链接后生成的可执行文件。</p>
</blockquote>
<hr>
<p>执行下面的命令</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">gcc -c -fPIC v1/dog.c -o v1/dog.o -I include</span><br><span class="line">gcc -c -fPIC v2/dog.c -o v2/dog.o -I include</span><br><span class="line">gcc -shared -fPIC -o libdog.so v1/dog.o</span><br><span class="line">gcc main.c libdog.so -o main -I include</span><br></pre></td></tr></table></figure>
<p>再将库文件路径设置为当前路径：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">LD_LIBRARY_PATH=.</span><br><span class="line"><span class="built_in">export</span> LD_LIBRARY_PATH</span><br></pre></td></tr></table></figure>
<p>执行 <code>./main</code>，之后再执行以下命令：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">gcc -shared -fPIC -o libdog.so v2/dog.o</span><br><span class="line">./main</span><br></pre></td></tr></table></figure>
<p>两次运行main可执行文件结果不同。</p>
<blockquote>
<p>引用动态库时，动态库的程序并不保存在可执行文件内部，而是在运行时才会动态地连接到程序中。</p>
</blockquote>
<h2 id="三、GDB"><a href="#三、GDB" class="headerlink" title="三、GDB"></a>三、GDB</h2><h3 id="基本操作-1"><a href="#基本操作-1" class="headerlink" title="基本操作"></a>基本操作</h3><ul>
<li>在使用 gcc 对程序编译时，需要<strong>加上-g 参数</strong>（产生调试信息）才能使 GDB 进行调试。</li>
<li>输入 help 命令获得帮助</li>
<li>输入 quit 或者按 Ctrl+D 组合键退出 GDB。</li>
<li>启动程序准备调试方法<ul>
<li>方法一：在执行 GDB 命令时加上要调试的可执行程序名称，如“GDB yourprogram”；</li>
<li>方法二：先输入 GDB，在 GDB 中输入 file yourprogram 加载需要调试的程序。最后使用 run 或者 r 命令开始执行，也可以使用 run parameter 方式传递参数</li>
</ul>
</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">命令</th>
<th style="text-align:center">命令缩写</th>
<th style="text-align:center">命令说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">list</td>
<td style="text-align:center">l</td>
<td style="text-align:center">显示多行源代码</td>
</tr>
<tr>
<td style="text-align:center">break</td>
<td style="text-align:center">b</td>
<td style="text-align:center">设置断点，程序运行到断点的位置会停下来</td>
</tr>
<tr>
<td style="text-align:center">info</td>
<td style="text-align:center">i</td>
<td style="text-align:center">描述程序运行的状态</td>
</tr>
<tr>
<td style="text-align:center">run</td>
<td style="text-align:center">r</td>
<td style="text-align:center">开始运行程序</td>
</tr>
<tr>
<td style="text-align:center">display</td>
<td style="text-align:center">disp</td>
<td style="text-align:center">跟踪查看某个变量，每次停下来都显示它的值</td>
</tr>
<tr>
<td style="text-align:center">step</td>
<td style="text-align:center">s</td>
<td style="text-align:center">执行下一条语句，若该语句为函数调用，则进入函数执行其第一条语句</td>
</tr>
<tr>
<td style="text-align:center">next</td>
<td style="text-align:center">n</td>
<td style="text-align:center">执行下一条语句，若该语句为函数调用，不会进入函数内部执行（即不会一步一步地调试函数内部语句）</td>
</tr>
<tr>
<td style="text-align:center">print</td>
<td style="text-align:center">p</td>
<td style="text-align:center">打印内部变量</td>
</tr>
<tr>
<td style="text-align:center">continue</td>
<td style="text-align:center">c</td>
<td style="text-align:center">继续程序的执行直到遇到下一个断点</td>
</tr>
<tr>
<td style="text-align:center">set var</td>
<td style="text-align:center"></td>
<td style="text-align:center">设置变量的值</td>
</tr>
<tr>
<td style="text-align:center">start</td>
<td style="text-align:center"></td>
<td style="text-align:center">开始执行程序，在 main 函数第一条语句前面停下</td>
</tr>
<tr>
<td style="text-align:center">file</td>
<td style="text-align:center"></td>
<td style="text-align:center">装入需要调试的文件</td>
</tr>
<tr>
<td style="text-align:center">kill</td>
<td style="text-align:center">k</td>
<td style="text-align:center">终止正在调试的程序</td>
</tr>
<tr>
<td style="text-align:center">watch</td>
<td style="text-align:center"></td>
<td style="text-align:center">监视变量值的变化</td>
</tr>
<tr>
<td style="text-align:center">backtrace</td>
<td style="text-align:center">bt</td>
<td style="text-align:center">查看函数调用的信息</td>
</tr>
<tr>
<td style="text-align:center">frame</td>
<td style="text-align:center">f</td>
<td style="text-align:center">查看栈帧</td>
</tr>
<tr>
<td style="text-align:center">quit</td>
<td style="text-align:center">q</td>
<td style="text-align:center">退出 GDB 环境</td>
</tr>
</tbody>
</table>
</div>
<p>GDB 的更多使用方法可以参阅<a href="http://sourceware.org/gdb/current/onlinedocs/gdb/"><strong>GDB User Manual</strong></a> (<a href="http://sourceware.org/gdb/current/onlinedocs/gdb.pdf">PDF</a>)</p>
<h3 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h3><p>当前文件夹下有test.c文件：<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> num;</span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Enter a positive integer: &quot;</span>);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;num);</span><br><span class="line">    &#125; <span class="keyword">while</span> (num &lt; <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> factorial;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= num; i++)</span><br><span class="line">        factorial = factorial * i;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d! = %d\n&quot;</span>, num, factorial);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>接下来对该文件进行调试。<br>按顺序执行如下操作：</p>
<p>（1）执行以下命令进入调试状态<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gcc -g test.c -o <span class="built_in">test</span></span><br><span class="line">gdb <span class="built_in">test</span></span><br></pre></td></tr></table></figure><br>（2）在 main 函数处设置断点<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">break</span> main</span><br></pre></td></tr></table></figure><br>（3）输入 <code>run</code> 命令开始程序<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Breakpoint 1, main () at test.c:2</span><br><span class="line">2	int <span class="function"><span class="title">main</span></span>() &#123;</span><br></pre></td></tr></table></figure><br>（4）多次输入 <code>next</code> 命令使程序运行到第 14 行,使用 print 命令打印 num 的值<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span> num</span><br></pre></td></tr></table></figure><br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="variable">$1</span> = 2</span><br></pre></td></tr></table></figure><br>（5）继续调试至程序第 15 行,使用 <code>print</code> 命令打印 factorial 的值<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span> factorial</span><br></pre></td></tr></table></figure><br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="variable">$2</span> = -17088</span><br></pre></td></tr></table></figure><br>（6）使用 <code>run</code> 命令再次调试程序</p>
<p>（7）在程序第 10 行加入断点<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">break</span> test.c:10</span><br></pre></td></tr></table></figure><br>（8）使用 <code>continue</code> 命令使程序运行到断点处</p>
<p>（9）使用 <code>next</code> 命令</p>
<p>（10）再次使用 <code>print</code> 命令打印 i 和 factorial 的值</p>
<p>（11）使用 <code>p factorial=1</code> 命令改变 factorial 的值</p>
<p>（12）使用 <code>info locals</code> 查看所有局部变量值<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">i = 1</span><br><span class="line">num = 2</span><br><span class="line">factorial = 1</span><br></pre></td></tr></table></figure><br>（13）继续调试至程序结束</p>
<blockquote>
<p>易知程序出错在没有初始化变量factorial</p>
<p>gdb能很好地展示程序的执行过程，方便查找出错的位置。</p>
</blockquote>
<h2 id="make"><a href="#make" class="headerlink" title="make"></a>make</h2><h3 id="基本操作-2"><a href="#基本操作-2" class="headerlink" title="基本操作"></a>基本操作</h3><h4 id="Makefile的格式"><a href="#Makefile的格式" class="headerlink" title="Makefile的格式"></a>Makefile的格式</h4><p>Makefile文件由一系列规则（rules）构成。每条规则的形式如下。<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&lt;target&gt; : &lt;prerequisites&gt; </span><br><span class="line">[tab]  &lt;commands&gt;</span><br></pre></td></tr></table></figure><br>第一行冒号前面的部分，叫做”目标”（target）；冒号后面的部分叫做”前置条件”（prerequisites）；第二行必须由一个tab键起首，后面跟着”命令”（commands）。</p>
<ul>
<li><p>目标</p>
<ul>
<li>一个目标（target）就构成一条规则。目标通常是文件名，指明Make命令所要构建的对象，比如上文的 a.txt 。目标可以是一个文件名，也可以是多个文件名，之间用空格分隔。</li>
<li>除了文件名，目标还可以是某个操作的名字，称为”伪目标”（phony target）。</li>
</ul>
</li>
<li><p>前置条件</p>
<ul>
<li>前置条件通常是一组文件名，之间用空格分隔。它指定了”目标”是否重新构建的判断标准：只要有一个前置文件不存在，或者有过更新（前置文件的last-modification时间戳比目标的时间戳新），”目标”就需要重新构建。</li>
</ul>
</li>
<li><p>命令</p>
<ul>
<li>命令（commands）表示如何更新目标文件，由一行或多行的Shell命令组成。它是构建”目标”的具体指令，它的运行结果通常就是生成目标文件。</li>
</ul>
</li>
</ul>
<h4 id="语法选述"><a href="#语法选述" class="headerlink" title="语法选述"></a>语法选述</h4><ul>
<li><p>注释</p>
<ul>
<li>井号（#）在Makefile中表示注释。</li>
</ul>
</li>
<li><p>模式匹配</p>
<ul>
<li>Make命令允许对文件名，进行类似正则运算的匹配，主要用到的匹配符是%。比如，假定当前目录下有 f1.c 和 f2.c 两个源码文件，需要将它们编译为对应的对象文件。<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">%.o: %.c</span><br></pre></td></tr></table></figure>
等同于下面的写法。<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">f1.o: f1.c</span><br><span class="line">f2.o: f2.c</span><br></pre></td></tr></table></figure>
使用匹配符%，可以将大量同类型的文件，只用一条规则就完成构建。</li>
</ul>
</li>
<li><p>通配符</p>
<ul>
<li>通配符（wildcard）用来指定一组符合条件的文件名。Makefile 的通配符与 Bash 一致</li>
</ul>
</li>
<li><p>依赖路径</p>
<ul>
<li>大写的VPATH或小写的vpath，表示搜索文件时的路径。写法例如<code>VPATH src:include:lib</code>表示在<code>./src</code> <code>./include</code> <code>./lib</code> 三个路径下寻找文件。<code>vpath %.c ./src</code>表示以.c结尾的文件在<code>./src</code>路径下寻找。</li>
</ul>
</li>
</ul>
<h3 id="示例-2"><a href="#示例-2" class="headerlink" title="示例"></a>示例</h3><p>当前文件夹下有如下结构：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">.</span><br><span class="line">├── include</span><br><span class="line">│   ├── dylib.h</span><br><span class="line">│   ├── fun1.h</span><br><span class="line">│   └── fun2.h</span><br><span class="line">├── lib</span><br><span class="line">│   └── libdy.so</span><br><span class="line">├── Makefile</span><br><span class="line">└── src</span><br><span class="line">    ├── fun1.c</span><br><span class="line">    ├── fun2.c</span><br><span class="line">    └── main.c</span><br></pre></td></tr></table></figure><br>将这些资源编译成一个可执行文件，在Makefile文件中写下：<br><figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">vpath</span> %.h ./<span class="keyword">include</span></span><br><span class="line"><span class="keyword">vpath</span> %.so ./lib</span><br><span class="line"><span class="keyword">vpath</span> %.c ./src</span><br><span class="line"></span><br><span class="line"><span class="section">main: main.o fun1.o fun2.o libdy.so</span></span><br><span class="line">    gcc <span class="variable">$^</span> -o main</span><br><span class="line"></span><br><span class="line"><span class="section">%.o: %.c</span></span><br><span class="line">    gcc <span class="variable">$^</span> -I <span class="keyword">include</span> -c</span><br><span class="line"></span><br><span class="line"><span class="meta"><span class="keyword">.PHONY</span>: clean</span></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">    rm *.o</span><br></pre></td></tr></table></figure><br>在终端中输入命令<code>make main</code>，即生成main文件（以及中间文件）。再输入<code>make clean</code>将中间文件删除。</p>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>系统编程</tag>
        <tag>GCC</tag>
        <tag>Makefile</tag>
      </tags>
  </entry>
  <entry>
    <title>系统编程之线程管理</title>
    <url>/posts/3fc6e65a/</url>
    <content><![CDATA[<h2 id="一、Linux-多线程简述"><a href="#一、Linux-多线程简述" class="headerlink" title="一、Linux 多线程简述"></a>一、Linux 多线程简述</h2><p>进程和线程的关系老生常谈。线程是最小的调度单位，进程是最小的资源分配单位。同一进程中的多个线程是在共享的内存空间中并发的多道执行路径，它们<strong>共享一个进程的资源</strong>。</p>
<p>对于Linux来说，Linux线程属于用户级线程，即线程的调度是在用户空间执行的。也就是说，Linux线程的实现是在内核之外的，多线程的概念对于内核来说并不是真实存在的，而只是通过线程库中的程序模拟的并发效果。</p>
<p>Linux线程遵循POSIX线程接口，称为pthread。pthread在其他平台也有对应的实现，如在windows。</p>
<h2 id="二、线程操作"><a href="#二、线程操作" class="headerlink" title="二、线程操作"></a>二、线程操作</h2><h3 id="（1）库的使用"><a href="#（1）库的使用" class="headerlink" title="（1）库的使用"></a>（1）库的使用</h3><p>在开始多线程编程之前，需要说明一下 pthread.h 库。在编译使用pthread.h库的代码时，一般需要加-lpthread。pthread在glibc2.34之前是在glibc里面的，之后分出来变成一个单独的库，因此有的情况下，不加-lpthread也能编译成功。</p>
<h3 id="（2）基本操作"><a href="#（2）基本操作" class="headerlink" title="（2）基本操作"></a>（2）基本操作</h3><ol>
<li><p>创建线程</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">pthread_create</span><span class="params">(<span class="type">pthread_t</span> _Nullable * _Nonnull __restrict,</span></span><br><span class="line"><span class="params">    <span class="type">const</span> <span class="type">pthread_attr_t</span> * _Nullable __restrict,</span></span><br><span class="line"><span class="params">    <span class="type">void</span> * _Nullable (* _Nonnull)(<span class="type">void</span> * _Nullable),</span></span><br><span class="line"><span class="params">    <span class="type">void</span> * _Nullable __restrict)</span>;</span><br></pre></td></tr></table></figure>
<p>该函数中第一个参数为指向一个线程标识变量的指针。第二个参数用来手动设置线程的各项属性，一般可以用NULL选择默认属性。第三个参数为一个函数指针，表示新建线程时需要执行的函数。注意该函数的参数类型和返回值类型，使用时需要进行强制类型转换。第四个参数为传递给函数的参数，也就是线程执行的函数的参数。不传递参数时可设置为NULL。<br>如下举一个创建线程的例子。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">pthread_t</span> tid;</span><br><span class="line"><span class="keyword">if</span> (pthread_create(&amp;tid, <span class="literal">NULL</span>, do_something, <span class="literal">NULL</span>)) </span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// error handler</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>线程退出</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">pthread_exit</span><span class="params">(<span class="type">void</span> *ral_ptr)</span>;</span><br></pre></td></tr></table></figure>
<p>当某一线程执行该函数时，会导致该线程结束。结束时会将ral_ptr指针传递给<code>pthread_join</code> 函数的 <code>rval_ptr</code></p>
</li>
<li><p>线程取消</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">pthread_cancel</span><span class="params">(<span class="type">pthread_t</span> tid)</span>;</span><br></pre></td></tr></table></figure>
<p>某一线程调用该函数，可以终止同一进程内的其他线程。 <code>tid</code> 即要终止的线程。</p>
</li>
<li><p>线程挂起</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">pthread_join</span><span class="params">(<span class="type">pthread_t</span> thread, <span class="type">void</span> **rval_ptr)</span>;</span><br></pre></td></tr></table></figure>
<p>某一线程调用该函数会阻塞该线程，直到参数 <code>thread</code> 所指示的线程退出。第二个参数为一个指向 <code>pthread_exit</code> 所设置的 <code>ral_ptr</code> 指针的指针。</p>
</li>
</ol>
<h2 id="三、线程的控制"><a href="#三、线程的控制" class="headerlink" title="三、线程的控制"></a>三、线程的控制</h2><p>多线程中，经常需要多个线程对同一资源进行访问。在这种情况下，保持访问的原子性以及确定访问的顺序就十分重要。互斥量和条件变量就是对线程进行控制的工具。</p>
<h3 id="（1）互斥量（mutex）"><a href="#（1）互斥量（mutex）" class="headerlink" title="（1）互斥量（mutex）"></a>（1）互斥量（mutex）</h3><p>互斥量的作用是避免对同一资源的同时访问。使用类似于信号量。只不过互斥量同时只能由一个线程持有。</p>
<ol>
<li><p>创建互斥量</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">pthread_mutex_init</span><span class="params">(<span class="type">pthread_mutex_t</span> *mutex, <span class="type">const</span> <span class="type">pthread_mutexattr_t</span> *attr)</span>;</span><br></pre></td></tr></table></figure>
<p>调用该函数初始化一个互斥量。第一个参数为一个指示互斥量的变量，第二个参数为互斥量的属性，一般可设为NULL。<br>互斥量的属性有如下几种：</p>
<ul>
<li><code>PTHREAD_MUTEX_TIMED_NP</code> 普通锁。当一个线程加锁以后，其余请求锁的线程将形成一个等待队列，并在解锁后按优先级获得锁。这种锁策略保证了资源分配的公平性</li>
<li><code>PTHREAD_MUTEX_RECURSIVE_NP</code> 嵌套锁，允许同一个线程对同一个锁成功获得多次，并通过多次unlock解锁。如果是不同线程请求，则在加锁线程解锁时重新竞<br>争</li>
<li><code>PTHREAD_MUTEX_ERRORCHECK_NP</code> 检错锁，如果同一个线程请求同一个锁，则返回EDEADLK，否则与PTHREAD_MUTEX_TIMED_NP类型动作相同。这样就保证当不允许多次加锁时不会出现最简单情况下的死锁</li>
<li><code>PTHREAD_MUTEX_ADAPTIVE_NP</code> 适应锁，动作最简单的锁类型，仅等待解锁后重新竞争</li>
</ul>
</li>
<li><p>加锁</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">pthread_mutex_lock</span><span class="params">(<span class="type">pthread_mutex_t</span> *mutex)</span>;</span><br></pre></td></tr></table></figure>
<p>调用该函数以对该互斥量进行加锁。加锁时，除获得锁的线程外，试图加锁的其他线程都会被阻塞，直到获得锁的线程进行解锁。</p>
</li>
<li><p>解锁</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">pthread_mutex_unlock</span><span class="params">(<span class="type">pthread_mutex_t</span> *mutex)</span>;</span><br></pre></td></tr></table></figure>
<p>调用该函数对互斥量进行解锁。没有获得锁的线程调用不会产生效果。</p>
</li>
<li><p>销毁互斥量</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">pthread_mutex_destroy</span><span class="params">(<span class="type">pthread_mutex_t</span> *mutex)</span>;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="（2）条件变量"><a href="#（2）条件变量" class="headerlink" title="（2）条件变量"></a>（2）条件变量</h3><p>条件变量与互斥量一起使用时，允许线程以无竞争的方式等待特定条件的发生。这类似于Java中的wait()和notify()。这能用于实现线程的同步和顺序执行。</p>
<ol>
<li><p>创建条件变量</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">pthread_cond_init</span><span class="params">(<span class="type">pthread_cond_t</span> *cond, <span class="type">pthread_condattr_t</span> *attr)</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>等待</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">pthread_cond_wait</span><span class="params">(<span class="type">pthread_cond_t</span> *cond, <span class="type">pthread_mutex_t</span> *mutex)</span>;</span><br></pre></td></tr></table></figure>
<p>调用该函数，可以使调用的线程陷入阻塞状态，直到该条件变量被通知。</p>
</li>
</ol>
<p>条件变量的等待需要与互斥量配合使用。在调用pthread_cond_wait前，需要使互斥量处于锁住状态。这样pthread_cond_wait函数可以以原子的方式，将调用<br>线程放到等待条件的线程列表上。</p>
<p>等待线程的操作顺序为：</p>
<ul>
<li>调用pthread_mutex_lock</li>
<li>调用pthread_cond_wait</li>
<li>调用pthread_mutex_unlock</li>
</ul>
<ol>
<li><p>通知</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">pthread_cond_signal</span><span class="params">(<span class="type">pthread_cond_t</span> *cond)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_cond_broadcast</span><span class="params">(<span class="type">pthread_cond_t</span> *)</span>;</span><br></pre></td></tr></table></figure>
<p><code>pthread_cond_signal</code> 和 <code>pthread_cond_broadcast</code> 都能唤醒因为调用 <code>pthread_cond_wait</code> 而陷入阻塞的线程，区别是 <code>pthread_cond_signal</code> 唤醒某一个等待该条件的线程， <code>pthread_cond_broadcast</code> 唤醒等待该条件的所有线程。</p>
</li>
<li><p>销毁条件变量</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">pthread_cond_destroy</span><span class="params">(<span class="type">pthread_cond_t</span> * cond)</span>;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="（3）代码实例——实现消费者模型"><a href="#（3）代码实例——实现消费者模型" class="headerlink" title="（3）代码实例——实现消费者模型"></a>（3）代码实例——实现消费者模型</h3><p>生产者消费者模型是条件变量最经典的使用场景之一，该问题描述了共享固定大小缓冲区的两个线程——即所谓的“生产者”和“消费者”——在实际运行时会发生的问题。生产者的主要作用是生成一定量的数据放到缓冲区中，然后重复此过程。与此同时，消费者也在缓冲区消耗这些数据。该问题的关键就是要保证生产者不会在缓冲区满时加入数据，消费者也不会在缓冲区中空时消耗数据。</p>
<p>生产者消费者问题主要要注意以下三点：</p>
<ul>
<li>在缓冲区为空时，消费者不能再进行消费</li>
<li>在缓冲区为满时，生产者不能再进行生产</li>
<li>在一个线程进行生产或消费时，其余线程不能再进行生产或消费等操作，即保持线程间的同步</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BUF_SIZE 20</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_STEP 5</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> T_SIZE 10</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> buf[BUF_SIZE];</span><br><span class="line"><span class="type">int</span> size = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> head = <span class="number">0</span>, top = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">pthread_mutex_t</span> mutex;</span><br><span class="line"><span class="type">pthread_cond_t</span> not_full, not_empty;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span>* <span class="title function_">consume</span><span class="params">(<span class="type">void</span> *vp)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> num = (<span class="type">int</span>)vp;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; MAX_STEP; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        pthread_mutex_lock(&amp;mutex);</span><br><span class="line">        <span class="keyword">while</span> (size == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            pthread_cond_wait(&amp;not_empty, &amp;mutex);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;consume %d, get %d\n&quot;</span>, num, buf[head]);</span><br><span class="line">        head = (head+<span class="number">1</span>)%BUF_SIZE;</span><br><span class="line">        size--;</span><br><span class="line">        pthread_mutex_unlock(&amp;mutex);</span><br><span class="line">        pthread_cond_signal(&amp;not_full);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span>* <span class="title function_">product</span><span class="params">(<span class="type">void</span> *vp)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> num = (<span class="type">int</span>)vp;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; MAX_STEP; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        pthread_mutex_lock(&amp;mutex);</span><br><span class="line">        <span class="keyword">while</span> (size == BUF_SIZE)</span><br><span class="line">        &#123;</span><br><span class="line">            pthread_cond_wait(&amp;not_full, &amp;mutex);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> r = rand() % <span class="number">20</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;product %d, send %d\n&quot;</span>, num, r);</span><br><span class="line">        buf[top] = r;</span><br><span class="line">        top = (top+<span class="number">1</span>)%BUF_SIZE;</span><br><span class="line">        size++;</span><br><span class="line">        pthread_mutex_unlock(&amp;mutex);</span><br><span class="line">        pthread_cond_signal(&amp;not_empty);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    pthread_mutex_init(&amp;mutex, <span class="literal">NULL</span>);</span><br><span class="line">    pthread_cond_init(&amp;not_empty, <span class="literal">NULL</span>);</span><br><span class="line">    pthread_cond_init(&amp;not_full, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">pthread_t</span> c[T_SIZE], p[T_SIZE];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; T_SIZE; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        pthread_create(c+i, <span class="literal">NULL</span>, consume, (<span class="type">void</span>*)i);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; T_SIZE; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        pthread_create(p+i, <span class="literal">NULL</span>, product, (<span class="type">void</span>*)i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; T_SIZE; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        pthread_join(c[i], <span class="literal">NULL</span>);</span><br><span class="line">        pthread_join(p[i], <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>一次执行的结果：</strong><br><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">product 0, send 3</span><br><span class="line">consume 0, get 3</span><br><span class="line">product 0, send 6</span><br><span class="line">product 0, send 17</span><br><span class="line">consume 2, get 6</span><br><span class="line">consume 2, get 17</span><br><span class="line">product 0, send 15</span><br><span class="line">product 0, send 13</span><br><span class="line">consume 4, get 15</span><br><span class="line">consume 4, get 13</span><br><span class="line">product 1, send 15</span><br><span class="line">consume 5, get 15</span><br><span class="line">product 4, send 6</span><br><span class="line">product 5, send 12</span><br><span class="line">product 5, send 9</span><br><span class="line">consume 8, get 6</span><br><span class="line">consume 8, get 12</span><br><span class="line">consume 8, get 9</span><br><span class="line">product 2, send 1</span><br><span class="line">consume 6, get 1</span><br><span class="line">product 4, send 2</span><br><span class="line">product 7, send 7</span><br><span class="line">product 7, send 10</span><br><span class="line">product 7, send 19</span><br><span class="line">product 7, send 3</span><br><span class="line">product 7, send 6</span><br><span class="line">consume 2, get 2</span><br><span class="line">consume 2, get 7</span><br><span class="line">consume 2, get 10</span><br><span class="line">consume 4, get 19</span><br><span class="line">consume 4, get 3</span><br><span class="line">consume 4, get 6</span><br><span class="line">product 2, send 0</span><br><span class="line">product 2, send 6</span><br><span class="line">product 2, send 12</span><br><span class="line">product 5, send 16</span><br><span class="line">consume 8, get 0</span><br><span class="line">consume 8, get 6</span><br><span class="line">consume 9, get 12</span><br><span class="line">consume 9, get 16</span><br><span class="line">product 6, send 11</span><br><span class="line">product 1, send 8</span><br><span class="line">product 3, send 7</span><br><span class="line">consume 0, get 11</span><br><span class="line">consume 0, get 8</span><br><span class="line">consume 0, get 7</span><br><span class="line">product 2, send 9</span><br><span class="line">consume 7, get 9</span><br><span class="line">product 8, send 2</span><br><span class="line">consume 1, get 2</span><br><span class="line">product 4, send 10</span><br><span class="line">consume 3, get 10</span><br><span class="line">product 4, send 2</span><br><span class="line">product 4, send 3</span><br><span class="line">product 8, send 7</span><br><span class="line">product 9, send 15</span><br><span class="line">consume 6, get 2</span><br><span class="line">consume 6, get 3</span><br><span class="line">consume 6, get 7</span><br><span class="line">consume 6, get 15</span><br><span class="line">product 6, send 9</span><br><span class="line">product 6, send 2</span><br><span class="line">product 6, send 2</span><br><span class="line">product 6, send 18</span><br><span class="line">consume 3, get 9</span><br><span class="line">consume 3, get 2</span><br><span class="line">consume 3, get 2</span><br><span class="line">consume 3, get 18</span><br><span class="line">product 1, send 9</span><br><span class="line">product 1, send 7</span><br><span class="line">product 1, send 13</span><br><span class="line">consume 1, get 9</span><br><span class="line">consume 1, get 7</span><br><span class="line">consume 1, get 13</span><br><span class="line">product 3, send 16</span><br><span class="line">consume 7, get 16</span><br><span class="line">product 3, send 11</span><br><span class="line">product 3, send 2</span><br><span class="line">product 3, send 9</span><br><span class="line">consume 1, get 11</span><br><span class="line">consume 5, get 2</span><br><span class="line">product 5, send 13</span><br><span class="line">product 5, send 1</span><br><span class="line">consume 0, get 9</span><br><span class="line">consume 5, get 13</span><br><span class="line">consume 5, get 1</span><br><span class="line">product 9, send 19</span><br><span class="line">consume 5, get 19</span><br><span class="line">product 9, send 4</span><br><span class="line">consume 9, get 4</span><br><span class="line">product 9, send 17</span><br><span class="line">consume 9, get 17</span><br><span class="line">product 9, send 18</span><br><span class="line">consume 9, get 18</span><br><span class="line">product 8, send 4</span><br><span class="line">consume 7, get 4</span><br><span class="line">product 8, send 15</span><br><span class="line">consume 7, get 15</span><br><span class="line">product 8, send 10</span><br><span class="line">consume 7, get 10</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>系统编程</tag>
        <tag>线程</tag>
      </tags>
  </entry>
  <entry>
    <title>系统编程之进程管理</title>
    <url>/posts/7ab376c3/</url>
    <content><![CDATA[<h2 id="一、引言"><a href="#一、引言" class="headerlink" title="一、引言"></a>一、引言</h2><p>进程是操作系统中的重要概念，是对执行一定功能的程序的过程的抽象。这篇文章将简要说明进程的相关知识。介绍进程管理相关的函数，并通过这些函数实现重定向和进程间通信等功能。</p>
<h2 id="二、进程简介"><a href="#二、进程简介" class="headerlink" title="二、进程简介"></a>二、进程简介</h2><h3 id="1-程序执行原理"><a href="#1-程序执行原理" class="headerlink" title="1. 程序执行原理"></a>1. 程序执行原理</h3><p>程序在编译后以二进制方式存在于外存上，执行的时候被操作系统载入内存。以 Linux 系统上的 C 语言编译出来的程序为例，载入的过程简单来说就是把编译完成的 ELF （Executable and Linkable Format 可执行与可链接格式） 文件的几个段的内容读取到内存指定位置，然后初始化寄存器的内容，将指令寄存器（比如<code>cs:ip</code>）指向程序入口，再初始化一些进程相关内容就完成了。</p>
<p>在某一次时钟中断发生的时候，进程主动陷入内核态，进行进程切换的系统调用，CPU 将切换到另一个进程工作。<strong>总而言之，整个计算机从开机到关机，就是一个不断创建、切换、终止进程的过程。</strong></p>
<h3 id="2-进程概念的用途"><a href="#2-进程概念的用途" class="headerlink" title="2. 进程概念的用途"></a>2. 进程概念的用途</h3><p>早期的计算机一次只能执行一个程序，这种程序完全控制系统，并且访问所有系统资源。相比之下，现代计算机系统允许“同时”加载多个应用程序到内存，以便并发（轮流）执行。</p>
<p>这种改进要求对各种程序提供更严的控制和更好的划分。这些需求导致了<strong>进程</strong>概念的诞生。</p>
<p>进程是现代分时操作系统的工作单元，是操作系统向运行中的程序进行资源分配的单位。进程包括程序代码(文本)，当前活动(程序计数器，寄存器的值)，堆栈，数据端，堆。</p>
<blockquote>
<p>需要注意区分程序和进程的概念。程序是被动实体，如存储在磁盘上的可执行文件；进程是活动实体，具有一个程序计数器用于表示下个执行命令和一组相关资源。</p>
<p>当一个可执行文件被加载到内存时，这个程序就成为进程。</p>
<p>两个进程可以与同一程序相关联，但当作两个单独的执行序列，虽然文本段相同，但是数据、堆、堆栈不同。</p>
</blockquote>
<h2 id="三-进程管理"><a href="#三-进程管理" class="headerlink" title="三. 进程管理"></a>三. 进程管理</h2><p>接下来介绍使用操作系统 API 进行进程管理的方法。</p>
<h3 id="1-使用-fork-创建新进程"><a href="#1-使用-fork-创建新进程" class="headerlink" title="1. 使用 fork 创建新进程"></a>1. 使用 fork 创建新进程</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">fork</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure>
<p><code>fork</code> 无参数，返回一个用于指示子进程的 <code>pid</code>（对于子进程，返回值为 0）。其作用是创建一个子进程，共享父进程所有内容，并且这个子进程会接着 <code>fork</code> 下面的代码继续执行。<code>fork</code>有以下两种用法：</p>
<ul>
<li>一个父进程希望复制自己，使父进程和子进程同时执行不同的代码段。</li>
<li>一个进程要执行一个不同的程序。在这种情况下，子进程从<code>fork</code>返回后立即调用<code>exec</code>。</li>
</ul>
<p>如果在调用 <code>fork</code> 后子进程先于父进程结束，则子进程就会变为僵尸进程，虽然结束，却依然占据了进程表中的一个位置。为了避免这种情况，需要调用 <code>wait</code> 或 <code>waitpid</code> 来使父进程等待子进程结束，并释放子进程的信息。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">wait</span><span class="params">(<span class="type">int</span> *status)</span>;</span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">waitpid</span><span class="params">(<span class="type">pid_t</span> pid,<span class="type">int</span> *status,<span class="type">int</span> options)</span>;</span><br></pre></td></tr></table></figure>
<p>下面将以一个程序作为例子。该程序由父进程创建两个子进程，父进程打印字符 B ，两个子进程分别打印 A 和 C ，并且要使最终的输出为 ABC 。<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">pid_t</span> pid1 = fork();</span><br><span class="line">    <span class="keyword">if</span> (pid1 == <span class="number">0</span>) <span class="comment">// child1</span></span><br><span class="line">    &#123;</span><br><span class="line">    	<span class="built_in">printf</span>(<span class="string">&quot;A&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="comment">// parent</span></span><br><span class="line">    &#123;</span><br><span class="line">        wait(<span class="literal">NULL</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;B&quot;</span>);</span><br><span class="line">        fflush(<span class="built_in">stdout</span>);</span><br><span class="line">        <span class="type">pid_t</span> pid2 = fork();</span><br><span class="line">        <span class="keyword">if</span> (pid2 == <span class="number">0</span>) <span class="comment">// child2</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;C&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="comment">// parent</span></span><br><span class="line">        &#123;</span><br><span class="line">            wait(<span class="literal">NULL</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><strong>代码说明：</strong> 在该程序中，我们先调用 <code>fork</code> 创建了一个子进程，通过 pid 的数值来区分父子进程。对子进程来说，打印字符 A，对父进程来说，调用 <code>wait</code> 等待子进程结束，随后父进程打印字符 B。（注意这里使用 <code>fflush</code> 刷新了缓冲区，这是因为调用 <code>fork</code> 进行进程复制也会将缓冲区的内容进行复制，没有在此之前刷新缓冲区会导致字符 B 输出两次）接着，类似的，我们根据 pid 判断父子进程，并在子进程中打印字符 C。父进程调用 <code>wait</code> 等待子进程结束，最后退出程序。</p>
<h3 id="2-exec族函数"><a href="#2-exec族函数" class="headerlink" title="2. exec族函数"></a>2. exec族函数</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">execl</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname, <span class="type">const</span> <span class="type">char</span> *arg0, ... <span class="comment">/* (char *)0 */</span>)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">execv</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname, <span class="type">char</span> *<span class="type">const</span> argv[])</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">execle</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname, <span class="type">const</span> <span class="type">char</span> *arg0, ...<span class="comment">/* (char *)0, char *const envp[] */</span>)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">execve</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname, <span class="type">char</span> *<span class="type">const</span> argv[], <span class="type">char</span> *<span class="type">const</span> envp[])</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">execlp</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *filename, <span class="type">const</span> <span class="type">char</span> *arg0, ... <span class="comment">/* (char *)0 */</span>)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">execvp</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *filename, <span class="type">char</span> *<span class="type">const</span> argv[])</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">fexecve</span><span class="params">(<span class="type">int</span> fd, <span class="type">char</span> *<span class="type">const</span> argv[], <span class="type">char</span> *<span class="type">const</span> envp[])</span>;</span><br><span class="line"><span class="comment">// 第一个参数使用的是打开的文件描述符，而非文件路径名</span></span><br></pre></td></tr></table></figure>
<p>exec 函数族的作用是根据指定的文件名找到可执行文件，并用它来取代调用进程的内容换句话说，就是在调用进程内部执行一个可执行文件。这里的可执行文件既可以是二进制文件，也可以是任何 Linux 下可执行的脚本文件。与一般情况不同，exec 函数族的函数执行成功后不会返回，因为调用进程的实体，包括代码段，数据段和堆栈等都已经被新的内容取代，只留下进程 ID 等一些表面上的信息仍保持原样。只有调用失败了，它们才会返回一个 -1，从原程序的调用点接着往下执行。</p>
<p>这几个函数的用法大体上是一致的，只是参数格式有所不同。</p>
<ul>
<li>“ l “ 代表 list 即列表，对应可变参数<code>argv</code> 以列表的形式出现</li>
<li>“ v “ 代表 vector 即矢量数组，对应可变参数<code>argv</code>以数组的形式出现</li>
<li>“ e “ 代表 environment ，对应 <code>envp</code>数组，是指给可执行文件指定环境变量。在全部 7 个函数中，只有<code>execle</code>、<code>execve</code>和<code>fexecve</code>使用了<code>char *envp[]</code>传递环境变量，其它的 4 个函数都没有这个参数，这并不意味着它们不传递环境变量，这 4 个函数将把默认的环境变量不做任何修改地传给被执行的应用程序。而它们用指定的环境变量去替代默认的那些。</li>
<li>“ p “ 代表 环境变量 PATH ,字母 p 是指在环境变量 PATH 的目录里去查找要执行的可执行文件。2 个以 p 结尾的函数<code>execlp</code>和<code>execvp</code>，看起来，和<code>execl</code>与<code>execv</code>的差别很小，事实也如此，它们的区别从第一个参数名可以看出：除 <code>execlp</code>和<code>execvp</code>之外的 4 个函数都要求，它们的第 1 个参数 path 必须是一个完整的路径，如”/bin/ls”；而<code>execlp</code>和<code>execvp</code> 的第 1 个参数 file 可以仅仅只是一个文件名，如”ls”，这两个函数可以自动到环境变量 PATH 指定的目录里去查找。</li>
</ul>
<blockquote>
<p><strong>注意：</strong></p>
<ul>
<li>当进程调用一种<code>exec</code>函数时，该进程执行的程序完全替换为新程序，而新程序从其<code>main</code>函数开始执行。</li>
<li>调用<code>exec</code>并不创建新进程，前后的进程 ID 并未改变，<code>exec</code>只是用磁盘上的一个新程 序替换了当前进程的正文段、数据段、堆段和栈段。</li>
<li>在很多 UNIX 实现中，<strong>这<code>7</code>个函数只有<code>execve</code>是内核的系统调用</strong>，另外<code>6</code>个只 是库函数，它们最终都要调用该系统调用。</li>
</ul>
</blockquote>
<p>如下的实例程序会对当前目录使用<code>ls -l</code>。<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    execlp(<span class="string">&quot;ls&quot;</span>, <span class="string">&quot;ls&quot;</span>, <span class="string">&quot;-l&quot;</span>, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>请注意，使用 <code>execlp</code> 及类似函数时，arg0 应为调用的程序名。在可变参数的末尾要加上 NULL</p>
</blockquote>
<h3 id="3-dup重定向"><a href="#3-dup重定向" class="headerlink" title="3. dup重定向"></a>3. dup重定向</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">dup</span><span class="params">(<span class="type">int</span> oldfd)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">dup2</span><span class="params">(<span class="type">int</span> oldfd, <span class="type">int</span> newfd)</span>;</span><br></pre></td></tr></table></figure>
<p>使用 <code>dup</code> 和 <code>dup2</code> 函数可以复制一个现存的文件描述符。从而实现输入输出的重定向。</p>
<ul>
<li><code>dup</code> 用来复制参数oldfd所指的文件描述符。当复制成功是，返回最小的尚未被使用过的文件描述符。</li>
<li><code>dup2</code> 与 <code>dup</code> 区别是 <code>dup2</code> 可以用参数 <code>newfd</code> 指定新文件描述符的数值。若参数 <code>newfd</code> 已经被程序使用，则系统就会将 <code>newfd</code> 所指的文件关闭，若 <code>newfd</code> 等于 <code>oldfd</code>，则返回 <code>newfd</code>，而不关闭 <code>newfd</code> 所指的文件。</li>
</ul>
<p>如下程序将 <code>printf</code> 的输出内容重定向到 redirect.txt。<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> filefd = open(<span class="string">&quot;redirect.txt&quot;</span>, O_CREAT|O_RDWR, <span class="number">777</span>);</span><br><span class="line">    <span class="type">int</span> redirectfd = dup2(filefd, <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;hahaha~~&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="4-管道"><a href="#4-管道" class="headerlink" title="4. 管道"></a>4. 管道</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pipe</span><span class="params">(<span class="type">int</span> pipefd[<span class="number">2</span>])</span>;</span><br></pre></td></tr></table></figure>
<p>管道是最基本的进程通信机制，可以想象成一个管道，两端分别连着 2 个进程，一个进程往里面写，一个进程从里面读。如果读或写管道的时候没有内容可供读或写，进程将被阻塞，直到有内容可供读写为止。</p>
<p>管道分为匿名管道和命名管道，这里只介绍匿名管的。匿名管道创建后本质上是 2 个文件描述符，父子进程分别持有就能够使用管道，需要注意的是不能够共用匿名管道，也就是除了使用的进程，其他进程需要关闭文件描述符，保证管道 的 2 个描述符分别同时只有 1 个进程持有。</p>
<p>下面是在父子进程间使用管道的例子（父进程写，子进程读）：<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> fd[<span class="number">2</span>];</span><br><span class="line">    pipe(fd);</span><br><span class="line">    <span class="type">pid_t</span> pid = fork();</span><br><span class="line">    <span class="keyword">if</span> (pid == <span class="number">0</span>) <span class="comment">// child</span></span><br><span class="line">    &#123;</span><br><span class="line">        close(fd[<span class="number">1</span>]);</span><br><span class="line">        <span class="comment">// do something to read with fd[0]</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        close(fd[<span class="number">0</span>]);</span><br><span class="line">        <span class="comment">// do something to write with fd[1]</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>需要注意的是，调用 <code>pipe</code> 应该在 <code>fork</code> 之前。</p>
</blockquote>
<p>接下来是一个利用进程实现素数筛的程序<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> numRead[<span class="number">1000</span>];</span><br><span class="line">    <span class="type">int</span> readCnt = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> numWrite[<span class="number">1000</span>];</span><br><span class="line">    <span class="keyword">if</span> (argc &gt; <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">    	<span class="type">int</span> input;</span><br><span class="line">    	<span class="built_in">sscanf</span>(argv[<span class="number">1</span>], <span class="string">&quot;%d&quot;</span>, &amp;input);</span><br><span class="line">    	readCnt = input<span class="number">-1</span>;</span><br><span class="line">    	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= input; i++)</span><br><span class="line">    		numRead[i<span class="number">-2</span>] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">pid_t</span> pid;</span><br><span class="line">    <span class="type">int</span> fds[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">    &#123;</span><br><span class="line">    	pipe(fds);</span><br><span class="line">    	pid = fork();</span><br><span class="line">    	<span class="keyword">if</span> (pid == <span class="number">0</span>) <span class="comment">// child</span></span><br><span class="line">    	&#123;</span><br><span class="line">    		close(fds[<span class="number">1</span>]);</span><br><span class="line">    		<span class="type">int</span> fdRead = fds[<span class="number">0</span>];</span><br><span class="line">    		readCnt = read(fdRead, numRead, <span class="keyword">sizeof</span>(numRead)) / <span class="number">4</span>;</span><br><span class="line">    		<span class="keyword">if</span> (readCnt == <span class="number">1</span> &amp;&amp; numRead[<span class="number">0</span>] == <span class="number">-1</span>)</span><br><span class="line">    			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    	&#125;</span><br><span class="line">    &#125;<span class="keyword">while</span>(pid == <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    close(fds[<span class="number">0</span>]);</span><br><span class="line">    <span class="type">int</span> fdWrite = fds[<span class="number">1</span>];</span><br><span class="line">    <span class="type">int</span> prime = numRead[<span class="number">0</span>];</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, prime);</span><br><span class="line">    fflush(<span class="built_in">stdout</span>);</span><br><span class="line">    <span class="type">int</span> writeCnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; readCnt; i++)</span><br><span class="line">    &#123;</span><br><span class="line">    	<span class="keyword">if</span> (numRead[i] % prime != <span class="number">0</span>)</span><br><span class="line">    		numWrite[writeCnt++] = numRead[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (writeCnt == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">    	fflush(<span class="built_in">stdout</span>);</span><br><span class="line">    	numWrite[<span class="number">0</span>] = <span class="number">-1</span>;</span><br><span class="line">    	write(fdWrite, numWrite, <span class="number">4</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    	write(fdWrite, numWrite, <span class="number">4</span> * writeCnt);</span><br><span class="line"></span><br><span class="line">    wait(<span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><strong>原理如下：</strong></p>
<blockquote>
<p>Eratosthenes的筛选法可以通过执行以下伪代码来模拟：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">p = get a number from left neighbor</span><br><span class="line">print p</span><br><span class="line">loop:</span><br><span class="line">    n = get a number from left neighbor</span><br><span class="line">    if (p does not divide n)</span><br><span class="line">        send n to right neighbor</span><br><span class="line">p = 从左邻居中获取一个数</span><br><span class="line">print p</span><br><span class="line">loop:</span><br><span class="line">    n = 从左邻居中获取一个数</span><br><span class="line">    if (n不能被p整除)</span><br><span class="line">        将n发送给右邻居</span><br></pre></td></tr></table></figure>
<p>生成进程可以将数字2、3、4、…、1000输入管道的左端：行中的第一个进程消除2的倍数，第二个进程消除3的倍数，第三个进程消除5的倍数，依此类推。</p>
</blockquote>
<img src="/posts/7ab376c3/p1.png" class="" title="Eratosthenes">]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>系统编程</tag>
        <tag>进程</tag>
      </tags>
  </entry>
  <entry>
    <title>系统编程之进程间通信</title>
    <url>/posts/c41aa3a/</url>
    <content><![CDATA[<h2 id="一、进程间通信简述"><a href="#一、进程间通信简述" class="headerlink" title="一、进程间通信简述"></a>一、进程间通信简述</h2><p>进程是程序的一次运行的动态过程，为了完成一个任务，很多进程之间需要进行通信，从而相互合作以实现需要的功能。操作系统内核中提供了进程间通信的方法，主要有以下几种：</p>
<ol>
<li>管道：<br>管道是最基本的进程通信机制，可以想象成一个管道，两端分别连着 2 个进程，一个进程往里面写，一个进程从里面读。如果读或写管道的时候没有内容可供读或写，进程将被阻塞，直到有内容可供读写为止。</li>
<li>消息队列：<br>消息队列本质上在内核空间中开辟了一块内存空间，这块内存是其他进程可以访问到的，在其中使用链表的方式实现了一个队列，进程可以向该队列中发送数据块或读取数据块，从而达到进程间通信的目的。其中每个数据块包含两部分，首先是一个类型为 long 的 type，然后是具体的数据，数据块的 type 可以作为进程之间相互约定好的协议。例如一个进程发送 type 为<code>123</code>的消息，另一个进程接收 type 为<code>123</code> 的消息，后者便可确认这就是前者发送的信息，并信任该数据块中的数据。</li>
<li>信号量：<br>不同进程之间存在对资源的竞争，信号量就是用来标明可用资源的数量的数据结构，本质是为了实现多个进程之间的同步。需要注意，信号量（semaphore）与 “信号”（signal）没有关系。</li>
<li>共享内存：<br>共享内存的本质就是把两个或多个进程的虚拟地址映射到同一块物理内存。这样，一个进程通过对这块内存的读写就能被其他进程访问到，从而实现进程间通信的功能。</li>
</ol>
<h2 id="二、进程间通信操作"><a href="#二、进程间通信操作" class="headerlink" title="二、进程间通信操作"></a>二、进程间通信操作</h2><h3 id="（1）准备操作"><a href="#（1）准备操作" class="headerlink" title="（1）准备操作"></a>（1）准备操作</h3><h4 id="获取-key"><a href="#获取-key" class="headerlink" title="获取 key"></a>获取 key</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="type">key_t</span> <span class="title function_">ftok</span><span class="params">( <span class="type">const</span> <span class="type">char</span> * fname, <span class="type">int</span> id )</span>;</span><br></pre></td></tr></table></figure>
<p>共享内存，消息队列，信号量等进程间通信方式都需要寻找一个中间介质来进行通信。不同的介质需要用不同的信息来进行区分，这就是进程间通信的 key。<code>ftok()</code> 函数就可以生成一个唯一的 key，该函数获取一个文件路径和一个字序号，生成一个用于区分的 key。</p>
<blockquote>
<p>注意，选择文件路径只是因为文件的编号是独有的。设置的文件路径与代码和程序并没有什么关系。</p>
</blockquote>
<h4 id="命令管理进程间通信"><a href="#命令管理进程间通信" class="headerlink" title="命令管理进程间通信"></a>命令管理进程间通信</h4><p>若没有调用控制函数进行删除，则已分配的进程间通信不会自动释放。如果共享内存，消息队列，信号量在新进程执行时依旧有之前残留的信息，可能导致程序运行结果错误。可以通过 <code>ipcs</code> 和 <code>ipcrm</code> 命令进行管理。<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ipcs # 显示所有进程间通信信息</span><br><span class="line">ipcrm -q MsgID # 删除消息队列</span><br><span class="line">ipcrm -s SemID # 删除信号量</span><br><span class="line">ipcrm -m ShrID # 删除共享内存</span><br></pre></td></tr></table></figure></p>
<h3 id="（2）消息队列"><a href="#（2）消息队列" class="headerlink" title="（2）消息队列"></a>（2）消息队列</h3><h4 id="消息队列获取"><a href="#消息队列获取" class="headerlink" title="消息队列获取"></a>消息队列获取</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/msg.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">msgget</span><span class="params">(<span class="type">key_t</span>, key, <span class="type">int</span> msgflg)</span>;</span><br></pre></td></tr></table></figure>
<p><code>msgget</code> 函数返回获得的消息队列的标识符，出错时返回-1，错误内容存于error中。<br><code>key</code> 获取消息队列的标识，取 <code>IPC_PRIVATE</code> 时会建立当前进程内的消息队列。<br><code>msgflg</code> 设置消息队列的访问权限和模式，如 <code>0666|IPC_CREAT</code>。</p>
<h4 id="消息队列控制"><a href="#消息队列控制" class="headerlink" title="消息队列控制"></a>消息队列控制</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/msg.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">msgctl</span><span class="params">(<span class="type">int</span> msqid, <span class="type">int</span> cmd, <span class="keyword">struct</span> msqid_ds *buf)</span>;</span><br></pre></td></tr></table></figure>
<p><code>msgctl</code> 函数获取和设置消息队列的属性。<br><code>msqid</code> 为消息队列标识符；<code>cmd</code> 获取该函数的行为，如 <code>IPC_STAT</code> 获取消息队列的属性，<code>IPC_SET</code> 设置消息队列的属性。<br><code>buf</code> 为保存消息队列属性的结构体。</p>
<h4 id="消息队列消息收发"><a href="#消息队列消息收发" class="headerlink" title="消息队列消息收发"></a>消息队列消息收发</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/msg.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">msgsnd</span><span class="params">(<span class="type">int</span> msqid, <span class="type">const</span> <span class="type">void</span> *msgp, <span class="type">size_t</span> msgsz, <span class="type">int</span> msgflg)</span>;</span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">msgrcv</span><span class="params">(<span class="type">int</span> msqid, <span class="type">void</span> *msgp, <span class="type">size_t</span> msgsz, <span class="type">long</span> msgtyp, <span class="type">int</span> msgflg)</span>;</span><br></pre></td></tr></table></figure>
<p><code>msgp</code> 获取要传递和接收的消息，它必须是一个结构体，包括一个 long 型的 mtype 和一个数组，如下<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msgbuf</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">long</span> mtype;</span><br><span class="line">    <span class="type">char</span> mtext[MAX_TEXT_LEN];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><code>msgsz</code> 是 <code>mtext</code> 的字节数；<br><code>msgflg</code> 获取发送和接受信息的方法，如 <code>IPC_NOWAIT</code> <code>IPC_EXCEPT</code> <code>IPC_NOERROR</code>，设置为 0 将采取默认阻塞的方式。<br><code>msgtyp</code> 设定要接收消息的 <code>mtype</code>。若值等于0则接受在队列首的消息，值大于0则接受类型等于该值的第一个消息，值小于0则接收类型小于等于该值绝对值的第一个消息。</p>
<h4 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h4><p>如下程序实现客户端进程和服务器进程，通过<strong>消息队列</strong>进行通信。客户端进程接受用户从终端的输入，并通过 Up 消息队列将消息传递给服务器进程，然后等待服务器进程从 Down 消息队列传回消息。服务器进程从 Up 接收到消息后<strong>将大小写字母转换</strong>，并通过 Down 传回给客户端进程，客户端随后输出转换后的消息。（例如：客户端通过 Up 发送’linuX’, 将从 Down 接收到’LINUx’）。<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// server.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/msg.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctype.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXLEN 1000</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msgbuf</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">long</span> mtype;</span><br><span class="line">    <span class="type">char</span> mtext[<span class="number">1000</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">key_t</span> upkey = ftok(<span class="string">&quot;.&quot;</span>, <span class="number">10</span>);</span><br><span class="line">    <span class="type">key_t</span> downkey = ftok(<span class="string">&quot;.&quot;</span>, <span class="number">20</span>);</span><br><span class="line">    <span class="type">int</span> length = <span class="keyword">sizeof</span>(<span class="keyword">struct</span> msgbuf) - <span class="keyword">sizeof</span>(<span class="type">long</span>);</span><br><span class="line">    <span class="type">int</span> upqid = msgget(upkey, <span class="number">0666</span>|IPC_CREAT);</span><br><span class="line">    <span class="type">int</span> downqid = msgget(downkey, <span class="number">0666</span>|IPC_CREAT);</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">msgbuf</span> <span class="title">buf</span>;</span></span><br><span class="line">        msgrcv(upqid, &amp;buf, length, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; buf.mtext[i] != <span class="string">&#x27;\0&#x27;</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">isupper</span>(buf.mtext[i]))</span><br><span class="line">                buf.mtext[i] = <span class="built_in">tolower</span>(buf.mtext[i]);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">islower</span>(buf.mtext[i]))</span><br><span class="line">                buf.mtext[i] = <span class="built_in">toupper</span>(buf.mtext[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        msgsnd(downqid, &amp;buf, length, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// client.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/msg.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXLEN 1000</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msgbuf</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">long</span> mtype;</span><br><span class="line">    <span class="type">char</span> mtext[MAXLEN];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">msgbuf</span> <span class="title">buf</span>;</span></span><br><span class="line">    <span class="type">key_t</span> upkey = ftok(<span class="string">&quot;.&quot;</span>, <span class="number">10</span>);</span><br><span class="line">    <span class="type">key_t</span> downkey = ftok(<span class="string">&quot;.&quot;</span>, <span class="number">20</span>);</span><br><span class="line">    <span class="type">int</span> length = <span class="keyword">sizeof</span>(<span class="keyword">struct</span> msgbuf) - <span class="keyword">sizeof</span>(<span class="type">long</span>);</span><br><span class="line">    <span class="type">int</span> upqid = msgget(upkey, <span class="number">0666</span>|IPC_CREAT);</span><br><span class="line">    <span class="type">int</span> downqid = msgget(downkey, <span class="number">0666</span>|IPC_CREAT);</span><br><span class="line">    <span class="type">char</span> text[MAXLEN];</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Enter some text:&quot;</span>);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, text);</span><br><span class="line">        buf.mtype = getpid();</span><br><span class="line">        <span class="built_in">strcpy</span>(buf.mtext, text);</span><br><span class="line">        msgsnd(upqid, &amp;buf, length, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        msgrcv(downqid, &amp;buf, length, getpid(), <span class="number">0</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Receive converted message:%s\n&quot;</span>, buf.mtext);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>效果：<br><img src="/posts/c41aa3a/msg.png" class="" title="msg"></p>
<h3 id="（3）信号量"><a href="#（3）信号量" class="headerlink" title="（3）信号量"></a>（3）信号量</h3><h4 id="信号量获取"><a href="#信号量获取" class="headerlink" title="信号量获取"></a>信号量获取</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/sem.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">semget</span><span class="params">(<span class="type">key_t</span> key, <span class="type">int</span> nsems, <span class="type">int</span> semflg)</span>;</span><br></pre></td></tr></table></figure>
<p><code>nsems</code> 指定创建的信号量的个数。也就是单个 <code>semid</code> 对应的信号量个数。</p>
<h4 id="信号量控制"><a href="#信号量控制" class="headerlink" title="信号量控制"></a>信号量控制</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/sem.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">semctl</span><span class="params">(<span class="type">int</span> semid, <span class="type">int</span> semnum, <span class="type">int</span> cmd, <span class="keyword">union</span> semun arg)</span>;</span><br></pre></td></tr></table></figure>
<p><code>semnum</code> 表示第几个信号量，从 0 开始。<code>cmd</code> 设置要进行的操作命令。<code>arg</code> 是命令的参数，不同的命令对应不同的参数类型。</p>
<h4 id="信息量操作"><a href="#信息量操作" class="headerlink" title="信息量操作"></a>信息量操作</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/sem.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">semop</span><span class="params">(<span class="type">int</span> semid, <span class="keyword">struct</span> sembuf *sops, <span class="type">unsigned</span> nsops)</span>;</span><br></pre></td></tr></table></figure>
<p><code>sops</code> 设置需要进行的操作，结构体的内容如下<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sembuf</span>  </span></span><br><span class="line"><span class="class">&#123;</span>  </span><br><span class="line">  <span class="type">short</span> sem_num;  <span class="comment">// 信号量的序号</span></span><br><span class="line">  <span class="type">short</span> sem_op;            <span class="comment">// 对信号量的操作 </span></span><br><span class="line">  <span class="type">short</span> sem_flg;           <span class="comment">// 操作标识</span></span><br><span class="line">&#125;;  </span><br></pre></td></tr></table></figure><br><code>sem_num</code> 设置要进行设置的信息量序号；<br><code>sem_op</code> 设置对信号量的增减，值大于0表示对信号量增加对应的值，小于0表示对信号量减小对应的值。等于0则信号量阻塞，直到信号量值为0；<br><code>sem_flg</code> 设置对信号量的操作，如设置 <code>IPC_NOWAIT</code> 设置信号量操作不等待。</p>
<h4 id="代码示例-1"><a href="#代码示例-1" class="headerlink" title="代码示例"></a>代码示例</h4><p>如下的程序实现这样的功能：一个进程创建 3 个子进程A、B、C，每个子进程都打印相同的数字串，但要求每个进程都打印完这一位数字后，才能有进程开始下一位数字的打印，并且进程打印顺序按照进程A、B、C依次打印。（<strong>在打印的数字前加上A、B、C</strong>以便区分）</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//sem.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/sem.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">print</span><span class="params">(<span class="type">int</span> num)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">P</span><span class="params">(<span class="type">int</span> semid, <span class="type">int</span> num)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">V</span><span class="params">(<span class="type">int</span> semid, <span class="type">int</span> num)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">pid_t</span> pid;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        pid = fork();</span><br><span class="line">        <span class="keyword">if</span> (pid == <span class="number">0</span>) <span class="comment">// child</span></span><br><span class="line">        &#123;</span><br><span class="line">            print(i);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">key_t</span> key = ftok(<span class="string">&quot;.&quot;</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sembuf</span> <span class="title">buf</span>;</span></span><br><span class="line">    <span class="type">int</span> semid = semget(key, <span class="number">3</span>, <span class="number">0666</span>|IPC_CREAT);</span><br><span class="line">    V(semid, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (wait(<span class="literal">NULL</span>) &gt; <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    fflush(<span class="built_in">stdout</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">P</span><span class="params">(<span class="type">int</span> semid, <span class="type">int</span> num)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sembuf</span> <span class="title">buf</span>;</span></span><br><span class="line">    buf.sem_num = num;</span><br><span class="line">    buf.sem_op = <span class="number">-1</span>;</span><br><span class="line">    semop(semid, &amp;buf, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">V</span><span class="params">(<span class="type">int</span> semid, <span class="type">int</span> num)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sembuf</span> <span class="title">buf</span>;</span></span><br><span class="line">    buf.sem_num = num;</span><br><span class="line">    buf.sem_op = <span class="number">1</span>;</span><br><span class="line">    semop(semid, &amp;buf, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> <span class="title function_">getAlpha</span><span class="params">(<span class="type">int</span> num)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (num == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;A&#x27;</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (num == <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;B&#x27;</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;C&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">print</span><span class="params">(<span class="type">int</span> num)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> stdID[] = <span class="string">&quot;21371326&quot;</span>;</span><br><span class="line">    <span class="type">key_t</span> key = ftok(<span class="string">&quot;.&quot;</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sembuf</span> <span class="title">buf</span>;</span></span><br><span class="line">    <span class="type">int</span> semid = semget(key, <span class="number">3</span>, <span class="number">0666</span>|IPC_CREAT);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; stdID[i] != <span class="string">&#x27;\0&#x27;</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        P(semid, num);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%c%c&quot;</span>, getAlpha(num), stdID[i]);</span><br><span class="line">        fflush(<span class="built_in">stdout</span>);</span><br><span class="line">        V(semid, (num+<span class="number">1</span>)%<span class="number">3</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>效果：<br><img src="/posts/c41aa3a/sem.png" class="" title="sem"></p>
<h3 id="（4）共享内存"><a href="#（4）共享内存" class="headerlink" title="（4）共享内存"></a>（4）共享内存</h3><h4 id="共享内存获取"><a href="#共享内存获取" class="headerlink" title="共享内存获取"></a>共享内存获取</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/shm.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">shmget</span><span class="params">(<span class="type">key_t</span> key, <span class="type">size_t</span> size, <span class="type">int</span> shmflg)</span>;</span><br></pre></td></tr></table></figure>
<p><code>size</code> 设置要获取的内存空间大小。</p>
<h4 id="共享内存控制"><a href="#共享内存控制" class="headerlink" title="共享内存控制"></a>共享内存控制</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/shm.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">shmctl</span><span class="params">(<span class="type">int</span> shmid, <span class="type">int</span> cmd, <span class="keyword">struct</span> shmid_ds *buf)</span>;</span><br></pre></td></tr></table></figure>
<p>此处类似信号量控制。</p>
<h4 id="共享内存映射到地址"><a href="#共享内存映射到地址" class="headerlink" title="共享内存映射到地址"></a>共享内存映射到地址</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/shm.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> *<span class="title function_">shmat</span><span class="params">(<span class="type">int</span> shmid, <span class="type">const</span> <span class="type">void</span> *shmaddr, <span class="type">int</span> shmflg)</span>;</span><br></pre></td></tr></table></figure>
<p>该函数获取一个地址，可以使用指针对共享内存进行访问。<br><code>shmaddr</code> 指定共享内存的地址位置，通常设为 NULL 来让内核自动选择地址；<br><code>shmflg</code> 设置内存的读写模式，如 <code>SHM_RDONLY</code> 为只读模式。</p>
<h4 id="共享内存断开连接"><a href="#共享内存断开连接" class="headerlink" title="共享内存断开连接"></a>共享内存断开连接</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/shm.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">shmdt</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *shmaddr)</span>;</span><br></pre></td></tr></table></figure>
<p><code>shmaddr</code> 表示连接的共享内存的起始地址。</p>
<h4 id="代码示例-2"><a href="#代码示例-2" class="headerlink" title="代码示例"></a>代码示例</h4><p>如下的代码将使用共享内存和信号量实现两个进程的资源共享。一个进程向共享内存写，然后终止，然后再启动一个进程从共享内存中读。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// a.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/sem.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/shm.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">writeNum</span><span class="params">()</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">P</span><span class="params">(<span class="type">int</span> semid, <span class="type">int</span> num)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">V</span><span class="params">(<span class="type">int</span> semid, <span class="type">int</span> num)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    srand(time(<span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> key = ftok(<span class="string">&quot;.&quot;</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="type">int</span> semid = semget(key, <span class="number">2</span>, <span class="number">0666</span>|IPC_CREAT);</span><br><span class="line"></span><br><span class="line">    <span class="type">pid_t</span> pid = fork();</span><br><span class="line">    <span class="keyword">if</span> (pid &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        V(semid, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            P(semid, <span class="number">0</span>);</span><br><span class="line">            writeNum();</span><br><span class="line">            V(semid, <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        execl(<span class="string">&quot;./b&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">writeNum</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">key_t</span> key = ftok(<span class="string">&quot;.&quot;</span>, <span class="number">2</span>);</span><br><span class="line">    <span class="type">int</span> shmid = shmget(key, <span class="keyword">sizeof</span>(<span class="type">int</span>), <span class="number">0666</span>|IPC_CREAT);</span><br><span class="line">    <span class="type">int</span>* p = shmat(shmid, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">    *p = rand();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;write:  %d\n&quot;</span>, *p);</span><br><span class="line">    fflush(<span class="built_in">stdout</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">P</span><span class="params">(<span class="type">int</span> semid, <span class="type">int</span> num)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sembuf</span> <span class="title">buf</span>;</span></span><br><span class="line">    buf.sem_num = num;</span><br><span class="line">    buf.sem_op = <span class="number">-1</span>;</span><br><span class="line">    semop(semid, &amp;buf, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">V</span><span class="params">(<span class="type">int</span> semid, <span class="type">int</span> num)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sembuf</span> <span class="title">buf</span>;</span></span><br><span class="line">    buf.sem_num = num;</span><br><span class="line">    buf.sem_op = <span class="number">1</span>;</span><br><span class="line">    semop(semid, &amp;buf, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// b.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/sem.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/shm.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">readNum</span><span class="params">()</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">P</span><span class="params">(<span class="type">int</span> semid, <span class="type">int</span> num)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">V</span><span class="params">(<span class="type">int</span> semid, <span class="type">int</span> num)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> key = ftok(<span class="string">&quot;.&quot;</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="type">int</span> semid = semget(key, <span class="number">2</span>, <span class="number">0666</span>|IPC_CREAT);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        P(semid, <span class="number">1</span>);</span><br><span class="line">        readNum();</span><br><span class="line">        V(semid, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">readNum</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">key_t</span> key = ftok(<span class="string">&quot;.&quot;</span>, <span class="number">2</span>);</span><br><span class="line">    <span class="type">int</span> shmid = shmget(key, <span class="keyword">sizeof</span>(<span class="type">int</span>), <span class="number">0666</span>|IPC_CREAT);</span><br><span class="line">    <span class="type">int</span>* p = shmat(shmid, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;read:   %d\n\n&quot;</span>, *p);</span><br><span class="line">    fflush(<span class="built_in">stdout</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">P</span><span class="params">(<span class="type">int</span> semid, <span class="type">int</span> num)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sembuf</span> <span class="title">buf</span>;</span></span><br><span class="line">    buf.sem_num = num;</span><br><span class="line">    buf.sem_op = <span class="number">-1</span>;</span><br><span class="line">    semop(semid, &amp;buf, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">V</span><span class="params">(<span class="type">int</span> semid, <span class="type">int</span> num)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sembuf</span> <span class="title">buf</span>;</span></span><br><span class="line">    buf.sem_num = num;</span><br><span class="line">    buf.sem_op = <span class="number">1</span>;</span><br><span class="line">    semop(semid, &amp;buf, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>效果：<br><img src="/posts/c41aa3a/shm.png" class="" title="shm"></p>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>系统编程</tag>
        <tag>进程间通信</tag>
      </tags>
  </entry>
  <entry>
    <title>雇佣K名工人的最低成本</title>
    <url>/posts/22319630/</url>
    <content><![CDATA[<h2 id="857-雇佣-K-名工人的最低成本"><a href="#857-雇佣-K-名工人的最低成本" class="headerlink" title="857. 雇佣 K 名工人的最低成本"></a>857. 雇佣 K 名工人的最低成本</h2><blockquote>
<p>有 n 名工人。 给定两个数组 quality 和 wage ，其中，quality[i] 表示第 i 名工人的工作质量，其最低期望工资为 wage[i] 。</p>
<p>现在我们想雇佣 k 名工人组成一个工资组。在雇佣 一组 k 名工人时，我们必须按照下述规则向他们支付工资：</p>
<p>对工资组中的每名工人，应当按其工作质量与同组其他工人的工作质量的比例来支付工资。<br>工资组中的每名工人至少应当得到他们的最低期望工资。<br>给定整数 k ，返回 组成满足上述条件的付费群体所需的最小金额 。在实际答案的 10-5 以内的答案将被接受。。</p>
<p>输入： quality = [10,20,5], wage = [70,50,30], k = 2<br>输出： 105.00000<br>解释： 我们向 0 号工人支付 70，向 2 号工人支付 35。</p>
</blockquote>
<h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><h3 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h3><p>假设选择某一组工人$[h_1, h_2,…h_m]$，设总工资为$totalpay$，则对每一个工人$h_i({1}\le{i}\le{m})$，有不等式：</p>
<script type="math/tex; mode=display">
\frac{quality[h_i]}{\sum_{i=1}^{m}{quality[h_i]}}\times{totalpay}\ge{wage[h_i]}</script><p>即：</p>
<script type="math/tex; mode=display">
    totalpay = {\sum_{i=1}^{m}{quality[h_i]}}\times{max(\frac{wage[h_i]}{quality[h_i]})}</script><p>$\frac{wage[h_i]}{quality[h_i]}$即为每个工人工作的“性价比”。</p>
<p>由等式可知，对于一组确定的工人，除了总工作质量外，其总工资只与“性价比”最高的那个工人有关。</p>
<p>因此可以得到这样的算法：对于每一个工人，在“性价比”低于该工人的人中找到k-1个人，使得总工作质量最小。求得当前的总工资。最后取所有得到的总工资中的最小值。</p>
<h3 id="程序实现"><a href="#程序实现" class="headerlink" title="程序实现"></a>程序实现</h3><p>我们需要找到“性价比”在倒数k-1名之前的所有工人，不妨先按照性价比进行排序。<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> n = wage.<span class="built_in">size</span>();</span><br><span class="line"><span class="type">int</span> wpq[n]; <span class="comment">// wage per quality</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    wpq[i] = i;</span><br><span class="line"><span class="built_in">sort</span>(wpq, wpq+n,</span><br><span class="line">    [&amp;](<span class="type">int</span> i, <span class="type">int</span> j)</span><br><span class="line">    &#123; <span class="keyword">return</span> wage[i] * quality[j] &lt; wage[j] * quality[i];&#125;);</span><br></pre></td></tr></table></figure><br>注意这里并未对quality和wage直接排序，而是将下标进行排序。</p>
<p>之后，再分析接下来需要进行的操作。对于每个工人，都要找到他（性价比中的位置）之前的k-1个工人，这些工人需要总工作质量最小。具体的，这些工人就是工作质量最小的k-1个人。</p>
<p>保存最大/最小的k个元素，可以利用优先队列。<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">priority_queue&lt;<span class="type">int</span>&gt; pq;</span><br><span class="line"><span class="type">int</span> qsum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; k<span class="number">-1</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> nowq = quality[wpq[i]];</span><br><span class="line">    pq.<span class="built_in">push</span>(nowq);</span><br><span class="line">    qsum += nowq;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>先将前k-1个人压入队列，那么对于前k-1个人，他们一定是工作质量最小的k-1个人。<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">double</span> ans = DBL_MAX; </span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = k<span class="number">-1</span>; i &lt; n; i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> work = wpq[i];</span><br><span class="line">    <span class="type">int</span> nowq = quality[work];</span><br><span class="line">    pq.<span class="built_in">push</span>(nowq);</span><br><span class="line">    qsum += nowq;</span><br><span class="line">    <span class="type">double</span> nowPay = qsum * ((<span class="type">double</span>)wage[work] / nowq);</span><br><span class="line">    ans = <span class="built_in">min</span>(ans, nowPay);</span><br><span class="line">    qsum -= pq.<span class="built_in">top</span>();</span><br><span class="line">    pq.<span class="built_in">pop</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> ans;</span><br></pre></td></tr></table></figure><br>然后从第k个工人开始，求最小的总工作质量。具体的，压入第i个工人，再从优先队列中弹出工作质量最大的那个。易证操作后队列里的k个依旧是最小的k个。</p>
<h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>话说这道题明明有思路，想到了“性价比”，也想到了优先队列，可是就是没做出来，实在是对不起自己了。现在想想，好像也没有什么困难的地方，或许只是自己被概念缠住了吧。有时候列一列公式还是很有必要的。</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>LeetCode</tag>
        <tag>优先队列</tag>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title>面向对象的c语言</title>
    <url>/posts/583d5770/</url>
    <content><![CDATA[<h2 id="一、前言——对象与过程"><a href="#一、前言——对象与过程" class="headerlink" title="一、前言——对象与过程"></a>一、前言——对象与过程</h2><blockquote>
<p>碎碎念：这篇文章里提到的语言是真的多：c、c++、c#、java、python、golang</p>
</blockquote>
<p>c 语言怎么能面向对象呢？c 语言的设计当然并非为面向对象做出考虑，但是其拥有的语法却足以使我们写出具有面向对象味道的代码了。因为无论是面向过程或面向对象，其背后的本质思想都是相同的，那就是这样一个著名的公式：</p>
<script type="math/tex; mode=display">
    程序 = 数据结构 + 算法</script><span id="more"></span>
<p>面向过程无非是强调其算法的一面；面向对象无非是强调其数据结构的一面。当我们使用面向过程的思想编写代码时，我们所想的是数据是函数中的参数和变量，数据在过程中流动和变化。而在面向对象中情况则反了过来：方法成为了类的成员，被类型所划分，并从属于一定数据的集合。</p>
<p>了解了这一点之后，再看程序语言从面向过程到面向对象的发展过程也能有新的认识。这一发展背后实际上是程序的关注点由机器向人的转变。在面向过程的时代，人们所关注的是如何<strong>操纵</strong>数据。那时的机器还没有蒙在名为抽象的面纱之下，呈现在操作者面前的依旧是赤裸裸的整个内存空间，数据与数据之间没有清晰的边界，是操作者自己组织起整个系统，为各个空间划分边界，定下名称。而在这一构筑起来的系统之上，数据本身就没有那么重要了，因为更底层已经为其提供了随时取用的接口。这时，<strong>管理</strong>流程成了另一个关键问题。因为在底层的支持下构建起来的日益庞大的应用，其自身的结构却往往不能支持其质量。于是人们以数据为界，将面条一般的数据流切割成彼此独立却又相互关联的部分。这样对象才得以诞生。</p>
<h2 id="二、c语言的面向对象何以可能"><a href="#二、c语言的面向对象何以可能" class="headerlink" title="二、c语言的面向对象何以可能"></a>二、c语言的面向对象何以可能</h2><p>说回 c 语言，当其以结构体的方式组织起数据的时候，就已经有了对象的雏形了。如果我们将函数视为所属于其第一个参数类型的方法，那么对象的方法也可以表示。但是只有这两点并非真正的面向对象，因为面向对象的三大特征——封装、继承和多态，其中的后两者还未实现。</p>
<p>让我们来详细分析一下继承和多态到底在表明什么。继承是两个类型间的关系，类型 A 继承了类型 B，则类型 A 具有类型 B 所具有的一切属性和方法，这意味着对于 A 和 B 这两个不同的类型，都具有所属于 B 的部分。从这一点来说，两者是<strong>相同</strong>的（也因为这种相同，子类才能不加转换的赋给父类变量）。而多态（在这里指方法的重写而不包括重载）则指子类 A 对从 B 所继承的方法的重写，使得虽是相同方法，其表现却能有所<strong>不同</strong>。</p>
<p>明确了继承和多态，接下来我们从数据的角度分析 c 语言为何可以面向对象。所谓的一个对象，即在地址空间中的一段连续区域。此时继承中所谓的相同，即对两个不同类型的对象，其内存空间中相同位置所表达的含义相同。如果对于 B 类型来说，偏移 4 个字节之后的 4 个字节表示一个 int 字段，那么对于继承 B 类型的 A 类型来说，偏移 4 个字节之后的 4 个字节应同样表示一个 int 字段。类似的，多态中所谓的不同，可以表达为类型中<strong>相同</strong>的方法名对应的具体过程<strong>不同</strong>。由于过程在机器码中表现为地址，那么本质上来说，多态的这种不同不过是指相同字段中的值不同罢了。</p>
<p>此时 c 语言中实现继承和多态的方法呼之欲出，那就是使用指针。地址指示了变量所处空间的起始位置，却不表明按何种方式解释这块区域，而指针完成了这份工作。对于所有赋给指针的地址值，其都如实翻译其中的数据，那么如果想要子类与父类按照同样的方式进行翻译，就需要子类在组织其结构时保持和父类一致。而对于多态来说，事情则更简单了，函数指针同样是指针，只要使其指向不同的函数即可。</p>
<p>这样也可以理解为什么 c++ 中只能使用指针实现多态（引用本质还是指针）。<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Child c;</span><br><span class="line">Father *f = &amp;c;  <span class="comment">// 正确</span></span><br><span class="line">Father f2 = c;   <span class="comment">// 错误</span></span><br></pre></td></tr></table></figure></p>
<p>而 c++ 中使用 <code>new</code> 关键字申请内存这一点也被 java、c# 等面向对象语言学了过去。java、c# 等中的类变量，实际上也和指针或引用没有区别<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// c++</span></span><br><span class="line">SomeClass *obj = <span class="keyword">new</span> <span class="built_in">SomeClass</span>();</span><br></pre></td></tr></table></figure><br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// java</span></span><br><span class="line"><span class="type">SomeClass</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SomeClass</span>();</span><br></pre></td></tr></table></figure><br><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// c#</span></span><br><span class="line">SomeClass obj = <span class="keyword">new</span> SomeClass();</span><br></pre></td></tr></table></figure></p>
<p>现在让我们结束一些形而上的讨论，看一下 c 语言到底应当如何实现面向对象。</p>
<h2 id="三、封装的实现"><a href="#三、封装的实现" class="headerlink" title="三、封装的实现"></a>三、封装的实现</h2><p>所谓封装就是数据成员与方法结合，隐藏类内成员，对外暴露方法接口。这一点很是简单。</p>
<p>假设现在有一个简单的 <code>Dog</code> 类，里面有一个字段 <code>name</code>。<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Dog</span> &#123;</span></span><br><span class="line">    <span class="type">char</span> *name;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>一般来说，想要访问 <code>name</code> 字段只需要直接指明字段名即可。<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Dog</span> <span class="title">dog</span>;</span></span><br><span class="line">    dog.name = <span class="string">&quot;scooby&quot;</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;the dog&#x27;s name is %s\n&quot;</span>, dog.name);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>不过为了封装，可以使用 <code>getter</code> <code>setter</code> 对字段进行读写。<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> *<span class="title function_">dog_get_name</span><span class="params">(<span class="keyword">struct</span> Dog *self)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> self-&gt;name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> *<span class="title function_">dog_set_name</span><span class="params">(<span class="keyword">struct</span> Dog *self, <span class="type">char</span> name[])</span> &#123;</span><br><span class="line">    self-&gt;name = name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里 <code>Dog</code> 作为了函数的第一个参数，以此表明该函数是属于 <code>Dog</code> 的方法。那么上面的程序就可以改写为下面的形式。<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Dog</span> <span class="title">dog</span>;</span></span><br><span class="line">    dog_set_name(&amp;dog, <span class="string">&quot;scooby&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;the dog&#x27;s name is %s\n&quot;</span>, dog_get_name(&amp;dog));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>当然对于简单的字段都要用程序封装实在是一种古板的做法，尤其是在使用 c 语言模拟面向对象的时候，但这只是一个例子而已。除此之外，golang 将首字母大写的属性公开的方法也有可取之处，c# 的 property 也模拟了类似的读写语法。<br><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// golang</span></span><br><span class="line"><span class="keyword">type</span> Dog <span class="keyword">struct</span> &#123;</span><br><span class="line">    Name <span class="type">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// csharp</span></span><br><span class="line"><span class="keyword">class</span> <span class="title">Dog</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Name &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>另外，各位应该能看出这样的写法和 python 实在类似，我们可以用 python 写出类似的代码。从中也可以稍微体会到一些 python 特有的设计哲学。<br><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span>:</span><br><span class="line">    name: <span class="built_in">str</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get_name</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> self.name</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">set_name</span>(<span class="params">self, name</span>):</span><br><span class="line">        self.name = name</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    dog = Dog()</span><br><span class="line">    Dog.set_name(dog, <span class="string">&quot;scooby&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;the dog&#x27;s name is <span class="subst">&#123;Dog.get_name(dog)&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure></p>
<h2 id="四、继承的实现"><a href="#四、继承的实现" class="headerlink" title="四、继承的实现"></a>四、继承的实现</h2><p>在第二小节时说过，继承体现在子类与父类具有相同的内存结构，举个例子，假如有两个类 <code>Pet</code> 和 <code>Dog</code>，其中 <code>Pet</code> 具有属性 <code>name</code>，<code>Dog</code> 继承了 <code>Pet</code>，同时增加了属性 <code>color</code>。那么对于 <code>Dog</code> 中的 <code>name</code> 来说，其所在的位置应该与 <code>Pet</code> 中的位置相同。</p>
<p>也就是说，对于 <code>Pet</code><br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Pet</span> &#123;</span></span><br><span class="line">    <span class="type">char</span> *name;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">pet_describe</span><span class="params">(<span class="keyword">struct</span> Pet *self)</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;the pet&#x27;s name is %s\n&quot;</span>, self-&gt;name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>那么 <code>Dog</code> 也应当具有相同的结构，<code>name</code> 应当位于最开始的位置<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 正确</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Dog</span> &#123;</span> <span class="comment">// : Pet</span></span><br><span class="line">    <span class="type">char</span> *name;</span><br><span class="line">    <span class="type">char</span> *color;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 错误</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">DogFalse</span> &#123;</span> <span class="comment">// : Pet</span></span><br><span class="line">    <span class="type">char</span> *color;</span><br><span class="line">    <span class="type">char</span> *name;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>对于错误的结构，会导致错误的输出。<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Dog</span> <span class="title">dog1</span> =</span> &#123;<span class="string">&quot;scooby&quot;</span>, <span class="string">&quot;brown&quot;</span>&#125;;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">DogFalse</span> <span class="title">dog2</span> =</span> &#123;<span class="string">&quot;white&quot;</span>, <span class="string">&quot;kitty&quot;</span>&#125;;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Pet</span> *<span class="title">p1</span> =</span> &amp;dog1;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Pet</span> *<span class="title">p2</span> =</span> &amp;dog2;</span><br><span class="line">    pet_describe(p1);</span><br><span class="line">    pet_describe(p2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">the pet&#x27;s name is scooby</span><br><span class="line">the pet&#x27;s name is white</span><br></pre></td></tr></table></figure></p>
<p>除此之外，继承还有另一种实现方式，就是使用嵌套的结构体，因为最终在内存中，嵌套的结构都会被展平。此时 <code>Pet</code> 的定义不变，<code>Dog</code> 的定义变为如下形式<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Dog</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Pet</span> <span class="title">super</span>;</span></span><br><span class="line">    <span class="type">char</span> *color;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>但是这样存在一个问题，就是 <code>Pet</code> 类中的字段我们不再能直接访问，这违反了继承的原则，尽管这种写法和之前的写法中 <code>Dog</code> 结构体的结构都是一样的。</p>
<p>golang 中采用后一种写法表示“继承”关系，规定当只使用类型名而不添加字段名的时候，自动使“子类”获得“父类”的属性。这就以一种很简单的方式解决了继承问题。Ken Thompson 在设计 golang 时确实保留了一些 c 的风格。<br><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Pet <span class="keyword">struct</span> &#123;</span><br><span class="line">    Name <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Dog <span class="keyword">struct</span> &#123;</span><br><span class="line">    Pet</span><br><span class="line">    Color <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	dog := Dog&#123;<span class="string">&quot;scooby&quot;</span>, <span class="string">&quot;brown&quot;</span>&#125;;</span><br><span class="line">    fmt.Println(dog.name);  <span class="comment">// 正确</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="五、多态的实现"><a href="#五、多态的实现" class="headerlink" title="五、多态的实现"></a>五、多态的实现</h2><p>除了属性之外，还有方法需要处理。为了实现多态，我们需要让方法也具有继承关系。具体来说，也应当有一个类似于属性的结构体，其中存储该类型所用到的所有函数，而当出现一个子类的时候，也应当有一个属于该子类的，继承父类函数结构体的结构体。该结构体称为虚表。</p>
<p>我们举 <code>Pet</code>、<code>Dog</code> 和 <code>Cat</code> 作为例子。<code>Pet</code> 具有属性 <code>name</code> 和方法 <code>describe</code>；<code>Dog</code> 和 <code>Cat</code> 继承 <code>Pet</code>。<code>Dog</code> 有额外属性 <code>color</code> 和方法 <code>bark</code>，<code>Cat</code> 有方法 <code>meow</code>。</p>
<p>那么三个类型各有其虚表<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">PetVTable</span> &#123;</span></span><br><span class="line">    <span class="type">char</span> *(*describe)(<span class="keyword">struct</span> Pet *, <span class="type">char</span> []);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">DogVTable</span> &#123;</span></span><br><span class="line">    <span class="type">char</span> *(*describe)(<span class="keyword">struct</span> Pet *, <span class="type">char</span> []);</span><br><span class="line">    <span class="type">void</span> (*bark)(<span class="keyword">struct</span> Dog *);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">CatVTable</span> &#123;</span></span><br><span class="line">    <span class="type">char</span> *(*describe)(<span class="keyword">struct</span> Pet *, <span class="type">char</span> []);</span><br><span class="line">    <span class="type">void</span> (*meow)(<span class="keyword">struct</span> Cat *);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>此时我们若想调用某一对象的方法，就不再直接通过函数的全局名称访问，而是通过虚表间接访问。由于虚表之间有着结构上的继承关系，所以子类必定拥有父类的方法；又由于虚表存储着函数的地址而非函数本身，因此对于有着不同虚表的对象，调用相同的方法也可能实际执行不同的函数。</p>
<p>对于面向对象来说，每个类的对象有着相同的虚表，因此只需要一个类使用一个全局的虚表即可。我们可以在每个类的字段中添加一个指向虚表的指针。由于需要保证对于父类和子类，都能访问其虚表，因此该指针必须放在结构体的首部。<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Pet</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">PetVTable</span> *<span class="title">f</span>;</span></span><br><span class="line">    <span class="type">char</span> *name;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Dog</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">DogVTable</span> *<span class="title">f</span>;</span></span><br><span class="line">    <span class="type">char</span> *name;</span><br><span class="line">    <span class="type">char</span> *color;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Cat</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">CatVTable</span> *<span class="title">f</span>;</span></span><br><span class="line">    <span class="type">char</span> *name;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>接下来需要将虚表与对象关联起来，也就是说，在初始化时，将类所对应的虚表的值赋给 <code>f</code>。这就需要引入构造函数了。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> Pet *<span class="title function_">create_Pet</span><span class="params">(<span class="keyword">struct</span> Pet *self, <span class="type">char</span> name[])</span> &#123;</span><br><span class="line">    <span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">PetVTable</span> <span class="title">v</span> =</span> &#123;<span class="literal">NULL</span>&#125;;</span><br><span class="line">    self-&gt;f = &amp;v;</span><br><span class="line">    self-&gt;name = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> Dog *<span class="title function_">create_Dog</span><span class="params">(<span class="keyword">struct</span> Dog *self, <span class="type">char</span> name[], <span class="type">char</span> color[])</span> &#123;</span><br><span class="line">    self = create_Pet(self, name);</span><br><span class="line">    <span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">DogVTable</span> <span class="title">v</span> =</span> &#123;dog_describe, dog_bark&#125;;</span><br><span class="line">    self-&gt;f = &amp;v;</span><br><span class="line">    self-&gt;color = color;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> Cat *<span class="title function_">create_Cat</span><span class="params">(<span class="keyword">struct</span> Cat *self, <span class="type">char</span> name[])</span> &#123;</span><br><span class="line">    self = create_Pet(self, name);</span><br><span class="line">    <span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">CatVTable</span> <span class="title">v</span> =</span> &#123;cat_describe, cat_meow&#125;;</span><br><span class="line">    self-&gt;f = &amp;v;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里分别定义了三个类型的构造函数，都传入了一个指针表示要初始化的对象的地址，为什么不在构造函数内部调用 <code>malloc</code> 呢？因为还存在栈上变量的可能。因此应该传入指针，把内存的申请留给用户。另外在 <code>Dog</code> 和 <code>Cat</code> 的构造函数中先调用了 <code>Pet</code> 的构造函数，这也是面向对象语言中的初始化流程。还有，我们将虚表定义为了函数内的 <code>static</code> 变量，这也保证了同一类只有同一虚表。</p>
<p>最后还请注意 <code>create_Pet</code> 函数中的虚表，这里将其值设定为 NULL，说明 <code>Pet</code> 类不存在一个对应 <code>describe</code> 方法的实际函数。这意味着 <code>Pet</code> 类不应调用 <code>describe</code> 函数，或更进一步的，<code>Pet</code> 类不应存在实例。也就是说 <code>Pet</code> 类应该是一个抽象类。这一点实际上很像 c++ 中对于虚函数的定义。以 c++ 来描述 <code>Pet</code> 类的话应该就是这样的：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Pet</span> &#123;</span><br><span class="line">    <span class="type">char</span> *name;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">char</span> *<span class="title">describe</span><span class="params">(<span class="type">char</span> buf[])</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>将 <code>describe</code>“赋值”为 0 和将虚表中的 <code>describe</code> 项赋值为 NULL（也是0）完全是一样的。</p>
<p>另外，是不是觉得 <code>create_Pet</code> 这样的函数名太奇怪了？这其实是为预处理宏来准备的。接下来上一点宏魔法 <code>:)</code><br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> NEW(cls, ...) create_##cls(malloc(sizeof(struct cls)), __VA_ARGS__)  <span class="comment">// alloc on heap</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DECL(cls, name, ...) struct cls name; create_##cls(&amp;name, __VA_ARGS__)  <span class="comment">// alloc on stack</span></span></span><br></pre></td></tr></table></figure></p>
<p>这样分别定义了两个宏用来在堆和栈上创建变量。使用起来就如下面这样：<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Pet</span> *<span class="title">pet</span> =</span> NEW(Cat, <span class="string">&quot;Kitty&quot;</span>);  <span class="comment">// Pet *pet = new Cat(&quot;Kitty&quot;);</span></span><br><span class="line">    DECL(Dog, dog, <span class="string">&quot;Beauty&quot;</span>, <span class="string">&quot;white&quot;</span>);  <span class="comment">// Dog dog(&quot;Beauty&quot;, &quot;white&quot;);</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>是不是有一点 c++ 的感觉了？</p>
<p>最后，我们实现一下 <code>Dog</code> 和 <code>Cat</code> 类的函数，并用一个小程序测试一下。<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> *<span class="title function_">dog_describe</span><span class="params">(<span class="keyword">struct</span> Pet *self, <span class="type">char</span> buf[])</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Dog</span> *<span class="title">dself</span> =</span> self;</span><br><span class="line">    <span class="built_in">sprintf</span>(buf, <span class="string">&quot;the %s dog is %s&quot;</span>, dself-&gt;color, dself-&gt;name);</span><br><span class="line">    <span class="keyword">return</span> buf;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *<span class="title function_">dog_bark</span><span class="params">(<span class="keyword">struct</span> Dog *self)</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s said: \&quot;wooof!!!\&quot;\n&quot;</span>, self-&gt;name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> *<span class="title function_">cat_describe</span><span class="params">(<span class="keyword">struct</span> Pet *self, <span class="type">char</span> buf[])</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Cat</span> *<span class="title">cself</span> =</span> self;</span><br><span class="line">    <span class="built_in">sprintf</span>(buf, <span class="string">&quot;this cat named %s&quot;</span>, cself-&gt;name);</span><br><span class="line">    <span class="keyword">return</span> buf;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *<span class="title function_">cat_meow</span><span class="params">(<span class="keyword">struct</span> Cat *self)</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s said: \&quot;meow...\&quot;\n&quot;</span>, self-&gt;name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Pet</span> *<span class="title">pet1</span> =</span> NEW(Cat, <span class="string">&quot;Kitty&quot;</span>);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Pet</span> *<span class="title">pet2</span> =</span> NEW(Dog, <span class="string">&quot;Scooby&quot;</span>, <span class="string">&quot;brown&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> desc_buf[<span class="number">30</span>];</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;desc cat: %s\n&quot;</span>, pet1-&gt;f-&gt;describe(pet1, desc_buf));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;desc dog: %s\n&quot;</span>, pet2-&gt;f-&gt;describe(pet2, desc_buf));</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Cat</span> *<span class="title">cat</span> =</span> pet1;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Dog</span> *<span class="title">dog</span> =</span> pet2;</span><br><span class="line">    cat-&gt;f-&gt;meow(cat);</span><br><span class="line">    dog-&gt;f-&gt;bark(dog);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>输出结果如下，可以看出 <code>describe</code> 函数的多态性。<br><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">desc cat: this cat named Kitty</span><br><span class="line">desc dog: the brown dog is Scooby</span><br><span class="line">Kitty said: &quot;meow...&quot;</span><br><span class="line">Scooby said: &quot;wooof!!!&quot;</span><br></pre></td></tr></table></figure></p>
<h2 id="六、函数重载？"><a href="#六、函数重载？" class="headerlink" title="六、函数重载？"></a>六、函数重载？</h2><p>最后还想讲一点关于函数重载的内容，函数重载也是面向对象的一部分。c 语言没有函数重载，这对于程序员来说十分不友好，因为众所周知，取名字是一项十分耗费时间精力的工作。可如果我说能够让 c 语言也有函数重载，你是否相信呢？</p>
<p>当然这一点是夸大了，我们不可能改变 c 语言的语法，我的意思是，如何在没有函数重载的情况下以类似的方式解决函数重载所解决的问题。对于这一点，实际上我们可以完全参考 python 的解决方法。python 没有函数重载，实际上我在使用 python 很长时间之后还没有意识到这一点，当然这一定上源于用 python 进行的工作大部分不过是调用 api 而已。但是这还是能一定程度上说明 python 的解决方法是较为合理的。</p>
<p>python 的实现方法实际上就是参数表。通过设定默认值使得调用者只需要设定自己需要的参数，从而实现了“伪重载”。举一个例子<br><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params"></span></span><br><span class="line"><span class="params">    a: <span class="built_in">int</span> = <span class="number">0</span>,</span></span><br><span class="line"><span class="params">    b: <span class="built_in">int</span> = <span class="number">0</span>,</span></span><br><span class="line"><span class="params">    arr: <span class="built_in">list</span>[<span class="built_in">int</span>] = <span class="literal">None</span>,</span></span><br><span class="line"><span class="params"></span>):</span><br><span class="line">    <span class="keyword">if</span> arr <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">return</span> a + b</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">sum</span>(arr)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(add(a=<span class="number">1</span>, b=<span class="number">2</span>))</span><br><span class="line"><span class="built_in">print</span>(add(arr=[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]))</span><br></pre></td></tr></table></figure><br>输出<br><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">3</span><br><span class="line">15</span><br></pre></td></tr></table></figure><br>当然 python 不需要重载还有部分鸭子类型的原因。c 语言虽然没有，但是依旧可以使用参数表模拟多态的方式更加灵活地调用函数。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">AddParam</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">    <span class="type">int</span> b;</span><br><span class="line">    <span class="type">int</span> *arr;</span><br><span class="line">    <span class="type">int</span> size;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="keyword">struct</span> AddParam *param)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (param-&gt;arr == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> param-&gt;a + param-&gt;b;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; param-&gt;size; i++) &#123;</span><br><span class="line">            sum += param-&gt;arr[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">AddParam</span> <span class="title">param1</span>;</span></span><br><span class="line">    param1.a = <span class="number">1</span>;</span><br><span class="line">    param1.b = <span class="number">2</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, add(&amp;param1));</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">AddParam</span> <span class="title">param2</span>;</span></span><br><span class="line">    <span class="type">int</span> arr[<span class="number">5</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    param2.arr = arr;</span><br><span class="line">    param2.size = <span class="number">5</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, add(&amp;param2));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>C#</tag>
        <tag>Java</tag>
        <tag>C</tag>
        <tag>C++</tag>
        <tag>Python</tag>
        <tag>Golang</tag>
        <tag>面向对象</tag>
      </tags>
  </entry>
  <entry>
    <title>不务正业：玩个zsh</title>
    <url>/posts/93ea500a/</url>
    <content><![CDATA[<h2 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h2><p>不知道为什么，这学期看到好几个人都用 zsh。最近恰好有时间，我也是时候换一个 shell 了。</p>
<p>不过嘛，shell 毕竟是用来工作的，不是一件艺术品，所以这里的配置也是以实用为主了。本文也没有用到 oh-my-zsh，用一个专门的框架来管理 shell 的配置在我看来还是太过沉重了。</p>
<blockquote>
<p>本篇文章所用的环境当然是 linux。更加具体来说是 debian 系的发行版。</p>
</blockquote>
<span id="more"></span>
<h2 id="二、zsh-的安装"><a href="#二、zsh-的安装" class="headerlink" title="二、zsh 的安装"></a>二、zsh 的安装</h2><p>这里当然不会仔细介绍 zsh，将网上许多其他文章都重复过的内容再重复一遍。zsh 只是一个 shell，只不过这个 shell 有较强的可扩展性，同时具有一些比较有用的特性，仅此而已。</p>
<p>安装 zsh，只需要一条命令<br><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">apt-get install zsh</span><br></pre></td></tr></table></figure></p>
<p>之后可以查看 /etc/shells 文件的内容，该文件记录了系统中已有的所有 shell，此时应当也有 zsh。<br><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cat</span> /etc/shells</span><br></pre></td></tr></table></figure></p>
<p>本人的输出结果是这样的<br><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># /etc/shells: valid login shells</span></span><br><span class="line">/bin/sh</span><br><span class="line">/bin/bash</span><br><span class="line">/usr/bin/bash</span><br><span class="line">/bin/rbash</span><br><span class="line">/usr/bin/rbash</span><br><span class="line">/usr/bin/sh</span><br><span class="line">/bin/dash</span><br><span class="line">/usr/bin/dash</span><br><span class="line">/bin/zsh</span><br><span class="line">/usr/bin/zsh</span><br></pre></td></tr></table></figure></p>
<p>之后首次运行 zsh<br><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">zsh</span><br></pre></td></tr></table></figure></p>
<p>应该会出现如下内容，因为此时我们并未创建 zsh 的配置文件。正如 bash 的 <code>.bashrc</code>。这里只需要选择 <code>0</code> 即可。之后会在用户目录创建一个空的 <code>.zshrc</code>，该文件将在下一小节中详细说明。选择后重新输入命令 <code>zsh</code> 进入 zsh，此时应该可以看到输入提示符等内容。<br><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">This is the Z Shell configuration function for new users,</span><br><span class="line">zsh-newuser-install.</span><br><span class="line">You are seeing this message because you have no zsh startup files</span><br><span class="line">(the files .zshenv, .zprofile, .zshrc, .zlogin in the directory</span><br><span class="line">~).  This function can help you with a few settings that should</span><br><span class="line">make your use of the shell easier.</span><br><span class="line"></span><br><span class="line">You can:</span><br><span class="line"></span><br><span class="line">(q)  Quit and do nothing.  The function will be run again next time.</span><br><span class="line"></span><br><span class="line">(0)  Exit, creating the file ~/.zshrc containing just a comment.</span><br><span class="line">     That will prevent this function being run again.</span><br><span class="line"></span><br><span class="line">(1)  Continue to the main menu.</span><br><span class="line"></span><br><span class="line">(2)  Populate your ~/.zshrc with the configuration recommended</span><br><span class="line">     by the system administrator and exit (you will need to edit</span><br><span class="line">     the file by hand, if so desired).</span><br><span class="line"></span><br><span class="line">--- Type one of the keys in parentheses --- </span><br></pre></td></tr></table></figure></p>
<p>我们当然不希望每次新建终端都要在 bash 中输入一次 <code>zsh</code>。因此应当将当前用户的默认终端修改为 zsh。输入如下命令即可。此命令需要输入用户密码。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">chsh -s /bin/zsh</span><br></pre></td></tr></table></figure>
<p>之后可以查看一下 /etc/passwd 文件，搜索当前用户名，查看其 shell 是否修改为了 zsh。<br><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">vim /etc/passwd</span><br></pre></td></tr></table></figure></p>
<p>此时如果新建终端，会发现使用的依旧是 bash。因为应用修改需要重启系统。当然现在还是不要重启，接着使用 bash 吧，因为现在的 zsh 比 bash 还要简陋。</p>
<h2 id="三、-zshrc-的配置"><a href="#三、-zshrc-的配置" class="headerlink" title="三、.zshrc 的配置"></a>三、<code>.zshrc</code> 的配置</h2><p>如果你修改过 bash 的配置，或者至少在 Linux 下安装过一些编程语言的环境，如 python 的 conda、golang 和 rust 的编译环境等等，应该知道用户目录下有一个 <code>.bashrc</code> 文件。这个文件用于对 bash 所使用的环境进行配置。在每次创建一个 bash 的时候，bash 会首先执行命令 <code>source ~/.bashrc</code>。<code>source</code> 命令将使用当前的终端依次执行文件中的每条内容，这样就完成了 bash 初始化。</p>
<p><code>.zshrc</code> 也是类似的配置文件。只不过 bash 和 zsh 的一些操作可能并不兼容，导致我们并不能直接将 <code>.bashrc</code> 的内容复制到 <code>.zshrc</code> 中。当然我们的目的是快速配置一个可用且美观的终端，所以本文不会也不可能详述 zsh 具体有什么特性，有什么和其他 shell 的区别。所以接下来我就简单列举一些自己用到的，较为实用配置。</p>
<h3 id="（1）基本命令的颜色"><a href="#（1）基本命令的颜色" class="headerlink" title="（1）基本命令的颜色"></a>（1）基本命令的颜色</h3><p>现在你使用毫无配置的 zsh，就连一个简单的 <code>ls</code> 命令都是没有颜色的，这怎么能忍？必须首先解决这个问题。</p>
<p>很庆幸的是这里 zsh 完全和 bash 兼容，默认的 <code>.bashrc</code> 中应该有如下的内容，只要将如下内容复制到 <code>.zshrc</code> 中即可。<br><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># enable color support of ls and also add handy aliases</span></span><br><span class="line"><span class="keyword">if</span> [ -x /usr/bin/dircolors ]; <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">test</span> -r ~/.dircolors &amp;&amp; <span class="built_in">eval</span> <span class="string">&quot;<span class="subst">$(dircolors -b ~/.dircolors)</span>&quot;</span> || <span class="built_in">eval</span> <span class="string">&quot;<span class="subst">$(dircolors -b)</span>&quot;</span></span><br><span class="line">    <span class="built_in">alias</span> <span class="built_in">ls</span>=<span class="string">&#x27;ls --color=auto&#x27;</span></span><br><span class="line">    <span class="comment">#alias dir=&#x27;dir --color=auto&#x27;</span></span><br><span class="line">    <span class="comment">#alias vdir=&#x27;vdir --color=auto&#x27;</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">alias</span> grep=<span class="string">&#x27;grep --color=auto&#x27;</span></span><br><span class="line">    <span class="built_in">alias</span> fgrep=<span class="string">&#x27;fgrep --color=auto&#x27;</span></span><br><span class="line">    <span class="built_in">alias</span> egrep=<span class="string">&#x27;egrep --color=auto&#x27;</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure></p>
<h3 id="（2）启用命令历史"><a href="#（2）启用命令历史" class="headerlink" title="（2）启用命令历史"></a>（2）启用命令历史</h3><p>zsh 竟然默认不启用命令历史，这导致每次新建一个终端，都没办法获取其他终端的命令历史。<code>.bashrc</code> 中可以找到和命令历史相关的配置，但可以这回直接复制并不会起作用<br><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># don&#x27;t put duplicate lines or lines starting with space in the history.</span></span><br><span class="line"><span class="comment"># See bash(1) for more options</span></span><br><span class="line">HISTCONTROL=ignoreboth</span><br><span class="line"></span><br><span class="line"><span class="comment"># for setting history length see HISTSIZE and HISTFILESIZE in bash(1)</span></span><br><span class="line">HISTSIZE=1000</span><br><span class="line">HISTFILESIZE=2000</span><br></pre></td></tr></table></figure></p>
<p>在 zsh 中，还需要设置记录历史的文件 <code>HISTFILE</code> 以及保存的历史数量 <code>SAVEHIST</code>。这样之前的命令历史才会记录下来。注意这里具体的数值可以自己设置。<br><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># config history</span></span><br><span class="line">HISTFILE=~/.zsh_history</span><br><span class="line">SAVEHIST=1000</span><br><span class="line">HISTSIZE=1000</span><br><span class="line">HISTFILESIZE=2000</span><br></pre></td></tr></table></figure></p>
<h3 id="（3）删除单个单词"><a href="#（3）删除单个单词" class="headerlink" title="（3）删除单个单词"></a>（3）删除单个单词</h3><p>用过 vscode 应该会觉得其中的 shell 操作很舒服。比如说在默认设置下 <code>Ctrl + Backspace</code> 可以直接删除单个单词。其实 shell 中也已经内置了这一操作，只不过快捷键是 <code>Ctrl + W</code>，这就很不直观了。zsh 中可以将某一按键绑定到某一操作。这样就可以使用 <code>Ctrl + Backspace</code> 删除单个单词了。只需要如下一行指令即可。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># enable kill word using ctrl + backspace</span></span><br><span class="line"><span class="built_in">bindkey</span> <span class="string">&#x27;^H&#x27;</span> backward-kill-word</span><br></pre></td></tr></table></figure>
<h3 id="（4）补全功能选择菜单"><a href="#（4）补全功能选择菜单" class="headerlink" title="（4）补全功能选择菜单"></a>（4）补全功能选择菜单</h3><p>稍微使用一下我们尚不完善的 zsh，你应该会发现补全操作似乎和 bash 中不一样。bash 中会在双击 tab 后补全或列出补全选项，而 zsh 则单击 tab 便会显示补全。这样做不只是为了禁止你在 zsh 中使用制表符（哈哈），而是因为双击 tab 还有另外的功能，只不过现在没有启用。</p>
<p>在 <code>.zshrc</code> 中添加如下一行，就可以在补全时启用选择菜单。在双击 tab 后会将下方列出的补全选项变为菜单，可以通过方向键选择具体的补全选项，按回车补全选定的内容。当然也可以按 <code>Backspace</code> 退出选择。<br><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># enable menu</span></span><br><span class="line"><span class="built_in">zstyle</span> <span class="string">&#x27;:completion:*&#x27;</span> menu select</span><br></pre></td></tr></table></figure></p>
<h3 id="（5）不要忘记其他配置"><a href="#（5）不要忘记其他配置" class="headerlink" title="（5）不要忘记其他配置"></a>（5）不要忘记其他配置</h3><p>一些程序在安装时会在 <code>.bashrc</code> 中添加内容，在搬家到 zsh 时不要把它们落下。这些程序比如说 rust、golang 的编译环境、nvm（nodejs version manager）、conda 等等。conda 似乎是其中的特例。你应该（在 bash 中）调用 <code>conda init zsh</code> 而非将 <code>.bashrc</code> 中的内容复制到 <code>.zshrc</code> 中。</p>
<h2 id="四、zsh-插件的安装"><a href="#四、zsh-插件的安装" class="headerlink" title="四、zsh 插件的安装"></a>四、zsh 插件的安装</h2><p>添加了这些内容后，zsh 开始像个回事了。zsh 已经完全具有了 bash 的基本内容，还拥有了一些特殊的功能，除了外观以外已经可以使用了。但是 zsh 还可以通过插件进一步提高其操作手感。这里和许多提及 zsh 的文章一样，推荐两个插件 <code>zsh-autosuggestions</code> 和 <code>zsh-syntax-highlighting</code>。</p>
<p>第一个插件会在输入命令时根据你的历史输入在已输入的内容后使用浅灰色指出你可能想要的输入，如果其确实是你所需要的，只需要按右方向键即可补全。</p>
<p>第二个插件会在输入命令的时候对命令自动染色，尤其对于不存在的指令会显示为红色，这对命令的检查很有帮助。</p>
<p>很好的是 <code>apt</code> 中已经有了这两个插件的包，只需要直接下载即可。<br><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">apt-get install zsh-autosuggestions</span><br><span class="line">apt-get install zsh-syntax-highlighting</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>你问我怎么知道的？这里提一下 apt 的搜索功能，似乎比较少有人提及。只需要执行如下命令即可搜索 zsh 相关的所有包<br><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">apt-cache search zsh</span><br></pre></td></tr></table></figure><br>使用如下命令还能得知软件源中的具体包版本<br><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">apt-cache madison zsh-syntax-highlighting</span><br></pre></td></tr></table></figure></p>
</blockquote>
<p>之后只需要将两个插件启用即可。只需要在 <code>.zshrc</code> 中添加如下两行。其中的路径是 <code>apt</code> 安装时的路径。<br><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># enable autosuggestions and syntax highlighting</span></span><br><span class="line"><span class="built_in">source</span> /usr/share/zsh-autosuggestions/zsh-autosuggestions.zsh</span><br><span class="line"><span class="built_in">source</span> /usr/share/zsh-syntax-highlighting/zsh-syntax-highlighting.zsh</span><br></pre></td></tr></table></figure></p>
<h2 id="五、Starship-定制外观"><a href="#五、Starship-定制外观" class="headerlink" title="五、Starship 定制外观"></a>五、Starship 定制外观</h2><p>如果你使用 zsh 是为一些炫酷的主题，那抱歉这一小节似乎无法提供给你，或许 oh-my-zsh 会更加适合。但是如果你只是想要一个实用且美观的 zsh 外观，那么这部分应该还是可以起到帮助的。</p>
<p>这一小节会通过 <a href="https://starship.rs/">Starship</a>，按官网所述，一个”轻量、迅速、可无限定制的高颜值终端“，来定制 zsh 的外观。值得注意的是 Starship 是跨 shell 的，这意味着你可以在自己系统的所有 shell 中都应用自己的配置。这是 oh-my-zsh 无法做到的。</p>
<h3 id="（1）安装-Nerd-Font-字体（非必须）"><a href="#（1）安装-Nerd-Font-字体（非必须）" class="headerlink" title="（1）安装 Nerd Font 字体（非必须）"></a>（1）安装 Nerd Font 字体（非必须）</h3><p>Starship 会使用 <a href="https://www.nerdfonts.com/">Nerd Font</a> 字体中的一些符号，因此需要下载一种 Nerd Font 类型的字体。可以从 Nerd Font 的官网上选择自己喜欢的字体。但之后并不一定需要直接在网站上下载压缩包。可以从 <code>apt</code> 或发行版本身的软件管理器上下载对应字体。如你想要使用 <code>fira</code> 字体，可以在 <code>apt</code> 上搜索相关内容，可以搜到相应的结果。<br><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ apt-cache search fira</span><br><span class="line">fonts-firacode - Monospaced font with programming ligatures</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>当然，字体其实也并非必须的，你可以选择使用全 ascii 的配置，同样有很好的效果，这一点会在之后说明。</p>
</blockquote>
<p>之后还需要配置终端的字体。不同的模拟终端软件应该有着不同的配置方法，这里肯定不能一一列举，只提一下 GNOME Terminal（默认终端） 和 vscode 终端的配置。</p>
<p>对于 GNOME Terminal，只需要右键终端，选择配置首选项，之后选择文本，使用自定义字体，选择新安装的字体即可。而对于 vscode，需要打开配置，搜索 <code>terminal.integrated.fontFamily</code> 将其值设置为新安装的字体名即可。</p>
<h3 id="（2）安装-Starship"><a href="#（2）安装-Starship" class="headerlink" title="（2）安装 Starship"></a>（2）安装 Starship</h3><p>执行如下命令即可安装。<br><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">curl -sS https://starship.rs/install.sh | sh</span><br></pre></td></tr></table></figure></p>
<p>之后在 <code>.zshrc</code> 中添加如下内容，以启用 Starship<br><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">eval</span> <span class="string">&quot;<span class="subst">$(starship init zsh)</span>&quot;</span></span><br></pre></td></tr></table></figure></p>
<p>在当前 zsh 中执行 <code>source .zshrc</code> 或创建一个新的 shell，现在你的 zsh 外观应该已经大变样了！</p>
<h3 id="（3）配置-Starship"><a href="#（3）配置-Starship" class="headerlink" title="（3）配置 Starship"></a>（3）配置 Starship</h3><p>Starship 使用一个配置文件 starship.toml 来配置 shell 外观。默认应该位于 ~/.config/starship.toml。Starship 官网上已经预设了一些<a href="https://starship.rs/presets">外观主题</a>，可以直接按照官网指导进行主题切换。只需要一条指令就可完成配置，比如下面的指令。<br><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">starship preset pastel-powerline -o ~/.config/starship.toml</span><br></pre></td></tr></table></figure></p>
<p>不过实际上我还是比较喜欢纯 ascii 的样子，这种主题也不需要使用 Nerd Font<br><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">starship preset plain-text-symbols -o ~/.config/starship.toml</span><br></pre></td></tr></table></figure></p>
<p>Starship 也提供了极其繁多的配置，可以在<a href="https://starship.rs/config/">文档</a>中查找自己感兴趣的内容自行配置。不过如果只是简单的配置一下的话，并不需要去把全部内容都看一遍。只需要了解如下几个内容即可。</p>
<p>在配置最开始使用 format 定义你的提示符格式。默认的配置是这样的<br><figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="attr">format</span> = <span class="string">&#x27;$all&#x27;</span></span><br></pre></td></tr></table></figure></p>
<p>实际等价于<br><figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="attr">format</span> = <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">$username\</span></span><br><span class="line"><span class="string">$hostname\</span></span><br><span class="line"><span class="string">$localip\</span></span><br><span class="line"><span class="string">$git_branch\</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">omit...</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">$cmd_duration\</span></span><br><span class="line"><span class="string">$line_break\</span></span><br><span class="line"><span class="string">$jobs\</span></span><br><span class="line"><span class="string">$battery\</span></span><br><span class="line"><span class="string">$time\</span></span><br><span class="line"><span class="string">$status\</span></span><br><span class="line"><span class="string">$os\</span></span><br><span class="line"><span class="string">$container\</span></span><br><span class="line"><span class="string">$shell\</span></span><br><span class="line"><span class="string">$character&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure></p>
<p>其中每一个 <code>$</code> 开头的变量都是用于表示对应内容在终端显示上的位置的占位符，当然其中很大部分都是不同语言的提示，也有很多都是未启用的功能。</p>
<p>如果想要自定义配置，其实并不需要按照和如上的格式一样将所有可能都列举出来。而只需要将想要移动位置的字符从 <code>$all</code> 中提出来即可。比如如果想要把用户名放在输入提示符的前面位置，只需要使用如下的 format 即可<br><figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="attr">format</span> = <span class="string">&#x27;$all $username $character&#x27;</span></span><br></pre></td></tr></table></figure></p>
<p>Starship 默认启用的功能就已经能够满足日常使用了。除此之外还可以启用一些功能，如用户名、时间等等，这就有待各位的探索了。</p>
<p>最后，展示一下我自己的 zsh 外观，各位也一定能配置出自己满意的外观。<br><img src="/posts/93ea500a/zsh.png" class="" title="my-zsh"></p>
]]></content>
      <categories>
        <category>踩坑记录</category>
      </categories>
      <tags>
        <tag>shell</tag>
        <tag>zsh</tag>
        <tag>starship</tag>
      </tags>
  </entry>
  <entry>
    <title>了解LLVM IR，从手写开始</title>
    <url>/posts/52312655/</url>
    <content><![CDATA[<h2 id="一、总览"><a href="#一、总览" class="headerlink" title="一、总览"></a>一、总览</h2><p>如果你想要了解 LLVM，那么有几种可能呢？你或许是想要创造一门新的编程语言的技术爱好者；或是陷入编译课的泥沼不能自拔的大学生，但不管怎么样，你都只希望使用 LLVM 做一件事：生成目标代码。</p>
<p>但是这一过程并不容易。你大概率经过了编译前端的艰辛历程，但是现在在你面前的是另一座大山，LLVM IR。在最开始就看到什么基本块、虚拟寄存器、phi 节点之类的概念使你心烦意乱；各种各样的代码示例中充满了和重点并不相关的细节。这些都使你无从下手……</p>
<p>会不会从一开始就错了？LLVM IR 并不应当被视为一种为了 “适配” LLVM 后端而创造的 “中间表示”，而应理解为一种特殊的编程语言。只不过这种语言站在了高级与低级语言之间，既具备了一定的抽象能力，又反映了底层汇编的工作原理。</p>
<span id="more"></span>
<p>本篇文章，就将以编程语言的视角粗略介绍 LLVM IR。通过直接手写 LLVM IR，逐步分析其特点和原理。希望能够有所帮助。</p>
<h3 id="（1）准备工作"><a href="#（1）准备工作" class="headerlink" title="（1）准备工作"></a>（1）准备工作</h3><p>LLVM IR 虽然是中间代码，但是 LLVM 也提供了 lli 工具用于解释/即时编译执行 LLVM IR 文件。这样 LLVM IR 又与 Java 字节码有了一些相似之处。使用 lli 可以直接运行我们手写的中间代码，很是方便。使用 lli 这需要安装 LLVM。<br><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">sudo apt-get install llvm</span><br></pre></td></tr></table></figure></p>
<p>另外，LLVM 中是没有内建输入输出的，因为 LLVM 的工作在操作系统之下。这就导致了一个问题，我们不能得知程序的执行结果。一种方法是可以用函数的返回值来输出，但是这样输出只能是单个数值。为了方便起见，可以先用 c 语言编写一个输出库。并使用 clang 将其编译成 LLVM IR。为此需要安装 clang<br><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">sudo apt-get install clang</span><br></pre></td></tr></table></figure></p>
<p>对于输出库，这里只简单定义 <code>putint</code> 函数。<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// lib.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">putint</span><span class="params">(<span class="type">int</span> i)</span> &#123; <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, i); &#125;</span><br></pre></td></tr></table></figure></p>
<p>使用 clang 将其翻译成中间代码。不要担心，我们并不需要关心生成的 <code>lib.ll</code> 中的任何内容。<br><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">clang -emit-llvm -S ./lib.c -o lib.ll</span><br></pre></td></tr></table></figure></p>
<p>现在准备工作就全部完成了。接下来我们从个第一个程序开始。</p>
<h3 id="（2）第一个程序，但是没有-hello-world"><a href="#（2）第一个程序，但是没有-hello-world" class="headerlink" title="（2）第一个程序，但是没有 hello world"></a>（2）第一个程序，但是没有 <code>hello world</code></h3><p>因为懒得去定义字符的输出，所以第一个程序并不会输出 hello world。这里就写一个简单的加法程序吧。只是输出 1、2 以及 1 + 2 的结果。<br><figure class="highlight llvm"><table><tr><td class="code"><pre><span class="line"><span class="comment">; first.ll</span></span><br><span class="line"><span class="keyword">declare</span> void <span class="title">@putint</span>(<span class="type">i32</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">define</span> <span class="type">i32</span> <span class="title">@main</span>() &#123;</span><br><span class="line">  <span class="keyword">call</span> void <span class="title">@putint</span>(<span class="type">i32</span> <span class="number">1</span>)</span><br><span class="line">  <span class="keyword">call</span> void <span class="title">@putint</span>(<span class="type">i32</span> <span class="number">2</span>)</span><br><span class="line">  <span class="variable">%result</span> <span class="operator">=</span> <span class="keyword">add</span> <span class="type">i32</span> <span class="number">1</span><span class="punctuation">,</span> <span class="number">2</span></span><br><span class="line">  <span class="keyword">call</span> void <span class="title">@putint</span>(<span class="type">i32</span> <span class="variable">%result</span>)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">ret</span> <span class="type">i32</span> <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>LLVM IR 使用 <code>;</code> 用作注释。</p>
</blockquote>
<p>编写完代码后，将该文件 first.ll 与之前通过 clang 生成的 lib.ll 使用 llvm-link 进行链接。<br><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">llvm-link lib.ll first.ll -o out.ll</span><br></pre></td></tr></table></figure></p>
<p>随后就可以使用 lli 命令执行链接后的 out.ll 文件<br><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">lli out.ll</span><br></pre></td></tr></table></figure></p>
<p>输出结果为<br><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td></tr></table></figure></p>
<p>从第一个程序中，你是否感觉到 LLVM IR 有很强的 c 的味道？首先是第一条 declare 语句，很明显对应了 c 语言中头文件的声明。</p>
<figure class="highlight llvm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">declare</span> void <span class="title">@putint</span>(<span class="type">i32</span>)</span><br></pre></td></tr></table></figure>
<p>对于函数定义，LLVM IR 中也保留了和 c 语言类似的结构。<br><figure class="highlight llvm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">define</span> <span class="type">i32</span> <span class="title">@main</span>() &#123;</span><br><span class="line">  <span class="comment">; omit...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>对于程序语句，函数调用依旧和 c 语言基本没有区别<br><figure class="highlight llvm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">call</span> void <span class="title">@putint</span>(<span class="type">i32</span> <span class="number">1</span>)</span><br></pre></td></tr></table></figure></p>
<p>唯一区别较大的是运算的部分，好像是不加定义就将结果赋给了一个<strong>变量</strong>，实际上 <code>%result</code> 表示了一个寄存器，而非在内存空间中存在的变量。<br><figure class="highlight llvm"><table><tr><td class="code"><pre><span class="line"><span class="variable">%result</span> <span class="operator">=</span> <span class="keyword">add</span> <span class="type">i32</span> <span class="number">1</span><span class="punctuation">,</span> <span class="number">2</span></span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>实际上，也不应当将 <code>%result</code> 这样的结果称为寄存器。而更应当将其看作用于表示该条指令结果的标识符。因为在 LLVM IR 中，这些 “寄存器” 并不对应任何指令集中的实际寄存器，可以任意定义，不需要进行寄存器的分配。且在同一函数中，每一条指令对应的寄存器名都不同。</p>
</blockquote>
<p>另外的区别在于类型上。LLVM IR 中保留了类型，但又与高级语言只在定义时声明类型不同，需要在每一次用到某一值的时候均说明其类型。以我们的第一个程序举例，在使用 add 指令、函数调用传参和函数返回时都显式写出了类型 <code>i32</code>。</p>
<p>但是不管怎么样，LLVM IR 依旧与 c 语言有很多相似之处，以至于我们可以直接将这个 LLVM IR 程序转换成 c 语言。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// lib.h</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">putint</span><span class="params">(<span class="type">int</span>)</span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// first.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;lib.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    putint(<span class="number">1</span>);</span><br><span class="line">    putint(<span class="number">2</span>);</span><br><span class="line">    putint(<span class="number">1</span> + <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从目前看来，LLVM IR 似乎也没什么难以理解的地方。之后我们就将逐步了解 LLVM IR 中的各部分内容，并编写相应代码。</p>
<h2 id="二、类型"><a href="#二、类型" class="headerlink" title="二、类型"></a>二、类型</h2><p>LLVM IR 是强类型的，并且每一个 “数值” 或 “变量” 在使用的时候都要指明其类型。这使得类型成为 LLVM IR 中十分重要的部分。因此这里将类型作为首先探讨的内容。不过 LLVM IR 的类型系统比较复杂，因此这里也只介绍和程序关系最紧密的部分。</p>
<p>对我们需要了解的部分来说，LLVM IR 的类型分为基本类型和聚合类型，和 c 语言类似。基本类型是各种运算指令的基本单位，包括整型、浮点型，再加上空（<code>void</code>）。聚合类型是基本类型的组合。包括数组和结构体。此外还有特殊的指针类型，各基本类型、聚合类型和指针本身都有其指针类型。</p>
<h3 id="（1）基本类型"><a href="#（1）基本类型" class="headerlink" title="（1）基本类型"></a>（1）基本类型</h3><p>对整型来说，LLVM 只关注整型的长度，而不关系其有无符号。符号的区别在 LLVM 中由指令表明。如无符号整数除法和有符号整数除法分别为 <code>udiv</code> 和 <code>sdiv</code>。</p>
<p>整型的长度，LLVM 并不明确设定为 32 和 64。而是可以选择 $1 \sim 2^{23} - 1$ 位中的任意数值作为整型所占比特数。</p>
<p>在 LLVM IR 中，整型由 <code>i</code> 加上整型所占比特数表示，因此 <code>i1</code>、<code>i2</code>、<code>i32</code>、<code>i64</code> 等都是合法的。特别的是 <code>i1</code> 在 LLVM IR 中明确表示 <code>bool</code> 类型，其常量值为 <code>true</code> 和 <code>false</code> 而非 <code>0</code> 和 <code>1</code>。</p>
<figure class="highlight llvm"><table><tr><td class="code"><pre><span class="line"><span class="comment">; int.ll</span></span><br><span class="line"><span class="comment">; i2 依旧可以使用，返回值应为 2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">define</span> <span class="type">i2</span> <span class="title">@main</span>() &#123;</span><br><span class="line">  <span class="variable">%t1</span> <span class="operator">=</span> <span class="keyword">add</span> <span class="type">i2</span> <span class="number">1</span><span class="punctuation">,</span> <span class="number">1</span></span><br><span class="line">  <span class="keyword">ret</span> <span class="type">i2</span> <span class="variable">%t1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>浮点类型包括 float、double 等等。根据标准的不同有不一样的具体类型。运算方式与整型类似。比如下面的例子，运行结果应为 7.555000。<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// lib.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">putint</span><span class="params">(<span class="type">int</span> i)</span> &#123; <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, i); &#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">putfloat</span><span class="params">(<span class="type">float</span> f)</span> &#123; <span class="built_in">printf</span>(<span class="string">&quot;%f\n&quot;</span>, f); &#125; <span class="comment">// new</span></span><br></pre></td></tr></table></figure><br><figure class="highlight llvm"><table><tr><td class="code"><pre><span class="line"><span class="comment">; float.ll</span></span><br><span class="line"><span class="keyword">declare</span> void <span class="title">@putfloat</span>(float)</span><br><span class="line"></span><br><span class="line"><span class="keyword">define</span> <span class="type">i32</span> <span class="title">@main</span>() &#123;</span><br><span class="line">  <span class="variable">%t0</span> <span class="operator">=</span> <span class="keyword">fadd</span> float <span class="number">2.0</span><span class="punctuation">,</span> <span class="number">0x40163851E0000000</span></span><br><span class="line">  <span class="keyword">call</span> void <span class="title">@putfloat</span>(float <span class="variable">%t0</span>)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">ret</span> <span class="type">i32</span> <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>需要注意的是，由于并非所有的小数都能用浮点数表示，因此有许多浮点数常量并不能直接被使用，如 2.0 可以由浮点数表示，因此可以作为常量；而 0.2 不能由浮点数表示，因此不能作为常量。更好的方式是直接用 16 进制表示浮点数。如上述例子中的 <code>0x40163851E0000000</code>，实际表示 0.555。</p>
<h3 id="（2）聚合类型"><a href="#（2）聚合类型" class="headerlink" title="（2）聚合类型"></a>（2）聚合类型</h3><p>数组用于表示一定连续地址空间中存储的类型相同的数据。在 LLVM IR 中用 <code>[N x T]</code> 的形式表示。其中 <code>N</code> 为数组的长度，<code>T</code> 为数据类型，可以是基本类型、结构体、指针或是另一个数组。因此 LLVM IR 中可以表示多维数组。举个例子，如果要表示类似于 <code>int arr[2][3]</code> 的二维数组，则其类型为 <code>[2 x [3 x i32]]</code>。</p>
<p>特别需要提一下数组常量的表示方法。这对于初始化全局变量来说十分重要。在 LLVM IR 中数组常量值用 <code>[T V, T V, ..., T V]</code> 的形式表示。如果是一位数组如 <code>&#123;1, 2, 3&#125;</code>，则其值为 <code>[i32 1, i32 2, i32 3]</code>。如果是二维数组如 <code>&#123;&#123;1, 2&#125;, &#123;3, 4&#125;&#125;</code>，则其值为 <code>[[2 x i32] [i32 1, i32 2], [2 x i32] [i32 3, i32 4]]</code>，更高维度则类似。当然在 LLVM IR 中一般在值前都要加上类型，因此在使用常量时还需在最前面加上常量本身的类型，比如说 <code>[i32 1, i32 2, i32 3]</code>，常以 <code>[3 x i32] [i32 1, i32 2, i32 3]</code> 的方式使用。</p>
<p>接下来举一例子来说明。当然因为数组涉及到地址的计算和从地址中取值，所以代码的 <code>main</code> 函数中用到了还未提及的指令，现在可以先忽略不看。只看定义全局变量时使用到的初始值 <code>[3 x i32] [i32 1, i32 2, i32 3]</code>。</p>
<figure class="highlight llvm"><table><tr><td class="code"><pre><span class="line"><span class="comment">; array.ll</span></span><br><span class="line"><span class="keyword">declare</span> void <span class="title">@putint</span>(<span class="type">i32</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">; 定义全局变量 @arr，这里用到了数组常量进行初始化</span></span><br><span class="line"><span class="title">@arr</span> <span class="operator">=</span> <span class="keyword">global</span> [<span class="number">3</span> <span class="keyword">x</span> <span class="type">i32</span>] [<span class="type">i32</span> <span class="number">1</span><span class="punctuation">,</span> <span class="type">i32</span> <span class="number">2</span><span class="punctuation">,</span> <span class="type">i32</span> <span class="number">3</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">define</span> <span class="type">i32</span> <span class="title">@main</span>() &#123;</span><br><span class="line">  <span class="comment">; 输出 arr[0] 的值</span></span><br><span class="line">  <span class="variable">%arr0</span> <span class="operator">=</span> <span class="keyword">getelementptr</span> [<span class="number">3</span> <span class="keyword">x</span> <span class="type">i32</span>]<span class="punctuation">,</span> [<span class="number">3</span> <span class="keyword">x</span> <span class="type">i32</span>]* <span class="title">@arr</span><span class="punctuation">,</span> <span class="type">i32</span> <span class="number">0</span><span class="punctuation">,</span> <span class="type">i32</span> <span class="number">0</span></span><br><span class="line">  <span class="variable">%arr0val</span> <span class="operator">=</span> <span class="keyword">load</span> <span class="type">i32</span><span class="punctuation">,</span> <span class="type">i32</span>* <span class="variable">%arr0</span></span><br><span class="line">  <span class="keyword">call</span> void <span class="title">@putint</span>(<span class="type">i32</span> <span class="variable">%arr0val</span>)</span><br><span class="line"></span><br><span class="line">  <span class="comment">; 输出 arr[1] 的值</span></span><br><span class="line">  <span class="variable">%arr1</span> <span class="operator">=</span> <span class="keyword">getelementptr</span> [<span class="number">3</span> <span class="keyword">x</span> <span class="type">i32</span>]<span class="punctuation">,</span> [<span class="number">3</span> <span class="keyword">x</span> <span class="type">i32</span>]* <span class="title">@arr</span><span class="punctuation">,</span> <span class="type">i32</span> <span class="number">0</span><span class="punctuation">,</span> <span class="type">i32</span> <span class="number">1</span></span><br><span class="line">  <span class="variable">%arr1val</span> <span class="operator">=</span> <span class="keyword">load</span> <span class="type">i32</span><span class="punctuation">,</span> <span class="type">i32</span>* <span class="variable">%arr1</span></span><br><span class="line">  <span class="keyword">call</span> void <span class="title">@putint</span>(<span class="type">i32</span> <span class="variable">%arr1val</span>)</span><br><span class="line"></span><br><span class="line">  <span class="comment">; 输出 arr[2] 的值</span></span><br><span class="line">  <span class="variable">%arr2</span> <span class="operator">=</span> <span class="keyword">getelementptr</span> [<span class="number">3</span> <span class="keyword">x</span> <span class="type">i32</span>]<span class="punctuation">,</span> [<span class="number">3</span> <span class="keyword">x</span> <span class="type">i32</span>]* <span class="title">@arr</span><span class="punctuation">,</span> <span class="type">i32</span> <span class="number">0</span><span class="punctuation">,</span> <span class="type">i32</span> <span class="number">2</span></span><br><span class="line">  <span class="variable">%arr2val</span> <span class="operator">=</span> <span class="keyword">load</span> <span class="type">i32</span><span class="punctuation">,</span> <span class="type">i32</span>* <span class="variable">%arr2</span></span><br><span class="line">  <span class="keyword">call</span> void <span class="title">@putint</span>(<span class="type">i32</span> <span class="variable">%arr2val</span>)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">ret</span> <span class="type">i32</span> <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在运行该程序，应该得到如下输出<br><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td></tr></table></figure></p>
<p>结构体与数组类似，但是用于表示连续地址空间中一组类型不同的数据。结构体在使用前需要先定义，其定义方式和 c 语言类似，同时也必须在函数体外定义。如下给出一个结构体定义的例子。例子中定义了结构体名为 <code>MyStruct</code>，其中包含一个整数、一个浮点数和一个大小为 3 的整数数组。注意 <code>%</code> 是必须的<br><figure class="highlight llvm"><table><tr><td class="code"><pre><span class="line"><span class="variable">%MyStruct</span> <span class="operator">=</span> <span class="keyword">type</span> &#123;</span><br><span class="line">    <span class="type">i32</span><span class="punctuation">,</span></span><br><span class="line">    float<span class="punctuation">,</span></span><br><span class="line">    [<span class="number">3</span> <span class="keyword">x</span> <span class="type">i32</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>定义完结构体后，使用该结构体类型和使用其他类型的方式基本相同。只不过需要使用定义时的结构体名而已，还以上面的代码为例子，在使用该类型时应当使用 <code>%MyStruct</code>。</p>
<p>结构体常量和数组常量类似，在定义全局变量的时候使用。在 LLVM IR 中用 <code>&#123;T V, T V, ..., T V&#125;</code> 的形式表示。在使用时也常在前面加上常量本身的类型。如对于 <code>%MyStruct</code> 可以定义常量 <code>%MyStruct &#123; i32 10, float 2.0, [3 x i32] [i32 3, i32 2, i32 1]&#125;</code>。</p>
<p>如下是一个使用结构体的例子，同样现在并不需要关注 <code>main</code> 函数中的内容。只需要看前面对于 <code>%MyStruct</code> 结构体类型的定义和对全局变量 <code>@mystruct</code> 定义时结构体常量的声明即可。</p>
<figure class="highlight llvm"><table><tr><td class="code"><pre><span class="line"><span class="comment">; struct.ll</span></span><br><span class="line"><span class="keyword">declare</span> void <span class="title">@putint</span>(<span class="type">i32</span>)</span><br><span class="line"><span class="keyword">declare</span> void <span class="title">@putfloat</span>(float)</span><br><span class="line"></span><br><span class="line"><span class="variable">%MyStruct</span> <span class="operator">=</span> <span class="keyword">type</span> &#123;</span><br><span class="line">    <span class="type">i32</span><span class="punctuation">,</span></span><br><span class="line">    float<span class="punctuation">,</span></span><br><span class="line">    [<span class="number">3</span> <span class="keyword">x</span> <span class="type">i32</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title">@mystruct</span> <span class="operator">=</span> <span class="keyword">global</span> <span class="variable">%MyStruct</span> &#123; <span class="type">i32</span> <span class="number">10</span><span class="punctuation">,</span> float <span class="number">2.0</span><span class="punctuation">,</span> [<span class="number">3</span> <span class="keyword">x</span> <span class="type">i32</span>] [<span class="type">i32</span> <span class="number">3</span><span class="punctuation">,</span> <span class="type">i32</span> <span class="number">2</span><span class="punctuation">,</span> <span class="type">i32</span> <span class="number">1</span>]&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">define</span> <span class="type">i32</span> <span class="title">@main</span>() &#123;</span><br><span class="line">  <span class="comment">; 取 i32</span></span><br><span class="line">  <span class="variable">%mystruct0</span> <span class="operator">=</span> <span class="keyword">getelementptr</span> <span class="variable">%MyStruct</span><span class="punctuation">,</span> <span class="variable">%MyStruct</span>* <span class="title">@mystruct</span><span class="punctuation">,</span> <span class="type">i32</span> <span class="number">0</span><span class="punctuation">,</span> <span class="type">i32</span> <span class="number">0</span></span><br><span class="line">  <span class="variable">%mystruct0val</span> <span class="operator">=</span> <span class="keyword">load</span> <span class="type">i32</span><span class="punctuation">,</span> <span class="type">i32</span>* <span class="variable">%mystruct0</span></span><br><span class="line">  <span class="keyword">call</span> void <span class="title">@putint</span>(<span class="type">i32</span> <span class="variable">%mystruct0val</span>)</span><br><span class="line">  </span><br><span class="line">  <span class="comment">; 取 float</span></span><br><span class="line">  <span class="variable">%mystruct1</span> <span class="operator">=</span> <span class="keyword">getelementptr</span> <span class="variable">%MyStruct</span><span class="punctuation">,</span> <span class="variable">%MyStruct</span>* <span class="title">@mystruct</span><span class="punctuation">,</span> <span class="type">i32</span> <span class="number">0</span><span class="punctuation">,</span> <span class="type">i32</span> <span class="number">1</span></span><br><span class="line">  <span class="variable">%mystruct1val</span> <span class="operator">=</span> <span class="keyword">load</span> float<span class="punctuation">,</span> float* <span class="variable">%mystruct1</span></span><br><span class="line">  <span class="keyword">call</span> void <span class="title">@putfloat</span>(float <span class="variable">%mystruct1val</span>)</span><br><span class="line"></span><br><span class="line">  <span class="comment">; 取 [3 x i32] 各元素</span></span><br><span class="line">  <span class="comment">; 取 [0]</span></span><br><span class="line">  <span class="variable">%mystruct2</span> <span class="operator">=</span> <span class="keyword">getelementptr</span> <span class="variable">%MyStruct</span><span class="punctuation">,</span> <span class="variable">%MyStruct</span>* <span class="title">@mystruct</span><span class="punctuation">,</span> <span class="type">i32</span> <span class="number">0</span><span class="punctuation">,</span> <span class="type">i32</span> <span class="number">2</span></span><br><span class="line">  <span class="variable">%arr0</span> <span class="operator">=</span> <span class="keyword">getelementptr</span> [<span class="number">3</span> <span class="keyword">x</span> <span class="type">i32</span>]<span class="punctuation">,</span> [<span class="number">3</span> <span class="keyword">x</span> <span class="type">i32</span>]* <span class="variable">%mystruct2</span><span class="punctuation">,</span> <span class="type">i32</span> <span class="number">0</span><span class="punctuation">,</span> <span class="type">i32</span> <span class="number">0</span></span><br><span class="line">  <span class="variable">%arr0val</span> <span class="operator">=</span> <span class="keyword">load</span> <span class="type">i32</span><span class="punctuation">,</span> <span class="type">i32</span>* <span class="variable">%arr0</span></span><br><span class="line">  <span class="keyword">call</span> void <span class="title">@putint</span>(<span class="type">i32</span> <span class="variable">%arr0val</span>)</span><br><span class="line"></span><br><span class="line">  <span class="comment">; 取 [1]</span></span><br><span class="line">  <span class="variable">%arr1</span> <span class="operator">=</span> <span class="keyword">getelementptr</span> [<span class="number">3</span> <span class="keyword">x</span> <span class="type">i32</span>]<span class="punctuation">,</span> [<span class="number">3</span> <span class="keyword">x</span> <span class="type">i32</span>]* <span class="variable">%mystruct2</span><span class="punctuation">,</span> <span class="type">i32</span> <span class="number">0</span><span class="punctuation">,</span> <span class="type">i32</span> <span class="number">1</span></span><br><span class="line">  <span class="variable">%arr1val</span> <span class="operator">=</span> <span class="keyword">load</span> <span class="type">i32</span><span class="punctuation">,</span> <span class="type">i32</span>* <span class="variable">%arr1</span></span><br><span class="line">  <span class="keyword">call</span> void <span class="title">@putint</span>(<span class="type">i32</span> <span class="variable">%arr1val</span>)</span><br><span class="line"></span><br><span class="line">  <span class="comment">; 取 [2]</span></span><br><span class="line">  <span class="variable">%arr2</span> <span class="operator">=</span> <span class="keyword">getelementptr</span> [<span class="number">3</span> <span class="keyword">x</span> <span class="type">i32</span>]<span class="punctuation">,</span> [<span class="number">3</span> <span class="keyword">x</span> <span class="type">i32</span>]* <span class="variable">%mystruct2</span><span class="punctuation">,</span> <span class="type">i32</span> <span class="number">0</span><span class="punctuation">,</span> <span class="type">i32</span> <span class="number">2</span></span><br><span class="line">  <span class="variable">%arr2val</span> <span class="operator">=</span> <span class="keyword">load</span> <span class="type">i32</span><span class="punctuation">,</span> <span class="type">i32</span>* <span class="variable">%arr2</span></span><br><span class="line">  <span class="keyword">call</span> void <span class="title">@putint</span>(<span class="type">i32</span> <span class="variable">%arr2val</span>)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">ret</span> <span class="type">i32</span> <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>运行程序的结果应是<br><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">10</span><br><span class="line">2.000000</span><br><span class="line">3</span><br><span class="line">2</span><br><span class="line">1</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>最后还需要说明一个小知识点。那就是可以使用 <code>zeroinitializer</code> 来统一对全局量所对应的地址区域的所有位置零。如一个全为 0 的大小为 3 的整数数组，可以使用如下形式作为初始值 <code>[3 x i32] zeroinitializer</code> 这表示一个 3 x i32 大小的全 0 区域。类似的，对于二维，如 <code>&#123;&#123;0, 0&#125;, &#123;0, 1&#125;&#125;</code>，也可以用如下的形式初始化：<code>[2 x [2 x i32]] [[2 x i32] zeroinitializer, [2 x i32] [i32 0, i32 1]]</code>。结构体使用 <code>zeroinitializer</code> 类似。</p>
</blockquote>
<h3 id="（3）指针"><a href="#（3）指针" class="headerlink" title="（3）指针"></a>（3）指针</h3><p>指针就是地址，所有类型都有其对应的指针。这一点和 c 相同。地址当然主要用于存取数据，有时也需要直接对地址进行运算操作。前一种操作将在下一章讲解，而后一种操作主要通过 <code>ptrtoint .. to</code> 和 <code>inttoptr .. to</code> 将指针与整型相互转化来完成。举个例子，可以使用 <code>%addr_int = ptrtoint i32* %some_addr to i64</code> 将指针转换为 64 位整数。这样就可以对指针采用整数的运算了。</p>
<p>指针常常作为函数参数传递。比如说对于一个数组，我们并不会将其全部内容都复制到栈上，而是只传递该数组的指针，这一点很好理解。与 c 语言类似，一个特殊的情况是在传递多维数组时，需要明确指定大于 1 的维度的具体数值。在 c 语言这表示为<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">func</span><span class="params">(<span class="type">int</span> arr[][<span class="number">10</span>])</span> &#123; &#125;</span><br></pre></td></tr></table></figure></p>
<p>而在 LLVM IR 中，则以如下形式表示<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">define <span class="type">void</span> @func([<span class="number">10</span> x i32]* %arr) &#123;</span><br><span class="line">  ret <span class="type">void</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>如下是一个使用指针的例子，请关注函数体中对 <code>ptrtoint</code> 的使用，以及函数的参数中的指针。通过注释，应该可以理解函数间数组指针的传递方式。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// lib.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">putint</span><span class="params">(<span class="type">int</span> i)</span> &#123; <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, i); &#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">putfloat</span><span class="params">(<span class="type">float</span> f)</span> &#123; <span class="built_in">printf</span>(<span class="string">&quot;%f\n&quot;</span>, f); &#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">putaddr</span><span class="params">(<span class="type">size_t</span> addr)</span> &#123; <span class="built_in">printf</span>(<span class="string">&quot;%#zx\n&quot;</span>, addr); &#125; <span class="comment">// new</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight llvm"><table><tr><td class="code"><pre><span class="line"><span class="comment">; pointer.ll</span></span><br><span class="line"><span class="keyword">declare</span> void <span class="title">@putaddr</span>(<span class="type">i64</span>)</span><br><span class="line"></span><br><span class="line"><span class="title">@arr</span> <span class="operator">=</span> <span class="keyword">global</span> [<span class="number">2</span> <span class="keyword">x</span> [<span class="number">2</span> <span class="keyword">x</span> <span class="type">i32</span>]] [[<span class="number">2</span> <span class="keyword">x</span> <span class="type">i32</span>] [<span class="type">i32</span> <span class="number">1</span><span class="punctuation">,</span> <span class="type">i32</span> <span class="number">2</span>]<span class="punctuation">,</span> [<span class="number">2</span> <span class="keyword">x</span> <span class="type">i32</span>] [<span class="type">i32</span> <span class="number">3</span><span class="punctuation">,</span> <span class="type">i32</span> <span class="number">4</span>]]</span><br><span class="line"></span><br><span class="line"><span class="keyword">define</span> void <span class="title">@func1</span>([<span class="number">2</span> <span class="keyword">x</span> <span class="type">i32</span>]* <span class="variable">%arr</span>) &#123;</span><br><span class="line">  <span class="variable">%addr</span> <span class="operator">=</span> <span class="keyword">ptrtoint</span> [<span class="number">2</span> <span class="keyword">x</span> <span class="type">i32</span>]* <span class="variable">%arr</span> <span class="keyword">to</span> <span class="type">i64</span></span><br><span class="line">  <span class="keyword">call</span> void <span class="title">@putaddr</span>(<span class="type">i64</span> <span class="variable">%addr</span>)</span><br><span class="line"></span><br><span class="line">  <span class="comment">; arr[1]</span></span><br><span class="line">  <span class="variable">%arr1addr</span> <span class="operator">=</span> <span class="keyword">getelementptr</span> [<span class="number">2</span> <span class="keyword">x</span> <span class="type">i32</span>]<span class="punctuation">,</span> [<span class="number">2</span> <span class="keyword">x</span> <span class="type">i32</span>]* <span class="variable">%arr</span><span class="punctuation">,</span> <span class="type">i32</span> <span class="number">0</span><span class="punctuation">,</span> <span class="type">i32</span> <span class="number">1</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">; func2(arr[1])</span></span><br><span class="line">  <span class="keyword">call</span> void <span class="title">@func2</span>(<span class="type">i32</span>* <span class="variable">%arr1addr</span>)</span><br><span class="line">  <span class="keyword">ret</span> void</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">define</span> void <span class="title">@func2</span>(<span class="type">i32</span>* <span class="variable">%arr</span>) &#123;</span><br><span class="line">  <span class="variable">%addr</span> <span class="operator">=</span> <span class="keyword">ptrtoint</span> <span class="type">i32</span>* <span class="variable">%arr</span> <span class="keyword">to</span> <span class="type">i64</span></span><br><span class="line">  <span class="keyword">call</span> void <span class="title">@putaddr</span>(<span class="type">i64</span> <span class="variable">%addr</span>)</span><br><span class="line">  <span class="keyword">ret</span> void</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">define</span> <span class="type">i32</span> <span class="title">@main</span>() &#123;</span><br><span class="line">  <span class="variable">%addr</span> <span class="operator">=</span> <span class="keyword">ptrtoint</span> [<span class="number">2</span> <span class="keyword">x</span> [<span class="number">2</span> <span class="keyword">x</span> <span class="type">i32</span>]]* <span class="title">@arr</span> <span class="keyword">to</span> <span class="type">i64</span></span><br><span class="line">  <span class="keyword">call</span> void <span class="title">@putaddr</span>(<span class="type">i64</span> <span class="variable">%addr</span>)</span><br><span class="line">  </span><br><span class="line">  <span class="comment">; arr[1]</span></span><br><span class="line">  <span class="variable">%arr1addr</span> <span class="operator">=</span> <span class="keyword">getelementptr</span> [<span class="number">2</span> <span class="keyword">x</span> [<span class="number">2</span> <span class="keyword">x</span> <span class="type">i32</span>]]<span class="punctuation">,</span> [<span class="number">2</span> <span class="keyword">x</span> [<span class="number">2</span> <span class="keyword">x</span> <span class="type">i32</span>]]* <span class="title">@arr</span><span class="punctuation">,</span> <span class="type">i32</span> <span class="number">0</span><span class="punctuation">,</span> <span class="type">i32</span> <span class="number">1</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">; func1(arr[1])</span></span><br><span class="line">  <span class="keyword">call</span> void <span class="title">@func1</span>([<span class="number">2</span> <span class="keyword">x</span> <span class="type">i32</span>]* <span class="variable">%arr1addr</span>)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">ret</span> <span class="type">i32</span> <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在我的设备上，该程序的运行结果如下<br><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">0x7f03162ff000</span><br><span class="line">0x7f03162ff008</span><br><span class="line">0x7f03162ff00c</span><br></pre></td></tr></table></figure><br>可以看出全局数组 <code>@arr</code> 的基地址为 <code>0x7f381bd79000</code>。之后调用 <code>func1(arr[1])</code>，在 <code>func1</code> 中传入的地址为 <code>0x7f03162ff008</code>，偏移了 8 个字节，即两个 i32 长度。再之后在 <code>func1</code> 中调用 <code>func2(arr[1])</code>，传入 <code>func2</code> 的地址变为 <code>0x7f03162ff00c</code>，与 <code>0x7f03162ff008</code> 相比偏移了 4 个字节，正是一个 i32 长度。</p>
<h2 id="三、变量"><a href="#三、变量" class="headerlink" title="三、变量"></a>三、变量</h2><p>类型定义了数据的表示，而变量定义了数据的位置。接下来我们就要了解 LLVM IR 中的变量。</p>
<p>众所周知，按其存储位置，变量分为三类，分别是栈上变量、堆上变量和静态存储区的变量。然而堆上变量由操作系统（或者说程序员）分配，在编译中并不考虑，所以实际上在 LLVM IR 中只有另外两种变量。</p>
<h3 id="（1）全局量"><a href="#（1）全局量" class="headerlink" title="（1）全局量"></a>（1）全局量</h3><p>静态存储区的变量，实际上我们已经在之前的章节中看到过了。就是那些定义在函数体以外的全局变量。此种变量可以使用 <code>global</code> 或 <code>constant</code> 定义。如 <code>@a = global i32 1</code> 或 <code>@two = constant i32 2</code>，其中以 <code>constant</code> 定义的全局量只读而不可写。这些变量都需要为其设置初始值，如果不想设定（或者说默认设定为 0），那么可以使用 <code>zeroinitializer</code> 将其置零，这在上一节中已经说明了。</p>
<blockquote>
<p>对于全局量还需要注意一点，那就是全局量在定义的同时都为其设定了一个名字，形如 <code>@xxx</code>。此标签和我们在函数体中使用的 “虚拟寄存器” 不同。实际上应当将其看作汇编中的 “标签”。也就是说，其本质应当是一个地址；更进一步来说，也可以看作是一个指向所定义全局量的指针。正因如此，像是 <code>%t = add i32 @a, 1</code> 这样的表述是错误的，因为 <code>@a</code> 的类型应为 <code>i32*</code>。</p>
</blockquote>
<h3 id="（2）局部量"><a href="#（2）局部量" class="headerlink" title="（2）局部量"></a>（2）局部量</h3><p>除了全局量就只剩下栈上变量了，或者可以称为局部变量。栈上变量的空间是动态增减的，在 LLVM 中使用一条特殊的指令 <code>alloca</code> 表示函数中的栈上空间申请操作。而当函数结束返回时，则会自动释放栈上空间。</p>
<blockquote>
<p>需要注意局部变量没有真正的 constant。因为对于全局量，可以分别将变量和常量划分到不同的地址区域中。使得变量所在地址区域可读写，而常量区域只可读。关于这一点，可以参见操作系统的页表管理和程序段加载相关的知识。</p>
</blockquote>
<p><code>alloca</code> 指令的具体形式是这样的 <code>%xxx = alloca T</code>，表示分配了一块用于存储 T 类型的栈上空间，<strong>其地址</strong>存储在虚拟寄存器 <code>%xxx</code> 中。注意这里 <code>%xxx</code> 的类型是 <code>T*</code> 而非 <code>T</code>，这一点与全局变量时类似。</p>
<blockquote>
<p><code>alloca</code> 与全局变量的定义有不同之处。<code>alloca</code> 指令不会带有初始值，因此如果想要设定初始值的话只能在此命令之后使用另外一条指令 <code>store</code> 设定其值。</p>
<p>需要注意一点，<code>alloca</code> 只应在函数的最开始使用，因为 <code>alloca</code> 本质上是向下移动栈指针，在栈上多分配一块空间。如果 <code>alloca</code> 不在最开始使用，则可能会出现在循环中，这会导致不停的分配栈空间，可能导致栈溢出。</p>
<p>如下代码能证明循环中的局部变量都占据相同的栈空间：<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        <span class="type">int</span> a;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, a);</span><br><span class="line">        a++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>输出为 <code>0 1 2 3 4 5 6 7 8 9</code></p>
</blockquote>
<p>现在我们已经知道了分配的内存空间的地址，想要对内存进行存取操作。又需要两条指令 <code>store</code> 和 <code>load</code>。（时刻记住，LLVM IR 中操作的是寄存器而非内存。这是 LLVM IR 类似于汇编而不同于高级语言的地方）。</p>
<p>对于 <code>store</code>，目的当然是将寄存器中的值存储到目的内存空间中。其格式为 <code>store T %val, P %ptr</code>，<code>%val</code> 为存储值的寄存器，T 为其类型；<code>%ptr</code> 为存储地址的寄存器，当然也可以是全局变量的 <code>@ptr</code>，P 为其类型，应当满足 T* = P。值得注意的是，<code>store</code> 指令是一条 没有“返回值” 的指令。</p>
<p>而 <code>load</code> 则是 <code>store</code> 的反操作，唯一的不同是 <code>load</code> 具有 ”返回值”。其格式为 <code>%val = load T, P %ptr</code>。</p>
<p>接下来就结合上述内容举一例子。</p>
<figure class="highlight llvm"><table><tr><td class="code"><pre><span class="line"><span class="comment">; val.ll</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">declare</span> void <span class="title">@putint</span>(<span class="type">i32</span>)</span><br><span class="line"></span><br><span class="line"><span class="title">@a</span> <span class="operator">=</span> <span class="keyword">global</span> <span class="type">i32</span> <span class="number">1</span></span><br><span class="line"><span class="title">@two</span> <span class="operator">=</span> <span class="keyword">constant</span> <span class="type">i32</span> <span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">define</span> <span class="type">i32</span> <span class="title">@main</span>() &#123;</span><br><span class="line">  <span class="comment">; alloca 必须在最开始使用</span></span><br><span class="line">  <span class="variable">%var</span> <span class="operator">=</span> <span class="keyword">alloca</span> <span class="type">i32</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">; 错误用法：call void @putint(@a)</span></span><br><span class="line">  <span class="variable">%a_val</span> <span class="operator">=</span> <span class="keyword">load</span> <span class="type">i32</span><span class="punctuation">,</span> <span class="type">i32</span>* <span class="title">@a</span></span><br><span class="line">  <span class="keyword">call</span> void <span class="title">@putint</span>(<span class="type">i32</span> <span class="variable">%a_val</span>)</span><br><span class="line">  </span><br><span class="line">  <span class="comment">; 错误用法：store i32 3, i32* @two</span></span><br><span class="line">  <span class="keyword">store</span> <span class="type">i32</span> <span class="number">100</span><span class="punctuation">,</span> <span class="type">i32</span>* <span class="title">@a</span></span><br><span class="line">  <span class="variable">%a_val2</span> <span class="operator">=</span> <span class="keyword">load</span> <span class="type">i32</span><span class="punctuation">,</span> <span class="type">i32</span>* <span class="title">@a</span></span><br><span class="line">  <span class="keyword">call</span> void <span class="title">@putint</span>(<span class="type">i32</span> <span class="variable">%a_val2</span>)</span><br><span class="line">  </span><br><span class="line">  <span class="comment">; 未初始化，取值未定义</span></span><br><span class="line">  <span class="variable">%var_val</span> <span class="operator">=</span> <span class="keyword">load</span> <span class="type">i32</span><span class="punctuation">,</span> <span class="type">i32</span>* <span class="variable">%var</span></span><br><span class="line">  <span class="keyword">call</span> void <span class="title">@putint</span>(<span class="type">i32</span> <span class="variable">%var_val</span>)</span><br><span class="line">  </span><br><span class="line">  <span class="comment">; 初值设定为 123</span></span><br><span class="line">  <span class="keyword">store</span> <span class="type">i32</span> <span class="number">123</span><span class="punctuation">,</span> <span class="type">i32</span>* <span class="variable">%var</span></span><br><span class="line">  <span class="variable">%var_val2</span> <span class="operator">=</span> <span class="keyword">load</span> <span class="type">i32</span><span class="punctuation">,</span> <span class="type">i32</span>* <span class="variable">%var</span></span><br><span class="line">  <span class="keyword">call</span> void <span class="title">@putint</span>(<span class="type">i32</span> <span class="variable">%var_val2</span>)</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">ret</span> <span class="type">i32</span> <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果如下，其中第三行的输出实际不确定。<br><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">1</span><br><span class="line">100</span><br><span class="line">0</span><br><span class="line">123</span><br></pre></td></tr></table></figure></p>
<h3 id="（3）古怪的-getelementptr"><a href="#（3）古怪的-getelementptr" class="headerlink" title="（3）古怪的 getelementptr"></a>（3）古怪的 getelementptr</h3><p>现在我们已经了解了如何定义变量，以及如何存取其值了。所以可以进入下一章了吗？其实还不能。假如我现在想要定义一个数组，并且想要获取其每个元素的值；或者定义一个结构体，访问其中的各个属性，需要怎么做呢？</p>
<p>不管是全局变量还是栈上，定义的话很是简单，只需要 <code>@arr = global [3 x i32] [i32 1, i32 2, i32 3]</code> 或 <code>%arr = alloca [3 x i32]</code> 即可。但问题是我们要如何取每一个元素的值呢？毕竟现在我们只知道数组的首地址。</p>
<p>你可能会想要使用指针运算，将当前的地址加上 4 得到下一个元素的地址。但是这样需要用到 <code>ptrtoint</code>，而得到地址之后，因为 <code>load</code> 和 <code>store</code> 只接受对应类型的指针，所以还需要用 <code>inttoptr</code> 转换回对应类型指针。这样的操作实在太过复杂，很明显不是正解。</p>
<p>真正的解决方法是使用指令 <code>getelementptr</code>。此指令在 LLVM IR 严格的类型系统下有着很大的作用，能够很方便的得到聚合类型各个元素的地址，同时实现指针类型的转换。</p>
<p><code>getelementptr</code> 在我看来有着三种使用形式，接下来就一一解释这三种形式</p>
<h4 id="计算数组指针的-getelementptr"><a href="#计算数组指针的-getelementptr" class="headerlink" title="计算数组指针的 getelementptr"></a>计算数组指针的 getelementptr</h4><p><code>getelementptr</code> 最简单的形式如下 <code>%ptr = getelementptr T, T* %baseptr, V %idx</code>。这实际上等价于 c 语言中的指针加法 <code>baseptr + idx</code>。旨在求以 T 类型的大小为单位，从 <code>%base</code> 所在地址开始，偏移 <code>%idx</code> 得到的地址。因此经过此命令后，指针的类型并不发生改变。</p>
<p>假设现在有一函数，其 c 语言形式为 <code>void func(int arr[])</code>，则我们现在就可以使用 <code>getelmentptr</code> 取得其值。<br><figure class="highlight llvm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">define</span> void <span class="title">@func</span>(<span class="type">i32</span>* <span class="variable">%arr</span>) &#123;</span><br><span class="line">  <span class="comment">; putint(arr[0])</span></span><br><span class="line">  <span class="variable">%arr0</span> <span class="operator">=</span> <span class="keyword">getelementptr</span> <span class="type">i32</span><span class="punctuation">,</span> <span class="type">i32</span>* <span class="variable">%arr</span><span class="punctuation">,</span> <span class="type">i32</span> <span class="number">0</span></span><br><span class="line">  <span class="variable">%arr0val</span> <span class="operator">=</span> <span class="keyword">load</span> <span class="type">i32</span><span class="punctuation">,</span> <span class="type">i32</span>* <span class="variable">%arr0</span></span><br><span class="line">  <span class="keyword">call</span> void <span class="title">@putint</span>(<span class="type">i32</span> <span class="variable">%arr0val</span>)</span><br><span class="line"></span><br><span class="line">  <span class="comment">; putint(arr[1])</span></span><br><span class="line">  <span class="variable">%arr1</span> <span class="operator">=</span> <span class="keyword">getelementptr</span> <span class="type">i32</span><span class="punctuation">,</span> <span class="type">i32</span>* <span class="variable">%arr</span><span class="punctuation">,</span> <span class="type">i32</span> <span class="number">1</span></span><br><span class="line">  <span class="variable">%arr1val</span> <span class="operator">=</span> <span class="keyword">load</span> <span class="type">i32</span><span class="punctuation">,</span> <span class="type">i32</span>* <span class="variable">%arr1</span></span><br><span class="line">  <span class="keyword">call</span> void <span class="title">@putint</span>(<span class="type">i32</span> <span class="variable">%arr1val</span>)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">ret</span> void</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>所以现在我们访问数组变量各元素的地址了吗？还不能。因为对于一个变量，比如说 <code>%arr = alloca [3 x i32]</code>，<code>%arr</code> 的类型实际上是 <code>[3 x i32]*</code> 而不是 <code>i32*</code>，所以此种形式的 <code>getelementptr</code> 依旧不能访问数组各元素的地址</p>
<h4 id="获取成员地址的-getelementptr"><a href="#获取成员地址的-getelementptr" class="headerlink" title="获取成员地址的 getelementptr"></a>获取成员地址的 getelementptr</h4><p>我们希望地址的计算不 “浮于表面” 而是要 “深入内部”。这就需要第二种形式的 <code>getelementptr</code>。形如 <code>%ptr = getelementptr T, T* %baseptr, V %idx1, V %idx2</code>。这其实只是在前一种形式的 <code>getelementptr</code> 后再加上一项偏移，而其他部分保持不变。其中 <code>%idx1</code> 的含义不变，而 <code>%idx2</code> 则意味着在取聚合类型 T 中第 <code>%idx2</code> 项的地址。其返回的类型即该项对应类型的指针。</p>
<p>例如 <code>getelementptr [2 x [2 x i32]], [2 x [2 x i32]]* @arr, i32 0, i32 1</code>，用 c 语言表示即 <code>(arr+0)[1]</code>，其返回类型为 <code>[2 x i32]*</code>。结构体与此类似，只不过各属性所对应的指针类型并不相同。</p>
<p>此种使用方式在之前的实例代码中使用颇多。各位可以回过头看一看之前我们忽略的代码部分，现在是否就已经明白其含义了？</p>
<h4 id="多层嵌套成员的-getelementptr"><a href="#多层嵌套成员的-getelementptr" class="headerlink" title="多层嵌套成员的 getelementptr"></a>多层嵌套成员的 getelementptr</h4><p>假如现在有如下的结构体，并有一个此结构体类型的全局变量：<br><figure class="highlight llvm"><table><tr><td class="code"><pre><span class="line"><span class="variable">%MyStruct</span> <span class="operator">=</span> <span class="keyword">type</span> &#123;</span><br><span class="line">  <span class="type">i32</span><span class="punctuation">,</span></span><br><span class="line">  [<span class="number">2</span> <span class="keyword">x</span> [<span class="number">2</span> <span class="keyword">x</span> <span class="type">i32</span>]]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title">@a</span> <span class="operator">=</span> <span class="keyword">global</span> <span class="variable">%MyStruct</span> &#123;<span class="type">i32</span> <span class="number">10</span><span class="punctuation">,</span> [<span class="number">2</span> <span class="keyword">x</span> [<span class="number">2</span> <span class="keyword">x</span> <span class="type">i32</span>]] [[<span class="number">2</span> <span class="keyword">x</span> <span class="type">i32</span>] [<span class="type">i32</span> <span class="number">1</span><span class="punctuation">,</span> <span class="type">i32</span> <span class="number">2</span>]<span class="punctuation">,</span> [<span class="number">2</span> <span class="keyword">x</span> <span class="type">i32</span>] [<span class="type">i32</span> <span class="number">3</span><span class="punctuation">,</span> <span class="type">i32</span> <span class="number">4</span>]]&#125;</span><br></pre></td></tr></table></figure></p>
<p>如果想要取结构体中的数组的第 1 行第 0 列的数值，对应的 <code>getelementptr</code> 指令是什么呢？</p>
<p>这当然可以求，只需要不断的使用 <code>getelementptr</code> 不就可以了吗？于是你写下了如下语句<br><figure class="highlight llvm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">define</span> <span class="type">i32</span> <span class="title">@main</span>() &#123;</span><br><span class="line">  <span class="variable">%t0</span> <span class="operator">=</span> <span class="keyword">getelementptr</span> <span class="variable">%MyStruct</span><span class="punctuation">,</span> <span class="variable">%MyStruct</span>* <span class="title">@a</span><span class="punctuation">,</span> <span class="type">i32</span> <span class="number">0</span><span class="punctuation">,</span> <span class="type">i32</span> <span class="number">1</span></span><br><span class="line">  <span class="variable">%t1</span> <span class="operator">=</span> <span class="keyword">getelementptr</span> [<span class="number">2</span> <span class="keyword">x</span> [<span class="number">2</span> <span class="keyword">x</span> <span class="type">i32</span>]]<span class="punctuation">,</span> [<span class="number">2</span> <span class="keyword">x</span> [<span class="number">2</span> <span class="keyword">x</span> <span class="type">i32</span>]]* <span class="variable">%t0</span><span class="punctuation">,</span> <span class="type">i32</span> <span class="number">0</span><span class="punctuation">,</span> <span class="type">i32</span> <span class="number">1</span></span><br><span class="line">  <span class="variable">%t2</span> <span class="operator">=</span> <span class="keyword">getelementptr</span> [<span class="number">2</span> <span class="keyword">x</span> <span class="type">i32</span>]<span class="punctuation">,</span> [<span class="number">2</span> <span class="keyword">x</span> <span class="type">i32</span>]* <span class="variable">%t1</span><span class="punctuation">,</span> <span class="type">i32</span> <span class="number">0</span><span class="punctuation">,</span> <span class="type">i32</span> <span class="number">0</span></span><br><span class="line">  <span class="variable">%val</span> <span class="operator">=</span> <span class="keyword">load</span> <span class="type">i32</span><span class="punctuation">,</span> <span class="type">i32</span>* <span class="variable">%t2</span></span><br><span class="line">  <span class="keyword">call</span> void <span class="title">@putint</span>(<span class="type">i32</span> <span class="variable">%val</span>)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">ret</span> <span class="type">i32</span> <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这当然是正确的代码，但问题是这样实在是过于繁琐了，有没有一种更方便的写法呢？实际上是有的，只需要将第一条之后的 <code>getelementptr</code> 语句中的第二个 idx 不断追加到第一条 <code>getelementptr</code> 指令之后即可。对于如上的代码，其等价形式即：<br><figure class="highlight llvm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">define</span> <span class="type">i32</span> <span class="title">@main</span>() &#123;</span><br><span class="line">  <span class="variable">%t</span> <span class="operator">=</span> <span class="keyword">getelementptr</span> <span class="variable">%MyStruct</span><span class="punctuation">,</span> <span class="variable">%MyStruct</span>* <span class="title">@a</span><span class="punctuation">,</span> <span class="type">i32</span> <span class="number">0</span><span class="punctuation">,</span> <span class="type">i32</span> <span class="number">1</span><span class="punctuation">,</span> <span class="type">i32</span> <span class="number">1</span><span class="punctuation">,</span> <span class="type">i32</span> <span class="number">0</span></span><br><span class="line">  <span class="variable">%val2</span> <span class="operator">=</span> <span class="keyword">load</span> <span class="type">i32</span><span class="punctuation">,</span> <span class="type">i32</span>* <span class="variable">%t</span></span><br><span class="line">  <span class="keyword">call</span> void <span class="title">@putint</span>(<span class="type">i32</span> <span class="variable">%val2</span>)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">ret</span> <span class="type">i32</span> <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>当然，你也可以认为 <code>getelementptr</code> 本来就只有一种形式而已。确实，只不过是我认为这样说应该会更加方便理解而已。</p>
<h2 id="四、运算"><a href="#四、运算" class="headerlink" title="四、运算"></a>四、运算</h2><p>计算是 CPU 的根本职责。关于这一部分实际上不需要多加赘述。因此这里只是稍微概述一下。在此事先提醒一下，运算指令的两输入都必须是相同的类型。运算指令的大致格式为 <code>%xxx = &lt;op&gt; T %yyy, %zzz</code>。比如说一个简单的整数加法，表示为 <code>%t2 = add i32 %t0, %t1</code>。</p>
<h3 id="（1）算数运算"><a href="#（1）算数运算" class="headerlink" title="（1）算数运算"></a>（1）算数运算</h3><p>运算包括算术运算和逻辑运算。算术运算当然包括加减乘除等基本运算，以 c 为例，对整数来说，其各类操作对应的 llvm 算术运算如下</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>c</th>
<th>llvm ir</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>+</code></td>
<td><code>add</code></td>
</tr>
<tr>
<td><code>-</code></td>
<td><code>sub</code></td>
</tr>
<tr>
<td><code>*</code></td>
<td><code>mul</code></td>
</tr>
<tr>
<td><code>/</code></td>
<td><code>sdiv</code> 或 <code>udiv</code></td>
</tr>
<tr>
<td><code>%</code></td>
<td><code>srem</code> 或 <code>urem</code></td>
</tr>
<tr>
<td>&#124;</td>
<td><code>or</code></td>
</tr>
<tr>
<td><code>&amp;</code></td>
<td><code>and</code></td>
</tr>
<tr>
<td><code>&lt;&lt;</code></td>
<td><code>shl</code></td>
</tr>
<tr>
<td><code>&gt;&gt;</code></td>
<td><code>ashr</code></td>
</tr>
</tbody>
</table>
</div>
<blockquote>
<p>需要注意，对于除除法以外的其他运算，整数有无符号并无区别，但在使用除法的时候却需要指定是否有符号，这就有了 <code>sdiv</code> 和 <code>udiv</code> 的区别；取模操作实际上就是除法时求余数，因此也需要指定有无符号。另外 c 中 <code>&gt;&gt;</code> 为算数右移，因此对应的 llvm ir 为 <code>ashr</code>（Arithmetic Shift Right） 而非 <code>lshr</code>（Logical Shift Right）。</p>
</blockquote>
<p>对于浮点数来说，LLVM 也提供了与整数运算相对应的指令，只是在指令前加上 <code>f</code> 而已。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>c</th>
<th>llvm ir</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>+</code></td>
<td><code>fadd</code></td>
</tr>
<tr>
<td><code>-</code></td>
<td><code>fsub</code></td>
</tr>
<tr>
<td><code>*</code></td>
<td><code>fmul</code></td>
</tr>
<tr>
<td><code>/</code></td>
<td><code>fdiv</code></td>
</tr>
<tr>
<td><code>%</code></td>
<td><code>frem</code></td>
</tr>
</tbody>
</table>
</div>
<blockquote>
<p>因为浮点数当然都是有符号的，所以对于除法来说就不再有 <code>sdiv</code> 和 <code>udiv</code> 的区别。</p>
</blockquote>
<p>对于整数运算来说，如下是一个简单的例子。浮点数的运算与其类似。<br><figure class="highlight llvm"><table><tr><td class="code"><pre><span class="line"><span class="comment">; calc.ll</span></span><br><span class="line"><span class="keyword">declare</span> void <span class="title">@putint</span>(<span class="type">i32</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">define</span> <span class="type">i32</span> <span class="title">@main</span>() &#123;</span><br><span class="line">  <span class="variable">%t0</span> <span class="operator">=</span> <span class="keyword">add</span> <span class="type">i32</span> <span class="number">5</span><span class="punctuation">,</span> <span class="number">8</span></span><br><span class="line">  <span class="keyword">call</span> void <span class="title">@putint</span>(<span class="type">i32</span> <span class="variable">%t0</span>) <span class="comment">; 13</span></span><br><span class="line">  </span><br><span class="line">  <span class="variable">%t1</span> <span class="operator">=</span> <span class="keyword">sub</span> <span class="type">i32</span> <span class="number">5</span><span class="punctuation">,</span> <span class="number">8</span></span><br><span class="line">  <span class="keyword">call</span> void <span class="title">@putint</span>(<span class="type">i32</span> <span class="variable">%t1</span>) <span class="comment">; -3</span></span><br><span class="line"></span><br><span class="line">  <span class="variable">%t2</span> <span class="operator">=</span> <span class="keyword">mul</span> <span class="type">i32</span> <span class="number">5</span><span class="punctuation">,</span> <span class="number">8</span></span><br><span class="line">  <span class="keyword">call</span> void <span class="title">@putint</span>(<span class="type">i32</span> <span class="variable">%t2</span>) <span class="comment">; 40</span></span><br><span class="line"></span><br><span class="line">  <span class="variable">%t3</span> <span class="operator">=</span> <span class="keyword">sdiv</span> <span class="type">i32</span> <span class="number">8</span><span class="punctuation">,</span> <span class="number">-5</span></span><br><span class="line">  <span class="keyword">call</span> void <span class="title">@putint</span>(<span class="type">i32</span> <span class="variable">%t3</span>) <span class="comment">; -1</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">; 注意这里，将 -5 看作无符号整数的话这个数远比 8 大，因此结果为 0</span></span><br><span class="line">  <span class="variable">%t4</span> <span class="operator">=</span> <span class="keyword">udiv</span> <span class="type">i32</span> <span class="number">8</span><span class="punctuation">,</span> <span class="number">-5</span></span><br><span class="line">  <span class="keyword">call</span> void <span class="title">@putint</span>(<span class="type">i32</span> <span class="variable">%t4</span>) <span class="comment">; 0 </span></span><br><span class="line"></span><br><span class="line">  <span class="variable">%t5</span> <span class="operator">=</span> <span class="keyword">udiv</span> <span class="type">i32</span> <span class="number">8</span><span class="punctuation">,</span> <span class="number">5</span></span><br><span class="line">  <span class="keyword">call</span> void <span class="title">@putint</span>(<span class="type">i32</span> <span class="variable">%t5</span>) <span class="comment">; 1</span></span><br><span class="line"></span><br><span class="line">  <span class="variable">%t6</span> <span class="operator">=</span> <span class="keyword">srem</span> <span class="type">i32</span> <span class="number">8</span><span class="punctuation">,</span> <span class="number">-5</span></span><br><span class="line">  <span class="keyword">call</span> void <span class="title">@putint</span>(<span class="type">i32</span> <span class="variable">%t6</span>) <span class="comment">; 3</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">; 与上一条注释同理</span></span><br><span class="line">  <span class="variable">%t7</span> <span class="operator">=</span> <span class="keyword">urem</span> <span class="type">i32</span> <span class="number">8</span><span class="punctuation">,</span> <span class="number">-5</span></span><br><span class="line">  <span class="keyword">call</span> void <span class="title">@putint</span>(<span class="type">i32</span> <span class="variable">%t7</span>) <span class="comment">; 8</span></span><br><span class="line"></span><br><span class="line">  <span class="variable">%t8</span> <span class="operator">=</span> <span class="keyword">urem</span> <span class="type">i32</span> <span class="number">8</span><span class="punctuation">,</span> <span class="number">5</span></span><br><span class="line">  <span class="keyword">call</span> void <span class="title">@putint</span>(<span class="type">i32</span> <span class="variable">%t8</span>) <span class="comment">; 3</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">; 0101 | 1000 = 1101</span></span><br><span class="line">  <span class="variable">%t9</span> <span class="operator">=</span> <span class="keyword">or</span> <span class="type">i32</span> <span class="number">5</span><span class="punctuation">,</span> <span class="number">8</span></span><br><span class="line">  <span class="keyword">call</span> void <span class="title">@putint</span>(<span class="type">i32</span> <span class="variable">%t9</span>) <span class="comment">; 13</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">; 0101 &amp; 0001 = 0001</span></span><br><span class="line">  <span class="variable">%t10</span> <span class="operator">=</span> <span class="keyword">and</span> <span class="type">i32</span> <span class="number">5</span><span class="punctuation">,</span> <span class="number">1</span></span><br><span class="line">  <span class="keyword">call</span> void <span class="title">@putint</span>(<span class="type">i32</span> <span class="variable">%t10</span>) <span class="comment">; 1</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">; 0101 &lt;&lt; 1 = 1010</span></span><br><span class="line">  <span class="variable">%t11</span> <span class="operator">=</span> <span class="keyword">shl</span> <span class="type">i32</span> <span class="number">5</span><span class="punctuation">,</span> <span class="number">1</span></span><br><span class="line">  <span class="keyword">call</span> void <span class="title">@putint</span>(<span class="type">i32</span> <span class="variable">%t11</span>) <span class="comment">; 10</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">; 0101 &gt;&gt; 1 = 0010</span></span><br><span class="line">  <span class="variable">%t12</span> <span class="operator">=</span> <span class="keyword">lshr</span> <span class="type">i32</span> <span class="number">5</span><span class="punctuation">,</span> <span class="number">1</span></span><br><span class="line">  <span class="keyword">call</span> void <span class="title">@putint</span>(<span class="type">i32</span> <span class="variable">%t12</span>) <span class="comment">; 2</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">; 符号右移，对负数前面补 1</span></span><br><span class="line">  <span class="variable">%t13</span> <span class="operator">=</span> <span class="keyword">ashr</span> <span class="type">i32</span> <span class="number">-5</span><span class="punctuation">,</span> <span class="number">1</span></span><br><span class="line">  <span class="keyword">call</span> void <span class="title">@putint</span>(<span class="type">i32</span> <span class="variable">%t13</span>) <span class="comment">; -3</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">ret</span> <span class="type">i32</span> <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<h3 id="（2）逻辑运算"><a href="#（2）逻辑运算" class="headerlink" title="（2）逻辑运算"></a>（2）逻辑运算</h3><p>逻辑运算用于比较两数的大小，对于整数和浮点数，分别用 <code>icmp</code> 和 <code>fcmp</code> 指令进行计算。<code>icmp</code> 或 <code>fcmp</code> 在使用时需要指定比较时两操作数的关系。指令的基本形式为 <code>%xxx = (icmp|fcmp) &lt;cond&gt; T %yyy, %zzz</code>。举个例子，比如说想要比较两整数是否相等，则应该使用指令 <code>%t2 = icmp eq i32 %t0, %t1</code>。</p>
<p>对于条件，同样以 c 为例，对应的 llvm ir 如下</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>c</th>
<th>llvm ir</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>==</code></td>
<td><code>eq</code></td>
</tr>
<tr>
<td><code>!=</code></td>
<td><code>ne</code></td>
</tr>
<tr>
<td><code>&gt;</code></td>
<td><code>gt</code></td>
</tr>
<tr>
<td><code>&gt;=</code></td>
<td><code>ge</code></td>
</tr>
<tr>
<td><code>&lt;</code></td>
<td><code>lt</code></td>
</tr>
<tr>
<td><code>&lt;=</code></td>
<td><code>le</code></td>
</tr>
</tbody>
</table>
</div>
<blockquote>
<p>需要注意的是，<code>icmp</code> 或 <code>fcmp</code> 的运算结果的类型为 <code>i1</code>，即 <code>bool</code> 类型。</p>
</blockquote>
<h3 id="（3）类型转换"><a href="#（3）类型转换" class="headerlink" title="（3）类型转换"></a>（3）类型转换</h3><p>尽管 LLVM IR 中各运算指令要求操作数的类型保持一致，可是实际编写代码时并不一定满足这一条件。在执行运算时我们会进行一系列的隐式或显式的类型转换。LLVM IR 中也提供了一系列类型转换指令。不过类型转换的指令十分繁多，因此这里只提一些较为简单的类型转换指令。</p>
<p>对于整数来说，类型的转换就只是扩充或截断一些比特位而已。对扩充和截断，LLVM IR 提供了指令 <code>zext</code>（Zero Extend）<code>sext</code>（Sign Extend）和 <code>trunc</code>（Truncate）。这些指令的使用形式为 <code>%xxx = zext T %yyy to Y</code>，其中 Y 为要转换到的类型。因此对于指令的结果 <code>%xxx</code>，其类型为 <code>Y</code>。</p>
<p><code>zext</code> 实现了零扩展，在扩展整数位数的时候会用 0 填充高位，用于对无符号整数进行扩展。<code>sext</code> 实现了符号扩展，在扩展整数位数的时候会根据之前最高位的符号来进行填充，用于对有符号整数进行扩展。<code>trunc</code> 则用于对高位进行截断。</p>
<p>对于浮点数来说，也有类似的指令 <code>fpext</code> 和 <code>fptrunc</code>。另外也有命令 <code>fptoui</code>、<code>fptosi</code> <code>uitofp</code> <code>sitofp</code> 用于实现有符号和无符号整数与浮点数间的相互转换。这里不再赘述。</p>
<h2 id="五、函数调用"><a href="#五、函数调用" class="headerlink" title="五、函数调用"></a>五、函数调用</h2><p>在之前的许多例子中，我们已经见到过函数调用的使用方式了。其形式为 <code>%xxx = call T @fff(T1 %p1, T2 %p2)</code>。当返回值类型为 <code>void</code> 的时候，不需要前面的”赋值“。</p>
<p>值得提一句的实际上是函数的定义方式。如果留意前面的例子的话，应该能发现函数定义时，参数实际上被表示为虚拟寄存器。也就是说在 LLVM IR 中函数参数被保存在寄存器中而不是栈中。</p>
<figure class="highlight llvm"><table><tr><td class="code"><pre><span class="line"><span class="comment">; 之前章节中的代码，参数 arr 实际上是寄存器 `%arr`</span></span><br><span class="line"><span class="keyword">define</span> void <span class="title">@func2</span>(<span class="type">i32</span>* <span class="variable">%arr</span>) &#123;</span><br><span class="line">  <span class="variable">%addr</span> <span class="operator">=</span> <span class="keyword">ptrtoint</span> <span class="type">i32</span>* <span class="variable">%arr</span> <span class="keyword">to</span> <span class="type">i64</span></span><br><span class="line">  <span class="keyword">call</span> void <span class="title">@putaddr</span>(<span class="type">i64</span> <span class="variable">%addr</span>)</span><br><span class="line">  <span class="keyword">ret</span> void</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>当然，“参数保存在栈上”其实也并不是什么必须的要求。只不过是根本没有那么多寄存器来存储大小可变的那么多参数而已。</p>
</blockquote>
<p>为保持一致性，可以在函数体中使用 <code>alloca</code> 指令为参数分配栈上空间，再使用 <code>store</code> 指令将参数寄存器中的值保存在栈上。</p>
<h2 id="六、流程控制"><a href="#六、流程控制" class="headerlink" title="六、流程控制"></a>六、流程控制</h2><p>最后，来谈一谈最重要的流程控制。对于像 LLVM IR 或更底层的语言来说，流程控制仅仅表现为跳转指令。在 LLVM IR 中的跳转指令为 <code>br</code>。</p>
<p><code>br</code> 存在两种形式，其一是条件跳转，接受一个 bool 类型（<code>i1</code>）的值，根据其真假分别跳转到不同的标签的位置。指令的具体形式为 <code>br i1 %cond, label %iftrue, label %iffalse</code>。表示的含义很简单，如果 <code>%cond</code> 为真，则跳转到 <code>%iftrue</code> 标签所在位置；如果为假，则跳转到 <code>%iffalse</code> 所在位置。</p>
<p><code>br</code> 的另一种形式是无条件跳转。形式为 <code>br label %target</code>，执行此条指令，就会跳转到 <code>%target</code> 所在位置。</p>
<p>而所谓标签，就是一个名称加上冒号，形如 <code>labelname:</code>。在汇编中，实际上指代紧跟冒号后的第一条指令的地址。</p>
<p>LLVM 对跳转语句和标签的使用做出了约束。具体来说，两个标签间的最后一条语句必须为 <code>br</code> 或 <code>ret</code>，标签间不能没有语句。如下的例子展示了错误的情况。<br><figure class="highlight llvm"><table><tr><td class="code"><pre><span class="line"><span class="comment">; errbr.ll</span></span><br><span class="line"><span class="keyword">define</span> <span class="type">i32</span> <span class="title">@main</span>() &#123;</span><br><span class="line"><span class="symbol">one:</span></span><br><span class="line">  <span class="variable">%t0</span> <span class="operator">=</span> <span class="keyword">add</span> <span class="type">i32</span> <span class="number">1</span><span class="punctuation">,</span> <span class="number">2</span></span><br><span class="line">  <span class="comment">; 错误，需要 br 或 ret</span></span><br><span class="line"><span class="symbol">two:</span></span><br><span class="line">  <span class="comment">; 错误，l2 和 l3 间需要包含指令</span></span><br><span class="line"><span class="symbol">three:</span></span><br><span class="line">  <span class="keyword">ret</span> <span class="type">i32</span> <span class="variable">%t0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>为什么这样规定？这就涉及到基本块的概念了。基本块是只有第一条语句作为入口，最后一条语句作为出口的语句序列。通过将程序划分为基本块，能够为编译器的代码优化提供便利。LLVM IR 在设计时就规定要以基本块的形式生成代码。因为基本块只有一个入口，所以只可能在最开始有一个标签；基本块只有一个出口，所以跳转语句之后不能再跟其他语句。这样我们就可以理解 LLVM IR 对跳转语句和标签的约束了：将两标签间的语句作为基本块的内容，在满足约束的情况下，最开始的标签是其唯一的入口，末尾的跳转语句是其唯一的出口。</p>
</blockquote>
<p>了解了标签和跳转语句，现在我们可以使用这两者实现各种各样的程序流程。但是不管标签和跳转语句的组合多么复杂，总是逃不出三种控制流程，那就是顺序、分支和循环。（关于这一点似乎存在某种数学证明。）</p>
<h3 id="（1）分支语句"><a href="#（1）分支语句" class="headerlink" title="（1）分支语句"></a>（1）分支语句</h3><p>对于<strong>顺序</strong>不必赘述，基本块内的指令就是按照顺序执行的。对于<strong>分支</strong>，以我们熟悉的 c 语言举例，存在两种类型的分支。</p>
<p><strong>if 类型</strong>：<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (cond) &#123;</span><br><span class="line">  <span class="comment">// do something if cond is true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>if-else 类型</strong>：<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (cond) &#123;</span><br><span class="line">  <span class="comment">// do something if cond is true</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="comment">// do something if cond is false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>“还有第三种呢，就是带有 <code>if else</code> 的分支语句。”实际上这样的说法并不正确。因为 <code>if else</code> 实际上只是分支语句的嵌套而已。对于如下两种带有 <code>if else</code> 的语句<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (cond1) &#123;</span><br><span class="line">  <span class="comment">// do something if cond1 is true</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (cond2) &#123;</span><br><span class="line">  <span class="comment">// do something if cond1 is false and cond2 is true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (cond1) &#123;</span><br><span class="line">  <span class="comment">// do something if cond1 is true</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (cond2) &#123;</span><br><span class="line">  <span class="comment">// do something if cond1 is false and cond2 is true</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="comment">// do something if cond1 and cond2 are false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>实际上应当将 <code>else</code> 之后的 <code>if</code> 看作另一条语句，为其加上括号的话，就是<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (cond1) &#123;</span><br><span class="line">  <span class="comment">// do something if cond1 is true</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="comment">// enter if cond1 is false</span></span><br><span class="line">  <span class="keyword">if</span> (cond2) &#123;</span><br><span class="line">    <span class="comment">// do something if cond2 is true</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (cond1) &#123;</span><br><span class="line">  <span class="comment">// do something if cond1 is true</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="comment">// enter if cond1 is false</span></span><br><span class="line">  <span class="keyword">if</span> (cond2) &#123;</span><br><span class="line">    <span class="comment">// do something if cond2 is true</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// do something if cond2 is false</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>这也是为什么 c 语言中存在“可以在 <code>if</code> <code>else</code> 后跟单条语句而不加大括号”的规则。</p>
</blockquote>
</blockquote>
<p>两种分支语句完全可以用跳转语句表示，以下就是用 LLVM IR 表示的两种控制流。尽管什么都没做，但是这个例子是可以正常编译的。</p>
<figure class="highlight llvm"><table><tr><td class="code"><pre><span class="line"><span class="comment">; ifelse.ll</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">define</span> void <span class="title">@dosomething</span>() &#123;</span><br><span class="line">  <span class="keyword">ret</span> void</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">define</span> void <span class="title">@if</span>(<span class="type">i1</span> <span class="variable">%cond</span>) &#123;</span><br><span class="line">  <span class="keyword">br</span> <span class="type">i1</span> <span class="variable">%cond</span><span class="punctuation">,</span> label <span class="variable">%true</span><span class="punctuation">,</span> label <span class="variable">%fi</span></span><br><span class="line"><span class="symbol"></span></span><br><span class="line"><span class="symbol">true:</span></span><br><span class="line">  <span class="keyword">call</span> void <span class="title">@dosomething</span>() <span class="comment">; do something if cond is true</span></span><br><span class="line">  <span class="keyword">br</span> label <span class="variable">%fi</span></span><br><span class="line"><span class="symbol"></span></span><br><span class="line"><span class="symbol">fi:</span></span><br><span class="line">  <span class="keyword">ret</span> void</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">define</span> void <span class="title">@ifelse</span>(<span class="type">i1</span> <span class="variable">%cond</span>) &#123;</span><br><span class="line">  <span class="keyword">br</span> <span class="type">i1</span> <span class="variable">%cond</span><span class="punctuation">,</span> label <span class="variable">%true</span><span class="punctuation">,</span> label <span class="variable">%false</span></span><br><span class="line"><span class="symbol"></span></span><br><span class="line"><span class="symbol">true:</span></span><br><span class="line">  <span class="keyword">call</span> void <span class="title">@dosomething</span>() <span class="comment">; do something if cond is true</span></span><br><span class="line">  <span class="keyword">br</span> label <span class="variable">%fi</span></span><br><span class="line"><span class="symbol"></span></span><br><span class="line"><span class="symbol">false:</span></span><br><span class="line">  <span class="keyword">call</span> void <span class="title">@dosomething</span>() <span class="comment">; do something if cond is false</span></span><br><span class="line">  <span class="keyword">br</span> label <span class="variable">%fi</span></span><br><span class="line"><span class="symbol"></span></span><br><span class="line"><span class="symbol">fi:</span></span><br><span class="line">  <span class="keyword">ret</span> void</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">define</span> <span class="type">i32</span> <span class="title">@main</span>() &#123;</span><br><span class="line">  <span class="keyword">call</span> void <span class="title">@if</span>(<span class="type">i1</span> <span class="keyword">true</span>)</span><br><span class="line">  <span class="keyword">call</span> void <span class="title">@ifelse</span>(<span class="type">i1</span> <span class="keyword">true</span>)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">ret</span> <span class="type">i32</span> <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>为了向 shell 的语法致敬，这里我特地用 <code>fi</code> 来表示退出分支语句时的标签。</p>
</blockquote>
<p>如果写过其他汇编应该会感觉上面的代码中有看似冗余的语句，跳转语句紧跟跳转到的目标标签。<br><figure class="highlight llvm"><table><tr><td class="code"><pre><span class="line">  <span class="keyword">br</span> label <span class="variable">%fi</span></span><br><span class="line"><span class="symbol">fi:</span></span><br></pre></td></tr></table></figure></p>
<p>但是要考虑到 LLVM IR 中的约束，每个基本块都要以 <code>br</code> 或 <code>ret</code> 结尾。这样的话就不难理解了。</p>
<h3 id="（2）循环语句"><a href="#（2）循环语句" class="headerlink" title="（2）循环语句"></a>（2）循环语句</h3><p>循环语句有三种形式。还以 c 举例。</p>
<p><strong>while 类型</strong>：<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> (cond) &#123;</span><br><span class="line">  <span class="comment">// do something</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>do-while 类型</strong>：<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">  <span class="comment">// do something</span></span><br><span class="line">&#125; <span class="keyword">while</span> (cond);</span><br></pre></td></tr></table></figure></p>
<p><strong>for 类型</strong>：<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (a = b, cond, a = a + c) &#123;</span><br><span class="line">  <span class="comment">// do something</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>do-while 并不常用，为什么一些编程语言还保留这种形式呢？因为 do-while 是最接近底层汇编的，其次为 while，最复杂的为 for。</p>
</blockquote>
<p>循环在汇编中表示为向前的跳转，下面用 LLVM IR 分别表示三种循环类型。</p>
<figure class="highlight llvm"><table><tr><td class="code"><pre><span class="line"><span class="comment">; loop.ll</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">define</span> void <span class="title">@dosomething</span>() &#123;</span><br><span class="line">  <span class="keyword">ret</span> void</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">define</span> void <span class="title">@while</span>(<span class="type">i1</span> <span class="variable">%cond</span>) &#123;</span><br><span class="line">  <span class="keyword">br</span> label <span class="variable">%while</span></span><br><span class="line"><span class="symbol"></span></span><br><span class="line"><span class="symbol">while:</span></span><br><span class="line">  <span class="keyword">br</span> <span class="type">i1</span> <span class="variable">%cond</span><span class="punctuation">,</span> label <span class="variable">%do</span><span class="punctuation">,</span> label <span class="variable">%done</span></span><br><span class="line"><span class="symbol"></span></span><br><span class="line"><span class="symbol">do:</span></span><br><span class="line">  <span class="keyword">call</span> void <span class="title">@dosomething</span>() <span class="comment">; do something while cond is true</span></span><br><span class="line">  <span class="keyword">br</span> label <span class="variable">%while</span></span><br><span class="line"><span class="symbol"></span></span><br><span class="line"><span class="symbol">done:</span></span><br><span class="line">  <span class="keyword">ret</span> void</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">define</span> void <span class="title">@dowhile</span>(<span class="type">i1</span> <span class="variable">%cond</span>) &#123;</span><br><span class="line">  <span class="keyword">br</span> label <span class="variable">%do</span></span><br><span class="line"><span class="symbol"></span></span><br><span class="line"><span class="symbol">do:</span></span><br><span class="line">  <span class="keyword">call</span> void <span class="title">@dosomething</span>() <span class="comment">; do something until cond is false</span></span><br><span class="line">  <span class="keyword">br</span> label <span class="variable">%while</span></span><br><span class="line"><span class="symbol"></span></span><br><span class="line"><span class="symbol">while:</span></span><br><span class="line">  <span class="keyword">br</span> <span class="type">i1</span> <span class="variable">%cond</span><span class="punctuation">,</span> label <span class="variable">%do</span><span class="punctuation">,</span> label <span class="variable">%done</span></span><br><span class="line"><span class="symbol"></span></span><br><span class="line"><span class="symbol">done:</span></span><br><span class="line">  <span class="keyword">ret</span> void</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">define</span> void <span class="title">@for</span>(<span class="type">i1</span> <span class="variable">%cond</span>) &#123;</span><br><span class="line">  <span class="keyword">call</span> void <span class="title">@dosomething</span>() <span class="comment">; initial stmt</span></span><br><span class="line">  <span class="keyword">br</span> label <span class="variable">%for</span></span><br><span class="line"><span class="symbol"></span></span><br><span class="line"><span class="symbol">for:</span></span><br><span class="line">  <span class="keyword">br</span> <span class="type">i1</span> <span class="variable">%cond</span><span class="punctuation">,</span> label <span class="variable">%do</span><span class="punctuation">,</span> label <span class="variable">%done</span></span><br><span class="line"><span class="symbol"></span></span><br><span class="line"><span class="symbol">do:</span></span><br><span class="line">  <span class="keyword">call</span> void <span class="title">@dosomething</span>() <span class="comment">; do something while cond is true</span></span><br><span class="line">  <span class="keyword">br</span> label <span class="variable">%update</span></span><br><span class="line"><span class="symbol"></span></span><br><span class="line"><span class="symbol">update:</span></span><br><span class="line">  <span class="keyword">call</span> void <span class="title">@dosomething</span>() <span class="comment">; update stmt</span></span><br><span class="line">  <span class="keyword">br</span> label <span class="variable">%for</span></span><br><span class="line"><span class="symbol"></span></span><br><span class="line"><span class="symbol">done:</span></span><br><span class="line">  <span class="keyword">ret</span> void</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">define</span> <span class="type">i32</span> <span class="title">@main</span>() &#123;</span><br><span class="line">  <span class="keyword">call</span> void <span class="title">@while</span>(<span class="type">i1</span> <span class="keyword">false</span>)</span><br><span class="line">  <span class="keyword">call</span> void <span class="title">@dowhile</span>(<span class="type">i1</span> <span class="keyword">false</span>)</span><br><span class="line">  <span class="keyword">call</span> void <span class="title">@for</span>(<span class="type">i1</span> <span class="keyword">false</span>)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">ret</span> <span class="type">i32</span> <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>do</code> 和 <code>done</code> 同样充满了 shell 的味道。</p>
</blockquote>
<p>从代码中就可以看出 do-while 的实现最为简单，因为 do-while 就只是简单的跳回之前的标签而已。</p>
<p>在代码中还需要注意的是 for 的实现中添加了 <code>update:</code> 标签，标签之后的是每次循环结束后的更新语句。此标签实际上是考虑到 <code>continue</code> 语句的翻译。对于 <code>continue</code> 来说，需要跳过本次循环，跳转到的标签位置应该是更新语句之前，因此应当跳转到 <code>update:</code> 而非 <code>for:</code>。同理对于 do-while 我们也额外添加了 <code>while</code> 标签，在 do-while 中使用 <code>continue</code> 也应当跳转到 <code>while:</code> 而非 <code>do:</code></p>
<h3 id="（3）短路求值"><a href="#（3）短路求值" class="headerlink" title="（3）短路求值"></a>（3）短路求值</h3><p>对于流程控制我们还有一点没有考虑，那就是跳转语句的条件值究竟从哪里来。当然，你可以用 <code>icmp</code>/<code>fcmp</code> 加上 <code>and</code> 和 <code>or</code> 来实现所有的布尔运算，但是这样并不满足编程语言中的一个基本设计，那就是短路求值。</p>
<blockquote>
<p>取反操作可以这样表示，<code>icmp eq i1 0, i1 %cond</code>。其中 <code>%cond</code> 为要取反的值</p>
</blockquote>
<p><code>&amp;&amp;</code> 和 <code>||</code> 与 <code>&amp;</code> 和 <code>|</code> 是不一样的，不管学什么编程语言，在最开始都会强调这一点。可是实际上如果只是计算条件值的话，也并没有什么区别。可以试试如下的例子。<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((a &gt; <span class="number">20</span>) &amp;&amp; (a &lt; <span class="number">40</span>)) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;20 &lt; a &lt; 40\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((a &gt; <span class="number">20</span>) &amp; (a &lt; <span class="number">40</span>)) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;20 &lt; a &lt; 40\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((a &gt; <span class="number">5</span>) || (a &lt; <span class="number">0</span>)) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;a &lt; 0 or a &gt; 5\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((a &lt; <span class="number">0</span>) | (a &gt; <span class="number">5</span>)) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;a &lt; 0 or a &gt; 5\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>唯一的问题在于求值过程中的”副作用“。很明显我们并没有在讨论函数式编程，所以副作用是不可避免的。这会使得位运算和逻辑运算的结果不同。<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> a, tmp;</span><br><span class="line"></span><br><span class="line">    tmp = a = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">if</span> ((a++ &gt; <span class="number">20</span>) &amp;&amp; (a++ &lt; <span class="number">40</span>)) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;20 &lt; a &lt; 40\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;change:%d\n&quot;</span>, a - tmp);</span><br><span class="line"></span><br><span class="line">    tmp = a = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">if</span> ((a++ &gt; <span class="number">20</span>) &amp; (a++ &lt; <span class="number">40</span>)) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;20 &lt; a &lt; 40\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;change:%d\n&quot;</span>, a - tmp);</span><br><span class="line"></span><br><span class="line">    tmp = a = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">if</span> ((a++ &gt; <span class="number">5</span>) || (a++ &lt; <span class="number">0</span>)) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;a &lt; 0 or a &gt; 5\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;change:%d\n&quot;</span>, a - tmp);</span><br><span class="line"></span><br><span class="line">    tmp = a = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">if</span> ((a++ &lt; <span class="number">0</span>) | (a++ &gt; <span class="number">5</span>)) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;a &lt; 0 or a &gt; 5\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;change:%d\n&quot;</span>, a - tmp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>结果</strong>：<br><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">change:1</span><br><span class="line">change:2</span><br><span class="line">a &lt; 0 or a &gt; 5</span><br><span class="line">change:1</span><br><span class="line">a &lt; 0 or a &gt; 5</span><br><span class="line">change:2</span><br></pre></td></tr></table></figure></p>
<p>因此需要采用位运算之外的方式实现 <code>&amp;&amp;</code> 和 <code>||</code>。</p>
<blockquote>
<p>实际上，因为位运算对于无副作用的表达式来说，其结果等同于短路求值，所以 LLVM IR 对于无副作用的表达式也可能采用位运算计算条件表达式。</p>
</blockquote>
<p>短路求值的重点在于提前跳转，对于之前的流程控制来说，我们只是对单一的比较语句的结果进行判断，分别跳转到不同的标签位置。而对于包含了逻辑运算符的条件表达式，则相当于存在多个不同的比较语句。我们所要做的就是为每个比较语句设置合适的跳转位置。</p>
<p>举个简单的例子：<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (a &lt; b &amp;&amp; c &lt; d) &#123;</span><br><span class="line">  <span class="comment">// do something</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="comment">// do something</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>对如上的代码，其流程应该是这样的：</p>
<ul>
<li>首先计算 <code>a &lt; b</code> 的值，如果为真则执行 <code>if</code> 语句块的内容，如果为假则转而计算 <code>c &lt; d</code>；</li>
<li>对于计算 <code>c &lt; d</code> 的情况，如果其值为真则执行 <code>if</code> 语句块的内容，如果为假则执行 <code>else</code> 语句块的内容</li>
</ul>
<p>以 LLVM 的方式叙述，只需要将“执行”、“计算”改为跳转；将 <code>a &lt; b</code> 和 <code>c &lt; d</code> 视作两个不同基本块中的指令序列即可。</p>
<p>这样我们就可以将问题抽象化了。假设现在有一系列基本块，<code>cond1</code>、<code>cond2</code>、… 、<code>condn</code>，这些基本块分别表示条件表达式中被 <code>||</code> 和 <code>&amp;&amp;</code> 分隔开的不同表达式。那么问题就是：这些基本块间的跳转关系是怎样的？</p>
<p>对于这一问题，首先要考虑所谓的条件表达式究竟是什么。以一种不严谨的方式定义，条件表达式要么是由 <code>||</code> 分隔的序列，序列成员是由 <code>&amp;&amp;</code> 分隔的序列或表达式；要么是由 <code>&amp;&amp;</code> 分隔的序列，序列成员是由 <code>||</code> 分隔的序列或表达式。这样避免引入对 <code>||</code> 和 <code>&amp;&amp;</code> 优先级的讨论。</p>
<p>我们的问题是，对于每一个表达式的基本块，要分别设定为真和为假时跳转的目标。即对于基本块 $B$，要设定 $\text{iftrue}_B$ 和 $\text{iffalse}_B$。</p>
<p>那么对于任意与序列 $S_\text{and}$ 、或序列 $S_\text{or}$ 和基本块 $B$ ，我们分别定义两个集合 $\text{TRUE}$ 和 $\text{FALSE}$ 以及一个函数 $\text{first}$ 。假设与序列和或序列中的成员为 $M_i$ ，序列的长度 $|S| = n$ ，则有：</p>
<script type="math/tex; mode=display">
\begin{align*}
  \text{first}(S) &= \text{first}(M_1) \\
  \text{first}(B) &= B
\end{align*}</script><p>另外对于 $S_\text{and}$：</p>
<script type="math/tex; mode=display">
\begin{align*}
  \text{TRUE}(S_\text{and}) &= \text{TRUE}(M_n) \\
  \text{FALSE}(S_\text{and}) &= \bigcup_{M_i \in S_\text{and}} \text{FALSE}(M_i)
\end{align*}</script><p>对于 $S_\text{or}$：</p>
<script type="math/tex; mode=display">
\begin{align*}
  \text{TRUE}(S_\text{or}) &= \bigcup_{M_i \in S_\text{or}} \text{TRUE}(M_i) \\
  \text{FALSE}(S_\text{or}) &= \text{FALSE}(M_n) \\
\end{align*}</script><p>对于基本块 $B$：</p>
<script type="math/tex; mode=display">
\begin{align*}
  \text{TRUE}(B) &= \{B\} \\
  \text{FALSE}(B) &= \{B\}
\end{align*}</script><p>这样，对于条件表达式中的任意基本块，其 $\text{iftrue}_B$ 和 $\text{iffalse}_B$ 可以按照如下方式得出：</p>
<p>对条件表达式中出现的任意与序列和或序列 $S$ 应用如下规则：</p>
<ul>
<li><p>若 $S$ 为与序列， $\forall M_i \in S, \forall B_j \in \text{TRUE}(M_i), \text{iftrue}_{B_j} = \text{first}(M_{i+1})$</p>
</li>
<li><p>若 $S$ 为或序列， $\forall M_i \in S, \forall B_j \in \text{FALSE}(M_i), \text{iffalse}_{B_j} = \text{first}(M_{i+1})$</p>
</li>
<li><p>若 $S$ 为组成整个条件表达式的序列，则额外有 $\forall B_i \in \text{TRUE}(S), \text{iftrue}_{B_i} = \text{T}$ ; $\forall B_j \in \text{FALSE}(S), \text{iffalse}_{B_j} = \text{F}$ ，其中 $T$ 和 $F$ 分别为循环或条件语句为真和为假时跳转到的基本块。</p>
</li>
</ul>
<p>对于上述的方法，这里用 python 写了一个简单的例子，应该可以更好的表达上述意思。<br><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment"># short_circuit_evaluation.py</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CondExp</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get_first_block</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get_true_set</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get_false_set</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AndSeq</span>(<span class="title class_ inherited__">CondExp</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, cond_list: <span class="built_in">list</span>[CondExp]</span>):</span><br><span class="line">        <span class="built_in">super</span>().__init__()</span><br><span class="line">        self.cond_list = cond_list</span><br><span class="line"></span><br><span class="line">        self.__set_jump_target()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__set_jump_target</span>(<span class="params">self</span>):</span><br><span class="line">        idx = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> idx &lt; <span class="built_in">len</span>(self.cond_list) - <span class="number">1</span>:</span><br><span class="line">            cond = self.cond_list[idx]</span><br><span class="line">            true_set = cond.get_true_set()</span><br><span class="line">            next_cond = self.cond_list[idx + <span class="number">1</span>]</span><br><span class="line">            jump_target = next_cond.get_first_block()</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> true_block <span class="keyword">in</span> true_set:</span><br><span class="line">                true_block.iftrue = jump_target</span><br><span class="line"></span><br><span class="line">            idx += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get_first_block</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> self.cond_list[<span class="number">0</span>].get_first_block()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get_true_set</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> self.cond_list[-<span class="number">1</span>].get_true_set()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get_false_set</span>(<span class="params">self</span>):</span><br><span class="line">        false_set = <span class="built_in">set</span>()</span><br><span class="line">        <span class="keyword">for</span> cond <span class="keyword">in</span> self.cond_list:</span><br><span class="line">            false_set.update(cond.get_false_set())</span><br><span class="line">        <span class="keyword">return</span> false_set</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__repr__</span>(<span class="params">self</span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;(&quot;</span> + <span class="string">&quot; &amp;&amp; &quot;</span>.join([<span class="built_in">str</span>(cond) <span class="keyword">for</span> cond <span class="keyword">in</span> self.cond_list]) + <span class="string">&quot;)&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">OrSeq</span>(<span class="title class_ inherited__">CondExp</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, cond_list: <span class="built_in">list</span>[CondExp]</span>):</span><br><span class="line">        <span class="built_in">super</span>().__init__()</span><br><span class="line">        self.cond_list = cond_list</span><br><span class="line"></span><br><span class="line">        self.__set_jump_target()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__set_jump_target</span>(<span class="params">self</span>):</span><br><span class="line">        idx = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> idx &lt; <span class="built_in">len</span>(self.cond_list) - <span class="number">1</span>:</span><br><span class="line">            cond = self.cond_list[idx]</span><br><span class="line">            false_set = cond.get_false_set()</span><br><span class="line">            next_cond = self.cond_list[idx + <span class="number">1</span>]</span><br><span class="line">            jump_target = next_cond.get_first_block()</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> false_block <span class="keyword">in</span> false_set:</span><br><span class="line">                false_block.iffalse = jump_target</span><br><span class="line"></span><br><span class="line">            idx += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get_first_block</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> self.cond_list[<span class="number">0</span>].get_first_block()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get_true_set</span>(<span class="params">self</span>):</span><br><span class="line">        true_set = <span class="built_in">set</span>()</span><br><span class="line">        <span class="keyword">for</span> cond <span class="keyword">in</span> self.cond_list:</span><br><span class="line">            true_set.update(cond.get_true_set())</span><br><span class="line">        <span class="keyword">return</span> true_set</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get_false_set</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> self.cond_list[-<span class="number">1</span>].get_false_set()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__repr__</span>(<span class="params">self</span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;(&quot;</span> + <span class="string">&quot; || &quot;</span>.join([<span class="built_in">str</span>(cond) <span class="keyword">for</span> cond <span class="keyword">in</span> self.cond_list]) + <span class="string">&quot;)&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Block</span>(<span class="title class_ inherited__">CondExp</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, exp_str=<span class="string">&quot;exp&quot;</span></span>):</span><br><span class="line">        self.iftrue = <span class="literal">None</span></span><br><span class="line">        self.iffalse = <span class="literal">None</span></span><br><span class="line">        self.exp_str = exp_str</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get_first_block</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> self</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get_true_set</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> &#123;self&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get_false_set</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> &#123;self&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__repr__</span>(<span class="params">self</span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">        <span class="keyword">return</span> self.exp_str</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    blocks = [</span><br><span class="line">        Block(<span class="string">&quot;a &lt; b&quot;</span>),</span><br><span class="line">        Block(<span class="string">&quot;c &gt; d&quot;</span>),</span><br><span class="line">        Block(<span class="string">&quot;d &gt; 10&quot;</span>),</span><br><span class="line">        Block(<span class="string">&quot;d &lt; 1&quot;</span>),</span><br><span class="line">        Block(<span class="string">&quot;e &gt; 10&quot;</span>),</span><br><span class="line">    ]</span><br><span class="line"></span><br><span class="line">    and_seq1 = AndSeq([blocks[<span class="number">2</span>], blocks[<span class="number">3</span>]])</span><br><span class="line">    or_seq1 = OrSeq([blocks[<span class="number">0</span>], blocks[<span class="number">1</span>]])</span><br><span class="line">    or_seq2 = OrSeq([and_seq1, blocks[<span class="number">4</span>]])</span><br><span class="line"></span><br><span class="line">    cond = AndSeq([or_seq1, or_seq2])</span><br><span class="line">    <span class="built_in">print</span>(cond)</span><br><span class="line">    <span class="built_in">print</span>()</span><br><span class="line"></span><br><span class="line">    target_true = Block(<span class="string">&quot;True Stmt&quot;</span>)</span><br><span class="line">    target_false = Block(<span class="string">&quot;False Stmt&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> true_block <span class="keyword">in</span> cond.get_true_set():</span><br><span class="line">        true_block.iftrue = target_true</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> false_block <span class="keyword">in</span> cond.get_false_set():</span><br><span class="line">        false_block.iffalse = target_false</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> block <span class="keyword">in</span> blocks:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;block&#125;</span>:&quot;</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;\ttrue  -&gt; <span class="subst">&#123;block.iftrue&#125;</span>&quot;</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;\tfalse -&gt; <span class="subst">&#123;block.iffalse&#125;</span>&quot;</span>)</span><br><span class="line">        <span class="built_in">print</span>()</span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<p>运行结果如下，可以看到程序正确得到了短路求值的跳转顺序。<br><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">((a &lt; b || c &gt; d) &amp;&amp; ((d &gt; 10 &amp;&amp; d &lt; 1) || e &gt; 10))</span><br><span class="line"></span><br><span class="line">a &lt; b:</span><br><span class="line">        true  -&gt; d &gt; 10</span><br><span class="line">        false -&gt; c &gt; d</span><br><span class="line"></span><br><span class="line">c &gt; d:</span><br><span class="line">        true  -&gt; d &gt; 10</span><br><span class="line">        false -&gt; False Stmt</span><br><span class="line"></span><br><span class="line">d &gt; 10:</span><br><span class="line">        true  -&gt; d &lt; 1</span><br><span class="line">        false -&gt; e &gt; 10</span><br><span class="line"></span><br><span class="line">d &lt; 1:</span><br><span class="line">        true  -&gt; True Stmt</span><br><span class="line">        false -&gt; e &gt; 10</span><br><span class="line"></span><br><span class="line">e &gt; 10:</span><br><span class="line">        true  -&gt; True Stmt</span><br><span class="line">        false -&gt; False Stmt</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>这一部分就不再手写 LLVM IR 了。阅读了上述内容后，短路求值只是一个体力活。</p>
<p>终于写完了…</p>
</blockquote>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>LLVM</tag>
        <tag>编译</tag>
        <tag>汇编</tag>
        <tag>短路求值</tag>
      </tags>
  </entry>
  <entry>
    <title>KeepAlive</title>
    <url>/posts/e7b1cb62/</url>
    <content><![CDATA[<p>最近这段时间文章似乎写得不太多，但是这个小小博客并非就此死掉了。为了一些可能并不存在的关注者，同时也为了我自己，先在这里发一篇短文。</p>
<p>现在的我处于这样的一个阶段，不再满足于罗列刚刚学到的知识，希望在文章中加上自己的思考；但同时自己却也没有经年的储备，稍有新意的认识只能慢慢积累。这就导致了一部分内容不必写；而另一部分内容又还不能写。有时我也想稍稍水一些字数，把那些不必写的内容写一写，可近期的学业又没有留给我那么多可浪费的时间。对这一点，我要向我的博客道歉。</p>
<p>可道歉归道歉，我并没有忘记写文章这件事。自我上一篇文章完成已有一个半月的时间，在这期间我也构思了许久自己要做些什么。就在今天，我从考试中解放出来，接下来的计划也早就在我脑中成熟了。</p>
<p>操作系统实验的笔记是本博客阅读量较多的一系列文章，接下来我希望以类似的形式写一系列编译技术的文章。从编译的理论知识出发，辅以相应代码，逐渐编写一个简单的编译器。这也是我对自己的编译技术课程的总结。</p>
<p>说出去的话就不能反悔了。本文也是对我自己的鞭策。</p>
]]></content>
      <categories>
        <category>感想</category>
      </categories>
  </entry>
  <entry>
    <title>从零开始的编译原理1:文法理论</title>
    <url>/posts/d76cf051/</url>
    <content><![CDATA[<h2 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h2><blockquote>
<p>一个人进行推理时…… 这种过程如果是用语词进行的，他便是在心中把各部分的名词序列连成一个整体的名词或从整体及一个部分的名词求得另一个部分的名词。</p>
<p>—— 托马斯•霍布斯《利维坦》第一部分 论人类 第五章 论推理与学术</p>
</blockquote>
<p>当霍布斯将他的机械唯物主义运用于人的思想时，语言便成为了人脑的齿轮。人的精神当然并非机械，可这种认识却也敏锐地察觉到了语言的一些本质，那就是语言是一些规则，通过这些规则的拼凑，我们得以表述我们的思想。如今，这种规则我们称之为<strong>文法</strong>。</p>
<p>语言学家的一部分工作是从现有的自然语言中总结文法，<strong>让语言成为机械</strong>。但是这并不是我们的重点，我们所要探索的是一个更加年轻的领域，这个领域的研究从机械出发，却要去创造千变万化的语言，<strong>让机械成为语言</strong>。</p>
<h2 id="二、自然语言的文法：一个例子"><a href="#二、自然语言的文法：一个例子" class="headerlink" title="二、自然语言的文法：一个例子"></a>二、自然语言的文法：一个例子</h2><p>但是要开始我们的旅程，还需要从自然语言开始。当我们听别人说话，或者阅读一段句子的时候，我们究竟在理解什么？比如说，现在有这样一句话，<code>你知道我的叉子被放在哪里吗</code>。让我们尝试理解这个句子。</p>
<blockquote>
<p>这部分默认各位已有了对词性的基本认识，至少知道名词、形容词、动词、副词等等的大致含义。否则的话，这部分内容实难描述。</p>
<p>另外注意对于自然语言的相关表述可能并不完全符合人的认知的真实情况，这一部分只是为了方便理解。</p>
</blockquote>
<p>首先需要明确一点，抛开我们所有的经验来看，语言就是符号的序列。也就是说语言是在时间上存在先后顺序的许多符号。这意味着我们的理解过程必定是从前到后的。对于上述句子来说，我们先读到 <code>你</code>，之后才能读到 <code>知</code>，再之后 <code>道</code>、<code>我</code> 等等。</p>
<p>另外，在这样不断读到一个个符号的时候，我们也并非单纯的按照字母或音节分别认识，而是首先明确哪些音节或符号共同组成相同含义，并将其作为一个单词来识别。在自然语言处理领域，这称为“分词”；而对于编译来说，这称为“词法分析”。</p>
<p>我们理解这个句子的过程可能是这样的：</p>
<ol>
<li>读到 <code>你</code>，这指代一个事物，为名词</li>
<li>读到 <code>知道</code>，这指代一个行为，为动词</li>
<li>读到 <code>我的</code>，这描述了事物的属性，为形容词</li>
<li>读到 <code>叉子</code>，这指代了另一个事物，为名词</li>
<li>形容词 <code>我的</code> 和名词 <code>叉子</code> 组成 <code>我的叉子</code>，也是个名词</li>
<li>读到 <code>被放</code>，这是动词。</li>
<li>读到 <code>在</code>，这表达了一个关系，为介词</li>
<li>读到 <code>哪里</code>，这是名词</li>
<li>介词 <code>在</code> 和 名词 <code>哪里</code> 组成 <code>在哪里</code>，用于描述行为，为副词</li>
<li>动词 <code>被放</code> 和副词 <code>在哪里</code> 组成 <code>被放在哪里</code>，也是个动词。</li>
<li>名词 <code>我的叉子</code> 和动词 <code>被放在哪里</code> 组成 <code>我的叉子被放在哪里</code>，用于陈述一个事实，称为陈述句</li>
<li>名词 <code>你</code>、动词 <code>知道</code> 和句子 <code>我的叉子被放在哪里</code> 组成了 <code>你知道我的叉子被放在哪里</code>，是另一个陈述句。</li>
<li>读到 <code>吗</code>，这是一个疑问语气词，用于表达疑问。</li>
<li>句子 <code>你知道我的叉子被放在哪里</code> 和疑问语气词 <code>吗</code> 组成 <code>你知道我的叉子被放在哪里吗</code>，表达对被陈述的事情真实性的询问，是疑问句。</li>
<li>读完了所有的单词，最后得到的疑问句就是整个句子。</li>
</ol>
<p>在上述过程中，我们不断将小的句子成分归纳为大的句子成分，在这样归纳的过程中，我们将句子中的每个单词相互关联起来，最终理解句子表达的含义。从中我们可以知道这是一个疑问，想要得到的回答是“你”与“我的叉子被放”两个事物间是否存在“知道”的关系等等。（这样说话好别扭。）</p>
<p>自我们出生，我们就在特定的语言环境下学习人与人的交流方式。耳濡目染，我们的大脑就形成了对语言结构的识别能力。这使我们知道一些单词表示事物，一些单词表示行为、一些单词用于形容、一些单词用于表示关系…… 我们也明白了名词加上形容词的修饰变成了新的名词，名词加动词加上另一个名词或者句子会构成新的句子。我们在平时交流时或许并不在意，但是这样的匹配能力却天生存在于我们大脑的特定脑区中。匹配所使用的规则，我们则称其为<strong>文法</strong>。</p>
<h2 id="三、从自然语言转变"><a href="#三、从自然语言转变" class="headerlink" title="三、从自然语言转变"></a>三、从自然语言转变</h2><h3 id="（1）规约的视角"><a href="#（1）规约的视角" class="headerlink" title="（1）规约的视角"></a>（1）规约的视角</h3><p>在上一节中我们使用一个自然语言的例句描述了理解句子的过程，并从中引出了文法的概念。现在我们可以整理一下在理解这个句子的过程中用到的文法：</p>
<ul>
<li>形容词加名词还是名词</li>
<li>介词加名词组成副词</li>
<li>动词加副词还是动词</li>
<li>名词加动词组成陈述句</li>
<li>名词加动词加名词也组成陈述句</li>
<li>陈述句加疑问语气词组成疑问句</li>
<li>陈述句和疑问句都是句子</li>
<li>“你”、“叉子”、“哪里” 是名词</li>
<li>“知道”、“被放” 是动词</li>
<li>“我的” 是形容词</li>
<li>“在” 是介词</li>
<li>“吗” 是疑问语气词</li>
</ul>
<p>我们可以发现，我们所有的文法描述都分为两个部分，前一部分是后一部分的组成。前一部分可以有多个成分，后一部分只能有一个。如 “名词加动词组成陈述句”，前一部分包括 “名词” 和 “动词”，而后一部分只包括 “陈述句”。</p>
<p>存在着这样的关系，意味着我们能够<strong>将文法组织成树的形式</strong>。对于一条文法规则，以整体作为父节点，以各组成成分为子节点。这样我们就得到了一个根为 “句子”、叶节点为各单词的树。我们称这样的树为文法树或语法树。对于我们的例句，其文法树如下所示：</p>
<img src="/posts/d76cf051/SyntaxTree.png" class="" title="SyntaxTree">
<p>如此一来，我们对句子的理解过程就抽象为从叶节点开始的文法树构建过程：在最开始，我们将每个单词都作为一棵只有一个节点的树；之后在每一步中，我们都选择一些相邻的树，用一个新的父节点作为这些树新的根；不断重复这一过程，最终我们就得到了一棵文法树。这一过程称为<strong>规约</strong>（Reduction）。</p>
<h3 id="（2）推导的视角"><a href="#（2）推导的视角" class="headerlink" title="（2）推导的视角"></a>（2）推导的视角</h3><p>上面的叙述中我们都采用了规约的视角，这是我们理解自然语言的过程。但是如果我们选择从语言生成的过程出发，这就带来了推导的视角。</p>
<p>假定现在我们想要言说某些概念，表达的依旧是 “你知道我的叉子被放在哪里吗” 的含义。那么我们会如何去做呢？我们的思维过程可能是这样的：首先，我想要询问，因此需要一个疑问句，疑问句由陈述句加上疑问语气词组成；其中陈述句希望表达 “你知道我的叉子被放在哪里” 的含义…… </p>
<p>这样，我们就从说一个句子出发，慢慢构建起了我们所希望说的具体内容。以这个视角，我们会发现文法树并没有发生变化，变化的是我们产生语法树的过程。这一次，我们从只有一个句子作为根节点开始，慢慢通过规则创造了叶节点，直到所有的叶节点变为我们实际可以言说的单词。这一过程就称为<strong>推导</strong>（Derivation）。</p>
<h2 id="四、语言的形式化"><a href="#四、语言的形式化" class="headerlink" title="四、语言的形式化"></a>四、语言的形式化</h2><h3 id="（1）文法的定义"><a href="#（1）文法的定义" class="headerlink" title="（1）文法的定义"></a>（1）文法的定义</h3><p>我们终于从自然语言中抽象出文法树的概念。现在是时候抛弃我们此前使用的不准确的表述，以形式化的方式定义文法了。</p>
<blockquote>
<p>但在此之前需要补充一些表示方法：</p>
<ul>
<li>我们将<strong>符号</strong>定义为句子的基本单位，这里所谓的符号是抽象的符号，可以是 a、abandon 或 “阿”，并未只能是单个字母。不同的符号互不相等，这些符号组成的非空有限集称为字母表，记作 $\sum$。</li>
<li><strong>符号串</strong>是符号所组成的有穷序列。特别的对于长度为零的符号串，记为 $\epsilon$。</li>
<li>符号串和符号串间可以进行<strong>拼接</strong>操作，若将符号看作长度为 1 的符号串，则符号也可以进行拼接操作。假设有符号或符号串 $x$ 和 $y$，则拼接操作记为 $xy$。</li>
<li>假设现在有符号串集 $A$ 和 $B$，定义符号串集合的<strong>乘积</strong>操作 $AB = {xy| x \in A, y \in B}$，其中 $xy$ 表示符号串拼接。</li>
<li>对符号串集合 $A$，定义<strong>幂运算</strong> $A^n = A^{n-1}A, A^0 = {\epsilon}$。</li>
<li>对字符串集合 $A$，定义<strong>正闭包</strong> $A^+ = \bigcup_{i = 1}^{\infty}A^i$；以及<strong>闭包</strong> $A^* = A^0 \cup A^+$。</li>
</ul>
</blockquote>
<p>文法（Grammar）可以表示为这样一个四元组（可以简记为 $G[Z]$）</p>
<script type="math/tex; mode=display">
  G = (V_n, V_t, P, Z)</script><ul>
<li>$V_n$ 表示<strong>非终结符号</strong>（Non-terminal Symbol）集。即在分析句子的过程中出现的中间符号，如前一节的“名词”、“动词”。</li>
<li>$V_t$ 表示<strong>终结符号</strong>（Terminal Symbol）集。即实际组成句子的符号，如前一节的“你”、“知道”。</li>
<li>$P$ 表示<strong>推导规则</strong>（Production Rules）集合，同样也是文法树中父子节点间的约束条件。一条规则可以表示为有序对 $(U, x)$，其中 <script type="math/tex; mode=display">
U \in V_n, x \in V^*, |U| = 1, |x| \ge 0</script></li>
<li>$Z$ 表示<strong>开始符号</strong>（推导视角），或称<strong>识别符号</strong>（规约视角）。即文法树的根节点。$Z \in V_n$。</li>
</ul>
<p>对于规则，为了表示有序对中两方角色的不同，常使用下面的两种表示方法</p>
<script type="math/tex; mode=display">
\begin{align*}
  U ::= x \\
  U \rightarrow x
\end{align*}</script><h3 id="（2）推导与规约"><a href="#（2）推导与规约" class="headerlink" title="（2）推导与规约"></a>（2）推导与规约</h3><h4 id="推导与规约的形式化"><a href="#推导与规约的形式化" class="headerlink" title="推导与规约的形式化"></a>推导与规约的形式化</h4><p>推导的过程，简单来说，就是从开始符号开始，不断使用推导规则，将规则左侧的非终结符替换为右侧的符号串。当然我们也可以形式化地定义推导：</p>
<p>若对于文法 $G$，定义</p>
<script type="math/tex; mode=display">
  v = xUy, w = xuy</script><p>其中 </p>
<script type="math/tex; mode=display">
  x, y \in V^*; U \in V_n; u \in V^*</script><p>若 $\exists U::=u \in P$，则 $v$ 可<strong>推导</strong>出 $w$，记为 $v \Rightarrow w$。</p>
<p>那么对于规约呢？规约是推导的逆运算，所以若有 $v \Rightarrow w$，则 $w$ 可<strong>规约</strong>为 $v$，记为 $w \Leftarrow v$。</p>
<!-- 语言是满足文法的所有可能句子的集合。通过推导，我们可以定义一个文法所能表达的语言。在此之前我们定义，若 $v$ 经过一步或多步推导可以推出 $w$，则记为 $v \stackrel{+}\Rightarrow w$；同时定义若 $v = w$ 或 $v \stackrel{+}\Rightarrow w$ 记为 $v \stackrel{*}\Rightarrow w$。

于是，满足文法 $G[Z]$ 的**语言**即 
$$
  \{x| x \in V_t^*, Z \stackrel{+}\Rightarrow x\}
$$

记为 $L(G[Z])$。$L(G[Z])$ 中的符号串我们称为**句子**。

另外对于推导/规约过程中出现的包含非终结符的中间形态，我们称其为句型。因此 $x$ 是句型当且仅当 $Z \stackrel{*}\Rightarrow x \land x \in V^*$。 -->
<h4 id="规范规约与最左推导"><a href="#规范规约与最左推导" class="headerlink" title="规范规约与最左推导"></a>规范规约与最左推导</h4><p>当我们</p>
<h2 id="五、"><a href="#五、" class="headerlink" title="五、"></a>五、</h2>]]></content>
      <categories>
        <category>教程</category>
      </categories>
      <tags>
        <tag>编译</tag>
        <tag>文法</tag>
      </tags>
  </entry>
</search>
