<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"wokron.github.io","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":"default","style":"mac"},"back2top":{"enable":true,"sidebar":false,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="StringCat的个人博客。记录学习、分享经验">
<meta property="og:type" content="website">
<meta property="og:title" content="StringCat的博客">
<meta property="og:url" content="https://wokron.github.io/page/5/index.html">
<meta property="og:site_name" content="StringCat的博客">
<meta property="og:description" content="StringCat的个人博客。记录学习、分享经验">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="wokron">
<meta property="article:tag" content="github,java,c#,python,pytorch,blog,engine,buaa,algorithm,software engineering">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://wokron.github.io/page/5/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>StringCat的博客</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">StringCat的博客</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">学生党踩坑记录</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://wokron.github.io/posts/903497ec/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="wokron">
      <meta itemprop="description" content="StringCat的个人博客。记录学习、分享经验">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="StringCat的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/posts/903497ec/" class="post-title-link" itemprop="url">系统编程之信号及信号处理</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-11-13 15:30:11" itemprop="dateCreated datePublished" datetime="2022-11-13T15:30:11+08:00">2022-11-13</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-06-26 10:38:38" itemprop="dateModified" datetime="2023-06-26T10:38:38+08:00">2023-06-26</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">学习笔记</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="一、信号简介"><a href="#一、信号简介" class="headerlink" title="一、信号简介"></a>一、信号简介</h2><h3 id="（1）信号含义"><a href="#（1）信号含义" class="headerlink" title="（1）信号含义"></a>（1）信号含义</h3><p>软中断信号(signal，又简称为信号)用来通知进程发生了异步事件。在软件层次上是对中断机制的一种模拟；在原理上，一个进程收到一个信号与处理器收到一个中断请求可以说是一样的。信号是进程间通信机制中唯一的异步通信机制，一个进程不必通过任何操作来等待信号的到达，事实上，进程也不知道信号到底什么时候到达。进程之间可以互相通过系统调用 kill 发送软中断信号。内核也可以因为内部事件而给进程发送信号，通知进程发生了某个事件。信号机制除了基本通知功能外，还可以传递附加信息。</p>
<h3 id="（2）信号分类"><a href="#（2）信号分类" class="headerlink" title="（2）信号分类"></a>（2）信号分类</h3><p>可以使用<code>kill -l</code>命令查看当前系统支持的所有信号：</p>
<img src="/posts/903497ec/signal.png" class="" title="signal">
<p>信号值小于 SIGRTMIN（&lt;=34）的信号都是不可靠信号。它的主要问题是信号可能丢失。 信号值位于 SIGRTMIN 和 SIGRTMAX 之间的信号都是可靠信号，这些信号支持排队，不会丢失。</p>
<h3 id="（3）信号的产生"><a href="#（3）信号的产生" class="headerlink" title="（3）信号的产生"></a>（3）信号的产生</h3><p>信号可以由一下几种方式产生：</p>
<ul>
<li>键盘事件：ctrl+c ctrl+\ ctrl+Z 等</li>
<li>非法内存：如果内存管理出错，系统就会发送一个信号进行处理</li>
<li>硬件检测到异常：如段错误，除 0，总线错误等</li>
<li>环境切换：比如说从用户态切换到其他态，状态的改变也会发送一个信号，这个信号会告知给系统</li>
<li>系统调用：如调用<code>kill</code>，<code>raise</code>，<code>sigsend</code> ，<code>sigqueue</code>函数等</li>
</ul>
<h3 id="（4）信号处理"><a href="#（4）信号处理" class="headerlink" title="（4）信号处理"></a>（4）信号处理</h3><p>进程可以通过三种方式响应信号：</p>
<ul>
<li>接受默认处理</li>
<li>忽略信号（某些信号不能被忽略，如 SIGKILL 和 SIGSTOP）</li>
<li>捕捉信号并执行信号处理程序</li>
</ul>
<h2 id="二、信号操作"><a href="#二、信号操作" class="headerlink" title="二、信号操作"></a>二、信号操作</h2><h3 id="（1）信号发送"><a href="#（1）信号发送" class="headerlink" title="（1）信号发送"></a>（1）信号发送</h3><p>系统调用中用于发送信号的函数有 <code>kill()</code> <code>raise()</code> <code>abort()</code> 等。</p>
<h4 id="kill-函数"><a href="#kill-函数" class="headerlink" title="kill() 函数"></a><code>kill()</code> 函数</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">kill</span><span class="params">(<span class="type">pid_t</span> pid, <span class="type">int</span> sig)</span>;</span><br><span class="line"><span class="comment">//第一个参数pid代表接受信号的进程PID，第二个参数代表要发送的信号</span></span><br></pre></td></tr></table></figure>
<p>参数 pid 会影响 kill()函数的作用，取值分为以下四种情况</p>
<ol>
<li>若 pid&gt;0，则发送信号 sig 给进程号为 pid 的进程。</li>
<li>若 pid=0，则发送信号 sig 给当前进程所属进程组的所有进程。</li>
<li>若 pid=-1，则发送信号 sig 给除 1 号进程和当前进程外的所有进程。</li>
<li>若 pid&lt;-1，则发送信号 sig 给属于进程组 pid 的所有进程。</li>
</ol>
<h4 id="segqueue-函数"><a href="#segqueue-函数" class="headerlink" title="segqueue() 函数"></a><code>segqueue()</code> 函数</h4><p>sigqueue()函数支持发送信号的同时传递参数，需要配合 <code>sigaction()</code> 函数一起使用。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sigqueue</span><span class="params">(<span class="type">pid_t</span> pid, <span class="type">int</span> sig, <span class="type">const</span> <span class="keyword">union</span> sigval value)</span>;</span><br><span class="line"><span class="comment">//第一个参数pid代表接受信号的进程PID，第二个参数代表要发送的信号，第三个参数于指定传递的数据</span></span><br></pre></td></tr></table></figure><br>参数 value 用于指定伴随信号传递的数据，为 sigval 联合体，该联合体的定义如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">sigval</span> &#123;</span></span><br><span class="line"><span class="type">int</span>   sival_int;</span><br><span class="line"><span class="type">void</span> *sival_ptr;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>如下的代码使用 <code>segqueue</code> 函数实现了数据的进程间传输</p>
</blockquote>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">./B &amp; <span class="comment"># 此时，输出进程 B 的 PID 号。</span></span><br><span class="line">./A processB_PID 123456 <span class="comment"># 第一个参数表示进程 B 的 PID，第二个参数为要传输的（数字）</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//code of A</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">pid_t</span> pid = atoi(argv[<span class="number">1</span>]);</span><br><span class="line">	<span class="type">int</span> stuID = atoi(argv[<span class="number">2</span>]);</span><br><span class="line">    <span class="class"><span class="keyword">union</span> <span class="title">sigval</span> <span class="title">v</span>;</span></span><br><span class="line">    v.sival_int = stuID;</span><br><span class="line">    sigqueue(pid, SIGINT, v);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//code of B</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="type">void</span> <span class="title function_">handler</span><span class="params">(<span class="type">int</span>, <span class="type">siginfo_t</span> *, <span class="type">void</span>*)</span>;</span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">act</span>;</span></span><br><span class="line">    act.sa_sigaction = handler;</span><br><span class="line">    sigemptyset(&amp;act.sa_mask);</span><br><span class="line">    act.sa_flags = SA_SIGINFO;</span><br><span class="line">    </span><br><span class="line">    sigaction(SIGINT, &amp;act, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">for</span>(; ;)</span><br><span class="line">      pause();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="type">void</span> <span class="title function_">handler</span><span class="params">(<span class="type">int</span> sig, <span class="type">siginfo_t</span> *info, <span class="type">void</span> *ctx)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;num received:%d\n&quot;</span>, info-&gt;si_value.sival_int);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="（2）信号捕捉"><a href="#（2）信号捕捉" class="headerlink" title="（2）信号捕捉"></a>（2）信号捕捉</h3><p>若进程捕捉某信号后，想要让其执行非默认的处理函数，则需要为该信号注册信号处理函数。进程的信号是在内核态下处理的，内核为每个进程准备了一个信号向量表，其中记录了每个信号所对应的信号处理函数。Linux 系统为用户提供了两个捕捉信号的函数，即 <code>signal()</code> 和 <code>sigaction()</code> 两个函数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="title function_">void</span> <span class="params">(*<span class="type">sighandler_t</span>)</span><span class="params">(<span class="type">int</span>)</span>;</span><br><span class="line"><span class="type">sighandler_t</span> <span class="title function_">signal</span><span class="params">(<span class="type">int</span> signum,<span class="type">sighandler_t</span> handler)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//第一个参数表示信号编号，第二个参数一般表示信号处理函数的函数指针，除此之外还可以为SIG_IGN和SIG_DEL</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sigaction</span><span class="params">(<span class="type">int</span> signum,<span class="type">const</span> <span class="keyword">struct</span> sigaction* act,<span class="type">const</span> <span class="keyword">struct</span> sigaction* oldact)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//第一个参数表示信号编号，第二个为传入参数，包含自定义处理函数和其他信息，第三个参数为传出参数，包含旧处理函数等信息</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>如下的代码通过信号实现了异步回收子进程。避免了 <code>wait()</code> 函数回收子进程时对父进程的阻塞。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">collect</span><span class="params">(<span class="type">int</span> sig)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    signal(SIGCHLD, collect);</span><br><span class="line">    <span class="type">pid_t</span> pid;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        pid = fork();</span><br><span class="line">        <span class="keyword">if</span> (pid == <span class="number">0</span>) <span class="comment">// child</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;child pid:%d\n&quot;</span>, getpid());</span><br><span class="line">            fflush(<span class="built_in">stdout</span>);</span><br><span class="line">            <span class="built_in">exit</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 模拟父进程继续执行</span></span><br><span class="line">    <span class="type">int</span> time = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">while</span> ((time = sleep(time)) != <span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">collect</span><span class="params">(<span class="type">int</span> sig)</span></span><br><span class="line">&#123;</span><br><span class="line">   signal(SIGCHLD, collect);</span><br><span class="line">   <span class="type">int</span> status;</span><br><span class="line">   <span class="type">pid_t</span> pid;</span><br><span class="line">   <span class="keyword">while</span> ((pid = waitpid(<span class="number">-1</span>, &amp;status, WNOHANG)) &gt; <span class="number">0</span>)</span><br><span class="line">   &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;child collected, pid:%d, status:%d\n&quot;</span>,</span><br><span class="line">         pid, WEXITSTATUS(status));</span><br><span class="line">      fflush(<span class="built_in">stdout</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="（3）信号屏蔽"><a href="#（3）信号屏蔽" class="headerlink" title="（3）信号屏蔽"></a>（3）信号屏蔽</h3><p>信号屏蔽机制是用于解决常规信号不可靠这一问题。在进程的 PCB 中存在两个信号集，分别为信号掩码和未决信号集。两个信号集实质上都是位图，其中每一位对应一个信号，若信号掩码某一位为 1，则其对应的信号会被屏蔽，进入阻塞状态，此时内核会修改未决信号集中该信号对应的位为 1，表示信号处于未决状态，之后除非信号被解除屏蔽，否则内核不会再向该进程发送该信号。</p>
<p>信号集设定函数：</p>
<ul>
<li><p><code>sigemptyset()</code>——将指定信号集清 0</p>
</li>
<li><p><code>sigfillset()</code>——将指定信号集置 1</p>
</li>
<li><p><code>sigaddset()</code>——将某信号加入指定信号集</p>
</li>
<li><p><code>sigdelset()</code>——将某信号从信号集中删除</p>
</li>
<li><p><code>sigismember()</code>——判断某信号是否已被加入指定信号集</p>
</li>
</ul>
<p>信号集函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">sigprocmask</span><span class="params">(<span class="type">int</span> how,<span class="type">const</span> <span class="type">sigset_t</span>* <span class="built_in">set</span>,<span class="type">sigset_t</span>* oldset)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//第一个参数用于设置位操作方式，第二个参数一般为用户指定信号集，第三个参数用于保存原信号集</span></span><br><span class="line"><span class="comment">//how=SIG_BLOCK：mask=mask|set</span></span><br><span class="line"><span class="comment">//how=SIG_UNBLOCK：mask=mask&amp;~set</span></span><br><span class="line"><span class="comment">//how=SIG_SETMASK：mask=set</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>如下的代码展示了信号遮蔽的使用方式。通过阻塞所有信号，避免了 printf() 函数因使用全局缓冲区而产生的异步信号不安全问题。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">print_safe</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">sigset_t</span> <span class="built_in">set</span>;</span><br><span class="line">    <span class="comment">// 1~64 为所有信号的编号</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">64</span>; i++)</span><br><span class="line">        sigaddset(&amp;<span class="built_in">set</span>, i);</span><br><span class="line">    <span class="comment">// 阻塞所有信号</span></span><br><span class="line">    sigprocmask(SIG_BLOCK, &amp;<span class="built_in">set</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;safe print!\n&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 恢复所有信号</span></span><br><span class="line">    sigprocmask(SIG_UNBLOCK, &amp;<span class="built_in">set</span>, <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="（4）定时信号"><a href="#（4）定时信号" class="headerlink" title="（4）定时信号"></a>（4）定时信号</h3><p>Linux 下的 <code>alarm()</code> 函数可以用来设置闹钟，该函数的原型为：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> <span class="title function_">alarm</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> seconds)</span>;</span><br><span class="line"><span class="comment">//第一个参数seconds用来指明时间，经过seconds秒后发送SIGALRM信号给当前进程，当参数为0则取消之前的闹钟</span></span><br></pre></td></tr></table></figure>
<p>返回值：</p>
<ul>
<li>如果本次调用前已有正在运行的闹钟，alarm()函数返回前一个闹钟的剩余秒数</li>
<li>如果本次调用前无正在运行的闹钟，alarm()函数返回 0</li>
</ul>
<p>Linux 系统中 sleep()函数内部使用 nanosleep()函数实现，该函数与信号无关；而其他系统中可能使用 alarm()和 pause()函数实现，此时不应该混用 alarm()和 sleep()。</p>
<blockquote>
<p>如下的代码实现了这样的功能：程序每间隔 1 秒输出信息，当按下 ctrl+c 后，程序询问是否退出程序（此时停止输出学号），输入 Y 或 5 秒未进行任何输入则退出程序，输入 N 程序恢复运行，继续输出信息</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">chooseIfExit</span><span class="params">(<span class="type">int</span> signal)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">doExit</span><span class="params">(<span class="type">int</span> signal)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	signal(SIGINT, chooseIfExit);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;21371326\n&quot;</span>);</span><br><span class="line">		sleep(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">chooseIfExit</span><span class="params">(<span class="type">int</span> sig)</span></span><br><span class="line">&#123;</span><br><span class="line">	signal(SIGINT, chooseIfExit);</span><br><span class="line">	signal(SIGALRM, doExit);</span><br><span class="line">	alarm(<span class="number">5</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;want to exit? (Y/N)\n&quot;</span>);</span><br><span class="line">	<span class="type">char</span> choose;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot; %c&quot;</span>, &amp;choose);</span><br><span class="line">	<span class="keyword">if</span> (choose == <span class="string">&#x27;N&#x27;</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		alarm(<span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		doExit(SIGINT);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">doExit</span><span class="params">(<span class="type">int</span> signal)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;exit...\n&quot;</span>);</span><br><span class="line">	<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="（5）计时器"><a href="#（5）计时器" class="headerlink" title="（5）计时器"></a>（5）计时器</h3><p>Linux 下的 <code>setitimer()</code> 和 <code>getitimer()</code> 系统调用可以用于访问和设置计时器，计时器在初次经过设定的时间后发出信号，也可以设置为每间隔相同的时间发出信号，该函数的原型为：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">getitimer</span><span class="params">(<span class="type">int</span> which, <span class="keyword">struct</span> itimerval *curr_value)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">setitimer</span><span class="params">(<span class="type">int</span> which, <span class="type">const</span> <span class="keyword">struct</span> itimerval *<span class="keyword">restrict</span> new_value,</span></span><br><span class="line"><span class="params">                     <span class="keyword">struct</span> itimerval *<span class="keyword">restrict</span> old_value)</span>;</span><br></pre></td></tr></table></figure>
<p>通过指定 which 参数，可以设置不同的计时器，不同的计时器触发后也会发出不同的信号，一个进程同时只能有一种计时器：</p>
<ul>
<li>ITIMER_REAL：真实计时器，计算程序运行的真实时间（墙钟时间），产生 SIGALRM 信号</li>
<li>ITIMER_VIRTUAL：虚拟计时器，计算当前进程处于用户态的 cpu 时间，产生 SIGVTALRM 信号</li>
<li>ITIMER_PROF：使用计时器，计算当前进程处于用户态和内核态的 cpu 时间，产生 SIGPROF 信号</li>
</ul>
<p>计时器的值有以下结构体定义：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">itimerval</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">it_interval</span>;</span> <span class="comment">//定期触发的间隔</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">it_value</span>;</span> <span class="comment">//初次触发时间</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> &#123;</span></span><br><span class="line">  <span class="type">time_t</span> tv_sec; <span class="comment">//秒</span></span><br><span class="line">  <span class="type">suseconds_t</span> tv_usec; <span class="comment">//微秒</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>若 new_value.it_value 的两个字段不全为 0，则定时器初次将会在设定的时间后触发；若 new_value.it_value 的两个字段全为 0，则计时器不工作。</p>
<p>若 new_value.it_interval 的两个字段不全为 0，则定时器将会在初次触发后按设定的时间间隔触发；若 new_value.it_interval 的两个字段全为 0，则计时器仅初次触发一次。</p>
<p>setitimer()函数和 alarm()函数共享同一个计时器，因此不应同时使用。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://wokron.github.io/posts/7ab376c3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="wokron">
      <meta itemprop="description" content="StringCat的个人博客。记录学习、分享经验">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="StringCat的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/posts/7ab376c3/" class="post-title-link" itemprop="url">系统编程之进程管理</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-10-31 22:08:16" itemprop="dateCreated datePublished" datetime="2022-10-31T22:08:16+08:00">2022-10-31</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-06-26 10:38:38" itemprop="dateModified" datetime="2023-06-26T10:38:38+08:00">2023-06-26</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">学习笔记</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="一、引言"><a href="#一、引言" class="headerlink" title="一、引言"></a>一、引言</h2><p>进程是操作系统中的重要概念，是对执行一定功能的程序的过程的抽象。这篇文章将简要说明进程的相关知识。介绍进程管理相关的函数，并通过这些函数实现重定向和进程间通信等功能。</p>
<h2 id="二、进程简介"><a href="#二、进程简介" class="headerlink" title="二、进程简介"></a>二、进程简介</h2><h3 id="1-程序执行原理"><a href="#1-程序执行原理" class="headerlink" title="1. 程序执行原理"></a>1. 程序执行原理</h3><p>程序在编译后以二进制方式存在于外存上，执行的时候被操作系统载入内存。以 Linux 系统上的 C 语言编译出来的程序为例，载入的过程简单来说就是把编译完成的 ELF （Executable and Linkable Format 可执行与可链接格式） 文件的几个段的内容读取到内存指定位置，然后初始化寄存器的内容，将指令寄存器（比如<code>cs:ip</code>）指向程序入口，再初始化一些进程相关内容就完成了。</p>
<p>在某一次时钟中断发生的时候，进程主动陷入内核态，进行进程切换的系统调用，CPU 将切换到另一个进程工作。<strong>总而言之，整个计算机从开机到关机，就是一个不断创建、切换、终止进程的过程。</strong></p>
<h3 id="2-进程概念的用途"><a href="#2-进程概念的用途" class="headerlink" title="2. 进程概念的用途"></a>2. 进程概念的用途</h3><p>早期的计算机一次只能执行一个程序，这种程序完全控制系统，并且访问所有系统资源。相比之下，现代计算机系统允许“同时”加载多个应用程序到内存，以便并发（轮流）执行。</p>
<p>这种改进要求对各种程序提供更严的控制和更好的划分。这些需求导致了<strong>进程</strong>概念的诞生。</p>
<p>进程是现代分时操作系统的工作单元，是操作系统向运行中的程序进行资源分配的单位。进程包括程序代码(文本)，当前活动(程序计数器，寄存器的值)，堆栈，数据端，堆。</p>
<blockquote>
<p>需要注意区分程序和进程的概念。程序是被动实体，如存储在磁盘上的可执行文件；进程是活动实体，具有一个程序计数器用于表示下个执行命令和一组相关资源。</p>
<p>当一个可执行文件被加载到内存时，这个程序就成为进程。</p>
<p>两个进程可以与同一程序相关联，但当作两个单独的执行序列，虽然文本段相同，但是数据、堆、堆栈不同。</p>
</blockquote>
<h2 id="三-进程管理"><a href="#三-进程管理" class="headerlink" title="三. 进程管理"></a>三. 进程管理</h2><p>接下来介绍使用操作系统 API 进行进程管理的方法。</p>
<h3 id="1-使用-fork-创建新进程"><a href="#1-使用-fork-创建新进程" class="headerlink" title="1. 使用 fork 创建新进程"></a>1. 使用 fork 创建新进程</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">fork</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure>
<p><code>fork</code> 无参数，返回一个用于指示子进程的 <code>pid</code>（对于子进程，返回值为 0）。其作用是创建一个子进程，共享父进程所有内容，并且这个子进程会接着 <code>fork</code> 下面的代码继续执行。<code>fork</code>有以下两种用法：</p>
<ul>
<li>一个父进程希望复制自己，使父进程和子进程同时执行不同的代码段。</li>
<li>一个进程要执行一个不同的程序。在这种情况下，子进程从<code>fork</code>返回后立即调用<code>exec</code>。</li>
</ul>
<p>如果在调用 <code>fork</code> 后子进程先于父进程结束，则子进程就会变为僵尸进程，虽然结束，却依然占据了进程表中的一个位置。为了避免这种情况，需要调用 <code>wait</code> 或 <code>waitpid</code> 来使父进程等待子进程结束，并释放子进程的信息。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">wait</span><span class="params">(<span class="type">int</span> *status)</span>;</span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">waitpid</span><span class="params">(<span class="type">pid_t</span> pid,<span class="type">int</span> *status,<span class="type">int</span> options)</span>;</span><br></pre></td></tr></table></figure>
<p>下面将以一个程序作为例子。该程序由父进程创建两个子进程，父进程打印字符 B ，两个子进程分别打印 A 和 C ，并且要使最终的输出为 ABC 。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">pid_t</span> pid1 = fork();</span><br><span class="line">    <span class="keyword">if</span> (pid1 == <span class="number">0</span>) <span class="comment">// child1</span></span><br><span class="line">    &#123;</span><br><span class="line">    	<span class="built_in">printf</span>(<span class="string">&quot;A&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="comment">// parent</span></span><br><span class="line">    &#123;</span><br><span class="line">        wait(<span class="literal">NULL</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;B&quot;</span>);</span><br><span class="line">        fflush(<span class="built_in">stdout</span>);</span><br><span class="line">        <span class="type">pid_t</span> pid2 = fork();</span><br><span class="line">        <span class="keyword">if</span> (pid2 == <span class="number">0</span>) <span class="comment">// child2</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;C&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="comment">// parent</span></span><br><span class="line">        &#123;</span><br><span class="line">            wait(<span class="literal">NULL</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><strong>代码说明：</strong> 在该程序中，我们先调用 <code>fork</code> 创建了一个子进程，通过 pid 的数值来区分父子进程。对子进程来说，打印字符 A，对父进程来说，调用 <code>wait</code> 等待子进程结束，随后父进程打印字符 B。（注意这里使用 <code>fflush</code> 刷新了缓冲区，这是因为调用 <code>fork</code> 进行进程复制也会将缓冲区的内容进行复制，没有在此之前刷新缓冲区会导致字符 B 输出两次）接着，类似的，我们根据 pid 判断父子进程，并在子进程中打印字符 C。父进程调用 <code>wait</code> 等待子进程结束，最后退出程序。</p>
<h3 id="2-exec族函数"><a href="#2-exec族函数" class="headerlink" title="2. exec族函数"></a>2. exec族函数</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">execl</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname, <span class="type">const</span> <span class="type">char</span> *arg0, ... <span class="comment">/* (char *)0 */</span>)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">execv</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname, <span class="type">char</span> *<span class="type">const</span> argv[])</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">execle</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname, <span class="type">const</span> <span class="type">char</span> *arg0, ...<span class="comment">/* (char *)0, char *const envp[] */</span>)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">execve</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname, <span class="type">char</span> *<span class="type">const</span> argv[], <span class="type">char</span> *<span class="type">const</span> envp[])</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">execlp</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *filename, <span class="type">const</span> <span class="type">char</span> *arg0, ... <span class="comment">/* (char *)0 */</span>)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">execvp</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *filename, <span class="type">char</span> *<span class="type">const</span> argv[])</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">fexecve</span><span class="params">(<span class="type">int</span> fd, <span class="type">char</span> *<span class="type">const</span> argv[], <span class="type">char</span> *<span class="type">const</span> envp[])</span>;</span><br><span class="line"><span class="comment">// 第一个参数使用的是打开的文件描述符，而非文件路径名</span></span><br></pre></td></tr></table></figure>
<p>exec 函数族的作用是根据指定的文件名找到可执行文件，并用它来取代调用进程的内容换句话说，就是在调用进程内部执行一个可执行文件。这里的可执行文件既可以是二进制文件，也可以是任何 Linux 下可执行的脚本文件。与一般情况不同，exec 函数族的函数执行成功后不会返回，因为调用进程的实体，包括代码段，数据段和堆栈等都已经被新的内容取代，只留下进程 ID 等一些表面上的信息仍保持原样。只有调用失败了，它们才会返回一个 -1，从原程序的调用点接着往下执行。</p>
<p>这几个函数的用法大体上是一致的，只是参数格式有所不同。</p>
<ul>
<li>“ l “ 代表 list 即列表，对应可变参数<code>argv</code> 以列表的形式出现</li>
<li>“ v “ 代表 vector 即矢量数组，对应可变参数<code>argv</code>以数组的形式出现</li>
<li>“ e “ 代表 environment ，对应 <code>envp</code>数组，是指给可执行文件指定环境变量。在全部 7 个函数中，只有<code>execle</code>、<code>execve</code>和<code>fexecve</code>使用了<code>char *envp[]</code>传递环境变量，其它的 4 个函数都没有这个参数，这并不意味着它们不传递环境变量，这 4 个函数将把默认的环境变量不做任何修改地传给被执行的应用程序。而它们用指定的环境变量去替代默认的那些。</li>
<li>“ p “ 代表 环境变量 PATH ,字母 p 是指在环境变量 PATH 的目录里去查找要执行的可执行文件。2 个以 p 结尾的函数<code>execlp</code>和<code>execvp</code>，看起来，和<code>execl</code>与<code>execv</code>的差别很小，事实也如此，它们的区别从第一个参数名可以看出：除 <code>execlp</code>和<code>execvp</code>之外的 4 个函数都要求，它们的第 1 个参数 path 必须是一个完整的路径，如”/bin/ls”；而<code>execlp</code>和<code>execvp</code> 的第 1 个参数 file 可以仅仅只是一个文件名，如”ls”，这两个函数可以自动到环境变量 PATH 指定的目录里去查找。</li>
</ul>
<blockquote>
<p><strong>注意：</strong></p>
<ul>
<li>当进程调用一种<code>exec</code>函数时，该进程执行的程序完全替换为新程序，而新程序从其<code>main</code>函数开始执行。</li>
<li>调用<code>exec</code>并不创建新进程，前后的进程 ID 并未改变，<code>exec</code>只是用磁盘上的一个新程 序替换了当前进程的正文段、数据段、堆段和栈段。</li>
<li>在很多 UNIX 实现中，<strong>这<code>7</code>个函数只有<code>execve</code>是内核的系统调用</strong>，另外<code>6</code>个只 是库函数，它们最终都要调用该系统调用。</li>
</ul>
</blockquote>
<p>如下的实例程序会对当前目录使用<code>ls -l</code>。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    execlp(<span class="string">&quot;ls&quot;</span>, <span class="string">&quot;ls&quot;</span>, <span class="string">&quot;-l&quot;</span>, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>请注意，使用 <code>execlp</code> 及类似函数时，arg0 应为调用的程序名。在可变参数的末尾要加上 NULL</p>
</blockquote>
<h3 id="3-dup重定向"><a href="#3-dup重定向" class="headerlink" title="3. dup重定向"></a>3. dup重定向</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">dup</span><span class="params">(<span class="type">int</span> oldfd)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">dup2</span><span class="params">(<span class="type">int</span> oldfd, <span class="type">int</span> newfd)</span>;</span><br></pre></td></tr></table></figure>
<p>使用 <code>dup</code> 和 <code>dup2</code> 函数可以复制一个现存的文件描述符。从而实现输入输出的重定向。</p>
<ul>
<li><code>dup</code> 用来复制参数oldfd所指的文件描述符。当复制成功是，返回最小的尚未被使用过的文件描述符。</li>
<li><code>dup2</code> 与 <code>dup</code> 区别是 <code>dup2</code> 可以用参数 <code>newfd</code> 指定新文件描述符的数值。若参数 <code>newfd</code> 已经被程序使用，则系统就会将 <code>newfd</code> 所指的文件关闭，若 <code>newfd</code> 等于 <code>oldfd</code>，则返回 <code>newfd</code>，而不关闭 <code>newfd</code> 所指的文件。</li>
</ul>
<p>如下程序将 <code>printf</code> 的输出内容重定向到 redirect.txt。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> filefd = open(<span class="string">&quot;redirect.txt&quot;</span>, O_CREAT|O_RDWR, <span class="number">777</span>);</span><br><span class="line">    <span class="type">int</span> redirectfd = dup2(filefd, <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;hahaha~~&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="4-管道"><a href="#4-管道" class="headerlink" title="4. 管道"></a>4. 管道</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pipe</span><span class="params">(<span class="type">int</span> pipefd[<span class="number">2</span>])</span>;</span><br></pre></td></tr></table></figure>
<p>管道是最基本的进程通信机制，可以想象成一个管道，两端分别连着 2 个进程，一个进程往里面写，一个进程从里面读。如果读或写管道的时候没有内容可供读或写，进程将被阻塞，直到有内容可供读写为止。</p>
<p>管道分为匿名管道和命名管道，这里只介绍匿名管的。匿名管道创建后本质上是 2 个文件描述符，父子进程分别持有就能够使用管道，需要注意的是不能够共用匿名管道，也就是除了使用的进程，其他进程需要关闭文件描述符，保证管道 的 2 个描述符分别同时只有 1 个进程持有。</p>
<p>下面是在父子进程间使用管道的例子（父进程写，子进程读）：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> fd[<span class="number">2</span>];</span><br><span class="line">    pipe(fd);</span><br><span class="line">    <span class="type">pid_t</span> pid = fork();</span><br><span class="line">    <span class="keyword">if</span> (pid == <span class="number">0</span>) <span class="comment">// child</span></span><br><span class="line">    &#123;</span><br><span class="line">        close(fd[<span class="number">1</span>]);</span><br><span class="line">        <span class="comment">// do something to read with fd[0]</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        close(fd[<span class="number">0</span>]);</span><br><span class="line">        <span class="comment">// do something to write with fd[1]</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>需要注意的是，调用 <code>pipe</code> 应该在 <code>fork</code> 之前。</p>
</blockquote>
<p>接下来是一个利用进程实现素数筛的程序<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> numRead[<span class="number">1000</span>];</span><br><span class="line">    <span class="type">int</span> readCnt = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> numWrite[<span class="number">1000</span>];</span><br><span class="line">    <span class="keyword">if</span> (argc &gt; <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">    	<span class="type">int</span> input;</span><br><span class="line">    	<span class="built_in">sscanf</span>(argv[<span class="number">1</span>], <span class="string">&quot;%d&quot;</span>, &amp;input);</span><br><span class="line">    	readCnt = input<span class="number">-1</span>;</span><br><span class="line">    	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= input; i++)</span><br><span class="line">    		numRead[i<span class="number">-2</span>] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">pid_t</span> pid;</span><br><span class="line">    <span class="type">int</span> fds[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">    &#123;</span><br><span class="line">    	pipe(fds);</span><br><span class="line">    	pid = fork();</span><br><span class="line">    	<span class="keyword">if</span> (pid == <span class="number">0</span>) <span class="comment">// child</span></span><br><span class="line">    	&#123;</span><br><span class="line">    		close(fds[<span class="number">1</span>]);</span><br><span class="line">    		<span class="type">int</span> fdRead = fds[<span class="number">0</span>];</span><br><span class="line">    		readCnt = read(fdRead, numRead, <span class="keyword">sizeof</span>(numRead)) / <span class="number">4</span>;</span><br><span class="line">    		<span class="keyword">if</span> (readCnt == <span class="number">1</span> &amp;&amp; numRead[<span class="number">0</span>] == <span class="number">-1</span>)</span><br><span class="line">    			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    	&#125;</span><br><span class="line">    &#125;<span class="keyword">while</span>(pid == <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    close(fds[<span class="number">0</span>]);</span><br><span class="line">    <span class="type">int</span> fdWrite = fds[<span class="number">1</span>];</span><br><span class="line">    <span class="type">int</span> prime = numRead[<span class="number">0</span>];</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, prime);</span><br><span class="line">    fflush(<span class="built_in">stdout</span>);</span><br><span class="line">    <span class="type">int</span> writeCnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; readCnt; i++)</span><br><span class="line">    &#123;</span><br><span class="line">    	<span class="keyword">if</span> (numRead[i] % prime != <span class="number">0</span>)</span><br><span class="line">    		numWrite[writeCnt++] = numRead[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (writeCnt == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">    	fflush(<span class="built_in">stdout</span>);</span><br><span class="line">    	numWrite[<span class="number">0</span>] = <span class="number">-1</span>;</span><br><span class="line">    	write(fdWrite, numWrite, <span class="number">4</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    	write(fdWrite, numWrite, <span class="number">4</span> * writeCnt);</span><br><span class="line"></span><br><span class="line">    wait(<span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><strong>原理如下：</strong></p>
<blockquote>
<p>Eratosthenes的筛选法可以通过执行以下伪代码来模拟：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">p = get a number from left neighbor</span><br><span class="line">print p</span><br><span class="line">loop:</span><br><span class="line">    n = get a number from left neighbor</span><br><span class="line">    if (p does not divide n)</span><br><span class="line">        send n to right neighbor</span><br><span class="line">p = 从左邻居中获取一个数</span><br><span class="line">print p</span><br><span class="line">loop:</span><br><span class="line">    n = 从左邻居中获取一个数</span><br><span class="line">    if (n不能被p整除)</span><br><span class="line">        将n发送给右邻居</span><br></pre></td></tr></table></figure>
<p>生成进程可以将数字2、3、4、…、1000输入管道的左端：行中的第一个进程消除2的倍数，第二个进程消除3的倍数，第三个进程消除5的倍数，依此类推。</p>
</blockquote>
<img src="/posts/7ab376c3/p1.png" class="" title="Eratosthenes">
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://wokron.github.io/posts/9b69f0a/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="wokron">
      <meta itemprop="description" content="StringCat的个人博客。记录学习、分享经验">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="StringCat的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/posts/9b69f0a/" class="post-title-link" itemprop="url">机器学习之异常检测</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-10-23 10:57:17" itemprop="dateCreated datePublished" datetime="2022-10-23T10:57:17+08:00">2022-10-23</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-06-26 10:38:38" itemprop="dateModified" datetime="2023-06-26T10:38:38+08:00">2023-06-26</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">学习笔记</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="一、引言"><a href="#一、引言" class="headerlink" title="一、引言"></a>一、引言</h2><p>另一种常用的非监督学习应用场景是异常检测。异常检测会学习正常情况下的样本数据，并在应用时检测出现的异常数据。</p>
<p>异常检测会运用正态分布等知识，这里先介绍一下正态分布（同时也作为自己对概率统计中的相关知识的一点总结）。</p>
<h2 id="二、正态分布"><a href="#二、正态分布" class="headerlink" title="二、正态分布"></a>二、正态分布</h2><p>对于连续型随机变量 X，若其概率密度函数为如下的形式</p>
<script type="math/tex; mode=display">
    f(x) = \frac{1}{\sqrt{2\pi}\sigma} e^{-\frac{(x-\mu)^2}{2\sigma^2}}</script><p>其中 $\sigma &gt; 0, \mu \in R$</p>
<p>则称 X 服从正态分布（Normal distribution），记 $X \sim N(\mu, \sigma^2)$。</p>
<p>取 $\mu = 0, \sigma = 1$，此时 $X \sim N(0, 1)$，称 X 服从标准正态分布。记标准正态分布的概率密度为 $\phi(x)$，分布函数为 $\Phi(x)$，则任意的服从正态分布的随机变量 X，其分布函数为 $F(x) = \Phi(\frac{x - \mu}{\sigma})$。</p>
<blockquote>
<ul>
<li>标准正态分布的分布函数数值有表可查。</li>
<li>任意正态分布的分布函数等式中的 $\frac{x - \mu}{\sigma}$ 是不是有点熟悉？在特征放缩那一篇文章中的 Z score 标准化部分有出现。 Z score 标准化似乎就是假定特征数值服从正态分布，并将其转化为标准正态分布形式。</li>
</ul>
</blockquote>
<h2 id="三、算法"><a href="#三、算法" class="headerlink" title="三、算法"></a>三、算法</h2><p>我们假设不同训练样本的每一个特征服从服从正态分布。那么，对每一个特征 <code>x_j</code>，求其期望 $\mu_j$ 和方差 $\sigma_j^2$，则该特征对应的概率密度为 $p(x_j, \mu_j, \sigma_j^2) = \Phi(\frac{x - \mu}{\sigma})$。我们假设各个特征之间相互独立，则对于任意的 $\vec{x}=(x_1, x_2, …, x_m)$，总的概率密度为</p>
<script type="math/tex; mode=display">
    p(\vec{x}) = p(x_1, \mu_1, \sigma_1^2) \times p(x_2, \mu_2, \sigma_2^2) \cdots \times p(x_m, \mu_m, \sigma_m^2)</script><p>即</p>
<script type="math/tex; mode=display">
    p(\vec{x}) = \prod_{j=1}^n p(x_j, \mu_j, \sigma_j^2)</script><p>求得的 $p(\vec{x})$ 能够反映 $\vec{x}$ 相对于训练样本正常的程度。当 $p(\vec{x})$ 很小时，说明该数据相对于训练样本的偏差很大，即异常。我们用一个很小的值 $\epsilon$ 作为判断是否异常的阈值。当 $p(\vec{x}) \lt \epsilon$，即判断为异常。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://wokron.github.io/posts/af468c0b/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="wokron">
      <meta itemprop="description" content="StringCat的个人博客。记录学习、分享经验">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="StringCat的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/posts/af468c0b/" class="post-title-link" itemprop="url">机器学习之K均值聚类</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-10-23 08:53:53" itemprop="dateCreated datePublished" datetime="2022-10-23T08:53:53+08:00">2022-10-23</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-06-26 10:38:38" itemprop="dateModified" datetime="2023-06-26T10:38:38+08:00">2023-06-26</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">学习笔记</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="一、引言——非监督学习"><a href="#一、引言——非监督学习" class="headerlink" title="一、引言——非监督学习"></a>一、引言——非监督学习</h2><p>之前介绍的算法都是监督学习算法。需要样本中包含各特征信息以及结果标签来让模型学习特征与结果的对应关系。但是，如果我们此时只有特征信息，而不指明具体结果是什么，又需要什么样的算法和模型才能得知哪些样本会有同样的标签呢？</p>
<p>这种从原始数据中探索样本间联系的学习方式称为非监督学习。其中非监督意指，模型不需要人来告知他 “什么是什么”，而能自己从数据中挖掘信息。</p>
<h2 id="二、聚类算法"><a href="#二、聚类算法" class="headerlink" title="二、聚类算法"></a>二、聚类算法</h2><p>非监督学习中的一种算法为聚类算法。它的目的是将数据按照一定特征进行分组。</p>
<p>最广泛使用的聚类算法称为 K 均值（K-means）算法。</p>
<h2 id="三、K均值算法"><a href="#三、K均值算法" class="headerlink" title="三、K均值算法"></a>三、K均值算法</h2><p>假设我们要将所有数据分成 k 组，并称在一组中的数据为一个簇。那么对于每一簇内的数据，我们就希望他们之间的距离相对较小，而他们与其他簇中的数据的距离较大。直观上讲，就是同簇的数据点形成一个较为密集的区域，不同簇之间则有较大的空隙（这或许就是聚类的含义）。</p>
<p>我们用簇内的数据的平均作为对簇的描述，相当于指示了簇在特征空间中的位置。这一平均后得到的点称为簇质心。假设我们现在已经得到了一种分组，那么这种分组现在是否有优化的可能呢？要回答这个问题就要查看每一数据点相对于各个簇质心的距离，如果某个数据点相对于其他簇质心的距离要小于其相对于当前所在的簇的质心的距离，就说明该点被错分类了。我们就要将其重新划分为与其距离最小的簇质心所对应的簇内。</p>
<p>但是，这种重新划分又会使得簇质心的位置发生变化，这又导致一些之前是距离该质心位置最小的数据点不再是距离该质心位置最小，又需要再次调整分类。就这样，不断地调整，直到最终所有的点距离当前所在簇的质心距离都为最小，就代表了分类完成。</p>
<p>经过了上面的分析，我们现在给出 K 均值算法的流程：</p>
<ol>
<li>初始化 k 个簇质心位置，分别对应 k 个簇</li>
<li>对每个数据点，选择与其距离最近的簇质心对应的簇作为其当前分组</li>
<li>对所有同一簇的数据点，计算其平均值，作为新的当前簇的簇质心</li>
<li>不断重复 2、3，直到所有簇的簇质心不再发生变化，即代表分组完成</li>
</ol>
<p>可以看出，该算法具有很简单的流程，且没有复杂的数据结构。</p>
<blockquote>
<p>算法中还需要明确两个点：</p>
<ul>
<li>如何初始化簇质心：<br>一般是随机选取点作为质心，或者在样本数据中随机选取 k 个点</li>
<li>怎么计算数据点到簇质心的距离<br>该算法使用二范数，或者说欧氏距离作为距离</li>
</ul>
</blockquote>
<h2 id="四、K均值算法的损失函数"><a href="#四、K均值算法的损失函数" class="headerlink" title="四、K均值算法的损失函数"></a>四、K均值算法的损失函数</h2><p>这里我们要更理论化地解释为什么这样的算法可以将数据成功分类</p>
<p>假设总共有 m 个样本数据 $x^{(1)}, x^{(2)}, …, x^{(m)}$，需要将其分为 k 类（k &lt; m）。我们用 $c^{(i)}$ 表示第 i 个数据点选择第几个簇。用 $\mu_{j}$ 表示第 j 个簇的簇质心。</p>
<p>要衡量当前分组，按照之前所说的 “同簇的数据点形成一个较为密集的区域，不同簇之间则有较大的空隙”，很容易采用簇中数据点相对于质心的距离的平均作为标准。这里直接给出损失函数</p>
<script type="math/tex; mode=display">
    J(c^{(1)}, ..., c^{(m)}, \mu_{1}, ..., \mu_{k}) =
    \frac{1}{m}\sum_{i=1}^m \Vert x^{(i)} - \mu_{c^{(i)}} \Vert^2</script><p>该损失函数在这里又叫做失真函数。很明显，失真函数是所有数据点到其对应的簇质心的距离的平方的平均。距离取平方是因为这样并不影响损失函数的衡量效果，而又方便计算。</p>
<p>根据失真函数，我们可以证明上一节算法的正确性。</p>
<ul>
<li>步骤 2 时，对第 i 个样本，我们重新选择 $c^{(i)}$ 使得 $\min\Vert x^{(i)} - \mu_{c^{(i)}} \Vert$ 从而使得 $\min J$。</li>
<li>步骤 3 时，我们使 $\mu<em>j$ 取所有簇内数据点的平均。可以数学证明，此时依旧使得 $\min \Vert x^{(i)} - \mu</em>{c^{(i)}} \Vert$。</li>
<li>这样我们就对失真函数中的每一个参数进行了调整，相当于进行了一次梯度下降。通过不断重复这一过程，最终便可达到使失真函数最小的位置。</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://wokron.github.io/posts/55036469/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="wokron">
      <meta itemprop="description" content="StringCat的个人博客。记录学习、分享经验">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="StringCat的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/posts/55036469/" class="post-title-link" itemprop="url">机器学习之决策树</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-10-17 08:07:31" itemprop="dateCreated datePublished" datetime="2022-10-17T08:07:31+08:00">2022-10-17</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-06-26 10:38:38" itemprop="dateModified" datetime="2023-06-26T10:38:38+08:00">2023-06-26</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">学习笔记</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="一、引言"><a href="#一、引言" class="headerlink" title="一、引言"></a>一、引言</h2><p>决策树是另一种十分有效的机器学习模型。该模型采取树状分支结构，能够很快地进行模型训练，并具有较高的准确率。</p>
<p>本文将以决策树的最简单形式开始，即特征只包括真值特征，或只有两种选择的特征，且结果也只有两种的情况。</p>
<h2 id="二、决策树基本模型"><a href="#二、决策树基本模型" class="headerlink" title="二、决策树基本模型"></a>二、决策树基本模型</h2><p>决策树是一个二叉树，树的非叶节点存储需要区分的特征，叶节点存储预测的分类。对于每一个要进行预测的数据，从根节点开始，根据当前节点所对应的特征，选择移动到左子节点或右子节点。直到最终移动到一个叶节点，返回预测结果。</p>
<p>可以认为决策树的预测过程就是通过不同特征将当前数据分组归类的过程。决策树的构建过程，或者更一般地说，该模型的学习过程，也就是不断确定如何分类的过程。</p>
<h2 id="三、决策树的构建"><a href="#三、决策树的构建" class="headerlink" title="三、决策树的构建"></a>三、决策树的构建</h2><p>总体上讲，对于我们已有的样本数据，构建决策树的过程时这样的。</p>
<ol>
<li>选择一个特征，将该特征作为当前节点的特征</li>
<li>根据该特征将样本数据分为两组</li>
<li>对于两组被分类的数据，分别递归执行如上操作，从而确定当前节点的左右子节点。直到当前数据已经全部是要预测的某个结果了、或者所有特征都被用完、又或者递归进行到了最大层数。</li>
</ol>
<p>可以看到，决策树构建的过程中大部分过程都可以用简单的程序逻辑实现。现在唯一要解决的就是在每个节点时，如何选择一个特征了。</p>
<blockquote>
<p>当然，对于神经网络来说也是这样的。唯一要解决的是如何选择权重。</p>
</blockquote>
<h2 id="四、特征的选择"><a href="#四、特征的选择" class="headerlink" title="四、特征的选择"></a>四、特征的选择</h2><p>我们要衡量选择不同特征对训练样本的区分效果。这点类似于损失函数。</p>
<p>我们区分的目标是使得所有当前组的样本属于同一个预测结果。那么我们就要找到一种衡量纯度的指标，数据越纯指标越小，数据越不纯指标越大。这种指标就是熵。假设某一种类在数据总体中的占比为 $p_1$，则熵 $H(p_1)$ 为</p>
<script type="math/tex; mode=display">
    p_0 = 1 - p_1 \\
    H(p_1) = -p_1log_2(p_1) - p_0 log_2(p_0)</script><p>即</p>
<script type="math/tex; mode=display">
    H(p_1) = -p_1log_2(p_1) - (1-p_1) log_2(1 - p_1)</script><p>当 $p_1 = 0$ 或 $p_1 = 1$ 时</p>
<script type="math/tex; mode=display">
    H(0) = H(0+0) = 0 \\
    H(1) = H(1-0) = 0</script><blockquote>
<p>可以看出熵与交叉熵损失函数之间有联系。确实，交叉熵损失函数也是用来衡量预测的纯度的。对于一个预测，我们总希望它接近 0 或者 1，也就是纯度最大的比例。</p>
</blockquote>
<p>我们不妨设决策树中预测可能结果中一个为正例，一个为负例。假设对于当前节点处的训练样本集合 $X$， 我们选择第 j 个特征，将该集合分为两个部分 $A<em>j$ 和 $B_j$。设此时 $A_j$ 和 $B_j$ 中正例所占比例分别为 $p</em>{Aj}, p_{Bj}$，则对应的熵为：</p>
<script type="math/tex; mode=display">
    H(p_{Aj}) 和 H(p_{Bj})</script><p>对于不同的 j，两个熵值均会不同，那么我们如何比较哪种选择更为合适呢？我们需要对熵取加权平均，权重为该集合中元素数量占原集合数量的比重。</p>
<script type="math/tex; mode=display">
    \frac{\#A_jH(p_{Aj}) + \#B_jH(p_{Bj})}{\#X}</script><blockquote>
<p>这是很合理的。举个例子，假设选择了一个特征将一个样本和其他样本分开，虽然第一个样本的熵为 0，可是该分类对样本整体的影响较小，决定整体纯度的还是其他样本的部分，最终平均后的熵可能并不会减少太多</p>
</blockquote>
<p>我们将分类后的平均熵值对分类前的总熵的减少量称为信息增益（Information Gain）。假设选择某一特征时，子集合元素数量占原集合的比重为 $w^{left}, w^{right}$，则</p>
<script type="math/tex; mode=display">
    \text{Information Gain} = H(p^{root}_1) - (w^{left}H(p^{left}_1) + w^{right}H(p^{right}_1))</script><p>这样我们就解决了选择特征的问题，只要选择使信息增益最大的特征即可。</p>
<blockquote>
<p>很明显，如果一个特征在祖先节点已经被选择过了，则信息增益为 0。当所有特征的信息增益都为 0 时，说明所有特征都已经被使用过了，此时就可以返回递归了。</p>
</blockquote>
<h2 id="五、多取值特征"><a href="#五、多取值特征" class="headerlink" title="五、多取值特征"></a>五、多取值特征</h2><p>之前，我们的每一个特征都只能有两个取值，我们要将特征的取值推广到多个。这里采用的方法是将多取值特征转化为双取值特征。</p>
<p>解决方案是采用独热（one-hot）编码。举例来说，如果有一个特征 x，取值为1、2或3。那么我们可以将其转化为三个特征 is_x_equal1、is_x_equal2和is_x_equal3。这样，三个新的特征就可以只取 0、1 两个值了。</p>
<h2 id="六、连续取值特征"><a href="#六、连续取值特征" class="headerlink" title="六、连续取值特征"></a>六、连续取值特征</h2><p>对于连续取值的特征，我们要将其转化为离散特征。</p>
<p>具体来说，我们可以取一个阈值 n，将样本按该特征的值分为大于 n 和小于等于 n 的两个部分。为了方便选择，我们可以取样本的值进行分割，也就是分别取每一个样本中该特征对应的值作为划分时所用的值，计算其信息增益，最后选择使信息增益最大的值作为对该特征的划分即可。</p>
<h2 id="七、回归树——对连续取值结果的预测"><a href="#七、回归树——对连续取值结果的预测" class="headerlink" title="七、回归树——对连续取值结果的预测"></a>七、回归树——对连续取值结果的预测</h2><p>回归树是对决策树的进一步扩展。使得决策树模型可以学习结果为连续值的训练样本。</p>
<p>这样，原本的计算信息增益的方法就不再适用了。现在的数据不再有纯度的分别了，取而代之的是疏密的区别。这里我们采用样本结果的方差来衡量数据的离散程度。依旧设子集合元素数量占原集合的比重为 $w^{left}, w^{right}$，样本结果的方差则为 $var^{root}, var^{left}, var^{right}$</p>
<p>则增益的大小为</p>
<script type="math/tex; mode=display">
    \text{Gain} = var^{root} - (w^{left}var^{left} + w^{right}var^{right})</script><p>经过不断的递归构建，我们最终在叶节点处得到一组方差较小的样本。将这组样本的结果取平均，即得到叶节点对应的预测值。</p>
<h2 id="八、决策树林"><a href="#八、决策树林" class="headerlink" title="八、决策树林"></a>八、决策树林</h2><p>决策树的缺点之一是其可能对数据中的微小变化十分敏感，以至于稍有不同的数据就会产生截然不同的决策树结构。对于需要有比较大可靠性的预测，这是需要避免的。</p>
<p>解决方法是生成许多不同结构的决策树，通过这些决策树的预测结果表决或取平均，得到最终的预测结果。但确定的训练样本只会产生确定的决策树。因此这里采用随机化保证生成不同结构的决策树。</p>
<p>也就是说，对于大小为 m 的训练集，我们从中随机放回抽取 m 个样本，组成一个新的训练集，用该训练集生成一个决策树。重复这样的过程多次，就可以得到许多不同结构的决策树。</p>
<blockquote>
<p>还有一种名为 XGBoost 的方法。这样方法在选取样本组成新的训练集的过程中，会倾向于选择之前并未被选取的样本，这样组成的样本集合将更为一般化，从而使得学习效果更好。</p>
</blockquote>
<p>这样，我们就得到了能解决大部分机器学习问题的决策树算法。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://wokron.github.io/posts/5b526508/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="wokron">
      <meta itemprop="description" content="StringCat的个人博客。记录学习、分享经验">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="StringCat的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/posts/5b526508/" class="post-title-link" itemprop="url">机器学习之模型评估与优化</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-10-16 16:22:46" itemprop="dateCreated datePublished" datetime="2022-10-16T16:22:46+08:00">2022-10-16</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-06-26 10:38:38" itemprop="dateModified" datetime="2023-06-26T10:38:38+08:00">2023-06-26</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">学习笔记</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="一、引言"><a href="#一、引言" class="headerlink" title="一、引言"></a>一、引言</h2><p>对于一个训练好的模型，我们需要知道它是否能很好地适应现实应用。也就是说，我们希望得知该模型对于训练样本之外的数据，是否也能有较好的预测效果。</p>
<blockquote>
<p>模型的这种能力称为泛化能力</p>
</blockquote>
<p>这一问题本质上还是我们之前讨论过的拟合问题。只不过对于一个较为复杂的模型来说，常常不能将其拟合或分类的结果用图像直观表示。如果我们不能较为清晰地评估模型，那就无法进一步进行优化调整（如调整正则化系数、增加或减少特征、增加样本数量等）。因此我们需要方法，来一般化地评估模型的质量。</p>
<h2 id="二、泛化能力的衡量指标"><a href="#二、泛化能力的衡量指标" class="headerlink" title="二、泛化能力的衡量指标"></a>二、泛化能力的衡量指标</h2><p>正如前一节所说，泛化能力的衡量就是衡量模型对训练样本集之外的数据集的预测效果。我们知道衡量模型对训练样本预测效果的指标是损失函数，那么对于其他数据，我们同样可以把损失函数的概念迁移到这里来。</p>
<p>我们可以将已经获得的数据划分为两部分，一部分用于训练模型，称为训练集；另一部分用于测试模型的泛化能力，称为测试集。对于用训练集训练后的数据，我们再求该模型对测试集数据的损失函数。</p>
<p>举个例子，如果我们采用简单的平方误差损失函数，则我们就是要求</p>
<script type="math/tex; mode=display">
    J_{test}(\vec{w},b) = 
    \frac{1}{2m_{test}}\sum_{i=0}^{m_{test}-1} ( f_{\vec{w},b}(\vec{x}^{(i)}_{test}) - y^{(i)}_{test} )^2</script><p>$J_{test}(\vec{w},b)$ 就是我们对该模型泛化能力的衡量指标，称为测试误差。</p>
<p>我们可以将该指标与训练集的损失函数值 $J<em>{train}(\vec{w},b)$（注意这里没有正则项，称为训练误差）进行比较。一般的情况是 $J</em>{test}(\vec{w},b)$ 大于 $J_{train}(\vec{w},b)$。</p>
<p>我们还可以将该模型的泛化能力与其他模型的泛化能力，或者与人类的误差进行比较。这样我们就可以评价我们所训练的模型的优劣了。</p>
<h2 id="三、交叉验证集"><a href="#三、交叉验证集" class="headerlink" title="三、交叉验证集"></a>三、交叉验证集</h2><p>在我们继续评估模型之前，我们要先来考虑一些我们究竟要如何进行优化。你可能会想，我们既然有了评价模型泛化能力的指标 $J_{test}$，那么只要试图让该指标减小不就可以了吗？这是一个很直接的想法。</p>
<p>但问题是，如果我们向着使 $J_{test}$ 减小的目标优化，那么测试集与训练集有什么区别呢？按照这种方法，测试集就相当于变成了训练集的一部分，而不再能成为衡量训练集之外泛化能力的样本了。</p>
<p>因此，我们不能将训练集作为优化的方向，而只能将其作为评价的指标。我们需要再分出一部分数据，作为优化时的参考。这就是交叉验证（Cross-validation）集。对应的衡量指标为 $J_{cv}$</p>
<h2 id="四、模型评价"><a href="#四、模型评价" class="headerlink" title="四、模型评价"></a>四、模型评价</h2><p>我们用偏差和方差来评价一个模型。</p>
<ul>
<li>偏差表示模型对训练集的预测相对于真实情况的误差，如果模型对训练样本都不能很好地拟合或分类，就称其为高偏差的。 $J_{train}$ 可衡量模型的偏差。</li>
<li>方差表示模型对测试集的预测相对于真实情况的误差（也就是泛化能力本身），如果模型不能很好地预测测试集中数据，就称其为高方差的。$J_{cv}$ 可衡量模型的方差。</li>
</ul>
<blockquote>
<p>一般来说，模型的方差会大于偏差。因此高偏差的模型都是高方差的。</p>
<p>随着模型复杂度的提升，模型的偏差会逐渐降低，但偏差会先降低再升高；随着训练样本量的提升，偏差会逐渐减小，方差会逐渐升高，直到最后方差和偏差程度接近。</p>
</blockquote>
<h2 id="五、倾斜数据集的误差指标"><a href="#五、倾斜数据集的误差指标" class="headerlink" title="五、倾斜数据集的误差指标"></a>五、倾斜数据集的误差指标</h2><p>对于正面例子和负面例子比例差距较大的训练样本（也就是说，被标记为某一结果的样本数量占样本总数的比例很大或很小），根据全概率分布可知，可能就算全部预测同一结果，其正确的概率也很大。因此我们需要能消除样本本身概率分布导致的正确率偏差的指标。</p>
<p>有两种误差指标用于评价这种情况。分别为准确率（Precision）和召回率（Recall）。</p>
<ul>
<li>准确率衡量的是，模型预测为某一结果的情况中，有多少是预测正确的。</li>
<li>召回率衡量的是，对所有真正为某一结果的情况，有多少是模型预测到的。</li>
</ul>
<p>也就是说，设</p>
<ul>
<li>TP表示将正类预测为正类的数量</li>
<li>FN表示将正类预测为负类的数量</li>
<li>FP表示将负类预测为正类的数量</li>
<li>TN表示将负类预测为负类的数量</li>
</ul>
<p>则准确率为</p>
<script type="math/tex; mode=display">
    P = \frac{TP}{TP + FP}</script><p>召回率为</p>
<script type="math/tex; mode=display">
    R = \frac{TP}{TP + FN}</script><p>可以这样理解，把预测的过程当做选择的过程，准确率高就是“不重”，不过多的选择，以致把许多不属于的也包括在内；召回率高就是“不漏”，不过少地选择，把一些属于的漏掉了。</p>
<p>我们很容易就能得知，准确率和召回率在一定程度上是矛盾的。想要准确率高，就很可能漏掉一些；想要召回率高，就可能包含了不属于的东西。</p>
<blockquote>
<p>对于逻辑回归来说，提高阈值（即把多少数值以上的设定为真），准确率上升，召回率下降；降低阈值，准确率下降，召回率上升。</p>
</blockquote>
<p>要权衡准确率和召回率，对模型进行整体的评价的方法是采用 F1 分数（F1 Score）。即</p>
<script type="math/tex; mode=display">
    F1 = \frac{1}{\frac{1}{2}(\frac{1}{P} + \frac{1}{R})}</script><blockquote>
<p>相当于对准确率和召回率的调和平均</p>
</blockquote>
<h2 id="五、优化策略"><a href="#五、优化策略" class="headerlink" title="五、优化策略"></a>五、优化策略</h2><p>优化模型需要考虑不同的情况。</p>
<p>一种是模型具有高偏差的情况。<br>模型具有高偏差，常常意味着当前的模型复杂度不足以拟合当前数据。此时若一味地增加训练数据量，并不会使得拟合效果提高太多。应该做的是提高模型复杂度。如增加特征、增加层数、减小正则化系数等等。</p>
<p>另一种是模型具有高方差，且偏差较低的情况。<br>这种情况常常意味着模型对样本产生了过拟合。需要做的是降低拟合程度。采取如减少特征、增大正则化系数等手段。增加训练数据量在这种情况下可以起到效果。</p>
<p><strong>这里再介绍一些增加数据量的方法：</strong></p>
<p>除了通过各种手段获取新数据以外，我们还可以利用现有数据创造新数据。如对于图像，可以将其经过旋转、伸缩、扭曲等操作生成新的图像；又比如音频，可以增加背景音、噪声等来模拟更加真实的环境。这些手段都能增加模型的稳健性和泛用性。</p>
<p>迁移学习同样是一种利用数据的手段。该方法获得经过其他数据训练过的用于完成类似任务的模型，修改部分神经层（如输出层），再进行当前任务的训练。这样做相当于使用了其他任务中的数据。（这种方法可行的原因是，相似的任务，在位置靠前的部分常有类似的处理过程）</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://wokron.github.io/posts/76c44d63/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="wokron">
      <meta itemprop="description" content="StringCat的个人博客。记录学习、分享经验">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="StringCat的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/posts/76c44d63/" class="post-title-link" itemprop="url">机器学习之神经网络基础</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-10-14 19:25:16" itemprop="dateCreated datePublished" datetime="2022-10-14T19:25:16+08:00">2022-10-14</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-06-26 10:38:38" itemprop="dateModified" datetime="2023-06-26T10:38:38+08:00">2023-06-26</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">学习笔记</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="一、神经元模型"><a href="#一、神经元模型" class="headerlink" title="一、神经元模型"></a>一、神经元模型</h2><p>在研究人工智能的过程中，模拟生物的神经是一条很显然的道路。神经网络模型最初便是以模拟生物的神经网络为目的的。但是在早期算力不足的情况下，神经网络的效果并不怎么好。直到硬件基础成熟的最近一段时间，神经网络才发挥出超常的能力。</p>
<p>当然，此时经过改进、优化后的神经网络也在一定程度上偏离了最初模拟生物神经系统的初衷。当前的，以统计为基础的神经网络模型是否是实现强人工智能的有效方法也不得而知。但是我们还是有必要对神经网络模型，特别是作为神经网络的最小单元——神经元模型，做充分的介绍。因为事实证明了，这是一条有效的创造 AI 工具的途径。</p>
<p>单个神经元可以看做有多个输入 $x_j$，单个输出 $a$ 的函数。神经元模型具有如下属性：</p>
<ul>
<li>权重 $\vec{w}, b$</li>
<li>激发函数 $g(z)$</li>
</ul>
<p>所对应的函数为</p>
<script type="math/tex; mode=display">
    f_{\vec{w}, b, g(z)}(\vec{x}) = g(\vec{w} \cdot \vec{x} + b)</script><blockquote>
<p>取 $g(z) = \frac{1}{1 + e^{-z}}$, 与我们之前学习过的逻辑回归没有差别。</p>
</blockquote>
<p>通过对这样的神经元按一定规则进行组合，便可以构造用于完成某种功能的神经网络。</p>
<h2 id="二、神经网络层"><a href="#二、神经网络层" class="headerlink" title="二、神经网络层"></a>二、神经网络层</h2><p>对于一组输入，我们可以将其依次通过不同的神经元进行计算，计算的结果可以按顺序组成向量，作为一组新的输入。这种不断迭代的能力是神经网络的基础。我们称同一次计算使用的所有神经元为<strong>同一层</strong>的神经元。这些神经元组成了神经网络上的一<strong>层</strong>。不同层的组合构成了整个神经网络。</p>
<blockquote>
<p>注意，同一层的神经元需要满足输入个数相同、激发函数相同。</p>
</blockquote>
<p>从数学上讲，设输入为 $\vec{x} = (x_1, x_2, …, x_n)$，输出为 $\vec{a} = (a_1, a_2, …, a_m)$，神经元函数为 $f_1(\vec{x}), f_2(\vec{x}), … f_m(\vec{x})$ 则</p>
<script type="math/tex; mode=display">
    \vec{a} = (f_1(\vec{x}), f_2(\vec{x}), ... f_m(\vec{x}))</script><p>对于不同层上的属性或参数 x，我们加上上标 $x^{[i]}$ 表示该属性或参数属于第 i 层（第几层指示神经元计算的顺序）；对于同一层的不同神经元，加上下标 $x^{[i]}_j$ 表示第 i 层的第 j 个神经元的属性或参数。</p>
<p>则更一般的，假设第 i 层接受 n 个参数的输入，并具有 m 个神经元，则第 i 层上的运算可表示为：</p>
<script type="math/tex; mode=display">
        \left\{
        \begin{array}{lr}
            a^{[i]}_1 = g(\vec{w}^{[i]}_1 \cdot \vec{a}^{[i-1]} + b^{[i]}_1) \\
            a^{[i]}_2 = g(\vec{w}^{[i]}_2 \cdot \vec{a}^{[i-1]} + b^{[i]}_2) \\
            \vdots \\
            a^{[i]}_m = g(\vec{w}^{[i]}_m \cdot \vec{a}^{[i-1]} + b^{[i]}_m)
        \end{array}
    \right.</script><blockquote>
<p>$\vec{a}^{[0]}$ 表示神经网络的总输入</p>
</blockquote>
<h2 id="三、神经网络的矩阵表示"><a href="#三、神经网络的矩阵表示" class="headerlink" title="三、神经网络的矩阵表示"></a>三、神经网络的矩阵表示</h2><p>神经网络所以一种有效的机器学习方法，在于其清晰的结构和高效的计算方式。清晰的结构已经在上一部分有所说明，这里进一步阐述神经网络的矩阵表示形式。通过矩阵并行化计算，神经网络的运行速度将得到极大地提升。</p>
<p>对于单一神经元上的权重，我们可以将其表示成列向量的形式，即</p>
<script type="math/tex; mode=display">
    W^{[i]}_j = \begin{bmatrix}
        w_1 & w_2 & \cdots & w_n
    \end{bmatrix}^T</script><p>按照上一节中的公式，要进行点乘运算，则应该将输入表示为行向量的形式</p>
<script type="math/tex; mode=display">
    A^{[i-1]} = \begin{bmatrix}
        a_1 & a_2 & \cdots & a_n
    \end{bmatrix}</script><p>则 $\vec{w}^{[i]}_j \cdot \vec{a}^{[i-1]}$ 就可以转化为 $A^{[i-1]}W^{[i]}_j$。</p>
<p>之后，我们可以先忽略激发函数。只看激发函数内的一组线性表达式，将这组表达式的结果也按顺序表示为行向量</p>
<script type="math/tex; mode=display">
    Z^{[i]} = \begin{bmatrix}
        z^{[i]}_1 & z^{[i]}_2 & \cdots & z^{[i]}_m
    \end{bmatrix}</script><p>把 b 的部分提出单独作为一个向量，记</p>
<script type="math/tex; mode=display">
    B^{[i]} = \begin{bmatrix}
        b_1 & b_2 & \cdots & b_m
    \end{bmatrix}</script><p>则</p>
<script type="math/tex; mode=display">
    Z^{[i]} = \begin{bmatrix}
        A^{[i-1]}W^{[i]}_1 & A^{[i-1]}W^{[i]}_2 & \cdots & A^{[i-1]}W^{[i]}_m
    \end{bmatrix} + B^{[i]}</script><p>再将输入 $A^{[i-1]}$ 提出来</p>
<script type="math/tex; mode=display">
    Z^{[i]} = A^{[i-1]} \begin{bmatrix}
        W^{[i]}_1 & W^{[i]}_2 & \cdots & W^{[i]}_m
    \end{bmatrix} + B^{[i]}</script><p>此时各个神经元的权重组合成了一个新的矩阵，记</p>
<script type="math/tex; mode=display">
    W^{[i]} = \begin{bmatrix}
        W^{[i]}_1 & W^{[i]}_2 & \cdots & W^{[i]}_m
    \end{bmatrix}_{n \times m}</script><blockquote>
<p>可以认为，神经网络的层的本质就是矩阵 $W^{[i]}$ 和向量 $B^{[i]}$</p>
</blockquote>
<p>此时如果我们认为函数 $g(Z)$ 表示对矩阵中的每一个元素应用激活函数 $g(z)$ ，则整个神经网络层就可以表示为</p>
<script type="math/tex; mode=display">
    A^{[i]} = g(A^{[i-1]} W^{[i]} + B^{[i]})</script><p>这不只是形式上的化简。利用 numpy 等数学库，可以极大加快运算的速度。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://wokron.github.io/posts/757349f6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="wokron">
      <meta itemprop="description" content="StringCat的个人博客。记录学习、分享经验">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="StringCat的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/posts/757349f6/" class="post-title-link" itemprop="url">系统编程之shell编程</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-10-08 19:30:58" itemprop="dateCreated datePublished" datetime="2022-10-08T19:30:58+08:00">2022-10-08</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-06-26 10:38:38" itemprop="dateModified" datetime="2023-06-26T10:38:38+08:00">2023-06-26</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">学习笔记</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h2><p>本文将简单探索shell脚本编程，介绍shell的基本语法。</p>
<h2 id="二、shell简介"><a href="#二、shell简介" class="headerlink" title="二、shell简介"></a>二、shell简介</h2><p>shell是一个命令解释器，可以用来启动、停止、编写程序；是用户和UNIX/Linux操作系统内核程序间的一个接口。</p>
<p>而shell编程则是将linux命令与shell的各种流程控制和条件判断来组合成命令与变量，形成可以进行自动处理的脚本程序。</p>
<h2 id="三、前期准备"><a href="#三、前期准备" class="headerlink" title="三、前期准备"></a>三、前期准备</h2><h3 id="创建脚本"><a href="#创建脚本" class="headerlink" title="创建脚本"></a>创建脚本</h3><p>shell脚本是一个文本文件，可用文本编辑器如vi、vim编辑保存。创建shell脚本只需按照创建文本文件的方式创建。如<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vi c1.sh</span><br><span class="line">vim c2.sh</span><br><span class="line">&gt; c3.sh</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>shell脚本一般以<code>.sh</code>为后缀，但没有后缀依旧可以执行。</p>
</blockquote>
<p>创建的shell脚本，一定要在开头第一行加上如下语句：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br></pre></td></tr></table></figure><br>这一行将指明该脚本执行所需要的命令解释器。</p>
<h3 id="执行脚本"><a href="#执行脚本" class="headerlink" title="执行脚本"></a>执行脚本</h3><p>shell脚本的执行方法有<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sh &lt;scriptname&gt;</span><br><span class="line">bash &lt;scriptname&gt;</span><br></pre></td></tr></table></figure><br>或者使用chmod命令修改脚本为可执行，再直接使用 <code>./&lt;scriptname&gt;</code> 运行。</p>
<h2 id="四、基本语法"><a href="#四、基本语法" class="headerlink" title="四、基本语法"></a>四、基本语法</h2><h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><p>shell中的变量分为环境变量、用户定义变量、内部变量。</p>
<p>其中环境变量是操作系统的一部分，但可以利用shell脚本进行修改；用户变量即在脚本中声明的变量；而内部变量则用来指示脚本运行中出现的一些变量。</p>
<h4 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h4><p>只有用户变量可以声明。和其他语言一样，使用等号进行声明。但要注意的是，shell脚本是弱类型的，因此变量名前不需要加上类型名。<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var=hello_world</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>注意shell对空格敏感，声明时等号两边不能有空格</p>
</blockquote>
<p>另外可以在变量名前添加 <code>readonly</code>关键字设为只读<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">readonly constVar</span><br></pre></td></tr></table></figure></p>
<p>shell中声明数组同样直接写出数组名称<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">arr[0]=1</span><br><span class="line">arr[1]=5</span><br><span class="line">arr[10]=20</span><br></pre></td></tr></table></figure><br>未赋值的部分默认为NULL。</p>
<blockquote>
<p>注意 ubuntu 默认使用 dash 而非 bash shell。dash 并不支持数组。要使用数组可以用bash运行脚本，即运行命令 <code>bash &lt;scriptname&gt;</code></p>
</blockquote>
<h4 id="赋值"><a href="#赋值" class="headerlink" title="赋值"></a>赋值</h4><p>shell变量有类似左值右值的区别。在用其他变量进行赋值时，需要对变量使用<code>$&#123; &#125;</code> 进行取值。<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var1=hi</span><br><span class="line">var2=$&#123;var1&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="引号"><a href="#引号" class="headerlink" title="引号"></a>引号</h4><p>shell脚本是为了自动化处理命令而设计的。因此语法中有很大一部分关注于字符串和命令的相关操作。在变量上体现在，shell中所有变量默认以字符串形式存在。</p>
<p>并且，为了满足命令处理的需要，shell设计出了引号变量值。</p>
<p>shell中的引号包括单引号、双引号和倒引号。</p>
<p><strong>单引号</strong>中的字符均作为普通字符出现。（可以包括空格）<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var1=hello_world</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">var2=hello world <span class="comment"># 不合法</span></span></span><br><span class="line">var3=&#x27;hello world&#x27;</span><br></pre></td></tr></table></figure></p>
<p><strong>双引号</strong>中的字符大部分作为普通字符对待。除了<code>$\’</code>和双引号，这些变量依旧用于对字符串内容进行变量替换。<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var4=hello</span><br><span class="line">var5=friend</span><br><span class="line">var6=&quot;$var4, my $var5!&quot;</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">var6 means <span class="string">&quot;hello, my friend!&quot;</span>.</span></span><br></pre></td></tr></table></figure></p>
<p><strong>倒引号</strong>将引号内的内容当做命令，会先执行倒引号内的内容，再用执行后的输出替换倒引号的内容。</p>
<blockquote>
<p>倒引号可以和双引号组合使用，在双引号内使用倒引号<br>$(command) 与 `command` 功能相同</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var7=&quot;now pwd: `pwd`&quot;</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">var6 means <span class="string">&quot;now pwd: /home/username&quot;</span> (depend on the position <span class="built_in">where</span> you execute the script)</span></span><br></pre></td></tr></table></figure>
<h3 id="基础操作"><a href="#基础操作" class="headerlink" title="基础操作"></a>基础操作</h3><h4 id="字符串操作"><a href="#字符串操作" class="headerlink" title="字符串操作"></a>字符串操作</h4><p>shell脚本自身具有一些字符串操作功能。</p>
<ul>
<li>字符串长度：<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$</span><span class="language-bash">&#123;<span class="comment">#str&#125;</span></span></span><br></pre></td></tr></table></figure></li>
<li>字符串截取：<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$</span><span class="language-bash">&#123;str:position&#125;</span></span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">&#123;str:start:length&#125;</span></span><br></pre></td></tr></table></figure></li>
<li>从字符串开头删除：<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$</span><span class="language-bash">&#123;str<span class="comment">#substr&#125;</span></span></span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">&#123;str<span class="comment">##substr&#125;</span></span></span><br></pre></td></tr></table></figure></li>
<li>从字符串末尾删除：<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$</span><span class="language-bash">&#123;str%substr&#125;</span></span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">&#123;str%%substr&#125;</span></span><br></pre></td></tr></table></figure></li>
<li>字符串替换：<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$</span><span class="language-bash">&#123;str/substr/replace&#125;</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<blockquote>
<p>字符串操作中出现匹配的部分都支持正则表达式。其中一个字符的为懒惰匹配，两个字符的为贪婪匹配。</p>
<p>使用 <code>expr</code> 等命令，可以更好地进行处理。</p>
</blockquote>
<h4 id="数字运算"><a href="#数字运算" class="headerlink" title="数字运算"></a>数字运算</h4><p>shell默认变量为字符串，因此若要进行数字运算，需要特殊指明。</p>
<p>具体地，有两种方法。一种是利用 <code>$(())</code> 运算符。指明括号内的表达式进行的不是字符串操作而是数字运算。<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">num1=10</span><br><span class="line">num2=20</span><br><span class="line">num3=$(($num1+$num2)) # 30</span><br></pre></td></tr></table></figure></p>
<p>另一种方法是调用 linux 的 expr 命令。<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">num4=3</span><br><span class="line">num5=$num4</span><br><span class="line">num6=`expr $num4 \* $num5` # 9</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>注意乘号在shell脚本中有特殊含义，因此需要加入反斜杠转义。另外 expr 命令中变量和运算符各自作为参数，因此中间需要用空格隔开.</p>
</blockquote>
<h3 id="流程控制"><a href="#流程控制" class="headerlink" title="流程控制"></a>流程控制</h3><h4 id="条件表达式"><a href="#条件表达式" class="headerlink" title="条件表达式"></a>条件表达式</h4><p>shell 利用 <code>test condition</code> 和 <code>[condition]</code> 进行条件测试。其中“condition” 表示一个条件表达式。包括字符比较、数值比较、文件操作、逻辑操作。</p>
<p>这一部分原理较为简单，但shell中判断符号与其他语言有较大差别，内容较多，就不一一列举了。</p>
<blockquote>
<p>注意使用条件表达式时，表达式与方括号间要有空格隔开</p>
</blockquote>
<h4 id="分支控制"><a href="#分支控制" class="headerlink" title="分支控制"></a>分支控制</h4><p>分支控制语句如下</p>
<p>if 分支：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">if [ condition ]</span><br><span class="line">then</span><br><span class="line">    commands</span><br><span class="line">elif</span><br><span class="line">    commands</span><br><span class="line">else</span><br><span class="line">    commands</span><br><span class="line">fi</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>注意末尾的 fi</p>
</blockquote>
<p>case分支（类似switch）：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">case variable in</span><br><span class="line">var1)</span><br><span class="line">    commands</span><br><span class="line">    ;;</span><br><span class="line">var2 | var3)</span><br><span class="line">    commands</span><br><span class="line">    ;;</span><br><span class="line">*)</span><br><span class="line">    commands</span><br><span class="line">esac</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>注意两个连续的分号，类似于 break。进入同样分支的变量值要用 “|” 隔开。末尾要添加 esac。</p>
</blockquote>
<h4 id="循环控制"><a href="#循环控制" class="headerlink" title="循环控制"></a>循环控制</h4><p>循环控制语句如下</p>
<p>while 循环：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">while [ condition ]</span><br><span class="line">do</span><br><span class="line">    commands</span><br><span class="line">done</span><br></pre></td></tr></table></figure></p>
<p>until 循环：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">until [ condition ]</span><br><span class="line">do</span><br><span class="line">    commands</span><br><span class="line">done</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>until 循环与条件取反的 while 循环等价</p>
</blockquote>
<p>for 循环如下：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">for arg in args</span><br><span class="line">do</span><br><span class="line">    commands</span><br><span class="line">done</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>其中 args 是一组列出的变量名或字符串</p>
</blockquote>
<h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><h4 id="函数的定义"><a href="#函数的定义" class="headerlink" title="函数的定义"></a>函数的定义</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function func_name&#123;</span><br><span class="line">    commands</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func_name()&#123;</span><br><span class="line">    commands</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>两种方式均可定义函数。</p>
<h4 id="参数取值"><a href="#参数取值" class="headerlink" title="参数取值"></a>参数取值</h4><p>shell中的函数只有可变参数。另外，整个shell脚本本身也可以看做一个函数，它同样也只有可变参数。都具有相同的取参数的方式。</p>
<p>shell中通过 <code>$0 $1 $2 ... $9</code>等参数来获取函数对应位置的参数。其中 <code>$0</code> 最开始为函数名/脚本名。当参数多于 10 个时，要获取十个之外的参数，可以使用 <code>shift</code> 命令，使得除了函数名/脚本名 $0 之外的所有参数整体左移一位。<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">sh &lt;scriptname&gt;.sh 123 456</span></span><br><span class="line">echo $1 # 123</span><br><span class="line">shift</span><br><span class="line">echo $1 # 456</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p><code>echo</code> 为输出命令</p>
</blockquote>
<h4 id="函数返回值"><a href="#函数返回值" class="headerlink" title="函数返回值"></a>函数返回值</h4><p>函数通过 <code>return [n]</code> 语句来返回变量值 n。如果没有设置返回值，那么会默认返回函数最后一条命令执行后的返回值。</p>
<p>在函数调用之后，可以使用 <code>$?</code> 获取函数的返回值。</p>
<blockquote>
<p>注意 return 的值必须只能是 0~255间的整数。要返回字符串或者更大的数字，可以直接使用 <code>echo</code> 输出内容，再通过倒引号获取输出的内容。</p>
</blockquote>
<h4 id="函数实例"><a href="#函数实例" class="headerlink" title="函数实例"></a>函数实例</h4><p>编写一个递归计算阶乘的函数<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">frac()</span><br><span class="line">&#123;</span><br><span class="line">    if [ $(($1)) -ge 1 ]</span><br><span class="line">    then</span><br><span class="line">        echo $((`frac $(($1-1))`*$1))</span><br><span class="line">    else</span><br><span class="line">        echo 1</span><br><span class="line">    fi</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">echo `frac 5` # 120</span><br></pre></td></tr></table></figure></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://wokron.github.io/posts/6d380668/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="wokron">
      <meta itemprop="description" content="StringCat的个人博客。记录学习、分享经验">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="StringCat的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/posts/6d380668/" class="post-title-link" itemprop="url">机器学习笔记之正则化</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-10-08 19:27:57" itemprop="dateCreated datePublished" datetime="2022-10-08T19:27:57+08:00">2022-10-08</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-06-26 10:38:38" itemprop="dateModified" datetime="2023-06-26T10:38:38+08:00">2023-06-26</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">学习笔记</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="一、前言——过拟合"><a href="#一、前言——过拟合" class="headerlink" title="一、前言——过拟合"></a>一、前言——过拟合</h2><p>我们知道，经过一组点可以有无数条曲线。这些曲线对于这组样本点的损失函数同为 0。但是对于预测来说，这些曲线产生的结果却并不相同。这就意味着，进行梯度下降到达某一最低点时，依旧不一定能得到“最好的”预测（拟合/分类）效果。甚至可能对于一些情况，此时的（预测/分类）效果反而更差了。这样的情况就称为过拟合。</p>
<p>过拟合的存在是很合理的。从感性上讲，将机器学习的过程类比人类的认知，一个观念的形成不能超出经验之外，认知的结果永远是片面而非客观的。那么在与更广泛的客观现实接触之前，我们必然无法得知已经形成的认知是否是依旧可以应用的。</p>
<p>这是一个很休谟的观点。但却无法解决现实问题。我们依旧需要找到减少过拟合的方法。</p>
<h2 id="二、惩罚"><a href="#二、惩罚" class="headerlink" title="二、惩罚"></a>二、惩罚</h2><p>我们的思想中存在着一种先验观念，它规范天地万物，在冥冥中告诉我们什么是“合理的”。对于机器学习模型来说也是一样的，它应当具有这样的机制，告诉它什么情况是不可能的。</p>
<p>就比如说，对于房价，我们知道一些特征是更加重要的，而另一些是更加不重要的。很显然，那些更重要的特征对应的权重应该较不重要的特征对应的权重大。那么我们就需要对那些不重要的权重进行“惩罚”，以避免这些权重过大，从而导致模型过拟合。这样的“惩罚”在损失函数中体现。即，当这些权重过大时，损失函数也会相应增大。</p>
<p>具体而言，对如下的表达式</p>
<script type="math/tex; mode=display">
    y = w_1x_1 + w_2x_2 + w_3x_3 + b</script><p>假设要使第二、三个权重相对较小，则可以在损失函数中加上惩罚项 $\lambda_2 w_2 + \lambda_3 w_3$。其中 $\lambda_2, \lambda_3$ 取较大值。则损失函数变为</p>
<script type="math/tex; mode=display">
    J_{new}(\vec{w}, b) = J(\vec{w}, b) + \lambda_2 w_2 + \lambda_3 w_3</script><p>具体地比如说</p>
<script type="math/tex; mode=display">
    J_{new}(\vec{w}, b) = J(\vec{w}, b) + 1000 w_2 + 2000 w_3</script><p>那么此时很显然，当 $w_2, w_3$ 较大时，损失函数也会相应更大。</p>
<p>可是对于大多数情况，我们无法事先知晓权重的重要程度。对于这些一般化的问题，还需要有一般化的解决办法。</p>
<h2 id="三、正则化"><a href="#三、正则化" class="headerlink" title="三、正则化"></a>三、正则化</h2><p>正则化是惩罚的一种。该方法在损失函数中增加了正则项：</p>
<script type="math/tex; mode=display">
    \frac{\lambda}{2m} \sum_{j=1}^n w^2_j</script><p>其中 $\lambda$ 称为正则化参数。</p>
<p>则新的损失函数为</p>
<script type="math/tex; mode=display">
    J_{new}(\vec{w}, b) = J(\vec{w}, b) + \frac{\lambda}{2m} \sum_{j=1}^n w^2_j</script><p>这里有几个值得解释的地方：</p>
<h3 id="惩罚所有权重"><a href="#惩罚所有权重" class="headerlink" title="惩罚所有权重"></a>惩罚所有权重</h3><p>第一是<strong>对所有权重的惩罚</strong>。如果按照上一节的解释，很容易认为，正则化等同于对所有权重的相同比例的惩罚。这是否相当于对所有权重都不惩罚呢？若是如此，那么正则化是否还有意义？</p>
<p>关键在于正则项的 $w^2_j$ 上。这是权重的平方而非权重本身。我们对损失函数求 $w_j$ 的偏导。</p>
<script type="math/tex; mode=display">
    \frac{\partial{J_{new}(\vec{w}, b)}}{\partial{w_j}}
    = \frac{\partial{J(\vec{w}, b)}}{\partial{w_j}}
    + \frac{\lambda}{m} w_j</script><p>我们可以得到两个结论。<br>首先，正则项永远使权重不断趋于0。即便在到达或接近原损失函数最小值时，$\frac{\partial{J(\vec{w}, b)}}{\partial{w_j}} \approx 0$，但此时正则项依旧会发挥作用。这就使得权重无法安定在拟合效果最好的位置。</p>
<p>并且，权重（绝对值）更大的特征，其权重值趋近于 0 的“速度”要快于权重更小的特征。这就避免了对所有权重同一的惩罚。</p>
<p>由此我们也可以看出正则项“眼中”最好的权重是什么样子的。那就是所有权重均为 0。当然，通过合理选择学习率 $\alpha$ 和正则化参数 $\lambda$，是不可能让这种情况发生的。但正则项却可以实实在在地提供一种“拉力”，用来纠正过于“复杂”的模型结构，使得拟合得到的超平面倾向于平缓。</p>
<h3 id="除-m-缩放"><a href="#除-m-缩放" class="headerlink" title="除 m 缩放"></a>除 m 缩放</h3><p>第二需要解释的是<strong>正则项中的除 m 缩放</strong>。这样做的目的是保证同一正则化参数在不同的样本数量下都有效。</p>
<p>我们以正则化了的多元线性回归损失函数对 $w_j$ 偏导为例。</p>
<script type="math/tex; mode=display">
    \frac{\partial{J(\vec{w}, b)}}{\partial{w_j}}
    = \frac{1}{m}\sum_{i=1}^{m}(\vec{w}\cdot\vec{x}^{(i)} + b - y^{(i)})x^{(i)}_j
    + \frac{\lambda}{m} w_j</script><p>假设正则项并不除以 m，或者按照感觉，除以 n。那么在学习率和正则化参数不变的情况下，随着样本量的增加，梯度下降时正则化对权重的影响保持不变；可原损失函数却因为除以了m，对权重的影响减小。这样就会影响正则化参数在不同样本量时的有效性。</p>
<p>因此对正则项也采取除 m。这样在样本量增加时，原损失函数和正则项对权重的影响就是同比例减小的了。</p>
<h2 id="四、代码实现"><a href="#四、代码实现" class="headerlink" title="四、代码实现"></a>四、代码实现</h2><p>这一部分很简单，就不具体写出来了。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://wokron.github.io/posts/ba0d6023/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="wokron">
      <meta itemprop="description" content="StringCat的个人博客。记录学习、分享经验">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="StringCat的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/posts/ba0d6023/" class="post-title-link" itemprop="url">机器学习笔记之逻辑回归</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-10-05 16:06:34" itemprop="dateCreated datePublished" datetime="2022-10-05T16:06:34+08:00">2022-10-05</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-06-26 10:38:38" itemprop="dateModified" datetime="2023-06-26T10:38:38+08:00">2023-06-26</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">学习笔记</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="一、前言——逻辑分类"><a href="#一、前言——逻辑分类" class="headerlink" title="一、前言——逻辑分类"></a>一、前言——逻辑分类</h2><p>机器学习研究的另一种问题为分类问题。给出一些信息，判断是或不是某种物体、属性。比如说给出病人的各项检测指标，判断其是否患病。</p>
<p>对于是、否的判断，这里用 1、0 表示。则训练样本就与之前的线性与多项式回归样本类似。</p>
<p>我们可以试着用一元线性回归来拟合分类问题的样本。</p>
<p>比如对于如下的样本数据<br><img src="/posts/ba0d6023/scatter1.png" class="" title="scatter1"></p>
<p>进行一元线性回归后得到<br><img src="/posts/ba0d6023/linear1.png" class="" title="linear1"></p>
<p>我们将数值大于 0.5 的部分看做预测为真，小于 0.5 的部分看做预测为假。可以看到，此时一元线性回归就已经可以使所有样本点符合判断结果了。</p>
<p>但如果我们在 x 值更大的区域增加更多的样本点，再进行回归<br><img src="/posts/ba0d6023/linear2.png" class="" title="linear2"></p>
<p>可以看到，有一部分应为 1 的点被分在了 y &lt; 0.5 的部分，被预测为 0。这说明只凭线性回归无法解决分类问题。我们需要另一种回归方法。</p>
<h2 id="二、逻辑回归"><a href="#二、逻辑回归" class="headerlink" title="二、逻辑回归"></a>二、逻辑回归</h2><p>线性回归失效的原因在于，拟合的目标是对所有点的方差最小，在分类边界上的样本可能因为其他样本的影响而被分到另一类。而为什么会受到其他样本的影响呢？因为线性回归得到的表达式值域趋向于无穷；而样本的结果却只有 0、1。所以对于一个样本，只要它的特征数值足够大或足够小，就足以产生极大的损失。（为什么可能出现足够远的样本？因为分类问题需要划分出一个边界，在边界两侧可能存在足够大的范围。）</p>
<p>我们要对线性回归进行修改，需要将回归得到的表达式的值域缩小到 0 至 1 的范围。</p>
<p>这里引入 Sigmoid 函数</p>
<script type="math/tex; mode=display">
    S(z) = \frac{1}{1 + e^{-z}}</script><p>它的图像如下<br><img src="/posts/ba0d6023/sigmoid.png" class="" title="sigmoid"></p>
<p>该函数定义域为 $(-\infty, +\infty)$，值域为 $(0, 1)$</p>
<p>假设原本线性回归的函数为</p>
<script type="math/tex; mode=display">
    f_{\vec{w}, b}(\vec{x}) = \vec{w} \cdot \vec{x} + b</script><p>则现在令</p>
<script type="math/tex; mode=display">
    f_{\vec{w}, b}(\vec{x}) = S(\vec{w} \cdot \vec{x} + b)</script><p>即</p>
<script type="math/tex; mode=display">
    f_{\vec{w}, b}(\vec{x}) = \frac{1}{1 + e^{\vec{w} \cdot \vec{x} + b}}</script><p>为新的函数。其中 $S(z)$ 即为 Sigmoid 函数。这样，表达式的值域就缩小为了 $(0, 1)$，从而消除了值域对损失的影响。</p>
<h2 id="三、损失函数"><a href="#三、损失函数" class="headerlink" title="三、损失函数"></a>三、损失函数</h2><p>如果我们依旧采用线性回归时的损失函数计算方式，就会发现函数非凸，那么梯度下降法将不能得到很好的结果。因此我们重新定义损失函数。</p>
<p>设单样本损失函数</p>
<script type="math/tex; mode=display">
    loss(f_{\vec{w},b}(\vec{x}^{(i)}), y^{(i)}) = \begin{cases}
        -log(f_{\vec{w},b}(\vec{x}^{(i)}))  &  \text{if } y^{(i)} = 1 \\
        -log(1 - f_{\vec{w},b}(\vec{x}^{(i)})) & \text{if } y^{(i)} = 0
    \end{cases}</script><p>这个损失函数保证了在样本真实结果为真或为假的条件下都能以同样的标准衡量预测的误差。</p>
<p>另外，因为 $y^{(i)}$ 的取值只有 0、1。所以可以将上式化简为单个公式的形式</p>
<script type="math/tex; mode=display">
    loss(f_{\vec{w},b}(\vec{x}^{(i)}), y^{(i)}) = 
    -y^{(i)}log(f_{\vec{w},b}(\vec{x}^{(i)})) - (1 - y^{(i)})log(1 - f_{\vec{w},b}(\vec{x}^{(i)}))</script><p>则全样本代价函数</p>
<script type="math/tex; mode=display">
    J(\vec{w}, b) = \frac{1}{m} \sum_{i = 1}^m loss(f_{\vec{w},b}(\vec{x}^{(i)}), y^{(i)})</script><h2 id="四、梯度下降"><a href="#四、梯度下降" class="headerlink" title="四、梯度下降"></a>四、梯度下降</h2><p>我们对损失函数求导，得</p>
<script type="math/tex; mode=display">
    \frac{\partial{J(\vec{w}, b)}}{\partial{w_j}}
    = \frac{1}{m}\sum_{i=1}^m (f_{\vec{w},b}(\vec{x}^{(i)}) - y^{(i)}) x^{(i)}_j \\
    \frac{\partial{J(\vec{w}, b)}}{\partial{b}}
    = \frac{1}{m}\sum_{i=1}^m (f_{\vec{w},b}(\vec{x}^{(i)}) - y^{(i)})</script><p>可以发现求导后的公式形式与线性回归时的相同，这是有意为之的。但是要注意的是， $f_{\vec{w},b}(\vec{x}^{(i)})$ 在线性回归与逻辑回归时并不相同。逻辑回归时的表达式是线性回归时的加上 Sigmoid 函数。</p>
<p>按照与线性回归相同的方法，以确定的步长 $\alpha$ 进行梯度下降，不断迭代</p>
<script type="math/tex; mode=display">
    w_j = w_j - \alpha \frac{\partial{J(\vec{w}, b)}}{\partial{w_j}} \\
    b = b - \alpha \frac{\partial{J(\vec{w}, b)}}{\partial{b}}</script><p>最终便可找到使损失函数最小的 $\vec{w}, b$。</p>
<h2 id="五、代码实现"><a href="#五、代码实现" class="headerlink" title="五、代码实现"></a>五、代码实现</h2><p>在线性回归的基础上，修改损失函数的计算<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">sigmoid</span>(<span class="params">x</span>):</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span> / (<span class="number">1</span> + np.exp(-x))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_loss</span>(<span class="params">actual_y, y</span>):</span><br><span class="line">    <span class="keyword">return</span> -y * math.log(actual_y) - (<span class="number">1</span> - y) * math.log(<span class="number">1</span> - actual_y)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_cost</span>(<span class="params">w, b, X, y</span>):</span><br><span class="line">    m = X.shape[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">    sum_cost = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(m):</span><br><span class="line">        z = np.dot(X[i], w) + b</span><br><span class="line">        actual_y = sigmoid(z)</span><br><span class="line">        sum_cost += get_loss(actual_y, y[i])</span><br><span class="line">    total_cost = sum_cost / m</span><br><span class="line">    <span class="keyword">return</span> total_cost</span><br></pre></td></tr></table></figure></p>
<p>修改梯度的计算<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">get_gradient</span>(<span class="params">w, b, X, y</span>):</span><br><span class="line">    m, n = X.shape</span><br><span class="line"></span><br><span class="line">    sum_w = np.zeros((n, ))</span><br><span class="line">    sum_b = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(m):</span><br><span class="line">        err = sigmoid(np.dot(w, X[i]) + b) - y[i]</span><br><span class="line">        sum_b += err</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            sum_w[j] += X[i,j] * err</span><br><span class="line"></span><br><span class="line">    gradients_w = sum_w / m</span><br><span class="line">    gradient_b = sum_b / m</span><br><span class="line">    <span class="keyword">return</span> gradients_w, gradient_b</span><br></pre></td></tr></table></figure></p>
<p>拟合结果<br><img src="/posts/ba0d6023/logical.png" class="" title="logical"></p>
<p>损失函数<br><img src="/posts/ba0d6023/cost.png" class="" title="cost"></p>
<p>对样本的预测<br><img src="/posts/ba0d6023/predict.png" class="" title="predict"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/4/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/4/">4</a><span class="page-number current">5</span><a class="page-number" href="/page/6/">6</a><a class="page-number" href="/page/7/">7</a><a class="extend next" rel="next" href="/page/6/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="wokron"
      src="/images/avatar.jpg">
  <p class="site-author-name" itemprop="name">wokron</p>
  <div class="site-description" itemprop="description">StringCat的个人博客。记录学习、分享经验</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">65</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">8</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">67</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/wokron" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;wokron" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="/stringcatwok@gmail.com" title="E-Mail → stringcatwok@gmail.com"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>
  <div class="cc-license motion-element" itemprop="license">
    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/zh-CN" class="cc-opacity" rel="noopener" target="_blank"><img src="/images/cc-by-nc-sa.svg" alt="Creative Commons"></a>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">wokron</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item-icon">
      <i class="fa fa-fa fa-user"></i>
    </span>
    <span class="site-uv" title="总访客量">
      总访问人数：<span id="busuanzi_value_site_uv"></span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-fa fa-eye"></i>
    </span>
    <span class="site-pv" title="总访问量">
      总阅读次数：<span id="busuanzi_value_site_pv"></span>
    </span>
</div>







      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  
      

<script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      loader: {
        source: {
          '[tex]/amsCd': '[tex]/amscd',
          '[tex]/AMScd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = '//cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }
</script>

    

  

<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"log":false,"model":{"jsonPath":"/live2dw/assets/hijiki.model.json"},"display":{"position":"right","width":150,"height":300},"mobile":{"show":true}});</script></body>
</html>
