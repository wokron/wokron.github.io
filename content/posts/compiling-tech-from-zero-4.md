+++
title = "从零开始的编译原理（4）：语法分析与下推自动机"
tags = ["下推自动机", "数学", "文法理论"]
categories = ["编译"]
series = ["从零开始的编译原理"]
date = 2024-02-15T14:14:06+08:00
draft = true
+++
## 一、前言
> 从这个精神王国的圣餐杯里，
>
> 他的无限性给他翻涌起泡沫。
>
> —— 格奥尔格·威廉·弗里德里希·黑格尔《精神现象学》下卷 第八章 绝对知识

<!-- more -->

## 二、从正则文法到上下文无关文法
词法分析阶段，我们可以使用正则文法描述词的定义，这是因为词的结构是**无嵌套的**。也就是说，词只会由例如前缀、后缀以及结构的顺序重复等概念描述，不可能出现需要**前后匹配**的地方。举个例子，正则文法不能定义形如 $12344321$ 的回文数；或形如 $(()(()))$ 的括号结构。

然而，所有的高级语言却都是**嵌套的**。通过嵌套，高级语言能够表示更加复杂的结构，实现控制流、子程序、作用域、类等等高级概念。因此，正则文法并不能描述高级语言的语法，我们需要使用 2 型文法，也即上下文无关文法描述高级语言。2 型文法区别于 3 型文法就在于其**嵌套性**。

举个例子，我们可以将上述括号结构用如下 2 型文法定义：
$$
    S \rightarrow (S)S | \epsilon
$$

其中规则 $S \rightarrow S(S)$ 中左括号和右括号**同时出现**，这样就保证了对于一个左括号，必定有一个右括号与其匹配。因而我们说上面的文法具有嵌套性。

而 3 型文法则不同。由于左线性和右线性的约束，3 型文法中不可能出现一条规则中右侧有多个终结符的情况。

不过虽然 2 型文法相较于 3 型文法具有更强的表达能力，但是这也为其解析提供了一定的困难。我们可以选择用前面定义的文法给出 $(()(()))$ 的文法树：

![syntax-tree](syntax-tree.png)

可以看出，相较于 3 型文法的文法树，2 型文法的文法树更像是树：并不是只向一侧增长，而是在任意地方都可能产生子树。因此，2 型文法的推导或归约过程不再能看作状态的转移，我们需要用有穷自动机之外的另一种模型描述，该模型应当具有接受嵌套结构的能力。这就是**下推自动机**。

## 三、下推自动机
### （1）例子：判断有效括号问题
初学编程的时候各位应该都做过类似的题目，那就是[判断有效括号](https://leetcode.com/problems/valid-parentheses/description/)。实际上这是一个编译问题。我们可以使用编译理论的语言将该问题表述为：对于符号集 $\Sigma = \{`(`, `)`, `[`, `]`, `\{`, `\}`\}$，对给定的括号文法 $G$，对于任意 $s \in \Sigma^*$，给出一个算法，判断是否有 $s \in L(G)$（即 $s$ 是否被文法 $G$ 接受）。

很明显，括号文法 $G$ 是 2 型文法，而我们又是如何解决这一问题的呢？由于左括号一定要与右括号匹配，因此我们要做的就是记录左括号的**嵌套状态**，并在读入右括号时尝试与其匹配。又由于嵌套具有**后进先出**的特点，所以我们会使用**栈**结构记录嵌套状态。具体的实现如下：

```py
def is_valid(s: str):
    match_cases = {'(': ')', '[': ']', '{':'}'}

    def is_match(left: str, right: str):
        return match_cases[left] == right

    stack = []
    for ch in s:
        if ch in match_cases.keys():
            stack.append(ch)
        else:
            if len(stack) == 0 or not is_match(stack.pop(), ch):
                return False
    return len(stack) == 0
```

从具体到一般，栈结构是处理嵌套的普遍方法。因而从 3 型文法到 2 型文法，我们需要做的就是在有穷自动机之外增加一个堆栈结构，使其能够存取当前状态之外的其他信息。这样得到的自动机称为**下推自动机**（Pushdown Automaton, PDA）。

### （2）下推自动机的介绍
非正式地说，下推自动机就是一个增加了堆栈的有穷自动机。而也因为增加了堆栈结构，下推自动机的状态转移取决于**读入符号**、**当前状态**和**栈顶元素**三部分；同时在转移时，下推自动机也可以同时操作堆栈，执行入栈出栈操作。

下推自动机的结构如下图所示，包括了输入符号序列 input tape、转移关系表 finite control、状态 state 以及堆栈 stack。

![pushdown-automata](pushdown-automata.svg)

在运行时，下推自动机会按顺序读入符号。读入符号之后查找转移关系表，通过读入符号、当前状态和栈顶元素索引得到转移到的**目标状态**和要进行的**堆栈操作**。其中堆栈操作包括将某符号入栈、出栈或者不进行操作。在最后，下推自动机读入所有符号，并根据当前状态判断是否接受该符号串。

与有穷自动机类似，根据 ”在给定读入符号、当前状态和栈顶元素下，是否允许存在多种不同的可选操作“ 可以将下推自动机分为**不确定的下推自动机**（NPDA）和**确定的下推自动机**（DPDA）。然而又不同于有穷自动机，NPDA 和 DPDA 并不等价。NPDA 能够识别所有 2 型文法所定义的语言（即 2 型语言），但 DPDA 却只能识别**确定性上下文无关语言**（Deterministic Context-free Language, DCFL）。这是 2 型语言的一个真子集。

尽管 NPDA 能够识别 2 型语言，但在编译领域中我们只使用 DPDA 实现语法分析器。并且为了语法分析器的实用性，我们还需要对其进行更加精巧的设计。

> 因为下推自动机的理论与真正实用的语法分析器的关系不大，所以本文就不再介绍下推自动机的理论了。

## 四、语法分析的一般方法
所有的语法分析器都是 DPDA。但根据其设计思路的不同，又分为**自顶向下分析器**（Top-Down Parsers）和**自底向上分析器**（Bottom-up Parsers）。两类分析器所使用的解析方法分别称**自顶向下分析**和**自底向上分析**。

### （1）自顶向下分析
自顶向下分析利用了文法理论中的 “推导“ 的视角。将句子的解析视为从文法开始符号起，不断运用规则推导从而生成与要解析的句子相同的句子的过程。原理是若 $Z \xRightarrow[G]{+} S$，则 $S \in L(G[Z])$，否则 $S \notin L(G[Z])$。

自顶向下分析器的栈中存储的是**当前还未匹配**的句型后缀。在每一步中，分析器都会检查栈顶符号以及输入串首部符号，并 ”按照一定方法“ 选择采取**推导**、**匹配**、**接受**或**拒绝**动作。其中：
- **推导**：指使用文法中某条规则将符号栈顶的非终结符推导为规则右侧的符号序列，并按从右到左的顺序入栈。
- **匹配**：指符号栈顶的终结符和输入串首部的终结符相同时，读入输入串首部终结符并使栈顶终结符出栈。这一操作意味着当前句型的终结符前缀增加了一个终结符。
- **接受**：指当读入输入串中所有符号后，判断符号栈是否**为空**。如为空则接受该输入串。
- **拒绝**：指当出现无法推导的情况时，判断拒绝该输入串。

我们还以之前定义的括号文法 $G[S]$ 为例，查看输入符号串 $(()(()))$ 的自顶向下分析过程。如下表所示：

> 需要注意：
> - 下面的符号栈的底部位于最左侧，因此符号栈中的符号顺序是从右到左，与正常的书写顺序相反。
> - 我们在符号序列的最右侧加上 $\#$ 表示到达符号序列的末尾。

|符号栈|输入串|动作|
|---|---|---|
|$\#S$|$(()(()))\#$|推导 $S \rightarrow (S)S$|
|$\#S)S($|$(()(()))\#$|匹配|
|$\#S)S$|$()(()))\#$|推导 $S \rightarrow (S)S$|
|$\#S)S)S($|$()(()))\#$|匹配|
|$\#S)S)S$|$)(()))\#$|推导 $S \rightarrow \epsilon$|
|$\#S)S)$|$)(()))\#$|匹配|
|$\#S)S$|$(()))\#$|推导 $S \rightarrow (S)S$|
|$\#S)S)S($|$(()))\#$|匹配|
|$\#S)S)S$|$()))\#$|推导 $S \rightarrow (S)S$|
|$\#S)S)S)S($|$()))\#$|匹配|
|$\#S)S)S)S$|$)))\#$|推导 $S \rightarrow \epsilon$|
|$\#S)S)S)$|$)))\#$|匹配|
|$\#S)S)S$|$))\#$|推导 $S \rightarrow \epsilon$|
|$\#S)S)$|$))\#$|匹配|
|$\#S)S$|$)\#$|推导 $S \rightarrow \epsilon$|
|$\#S)$|$)\#$|匹配|
|$\#S$|$\#$|推导 $S \rightarrow \epsilon$|
|$\#$|$\#$|接受|

当然，上表虽然表现了自顶向下分析的一般方法，但却未指出何时应当选取何种规则进行推导。在具体的自顶向下分析方法中，则会处理这些并未明确的内容。在本文后续将会介绍常用的自顶向下方法 **LL(1) 分析法**。

### （2）自底向上分析
自底向上分析则利用了文法理论中的 “归约“ 的视角。将句子的解析视为从句子开始，不断运用规则归约句型成分，最终归约为文法开始符号的过程。原理是若 $Z \xLeftarrow[G]{+} S$，则 $S \in L(G[Z])$，否则 $S \notin L(G[Z])$。

和自顶向下时类似，在自底向上分析器运行的每一步中，分析器都会检查栈顶符号以及输入串首部符号，并 ”按照一定方法“ 选择采取**移进**、**归约**、**接受**或**拒绝**动作。其中：
- **移进**：指读入输入串的一个符号并将其入栈。移进的过程是寻找句柄的过程。
- **归约**：指栈顶部的一部分符号串被识别为句柄时，按照某条规则进行归约，并将归约的结果入栈。
符号栈顶的终结符和输入串首部的终结符相同时，读入输入串首部终结符并使栈顶终结符出栈。这一操作意味着当前句型的终结符前缀增加了一个终结符。
- **接受**：指当读入输入串中所有符号后，判断符号栈中是否**只有单一开始符号**。如是则接受该输入串。
- **拒绝**：指当出现无法归约的情况时，判断拒绝该输入串。

我们还使用上一小节的例子，只不过这次展示自底向上分析的一般过程：

|符号栈|输入串|动作|
|---|---|---|
|$\#$|$(()(()))\#$|移进|
|$\#($|$()(()))\#$|移进|
|$\#(($|$)(()))\#$|归约 $\epsilon \leftarrow S$|
|$\#((S$|$)(()))\#$|移进|
|$\#((S)$|$(()))\#$|移进|
|$\#((S)($|$()))\#$|移进|
|$\#((S)(($|$)))\#$|归约 $\epsilon \leftarrow S$|
|$\#((S)((S$|$)))\#$|移进|
|$\#((S)((S)$|$))\#$|归约 $\epsilon \leftarrow S$|
|$\#((S)((S)S$|$))\#$|归约 $(S)S \leftarrow S$|
|$\#((S)(S$|$))\#$|移进|
|$\#((S)(S)$|$)\#$|归约 $\epsilon \leftarrow S$|
|$\#((S)(S)S$|$)\#$|归约 $(S)S \leftarrow S$|
|$\#((S)S$|$)\#$|归约 $(S)S \leftarrow S$|
|$\#(S$|$)\#$|移进|
|$\#(S)$|$\#$|归约 $\epsilon \leftarrow S$|
|$\#(S)S$|$\#$|归约 $(S)S \leftarrow S$|
|$\#S$|$\#$|接受|

根据文法树，我们当然知道何时应该移进、何时可以归约，但是如何以形式化的方法识别可归约成分，却是一个难题。不同的具体的自底向上分析方法采用不同的策略解决这一问题。在后面我们便会介绍常用的两种自底向上分析方法：**算符优先分析法**和 **LR 分析法**。

## 五、LL(1) 分析法
LL(1) 分析法是实现自顶向下分析的一种方法。所谓 LL，指的是该方法 “**从左向右**（**L**eft to Right）扫描输入符号串，并产生句子的**最左推导**（**L**eftmost Derivation）”。而括号中的 1 则指该方法在一步中只**向前看一个**输入符号。

> 推广来看，还有向前看 k 个符号的分析法 LL(k)。其原理与 LL(1) 类似，但实现起来更加复杂，因此并不介绍。

### （1）LL(1) 分析算法和分析表
虽然在上一节中我们已经稍微提到了自顶向下分析法的流程，但是这里我们还是给出更详细的算法描述：

除了符号栈，在一个 LL(1) 分析器中还会维护一个分析表 $M$，其每一行代表一个非终结符，每一列代表一个终结符或 $\#$ 符号。表中元素则是文法规则或是留空以表示不存在匹配的规则。

1. 在最开始，将符号 $\#$ 以及文法开始符号 $S$ 依次推入符号栈中。
2. 在分析的某一步中：
    - 如果栈顶的符号为非终结符,令当前栈顶非终结符为 $A$，输入串首部符号为 $a$。此时查找分析表 $M$。取规则 $M[A, a]$。如果此处不存在规则，则进行错误处理（拒绝）。如果存在规则，将 $A$ 从符号栈中弹出，并将规则右侧符号按从右到左的顺序依次压入符号栈（推导）。
    - 如果是终结符,令当前栈顶终结符为 $a'$，输入串首部符号为 $a$。若 $a' = a \neq \#$，则将 $A$ 从栈中弹出，并读入符号 $a$（匹配）。若 $a' = a \neq \#$，说明输入串完全匹配，说明分析其成功接受了该输入串，算法结束（接受）。若 $a' \ne a$，则进行错误处理（拒绝）。
3. 不断重复步骤 2，直到算法结束。

根据算法，我们所要做的就是找到分析表 $M$ 的构造方法。由于在推导时，我们将规则右侧的符号按从右侧到左的顺序压入栈中，因此位于栈顶的永远是最左侧的符号。故而分析表项 $M[A,a]$ 中的规则实际上的是 “能使非终结符 $A$ 最终推导出的句子中**最左侧终结符**为 $a$” 的规则。

更形式地说，对于规则 $A \rightarrow \alpha, \alpha \in V^*$，定义 $\alpha$ 最终能推导出的句子中最左侧终结符集合 $\text{FIRST}(\alpha) = \{a | \alpha \xRightarrow{*} a..., a \in V_t\}$。那么若终结符 $a \in \text{FIRST}(\alpha)$，则有 $M[A, a] = A \rightarrow \alpha$。

但是如果选择该规则后最终能够推导出空符号串 $\epsilon$（$\epsilon \in \text{FIRST}(\alpha)$），那么还需要特殊考虑。因为这种情况意味着选用该规则后可以 “跳过” 当前的非终结符 $A$，此时输入串中的首部符号应当与**在 $A$ 之后出现的终结符**进行匹配。

因此对于规则 $A \rightarrow \alpha, \alpha \in V^*$，我们定义在非终结符 $A$ 之后可能出现的终结符集合 $\text{FOLLOW}(A) = \{a | S \xRightarrow{*} ...Aa..., a \in V_t \}$。那么若 $\epsilon \in \text{FIRST}(\alpha)$ 且 $a \in \text{FOLLOW}(A)$，则有 $M[A, a] = A \rightarrow \alpha$。

> 特别的，若 $S \xRightarrow{*} ...A$，则规定 $\# \in \text{FOLLOW}(A)$。

让我们总结一下，$M[A, a] = A \rightarrow a$ 当且仅当 $a \in \text{FIRST}(\alpha)$ 或 $\epsilon \in \text{FIRST}(\alpha) \land a \in \text{FOLLOW}(A)$。现在我们得到了分析表 $M$ 的构造方法，接下来就是确定如何计算 $\text{FIRST}(\alpha)$ 和 $\text{FOLLOW}(A)$。

### （2）FIRST 集和 FOLLOW 集的构造
#### FIRST 集
规则右侧 $\alpha = A_1A_2...A_n$ 为一符号串，因此在构造 $\text{FIRST}(\alpha)$ 之前我们可以先求出组成 $\alpha$ 的每一个符号 $A_i$ 的 FIRST 集合 $\text{FIRST}(A_i)$。

因为对于规则 $A \rightarrow B...$，有 $\text{FIRST}(B) - \{\epsilon\} \subset \text{FIRST}(A)$。我们可以使用一个递归算法求得 $\text{FIRST}(A_i)$：

1. 若 $A_i \in V_t \cup \{\epsilon\}$，则 $\text{FIRST}(A_i) = \{A_i\}$
2. 若 $A_i \in V_n$，则对于每条规则 $A_i \rightarrow A_1A_2... A_n$，
    - 有 $\text{FIRST}(A_1) - \{\epsilon\} \subset \text{FIRST}(A)$。
    - 若 $\epsilon \in \text{FIRST}(A_1)$，则有 $\text{FIRST}(A_2) - \{\epsilon\} \subset \text{FIRST}(A)$。
    - 若 $\epsilon \in \text{FIRST}(A_2)$，则有 $\text{FIRST}(A_3) - \{\epsilon\} \subset \text{FIRST}(A)$。
    - 若...

    以此类推，直到找到 $i \le n$，$\epsilon \notin \text{FIRST}(A_i)$，此时停止。而如果对于规则中最后一个符号 $A_n$ 依旧有 $\epsilon \in \text{FIRST}(A_n)$，则有 $\epsilon \in \text{FIRST}(A)$。

此时对于 $\alpha = A_1A_2...A_n$，我们就可以采用和上述算法中步骤 2 类似的方法求得 $\text{FIRST}(\alpha)$，这里不再赘述。

#### FOLLOW 集


### （3）LL(1) 的局限性
