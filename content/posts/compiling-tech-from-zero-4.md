+++
title = "从零开始的编译原理（4）：语法分析与下推自动机"
tags = ["下推自动机", "数学", "文法理论"]
categories = ["编译"]
series = ["从零开始的编译原理"]
date = 2024-02-15T14:14:06+08:00
draft = true
+++
## 一、前言
> 从这个精神王国的圣餐杯里，
>
> 他的无限性给他翻涌起泡沫。
>
> —— 格奥尔格·威廉·弗里德里希·黑格尔《精神现象学》下卷 第八章 绝对知识

<!-- more -->

## 二、从正则文法到上下文无关文法
词法分析阶段，我们可以使用正则文法描述词的定义，这是因为词的结构是**无嵌套的**。也就是说，词只会由例如前缀、后缀以及结构的顺序重复等概念描述，不可能出现需要**前后匹配**的地方。举个例子，正则文法不能定义形如 $12344321$ 的回文数；或形如 $(()(()))$ 的括号结构。

然而，所有的高级语言却都是**嵌套的**。通过嵌套，高级语言能够表示更加复杂的结构，实现控制流、子程序、作用域、类等等高级概念。因此，正则文法并不能描述高级语言的语法，我们需要使用 2 型文法，也即上下文无关文法描述高级语言。2 型文法区别于 3 型文法就在于其**嵌套性**。

举个例子，我们可以将上述括号结构用如下 2 型文法定义：
$$
    S \rightarrow (S)S | \epsilon
$$

其中规则 $S \rightarrow S(S)$ 中左括号和右括号**同时出现**，这样就保证了对于一个左括号，必定有一个右括号与其匹配。因而我们说上面的文法具有嵌套性。

而 3 型文法则不同。由于左线性和右线性的约束，3 型文法中不可能出现一条规则中右侧有多个终结符的情况。

不过虽然 2 型文法相较于 3 型文法具有更强的表达能力，但是这也为其解析提供了一定的困难。我们可以选择用前面定义的文法给出 $(()(()))$ 的文法树：

![syntax-tree](syntax-tree.png)

可以看出，相较于 3 型文法的文法树，2 型文法的文法树更像是树：并不是只向一侧增长，而是在任意地方都可能产生子树。因此，2 型文法的推导或归约过程不再能看作状态的转移，我们需要用有穷自动机之外的另一种模型描述，该模型应当具有接受嵌套结构的能力。这就是**下推自动机**。

## 三、下推自动机
### （1）例子：判断有效括号问题
初学编程的时候各位应该都做过类似的题目，那就是[判断有效括号](https://leetcode.com/problems/valid-parentheses/description/)。实际上这是一个编译问题。我们可以使用编译理论的语言将该问题表述为：对于符号集 $\Sigma = \{`(`, `)`, `[`, `]`, `\{`, `\}`\}$，对给定的括号文法 $G$，对于任意 $s \in \Sigma^*$，给出一个算法，判断是否有 $s \in L(G)$（即 $s$ 是否被文法 $G$ 接受）。

很明显，括号文法 $G$ 是 2 型文法，而我们又是如何解决这一问题的呢？由于左括号一定要与右括号匹配，因此我们要做的就是记录左括号的**嵌套状态**，并在读入右括号时尝试与其匹配。又由于嵌套具有**后进先出**的特点，所以我们会使用**栈**结构记录嵌套状态。具体的实现如下：

```py
def is_valid(s: str):
    match_cases = {'(': ')', '[': ']', '{':'}'}

    def is_match(left: str, right: str):
        return match_cases[left] == right

    stack = []
    for ch in s:
        if ch in match_cases.keys():
            stack.append(ch)
        else:
            if len(stack) == 0 or not is_match(stack.pop(), ch):
                return False
    return len(stack) == 0
```

从具体到一般，栈结构是处理嵌套的普遍方法。因而从 3 型文法到 2 型文法，我们需要做的就是在有穷自动机之外增加一个堆栈结构，使其能够存取当前状态之外的其他信息。这样得到的自动机称为**下推自动机**（Pushdown Automaton, PDA）。

### （2）下推自动机的介绍
非正式地说，下推自动机就是一个增加了堆栈的有穷自动机。而也因为增加了堆栈结构，下推自动机的状态转移取决于**读入符号**、**当前状态**和**栈顶元素**三部分；同时在转移时，下推自动机也可以同时操作堆栈，执行入栈出栈操作。

下推自动机的结构如下图所示，包括了输入符号序列 input tape、转移关系表 finite control、状态 state 以及堆栈 stack。

![pushdown-automata](pushdown-automata.svg)

在运行时，下推自动机会按顺序读入符号。读入符号之后查找转移关系表，通过读入符号、当前状态和栈顶元素索引得到转移到的**目标状态**和要进行的**堆栈操作**。其中堆栈操作包括将某符号入栈、出栈或者不进行操作。在最后，下推自动机读入所有符号，并根据当前状态判断是否接受该符号串。

与有穷自动机类似，根据 ”在给定读入符号、当前状态和栈顶元素下，是否允许存在多种不同的可选操作“ 可以将下推自动机分为**不确定的下推自动机**（NPDA）和**确定的下推自动机**（DPDA）。然而又不同于有穷自动机，NPDA 和 DPDA 并不等价。NPDA 能够识别所有 2 型文法所定义的语言（即 2 型语言），但 DPDA 却只能识别**确定性上下文无关语言**（Deterministic Context-free Language, DCFL）。这是 2 型语言的一个真子集。

尽管 NPDA 能够识别 2 型语言，但在编译领域中我们只使用 DPDA 实现语法分析器。并且为了语法分析器的实用性，我们还需要对其进行更加精巧的设计。

> 因为下推自动机的理论与真正实用的语法分析器的关系不大，所以本文就不再介绍下推自动机的理论了。

## 四、语法分析的一般方法
所有的语法分析器都是 DPDA。但根据其设计思路的不同，又分为**自顶向下分析器**（Top-Down Parsers）和**自底向上分析器**（Bottom-up Parsers）。两类分析器所使用的解析方法分别称**自顶向下分析**和**自底向上分析**。

### （1）自顶向下分析
自顶向下分析利用了文法理论中的 “推导“ 的视角。将句子的解析视为从文法开始符号起，不断运用规则推导从而生成与要解析的句子相同的句子的过程。原理是若 $Z \xRightarrow[G]{+} S$，则 $S \in L(G[Z])$，否则 $S \notin L(G[Z])$。

自顶向下分析器的栈中存储的是**当前还未匹配**的句型后缀。在每一步中，分析器都会检查栈顶符号以及输入串首部符号，并 ”按照一定方法“ 选择采取**推导**、**匹配**、**接受**或**拒绝**动作。其中：
- **推导**：指使用文法中某条规则将符号栈顶的非终结符推导为规则右侧的符号序列，并按从右到左的顺序入栈。
- **匹配**：指符号栈顶的终结符和输入串首部的终结符相同时，读入输入串首部终结符并使栈顶终结符出栈。这一操作意味着当前句型的终结符前缀增加了一个终结符。
- **接受**：指当读入输入串中所有符号后，判断符号栈是否**为空**。如为空则接受该输入串。
- **拒绝**：指当出现无法推导的情况时，判断拒绝该输入串。

我们还以之前定义的括号文法 $G[S]$ 为例，查看输入符号串 $(()(()))$ 的自顶向下分析过程。如下表所示：

> 需要注意：
> - 下面的符号栈的底部位于最左侧，因此符号栈中的符号顺序是从右到左，与正常的书写顺序相反。
> - 我们在符号序列的最右侧加上 $\#$ 表示到达符号序列的末尾。

|符号栈|输入串|动作|
|---|---|---|
|$\#S$|$(()(()))\#$|推导 $S \rightarrow (S)S$|
|$\#S)S($|$(()(()))\#$|匹配|
|$\#S)S$|$()(()))\#$|推导 $S \rightarrow (S)S$|
|$\#S)S)S($|$()(()))\#$|匹配|
|$\#S)S)S$|$)(()))\#$|推导 $S \rightarrow \epsilon$|
|$\#S)S)$|$)(()))\#$|匹配|
|$\#S)S$|$(()))\#$|推导 $S \rightarrow (S)S$|
|$\#S)S)S($|$(()))\#$|匹配|
|$\#S)S)S$|$()))\#$|推导 $S \rightarrow (S)S$|
|$\#S)S)S)S($|$()))\#$|匹配|
|$\#S)S)S)S$|$)))\#$|推导 $S \rightarrow \epsilon$|
|$\#S)S)S)$|$)))\#$|匹配|
|$\#S)S)S$|$))\#$|推导 $S \rightarrow \epsilon$|
|$\#S)S)$|$))\#$|匹配|
|$\#S)S$|$)\#$|推导 $S \rightarrow \epsilon$|
|$\#S)$|$)\#$|匹配|
|$\#S$|$\#$|推导 $S \rightarrow \epsilon$|
|$\#$|$\#$|接受|

当然，上表虽然表现了自顶向下分析的一般方法，但却未指出何时应当选取何种规则进行推导。在具体的自顶向下分析方法中，则会处理这些并未明确的内容。在本文后续将会介绍常用的自顶向下方法 **LL(1) 分析法**。

### （2）自底向上分析
自底向上分析则利用了文法理论中的 “归约“ 的视角。将句子的解析视为从句子开始，不断运用规则归约句型成分，最终归约为文法开始符号的过程。原理是若 $Z \xLeftarrow[G]{+} S$，则 $S \in L(G[Z])$，否则 $S \notin L(G[Z])$。

和自顶向下时类似，在自底向上分析器运行的每一步中，分析器都会检查栈顶符号以及输入串首部符号，并 ”按照一定方法“ 选择采取**移进**、**归约**、**接受**或**拒绝**动作。其中：
- **移进**：指读入输入串的一个符号并将其入栈。移进的过程是寻找句柄的过程。
- **归约**：指栈顶部的一部分符号串被识别为句柄时，按照某条规则进行归约，并将归约的结果入栈。
符号栈顶的终结符和输入串首部的终结符相同时，读入输入串首部终结符并使栈顶终结符出栈。这一操作意味着当前句型的终结符前缀增加了一个终结符。
- **接受**：指当读入输入串中所有符号后，判断符号栈中是否**只有单一开始符号**。如是则接受该输入串。
- **拒绝**：指当出现无法归约的情况时，判断拒绝该输入串。

我们还使用上一小节的例子，只不过这次展示自底向上分析的一般过程：

|符号栈|输入串|动作|
|---|---|---|
|$\#$|$(()(()))\#$|移进|
|$\#($|$()(()))\#$|移进|
|$\#(($|$)(()))\#$|归约 $\epsilon \leftarrow S$|
|$\#((S$|$)(()))\#$|移进|
|$\#((S)$|$(()))\#$|移进|
|$\#((S)($|$()))\#$|移进|
|$\#((S)(($|$)))\#$|归约 $\epsilon \leftarrow S$|
|$\#((S)((S$|$)))\#$|移进|
|$\#((S)((S)$|$))\#$|归约 $\epsilon \leftarrow S$|
|$\#((S)((S)S$|$))\#$|归约 $(S)S \leftarrow S$|
|$\#((S)(S$|$))\#$|移进|
|$\#((S)(S)$|$)\#$|归约 $\epsilon \leftarrow S$|
|$\#((S)(S)S$|$)\#$|归约 $(S)S \leftarrow S$|
|$\#((S)S$|$)\#$|归约 $(S)S \leftarrow S$|
|$\#(S$|$)\#$|移进|
|$\#(S)$|$\#$|归约 $\epsilon \leftarrow S$|
|$\#(S)S$|$\#$|归约 $(S)S \leftarrow S$|
|$\#S$|$\#$|接受|

根据文法树，我们当然知道何时应该移进、何时可以归约，但是如何以形式化的方法识别可归约成分，却是一个难题。不同的具体的自底向上分析方法采用不同的策略解决这一问题。在后面我们便会介绍常用的两种自底向上分析方法：**算符优先分析法**和 **LR 分析法**。

## 五、LL(1) 分析法
LL(1) 分析法是实现自顶向下分析的一种方法。所谓 LL，指的是该方法 “**从左向右**（**L**eft to Right）扫描输入符号串，并产生句子的**最左推导**（**L**eftmost Derivation）”。而括号中的 1 则指该方法在一步中只**向前看一个**输入符号。

> 推广来看，还有向前看 k 个符号的分析法 LL(k)。其原理与 LL(1) 类似，但实现起来更加复杂，因此并不介绍。

### （1）LL(1) 分析算法和分析表
虽然在上一节中我们已经稍微提到了自顶向下分析法的流程，但是这里我们还是给出更详细的算法描述：

除了符号栈，在一个 LL(1) 分析器中还会维护一个分析表 $M$，其每一行代表一个非终结符，每一列代表一个终结符或 $\#$ 符号。表中元素则是文法规则或是留空以表示不存在匹配的规则。

1. 在最开始，将符号 $\#$ 以及文法开始符号 $S$ 依次推入符号栈中。
2. 在分析的某一步中：
    - 如果栈顶的符号为非终结符,令当前栈顶非终结符为 $A$，输入串首部符号为 $a$。此时查找分析表 $M$。取规则 $M[A, a]$。如果此处不存在规则，则进行错误处理（拒绝）。如果存在规则，将 $A$ 从符号栈中弹出，并将规则右侧符号按从右到左的顺序依次压入符号栈（推导）。
    - 如果是终结符,令当前栈顶终结符为 $a'$，输入串首部符号为 $a$。若 $a' = a \neq \#$，则将 $A$ 从栈中弹出，并读入符号 $a$（匹配）。若 $a' = a \neq \#$，说明输入串完全匹配，说明分析其成功接受了该输入串，算法结束（接受）。若 $a' \ne a$，则进行错误处理（拒绝）。
3. 不断重复步骤 2，直到算法结束。

根据算法，我们所要做的就是找到分析表 $M$ 的构造方法。由于在推导时，我们将规则右侧的符号按从右侧到左的顺序压入栈中，因此位于栈顶的永远是最左侧的符号。故而分析表项 $M[A,a]$ 中的规则实际上的是 “能使非终结符 $A$ 最终推导出的句子中**最左侧终结符**为 $a$” 的规则。

更形式地说，对于规则 $A \rightarrow \alpha, \alpha \in V^*$，定义 $\alpha$ 最终能推导出的句子中最左侧终结符集合 $\text{FIRST}(\alpha) = \{a | \alpha \xRightarrow{*} a..., a \in V_t\}$。那么若终结符 $a \in \text{FIRST}(\alpha)$，则有 $M[A, a] = A \rightarrow \alpha$。

但是如果选择该规则后最终能够推导出空符号串 $\epsilon$（$\epsilon \in \text{FIRST}(\alpha)$），那么还需要特殊考虑。因为这种情况意味着选用该规则后可以 “跳过” 当前的非终结符 $A$，此时输入串中的首部符号应当与**在 $A$ 之后出现的终结符**进行匹配。

因此对于规则 $A \rightarrow \alpha, \alpha \in V^*$，我们定义在非终结符 $A$ 之后可能出现的终结符集合 $\text{FOLLOW}(A) = \{a | S \xRightarrow{*} ...Aa..., a \in V_t \}$。那么若 $\epsilon \in \text{FIRST}(\alpha)$ 且 $a \in \text{FOLLOW}(A)$，则有 $M[A, a] = A \rightarrow \alpha$。

> 特别的，若 $S \xRightarrow{*} ...A$，则规定 $\# \in \text{FOLLOW}(A)$。

让我们总结一下，$M[A, a] = A \rightarrow a$ 当且仅当 $a \in \text{FIRST}(\alpha)$ 或 $\epsilon \in \text{FIRST}(\alpha) \land a \in \text{FOLLOW}(A)$。现在我们得到了分析表 $M$ 的构造方法，接下来就是确定如何计算 $\text{FIRST}(\alpha)$ 和 $\text{FOLLOW}(A)$。

### （2）FIRST 集的构造
规则右侧 $\alpha = A_1A_2...A_n$ 为一符号串，因此在构造 $\text{FIRST}(\alpha)$ 之前我们可以先求出组成 $\alpha$ 的每一个符号 $A_i$ 的 FIRST 集合 $\text{FIRST}(A_i)$。

因为对于规则 $A \rightarrow B...$，有 $\text{FIRST}(B) - \{\epsilon\} \subset \text{FIRST}(A)$。我们可以使用一个递归算法求得 $\text{FIRST}(A_i)$：

1. 若 $A_i \in V_t \cup \{\epsilon\}$，则 $\text{FIRST}(A_i) = \{A_i\}$
2. 若 $A_i \in V_n$，则对于每条规则 $A_i \rightarrow A_1A_2... A_n$，
    - 有 $\text{FIRST}(A_1) - \{\epsilon\} \subset \text{FIRST}(A)$。
    - 若 $\epsilon \in \text{FIRST}(A_1)$，则有 $\text{FIRST}(A_2) - \{\epsilon\} \subset \text{FIRST}(A)$。
    - 若 $\epsilon \in \text{FIRST}(A_2)$，则有 $\text{FIRST}(A_3) - \{\epsilon\} \subset \text{FIRST}(A)$。
    - 若...

    以此类推，直到找到 $i \le n$，$\epsilon \notin \text{FIRST}(A_i)$，此时停止。而如果对于规则中最后一个符号 $A_n$ 依旧有 $\epsilon \in \text{FIRST}(A_n)$，则有 $\epsilon \in \text{FIRST}(A)$。

此时对于 $\alpha = A_1A_2...A_n$，我们就可以采用和上述算法中步骤 2 类似的方法求得 $\text{FIRST}(\alpha)$，这里不再赘述。

我们可以用一个例子演示上述算法。对于如下文法 $G[E]$：
$$
\begin{align*}
    E &\rightarrow TE' \\
    E' &\rightarrow +TE' | \epsilon \\
    T &\rightarrow FT' \\
    T' &\rightarrow *FT' | \epsilon \\
    F &\rightarrow (E) | i
\end{align*}
$$

我们求其 FIRST 集。

算法是递归过程，我们可以将其转换为迭代，先求可以直接得出的 FIRST 集。对于本例来说，我们从 $F$ 开始。

1. $F$ 的两条规则都以终结符开头，因此直接得到 FIRST 集。

    |非终结符|FIRST|
    |---|---|
    |$E$|$\{\}$|
    |$E'$|$\{\}$|
    |$T$|$\{\}$|
    |$T'$|$\{\}$|
    |$F$|$\{(, i\}$|

2. 之后是 $T'$，其第一条规则以终结符开头，第二条为 $\epsilon$，同样直接得到 FIRST 集。

    |非终结符|FIRST|
    |---|---|
    |$E$|$\{\}$|
    |$E'$|$\{\}$|
    |$T$|$\{\}$|
    |$T'$|$\{*, \epsilon \}$|
    |$F$|$\{(, i\}$|

3. 之后是 $T$。由于规则以非终结诶符 $F$ 开头，因此需要求 $\text{FIRST}(F)$。因为 $\epsilon \notin \text{FIRST}(F)$，所以不需要再求 $T'$ 的 FIRST 集。

    |非终结符|FIRST|
    |---|---|
    |$E$|$\{\}$|
    |$E'$|$\{\}$|
    |$T$|$\{(, i\}$|
    |$T'$|$\{*, \epsilon \}$|
    |$F$|$\{(, i\}$|

4. 之后是 $E'$。

    |非终结符|FIRST|
    |---|---|
    |$E$|$\{\}$|
    |$E'$|$\{+, \epsilon \}$|
    |$T$|$\{(, i\}$|
    |$T'$|$\{*, \epsilon \}$|
    |$F$|$\{(, i\}$|

5. 最后是 $E$。同样需要求 $\text{FIRST}(T)$。

    |非终结符|FIRST|
    |---|---|
    |$E$|$\{(, i\}$|
    |$E'$|$\{+, \epsilon \}$|
    |$T$|$\{(, i\}$|
    |$T'$|$\{*, \epsilon \}$|
    |$F$|$\{(, i\}$|

得到各非终结符的 FIRST 集后，我们就可以求得各规则右侧符号串的 FIRST 集了。

$$
\begin{align*}
    \text{FIRST}(TE') &= \text{FIRST}(T) - \{\epsilon\} = \{(, i\} \\
    \text{FIRST}(+TE') &= \{+\} \\
    \text{FIRST}(\epsilon) &= \{\epsilon\} \\
    \text{FIRST}(FT') &= \text{FIRST}(F) - \{\epsilon\} = \{(, i\} \\
    \text{FIRST}(*FT') &= \{*\} \\
    \text{FIRST}((E)) &= \{(\} \\
    \text{FIRST}(i) &= \{i\}
\end{align*}
$$

### （3）FOLLOW 集的构造
FOLLOW 集的构造要在 FIRST 集之后。因为我们要得到的是非终结符 “之后” 可能出现的终结符。所以实际上要求的就是**非终结符之后的子符号串的 FIRST 集**。

按照这一思路，我们就可以得到构造 FOLLOW 集的算法：

1. 对于开始符号 $S$，有 $\# \in \text{FOLLOW}(S)$。
2. 在每一步迭代中，对于非终结符 $B$，若有 $A \rightarrow \alpha B \beta$ 其中 $\alpha, \beta \in V^* \cup \{\epsilon\}$，则有 $\text{FIRST}(\beta) - \{\epsilon\} \subset \text{FOLLOW}(B)$。若 $\epsilon \in \text{FIRST}(\beta)$，则还有 $\text{FOLLOW}(A) \subset \text{FOLLOW}(B)$。
3. 重复步骤 2，直到所有非终结符的 FOLLOW 集都不再变化。

> 对于规则 $A \rightarrow \alpha B \beta$，由于非终结符 $B$ 之后的子符号串 $\beta$ 也可能推出 $\epsilon$。此时规则等同于 $A \rightarrow \alpha B$，**在 $A$ 之后可能出现的终结符也同样是在 $B$ 之后可能出现的终结符**。
>
> 也正因为上面的特点，FOLLOW 集的构造算法只用一次迭代不一定能得到最终结果。必须多次迭代，使得 FOLLOW 集从规则的左侧 “传播” 到右侧。

我们还以前一小节中的文法 $G[E]$ 为例。

1. 首先进行初始化，将 $\#$ 加入 $\text{FOLLOW}(E)$ 中。

    |非终结符|FIRST|FOLLOW|
    |---|---|---|
    |$E$|$\{(, i\}$|$\{\#\}$|
    |$E'$|$\{+, \epsilon \}$|$\{\}$|
    |$T$|$\{(, i\}$|$\{\}$|
    |$T'$|$\{*, \epsilon \}$|$\{\}$|
    |$F$|$\{(, i\}$|$\{\}$|

2. 对于 $E$，其出现在 $F \rightarrow (E)$ 中，因此 $)$ 位于 FOLLOW 集中。

    |非终结符|FIRST|FOLLOW|
    |---|---|---|
    |$E$|$\{(, i\}$|$\{\#, )\}$|
    |$E'$|$\{+, \epsilon \}$|$\{\}$|
    |$T$|$\{(, i\}$|$\{\}$|
    |$T'$|$\{*, \epsilon \}$|$\{\}$|
    |$F$|$\{(, i\}$|$\{\}$|

3. 对于 $E'$，其出现在 $E \rightarrow TE'$ 和 $E' \rightarrow + TE'$ 中。我们只需求 $\text{FOLLOW}(E)$。

    |非终结符|FIRST|FOLLOW|
    |---|---|---|
    |$E$|$\{(, i\}$|$\{\#, )\}$|
    |$E'$|$\{+, \epsilon \}$|$\{\#, )\}$|
    |$T$|$\{(, i\}$|$\{\}$|
    |$T'$|$\{*, \epsilon \}$|$\{\}$|
    |$F$|$\{(, i\}$|$\{\}$|

4. 对于 $T$，其出现在 $E \rightarrow TE'$ 和 $E' \rightarrow +TE'$ 中。需要求 $FIRST(E')$。并且由于 $\epsilon \in FIRST(E')$，因此还要求 $\text{FOLLOW}(E)$。

    |非终结符|FIRST|FOLLOW|
    |---|---|---|
    |$E$|$\{(, i\}$|$\{\#, )\}$|
    |$E'$|$\{+, \epsilon \}$|$\{\#, )\}$|
    |$T$|$\{(, i\}$|$\{\#,),+\}$|
    |$T'$|$\{*, \epsilon \}$|$\{\}$|
    |$F$|$\{(, i\}$|$\{\}$|

5. 对于 $T'$，其出现在 $T \rightarrow FT'$ 和 $T' \rightarrow *FT'$ 中。我们只需求 $\text{FOLLOW}(T)$。

    |非终结符|FIRST|FOLLOW|
    |---|---|---|
    |$E$|$\{(, i\}$|$\{\#, )\}$|
    |$E'$|$\{+, \epsilon \}$|$\{\#, )\}$|
    |$T$|$\{(, i\}$|$\{\#,),+\}$|
    |$T'$|$\{*, \epsilon \}$|$\{\#,),+\}$|
    |$F$|$\{(, i\}$|$\{\}$|

6. 对于 $F$，其出现在 $T \rightarrow FT'$ 和 $T' \rightarrow *FT'$ 中。我们需要求 $\text{FIRST}(T')$，并且由于 $\epsilon \in \text{FIRST}(T')$，我们还需要求 $\text{FOLLOW}(T)$。

    |非终结符|FIRST|FOLLOW|
    |---|---|---|
    |$E$|$\{(, i\}$|$\{\#, )\}$|
    |$E'$|$\{+, \epsilon \}$|$\{\#, )\}$|
    |$T$|$\{(, i\}$|$\{\#,),+\}$|
    |$T'$|$\{*, \epsilon \}$|$\{\#,),+\}$|
    |$F$|$\{(, i\}$|$\{*，\#,),+\}$|

7. 重复此过程，发现 FOLLOW 集不再变化。停止迭代。

### （4）LL(1) 的局限性
根据上面构造的 FIRST 集和 FOLLOW 集，并结合在前面提到的构造分析表算法，我们可以构造文法 $G[E]$ 的 LL(1) 分析表。这里就直接给出了。

||$i$|$+$|$*$|$($|$)$|$\#$|
|:---:|:---:|:---:|:---:|:---:|:---:|:---:|
|$E$|$E \rightarrow TE'$|||$E \rightarrow TE'$|||
|$E'$||$E' \rightarrow +TE'$|||$E' \rightarrow \epsilon$|$E' \rightarrow \epsilon$|
|$T$|$T \rightarrow FT'$|||$T \rightarrow FT'$|||
|$T'$||$T' \rightarrow \epsilon$|$T' \rightarrow *FT'$||$T' \rightarrow \epsilon$|$T' \rightarrow \epsilon$|
|$F$|$F \rightarrow i$|||$F \rightarrow (E)$|||

可以看到，此时的分析表 $M$ 中每一个位置最多只有一条规则。这意味着对于任意的符号栈和输入串，要么找不到规则，语法分析器不接受该输入串；要么找到一条规则，直接使用该规则进行推导。而不存在推导时出现**歧义**的情况。

而如果分析表中的一个位置出现多于一条规则，则不能使用 LL(1) 分析法进行分析。设这时出现在同一位置 $M[A, a]$ 的两条规则分别为 $A \rightarrow \alpha$ 和 $A \rightarrow \beta$。那么一定满足下面两个条件之一：
1. $a \in \text{FIRST}(\alpha) \cap \text{FIRST}(\beta)$
2. $\epsilon \in \text{FIRST}(\beta)$ 且 $a \in \text{FIRST}(\alpha) \cap \text{FOLLOW}(A)$

我们定义可以构造出无歧义的 LL(1) 分析器的文法称为 **LL(1) 文法**。那么将上面的两个条件取逆，我们就可以得到**文法 $G$ 是 LL(1) 文法的充要条件**：对于 $G$ 的每一个非终结符 $A$ 的任意两条规则 $A \rightarrow \alpha | \beta$，下面两条件成立
1. $\text{FIRST}(\alpha) \cap \text{FIRST}(\beta) = \emptyset$
2. 若 $\epsilon \in \text{FIRST}(\beta)$，则 $\text{FIRST}(\alpha) \cap \text{FOLLOW}(A) = \emptyset$

很明显，由于增加了额外的限制条件，所以 **LL(1) 文法的集合是上下文无关文法的集合的真子集**。这与下推自动机的结论吻合。

关于 LL(1) 的局限性，还有另一个结论。在第一篇文章中我们介绍了递归规则，指的是非终结符推出其自身的规则。如果递归规则是类似下面的形式 $A \rightarrow A...$，即非终结符出现在推出的符号串的最左侧，则我们称其为**左递归**规则。可以证明，**如果文法 $G$ 中存在左递归规则，则其一定不是 LL(1) 文法**。

对此我们可以给出一个简单的证明：若文法 $G$ 中存在一条左递归规则 $A \rightarrow A\alpha$，则对于非终结符 $A$，必定存在至少一条规则 $A \rightarrow \beta$。那么对于 $A \rightarrow A\alpha$，有 $\text{FIRST}(A) = \text{FIRST}(A\alpha)$。而对于 $A \rightarrow \beta$，又有 $\text{FIRST}(\beta) \subset \text{FIRST}(A)$。因此有 $\text{FIRST}(\beta) \subset \text{FIRST}(A\alpha)$。因此 $\text{FIRST}(\beta) \cap \text{FIRST}(A\alpha) = \text{FIRST}(\beta) \ne \emptyset$，$G$ 不是 LL(1) 文法。

然而，左递归又是非常普遍的，比如说为了实现从左到右的运算，我们常常会使用类似这样的文法规则：
$$
\begin{align*}
    A &\rightarrow A + B | A - B | B \\
    B &\rightarrow B * C | B / C | C \\
    C &\rightarrow i
\end{align*}
$$

这样的规则能够保证位于更左侧的运算处于更深的文法子树中。这时使用后序遍历访问整棵文法树的顺序就是计算的顺序。

因而我们可以选择改造文法，消除其中的左递归。有两种方法。
1. 第一种方法是**将文法改为右递归**：
    - 第一步：提取左递归公因子。若有左递归文法 $U \rightarrow U\alpha | U \beta | V$，则改为 $U \rightarrow U(\alpha|\beta) | V$。对本例来说，将文法改造成 $A \rightarrow A (+ B | - B) | B$ 的形式
    - 第二步：增加间接非终结符 $P'$，将 $P \rightarrow P\alpha|\beta$ 改写为 $P \rightarrow \beta P'$ 和 $P' \rightarrow \alpha P' | \epsilon$。对本例来说，可将文法改造为 $A \rightarrow BA'$ 和 $A' \rightarrow +BA' | -BA' | \epsilon$。

    我们以规则 $A \rightarrow A + B | A - B | B$ 为例。首先提取左递归公因子，将其改写为 $A \rightarrow A (+ B | - B) | B$；之后再增加非终结符 $A'$，改写为 $A \rightarrow BA'$ 和 $A' \rightarrow +BA' | -BA' | \epsilon$。此时我们就将左递归转化为了右递归。

2. 第二种方法是**使用扩展 BNF 范式改写**：
    - 第一步：和第一种方法相同
    - 第二步：使用 $\{\}$ 符号，将 $P \rightarrow P\alpha|\beta$ 改写为 $P \rightarrow \beta \{\alpha\}$

    我们还以规则 $A \rightarrow A + B | A - B | B$ 为例。首先同样改写为 $A \rightarrow A (+ B | - B) | B$；之后使用扩展 BNF 范式改写为 $A \rightarrow B\{+B | -B\}$。

两种方法都消除了左递归，但也有一些缺陷。第一种方法修改了文法，导致文法树发生改变；第二种方法使用了扩展 BNF 范式，无法根据文法构建 LL(1) 分析表。

> 你可能会想，第二种方法不能构建分析表，那又有什么用？其实，虽然我们无法据此构建 “标准的” LL(1) 语法分析器，但却可以在一种更加实用的 LL(1) 分析方法中使用。即就是**递归子程序法**。

## 六、递归子程序法
递归子程序法不是另一种自顶向下分析法，而**就是** LL(1) 分析法。其和 LL(1) 分析法的唯一区别就是递归子程序法**使用程序的函数调用栈作为符号栈**。因此递归子程序法相较于标准的 LL(1) 分析法，更适合编程实现。

递归子程序法不会显式地构造分析表结构，而是将分析表蕴含在程序中。具体来说，递归子程序法需要对文法的每一个非终结符都编写一个**分析子程序**（即函数），当根据所处的子程序和当前的输入符号预测到要使用某个非终结符去匹配输入串时，就**调用**该非终结符的分析程序。（而一次调用过程，实际上就相当于非终结符入栈的过程。）

接下来我们使用伪代码展示递归子程序法的实现细节。首先我们约定一些程序运行的上下文。

```py
# FIRST sets of symbol strings
FIRST: dict[str, set[str]]

# FOLLOW sets of non-terminal symbols
FOLLOW: dict[str, set[str]]

def getsym() -> str:
    """
    read the next symbol from the input string 
    """

def error():
    """
    raise an error
    """

def assert_match(actual: str, expect: str):
    """
    if the value of `actual` is not equal to `expect`, raise an error
    """
```
- `FIRST`：即规则右侧符号串的 FIRST 集；
- `FOLLOW`：即非终结符的 FOLLOW 集；
- `getsym`：用于读入下一个符号；
- `error`：用于报告解析错误；
- `assert_match`：当两符号不相同时报告解析错误。

在此上下文中，在不考虑其他功能（如构建文法树），只考虑推导过程的情况下，任意非终结符 $X$ 的分析子程序 `x` 应当为如下形式：
```py
def x(curr_sym: str) -> str:
    """
    function to analyze non-terminal symbol `X`
    """
```

此时函数 `x` 传入的参数 `curr_sym` 是将要进行解析的，属于非终结符 $X$ 的第一个符号（应有 $\text{curr\_sym} \in \text{FIRST}(X)$）。而函数的返回值则是解析完 $X$ 之后，第一个不属于 $X$ 的符号（应有 $\text{ret\_val} \in \text{FOLLOW}(X)$）。

而对于相同非终结符 $X$ 的所有规则 $X \rightarrow x_1 | x_2 |...| x_n$，我们使用 FIRST 和 FOLLOW 集判断当前符号应当适用于那条规则，从而划分到不同的条件分支中。
```py
def x(curr_sym: str) -> str:
    if curr_sym in FIRST["x1"]:
        pass
    elif curr_sym in FIRST["x2"]:
        pass
    # omit...
    elif curr_sym in FIRST["xn"]:
        pass
    else:
        error()

```